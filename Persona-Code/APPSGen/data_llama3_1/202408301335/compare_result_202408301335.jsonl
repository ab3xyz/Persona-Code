{"solution": "def max_accordion_length(s):\n    max_length = -1\n    opening_bracket_index = -1\n    for i, char in enumerate(s):\n        if char == '[':\n            opening_bracket_index = i\n        elif char == ':':\n            if opening_bracket_index!= -1:\n                max_length = max(max_length, 4)\n                colon_index = i\n                max_vertical_lines = 0\n                for j in range(colon_index + 1, len(s)):\n                    if s[j] == '|':\n                        max_vertical_lines += 1\n                    elif s[j] == ':':\n                        max_length = max(max_length, 4 + 2 * max_vertical_lines)\n                        break\n                    elif s[j] == ']':\n                        max_length = max(max_length, 4 + max_vertical_lines)\n                        break\n    return max_length\n\ns = input()\nprint(max_accordion_length(s))"}
{"solution": "def digit_sum(n):\n    return sum(int(digit) for digit in str(n))\n\ndef largest_digit_sum(x):\n    max_sum = 0\n    max_num = 0\n    for i in range(x, 0, -1):\n        current_sum = digit_sum(i)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_num = i\n    return max_num\n\nx = int(input())\nprint(largest_digit_sum(x))"}
{"solution": "def is_lucky(year):\n    \"\"\"Check if a year is lucky.\"\"\"\n    return sum(1 for digit in str(year) if digit!= '0') <= 1\n\n\ndef next_lucky_year(year):\n    \"\"\"Find the next lucky year.\"\"\"\n    while True:\n        year += 1\n        if is_lucky(year):\n            return year\n\n\ndef main():\n    \"\"\"Read the current year and print the years until the next lucky year.\"\"\"\n    current_year = int(input())\n    next_year = next_lucky_year(current_year)\n    print(next_year - current_year)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef read_ints():\n    return map(int, sys.stdin.readline().split())\n\ndef main():\n    n, q = read_ints()\n    ranges = [tuple(read_ints()) for _ in range(q)]\n\n    prefix_sum = [[0] * (n + 1) for _ in range(q)]\n    for i, (l, r) in enumerate(ranges):\n        for j in range(l, r + 1):\n            prefix_sum[i][j] = 1\n\n    for i in range(q):\n        for j in range(1, n + 1):\n            prefix_sum[i][j] += prefix_sum[i][j - 1]\n\n    dp = [[[0] * (n + 1) for _ in range(n + 1)] for _ in range(q)]\n    for i in range(q):\n        for l in range(1, n + 1):\n            for r in range(l, n + 1):\n                if l == r:\n                    dp[i][l][r] = prefix_sum[i][r]\n                else:\n                    max_val = 0\n                    for j in range(l, r):\n                        max_val = max(max_val, dp[i][l][j] + dp[i][j + 1][r])\n                    dp[i][l][r] = max(prefix_sum[i][r] - prefix_sum[i][l - 1], max_val)\n\n    ans = 0\n    for i in range(q):\n        for j in range(i + 1, q):\n            for l in range(1, n + 1):\n                for r in range(l, n + 1):\n                    ans = max(ans, dp[i][l][r] + dp[j][l][r] - (prefix_sum[i][r] - prefix_sum[i][l - 1]) - (prefix_sum[j][r] - prefix_sum[j][l - 1]) + prefix_sum[i][n] + prefix_sum[j][n])\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_lucky(time):\n    return '7' in time\n\ndef prev_time(time, x):\n    h, m = map(int, time.split(':'))\n    m -= x\n    if m < 0:\n        h -= 1\n        m += 60\n    if h < 0:\n        h += 24\n    return f'{h:02d}:{m:02d}'\n\nx = int(input())\ntime = input()\nif is_lucky(time):\n    print(0)\nelse:\n    count = 0\n    while True:\n        time = prev_time(time, x)\n        count += 1\n        if is_lucky(time):\n            print(count)\n            break"}
{"solution": "n, pos, l, r = map(int, input().split())\n\ndef solve(n, pos, l, r):\n    left = pos - l\n    right = r - pos\n    left_outside = l - 1\n    right_outside = n - r\n\n    if left_outside <= right_outside:\n        return left + right_outside + 1\n    else:\n        return right + left_outside + 1\n\nprint(solve(n, pos, l, r))"}
{"solution": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    d = []\n    h = []\n    for _ in range(n):\n        di, hi = map(int, sys.stdin.readline().split())\n        d.append(di)\n        h.append(hi)\n\n    best = -1\n    for i in range(n):\n        if d[i] > h[i]:\n            best = i\n            break\n\n    if best == -1:\n        print(-1)\n        return\n\n    ans = 0\n    while x > 0:\n        if d[best] >= x:\n            ans += 1\n            break\n        else:\n            x = x - d[best] + h[best]\n            ans += 1\n\n    print(ans)\n\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    solve()"}
{"solution": "def solve():\n    n, m = map(int, input().split())\n    day = 0\n    while True:\n        day += 1\n        n += m\n        if n > 10**18:\n            n = 10**18\n        if n < day:\n            break\n        n -= day\n    print(day)\n\nsolve()"}
{"solution": "from collections import defaultdict\n\ndef is_koutsu(hand):\n    count = defaultdict(int)\n    for tile in hand:\n        count[tile] += 1\n    return 3 in count.values()\n\ndef is_shuntsu(hand):\n    numbers = defaultdict(list)\n    for tile in hand:\n        numbers[tile[1]].append(int(tile[0]))\n    for num_list in numbers.values():\n        num_list.sort()\n        for i in range(len(num_list) - 2):\n            if num_list[i] + 1 == num_list[i+1] and num_list[i+1] + 1 == num_list[i+2]:\n                return True\n    return False\n\ndef min_tiles_to_draw(hand):\n    if is_koutsu(hand) or is_shuntsu(hand):\n        return 0\n    else:\n        min_tiles = float('inf')\n        for i in range(1, 10):\n            for suit in'mps':\n                new_hand = hand + [str(i) + suit]\n                if is_koutsu(new_hand) or is_shuntsu(new_hand):\n                    min_tiles = min(min_tiles, 1)\n        for i in range(1, 8):\n            for suit in'mps':\n                new_hand = hand + [str(i) + suit, str(i+2) + suit]\n                if is_shuntsu(new_hand):\n                    min_tiles = min(min_tiles, 2)\n        return min_tiles if min_tiles!= float('inf') else 2\n\nhand = input().split()\nprint(min_tiles_to_draw(hand))"}
{"solution": "import sys\n\ndef input():\n    return sys.stdin.readline().strip()\n\ndef read_int():\n    return int(input())\n\ndef read_ints():\n    return map(int, input().split())\n\ndef read_list():\n    return list(map(int, input().split()))\n\ndef solve():\n    d = read_int()\n    n, m = read_ints()\n    sofas = []\n    for _ in range(d):\n        x1, y1, x2, y2 = read_ints()\n        sofas.append([(x1, y1), (x2, y2)])\n\n    cnt_l, cnt_r, cnt_t, cnt_b = read_ints()\n\n    def count_sofas(sofas, x, y):\n        cnt_l = 0\n        cnt_r = 0\n        cnt_t = 0\n        cnt_b = 0\n        for sofa in sofas:\n            if sofa[0][0] == x and sofa[0][1] == y:\n                if sofa[1][0] < x:\n                    cnt_l += 1\n                elif sofa[1][0] > x:\n                    cnt_r += 1\n                if sofa[1][1] < y:\n                    cnt_t += 1\n                elif sofa[1][1] > y:\n                    cnt_b += 1\n            elif sofa[1][0] == x and sofa[1][1] == y:\n                if sofa[0][0] < x:\n                    cnt_l += 1\n                elif sofa[0][0] > x:\n                    cnt_r += 1\n                if sofa[0][1] < y:\n                    cnt_t += 1\n                elif sofa[0][1] > y:\n                    cnt_b += 1\n        return cnt_l, cnt_r, cnt_t, cnt_b\n\n    for i in range(d):\n        cnt_l1, cnt_r1, cnt_t1, cnt_b1 = count_sofas(sofas[:i] + sofas[i+1:], sofas[i][0][0], sofas[i][0][1])\n        cnt_l2, cnt_r2, cnt_t2, cnt_b2 = count_sofas(sofas[:i] + sofas[i+1:], sofas[i][1][0], sofas[i][1][1])\n        if cnt_l1 == cnt_l and cnt_r1 == cnt_r and cnt_t1 == cnt_t and cnt_b1 == cnt_b:\n            print(i + 1)\n            return\n        if cnt_l2 == cnt_l and cnt_r2 == cnt_r and cnt_t2 == cnt_t and cnt_b2 == cnt_b:\n            print(i + 1)\n            return\n    print(-1)\n\nsolve()"}
{"solution": "n = int(input())\nmin_days_off = (n - 1) // 7 * 2 + max(0, (n - 1) % 7 - 4)\nmax_days_off = n // 7 * 2 + min(2, n % 7)\nprint(min_days_off, max_days_off)"}
{"solution": "import math\n\nn, a, b, p, q = map(int, input().split())\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nlcm = (a * b) // gcd(a, b)\n\nred = n // a\nblue = n // b\nboth = n // lcm\n\nchocolates_red = red * p - both * min(p, q)\nchocolates_blue = blue * q - both * min(p, q)\n\nprint(chocolates_red + chocolates_blue + both * max(p, q))"}
{"solution": "def max_golden_trophies(n, trophies):\n    max_length = 0\n    current_length = 0\n    first_silver = -1\n    last_silver = -1\n    silver_count = 0\n\n    for i in range(n):\n        if trophies[i] == 'G':\n            current_length += 1\n            max_length = max(max_length, current_length)\n        else:\n            if first_silver == -1:\n                first_silver = i\n            last_silver = i\n            silver_count += 1\n            current_length = 0\n\n    if silver_count == 0:\n        return max_length\n    elif silver_count == 1:\n        return max_length + 1\n    else:\n        max_length_with_swap = 0\n        left_length = 0\n        right_length = 0\n\n        for i in range(first_silver):\n            if trophies[i] == 'G':\n                left_length += 1\n\n        for i in range(last_silver + 1, n):\n            if trophies[i] == 'G':\n                right_length += 1\n\n        max_length_with_swap = max(max_length_with_swap, left_length + right_length + 1)\n\n        for i in range(first_silver + 1, last_silver):\n            if trophies[i] == 'G':\n                max_length_with_swap += 1\n\n        return max(max_length, max_length_with_swap)\n\n\nn = int(input())\ntrophies = input()\nprint(max_golden_trophies(n, trophies))"}
{"solution": "from collections import defaultdict, deque\n\ndef solve():\n    n, k = map(int, input().split())\n    main_courses = list(map(int, input().split()))\n    graph = defaultdict(list)\n    in_degree = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        dependencies = list(map(int, input().split()))\n        in_degree[i] = dependencies[0]\n        if dependencies[0] > 0:\n            for dependency in dependencies[1:]:\n                graph[dependency].append(i)\n\n    queue = deque([course for course in main_courses if in_degree[course] == 0])\n    result = []\n\n    while queue:\n        course = queue.popleft()\n        result.append(course)\n        for neighbor in graph[course]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n\n    if len(result)!= len(set(result)):\n        print(-1)\n        return\n\n    for course in range(1, n + 1):\n        if course not in result and in_degree[course] == 0:\n            result.append(course)\n\n    if len(result)!= n:\n        print(-1)\n        return\n\n    print(len(result))\n    print(*result)\n\nsolve()"}
{"solution": "import sys\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    p = list(map(int, sys.stdin.readline().split()))\n\n    s = []\n    b = []\n    for i in range(k):\n        while s and s[-1] < p[i]:\n            b.append(s.pop())\n        if s and s[-1] > p[i]:\n            print(-1)\n            return\n        s.append(p[i])\n\n    for i in range(n, 0, -1):\n        if i not in p:\n            while s and s[-1] < i:\n                b.append(s.pop())\n            if s and s[-1] > i:\n                print(-1)\n                return\n            s.append(i)\n\n    while s:\n        b.append(s.pop())\n\n    print(*p, end=' ')\n    print(*b)\n\nif __name__ == '__main__':\n    solve()"}
{"solution": "a, b, c = map(int, input().split())\n\nif c == 0:\n    print(\"YES\" if a == b else \"NO\")\nelse:\n    print(\"YES\" if (b - a) % c == 0 and (b - a) // c >= 0 else \"NO\")"}
{"solution": "a = int(input())\nb = int(input())\nc = int(input())\nd = int(input())\n\nif a == c and b >= 1 or a == c + 1 and b >= c + 1 or a + 1 == c and b >= c:\n    print(1)\nelse:\n    print(0)"}
{"solution": "n, k, t = map(int, input().split())\n\nif t <= k:\n    print(min(t, n))\nelif t <= n:\n    print(k)\nelse:\n    print(max(k - (t - n), 0))"}
{"solution": "def solve(s):\n    t = []\n    u = []\n    for char in s:\n        if not t or char < t[-1]:\n            t.append(char)\n        else:\n            while t and char > t[-1]:\n                u.append(t.pop())\n            t.append(char)\n    while t:\n        u.append(t.pop())\n    return ''.join(u)\n\ns = input()\nprint(solve(s))"}
{"solution": "def check_records(n, records):\n    for i in range(1, n):\n        plays_diff = records[i][0] - records[i-1][0]\n        clears_diff = records[i][1] - records[i-1][1]\n        if plays_diff < 0 or clears_diff < 0 or clears_diff > plays_diff:\n            return \"NO\"\n    return \"YES\"\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    records = [list(map(int, input().split())) for _ in range(n)]\n    print(check_records(n, records))"}
{"solution": "def is_palindrome(time):\n    return time == time[::-1]\n\ndef next_palindrome(time):\n    h, m = map(int, time.split(':'))\n    m += 1\n    if m == 60:\n        m = 0\n        h = (h + 1) % 24\n    return f'{h:02d}:{m:02d}'\n\ndef minutes_diff(time1, time2):\n    h1, m1 = map(int, time1.split(':'))\n    h2, m2 = map(int, time2.split(':'))\n    return (h2 - h1) * 60 + (m2 - m1)\n\ntime = input()\nif is_palindrome(time):\n    print(0)\nelse:\n    next_pal = next_palindrome(time)\n    while not is_palindrome(next_pal):\n        next_pal = next_palindrome(next_pal)\n    print(minutes_diff(time, next_pal))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nmin_index = a.index(1)\nmax_index = a.index(n)\n\nmax_distance = max(abs(min_index - (n - 1)), abs(max_index - 0))\n\nif max_index < min_index:\n    max_distance = max(max_distance, abs(min_index - 0) + abs(max_index - (n - 1)))\nelse:\n    max_distance = max(max_distance, abs(min_index - (n - 1)) + abs(max_index - 0))\n\nprint(max_distance)"}
{"solution": "def is_s_palindrome(s):\n    s = s.lower()\n    return s == s[::-1]\n\ns = input()\nprint(\"TAK\" if is_s_palindrome(s) else \"NIE\")"}
{"solution": "from collections import Counter\n\ndef largest_permutation(a, b):\n    a = list(a)\n    b = list(b)\n    a_count = Counter(a)\n    b_count = Counter(b)\n    result = []\n    i = 0\n\n    while i < len(b):\n        max_digit = b[i]\n        if a_count[max_digit] > 0 and max_digit not in result:\n            result.append(max_digit)\n            a_count[max_digit] -= 1\n        else:\n            for digit in sorted(a_count.keys(), reverse=True):\n                if a_count[digit] > 0 and digit not in result:\n                    result.append(digit)\n                    a_count[digit] -= 1\n                    break\n        i += 1\n\n    return ''.join(result)\n\na = input()\nb = input()\nprint(largest_permutation(a, b))"}
{"solution": "def check_win(board, x, y):\n    directions = [(0, 1), (1, 0), (1, 1), (1, -1)]\n    for dx, dy in directions:\n        count = 0\n        for i in range(-4, 5):\n            nx, ny = x + i * dx, y + i * dy\n            if 0 <= nx < 10 and 0 <= ny < 10 and board[nx][ny] == 'X':\n                count += 1\n                if count >= 5:\n                    return True\n            else:\n                count = 0\n    return False\n\ndef check_possible_win(board):\n    for i in range(10):\n        for j in range(10):\n            if board[i][j] == '.':\n                board[i] = board[i][:j] + 'X' + board[i][j+1:]\n                if check_win(board, i, j):\n                    return True\n                board[i] = board[i][:j] + '.' + board[i][j+1:]\n    return False\n\nboard = [input() for _ in range(10)]\nprint('YES' if check_possible_win(board) else 'NO')"}
{"solution": "import sys\n\nn, k = map(int, input().split())\n\nif k > n * (n + 1) // 2:\n    print(-1)\n    sys.exit()\n\nmatrix = [[0] * n for _ in range(n)]\n\nfor i in range(n):\n    for j in range(i, n):\n        if k > 0:\n            matrix[i][j] = matrix[j][i] = 1\n            k -= 1\n\nfor row in matrix:\n    print(*row)"}
{"solution": "import math\n\nx, y, z = map(float, input().split())\n\noptions = {\n    \"x^y^z\": x ** (y ** z),\n    \"x^z^y\": x ** (z ** y),\n    \"(x^y)^z\": (x ** y) ** z,\n    \"(x^z)^y\": (x ** z) ** y,\n    \"y^x^z\": y ** (x ** z),\n    \"y^z^x\": y ** (z ** x),\n    \"(y^x)^z\": (y ** x) ** z,\n    \"(y^z)^x\": (y ** z) ** x,\n    \"z^x^y\": z ** (x ** y),\n    \"z^y^x\": z ** (y ** x),\n    \"(z^x)^y\": (z ** x) ** y,\n    \"(z^y)^x\": (z ** y) ** x,\n}\n\nmax_value = max(options.values())\nmax_key = [key for key, value in options.items() if math.isclose(value, max_value)][0]\n\nprint(max_key)"}
{"solution": "def min_operations(n, s):\n    min_ops = n\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            prefix = s[:i]\n            if prefix * (n // i) == s:\n                min_ops = min(min_ops, i + 1)\n            else:\n                for j in range(i + 1, n // 2 + 1):\n                    if n % j == 0:\n                        mid = s[:j]\n                        if mid * (n // j) == s:\n                            min_ops = min(min_ops, j + 1)\n    return min_ops\n\nn = int(input())\ns = input()\nprint(min_operations(n, s))"}
{"solution": "import sys\n\nn = int(input())\nfiles = {}\nfor _ in range(n):\n    name, type = input().split()\n    files[name] = int(type)\n\ne = sum(files.values())\nnon_e = n - e\n\ne_files = [name for name, type in files.items() if type == 1]\nnon_e_files = [name for name, type in files.items() if type == 0]\n\ne_files.sort(key=lambda x: (int(x) if x.isdigit() else float('inf'), x))\nnon_e_files.sort(key=lambda x: (int(x) if x.isdigit() else float('inf'), x))\n\ne_set = set(str(i) for i in range(1, e + 1))\nnon_e_set = set(str(i) for i in range(e + 1, n + 1))\n\ne_to_move = [file for file in e_files if file not in e_set]\nnon_e_to_move = [file for file in non_e_files if file not in non_e_set]\n\ne_to_rename = [file for file in e_files if file in non_e_set]\nnon_e_to_rename = [file for file in non_e_files if file in e_set]\n\nmoves = []\nfor file in e_to_move:\n    new_name = str(e_files.index(file) + 1)\n    moves.append((file, new_name))\nfor file in non_e_to_move:\n    new_name = str(non_e_files.index(file) + e + 1)\n    moves.append((file, new_name))\nfor file in e_to_rename:\n    new_name = str(e + non_e_files.index(file) + 1)\n    moves.append((file, new_name))\nfor file in non_e_to_rename:\n    new_name = str(non_e_files.index(file) + 1)\n    moves.append((file, new_name))\n\nprint(len(moves))\nfor file, new_name in moves:\n    print(f\"move {file} {new_name}\")"}
{"solution": "def min_replacements(ticket):\n    first_half_sum = sum(int(digit) for digit in ticket[:3])\n    second_half_sum = sum(int(digit) for digit in ticket[3:])\n\n    diff = abs(first_half_sum - second_half_sum)\n\n    if diff == 0:\n        return 0\n    elif diff < 10:\n        return 1\n    else:\n        return 2\n\nticket = input()\nprint(min_replacements(ticket))"}
{"solution": "import math\n\ndef euler_totient(n):\n    result = n\n    p = 2\n    while p * p <= n:\n        if n % p == 0:\n            while n % p == 0:\n                n //= p\n            result -= result // p\n        p += 1\n    if n > 1:\n        result -= result // n\n    return result\n\ndef solve():\n    m, x = map(int, input().split())\n    if m % 2 == 0:\n        print(m // 2 + 1 if x % 2 == 1 else 2)\n    else:\n        print(euler_totient(m))\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def power(a, b, mod):\n    res = 1\n    while b > 0:\n        if b & 1:\n            res = (res * a) % mod\n        a = (a * a) % mod\n        b >>= 1\n    return res\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nmod = 10**6 + 3\nn, k = map(int, input().split())\nden = power(2, n, mod)\nnum = 1\nfor i in range(1, k):\n    num = (num * (den - i)) % mod\n    den = (den * power(i, mod - 2, mod)) % mod\n    g = gcd(num, den)\n    num //= g\n    den //= g\nprint(num, den)"}
{"solution": "n = int(input())\nlat = 0\nfor _ in range(n):\n    t, dir = input().split()\n    t = int(t)\n    if dir == \"North\":\n        if lat == -20000:\n            print(\"NO\")\n            exit()\n        lat += t\n        if lat > 0:\n            lat = 0\n    elif dir == \"South\":\n        if lat == 0 and t > 0:\n            lat -= t\n            if lat < -20000:\n                lat = -20000\n        elif lat!= 0:\n            print(\"NO\")\n            exit()\n    elif dir == \"East\" or dir == \"West\":\n        if lat!= 0 and lat!= -20000:\n            print(\"NO\")\n            exit()\nprint(\"YES\" if lat == 0 else \"NO\")"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\na1, b1, a2, b2, L, R = map(int, input().split())\n\nif a1 > a2:\n    a1, a2 = a2, a1\n    b1, b2 = b2, b1\n\nif b1 > b2:\n    k = math.ceil((b2 - b1) / a1)\n    b1 += k * a1\n\nif b1 < b2:\n    l = math.ceil((b1 - b2) / a2)\n    b2 += l * a2\n\nif b1!= b2:\n    print(0)\nelse:\n    if a1 == a2:\n        print(max(0, R - b1) // a1 + 1 - max(0, L - b1 - 1) // a1)\n    else:\n        print(max(0, R - b1) // lcm(a1, a2) + 1 - max(0, L - b1 - 1) // lcm(a1, a2))"}
{"solution": "import math\n\nn, a, b = map(int, input().split())\n\ndef check(x):\n    if a % x == 0 and b % x == 0:\n        return a // x + b // x >= n\n    elif a % x == 0:\n        return a // x + (b - b % x) // x >= n\n    elif b % x == 0:\n        return (a - a % x) // x + b // x >= n\n    else:\n        return (a - a % x) // x + (b - b % x) // x >= n\n\nl, r = 1, min(a, b)\nwhile l < r:\n    mid = (l + r + 1) // 2\n    if check(mid):\n        l = mid\n    else:\n        r = mid - 1\n\nprint(l)"}
{"solution": "def is_valid_flag(n, m, flag):\n    colors = set()\n    for i in range(n):\n        color = flag[i][0]\n        for j in range(m):\n            if flag[i][j]!= color:\n                return False\n        colors.add(color)\n    if len(colors)!= 3:\n        return False\n    return True\n\ndef is_valid_stripe(n, m, flag):\n    stripe_height = n // 3\n    for i in range(3):\n        start = i * stripe_height\n        end = start + stripe_height\n        for j in range(start, end):\n            color = flag[j][0]\n            for k in range(m):\n                if flag[j][k]!= color:\n                    return False\n    return True\n\nn, m = map(int, input().split())\nflag = [input() for _ in range(n)]\n\nif is_valid_flag(n, m, flag) and is_valid_stripe(n, m, flag):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import math\n\nn = int(input())\n\nlayer = math.ceil((math.sqrt(6 * n + 1) - 1) / 6)\n\nstart = (layer - 1) * 6\nx, y = layer, -layer\n\nfor i in range(start, start + 6):\n    if i <= n:\n        if i < start + 1:\n            x -= 1\n        elif i < start + 2:\n            y += 1\n        elif i < start + 3:\n            x += 1\n        elif i < start + 4:\n            y += 1\n        elif i < start + 5:\n            x += 1\n        elif i < start + 6:\n            y -= 1\n\nprint(x, y)"}
{"solution": "a, b, c = map(int, input().split())\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\nl = lcm(a, b)\nprint(\"Yes\" if c % l == 0 or (c % a == 0) or (c % b == 0) or (c > a and c > b and (c - a) % b == 0) or (c > a and c > b and (c - b) % a == 0) else \"No\")"}
{"solution": "def is_coinciding_tracks(n, L, kefa, sasha):\n    kefa_diff = [(kefa[i] - kefa[i-1]) % L for i in range(n)]\n    kefa_diff.append((L - kefa[-1] + kefa[0]) % L)\n    sasha_diff = [(sasha[i] - sasha[i-1]) % L for i in range(n)]\n    sasha_diff.append((L - sasha[-1] + sasha[0]) % L)\n    return sorted(kefa_diff) == sorted(sasha_diff)\n\nn, L = map(int, input().split())\nkefa = list(map(int, input().split()))\nsasha = list(map(int, input().split()))\n\nif is_coinciding_tracks(n, L, kefa, sasha):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindrome(s):\n    max_length = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            substring = s[i:j]\n            if not is_palindrome(substring):\n                max_length = max(max_length, len(substring))\n    return max_length\n\ns = input()\nprint(longest_non_palindrome(s))"}
{"solution": "n = int(input())\nrated = False\nmaybe = True\n\nratings_before = []\nratings_after = []\n\nfor _ in range(n):\n    a, b = map(int, input().split())\n    ratings_before.append(a)\n    ratings_after.append(b)\n\nfor i in range(n):\n    if ratings_after[i]!= ratings_before[i]:\n        rated = True\n        break\n\nfor i in range(n - 1):\n    if ratings_before[i] < ratings_before[i + 1]:\n        maybe = False\n        break\n\nif rated:\n    print(\"rated\")\nelif maybe:\n    print(\"maybe\")\nelse:\n    print(\"unrated\")"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\ndistances = [float('inf')] * n\nzeros = [i for i, x in enumerate(a) if x == 0]\n\nfor i in range(n):\n    for zero in zeros:\n        distances[i] = min(distances[i], abs(i - zero))\n\nprint(*distances)"}
{"solution": "def count_cyclical_strings(n, s):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def count_strings(length):\n        count = 0\n        for i in range(1 << length):\n            binary = bin(i)[2:].zfill(length)\n            if s in binary or s in binary[1:] + binary[0]:\n                count += 1\n        return count\n\n    def count_cyclical_strings(length):\n        count = 0\n        for i in range(1 << length):\n            binary = bin(i)[2:].zfill(length)\n            if s in binary or s in binary[1:] + binary[0]:\n                g = gcd(length, i)\n                count += 1 << g\n        return count // length\n\n    return count_cyclical_strings(n)\n\nn = int(input())\ns = input()\nprint(count_cyclical_strings(n, s))"}
{"solution": "import math\n\nn = int(input())\nvectors = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    length = math.sqrt(x**2 + y**2)\n    angle = math.atan2(y, x)\n    vectors.append((angle, i+1))\n\nvectors.sort()\n\nmin_angle = float('inf')\nmin_indices = None\nfor i in range(n-1):\n    angle = vectors[i+1][0] - vectors[i][0]\n    if angle < 0:\n        angle += 2 * math.pi\n    if angle < min_angle:\n        min_angle = angle\n        min_indices = (vectors[i][1], vectors[i+1][1])\n\nangle = vectors[0][0] - vectors[-1][0] + 2 * math.pi\nif angle < min_angle:\n    min_angle = angle\n    min_indices = (vectors[0][1], vectors[-1][1])\n\nprint(*min_indices)"}
{"solution": "import math\n\nd, k, a, b, t = map(int, input().split())\n\ndef calculate_time(distance, k, a, b, t):\n    full_trips = math.floor(distance / k)\n    remaining_distance = distance % k\n\n    time_driving = full_trips * k * a\n    time_repairing = full_trips * t\n\n    time_remaining = min(remaining_distance * a + t, remaining_distance * b)\n\n    return time_driving + time_repairing + time_remaining\n\nprint(calculate_time(d, k, a, b, t))"}
{"solution": "import math\n\nn, k = map(int, input().split())\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef solve(n, k):\n    if n < k:\n        return -1\n    if n % k == 0:\n        return [n // k] * k\n    g = n // k\n    r = n % k\n    if r == 1:\n        return [g] * (k - 1) + [g + 1]\n    if r == 2 and k % 2 == 0:\n        return [g] * (k - 2) + [g + 1, g + 1]\n    if r == 2 and k % 2 == 1:\n        return [g] * (k - 3) + [g + 1, g + 1, g + 2]\n    if r > 2:\n        return [g] * (k - r) + [g + 1] * (r - 1) + [g + 2]\n\nresult = solve(n, k)\nif result == -1:\n    print(-1)\nelse:\n    print(*result)"}
{"solution": "n, m = map(int, input().split())\n\ncount = 0\nfor i in range(5):\n    count += min(n - i, m - (4 - i)) + max(0, min(n - i, m - (9 - i)) - 5)\n\nprint(count)"}
{"solution": "import sys\n\ndef read_ints():\n    return map(int, sys.stdin.readline().split())\n\ndef kadane(arr):\n    max_sum = 0\n    current_sum = 0\n    for num in arr:\n        current_sum = max(0, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n\ndef solve():\n    n, x = read_ints()\n    arr = list(read_ints())\n\n    if x >= 0:\n        return kadane([x * num for num in arr])\n\n    max_sum = 0\n    min_sum = 0\n    current_max_sum = 0\n    current_min_sum = 0\n    max_prefix_sum = 0\n    max_suffix_sum = 0\n    prefix_sum = 0\n    suffix_sum = 0\n\n    for num in arr:\n        current_max_sum = max(0, current_max_sum + num)\n        max_sum = max(max_sum, current_max_sum)\n\n        current_min_sum = min(0, current_min_sum + num)\n        min_sum = min(min_sum, current_min_sum)\n\n        prefix_sum += num\n        max_prefix_sum = max(max_prefix_sum, prefix_sum)\n\n    for num in reversed(arr):\n        suffix_sum += num\n        max_suffix_sum = max(max_suffix_sum, suffix_sum)\n\n    return max(max_sum, x * min_sum, max_prefix_sum + x * (prefix_sum - max_prefix_sum), max_suffix_sum + x * (suffix_sum - max_suffix_sum))\n\nprint(solve())"}
{"solution": "import sys\n\ndef count_less_equal(mid, n, m):\n    count = 0\n    for i in range(1, n + 1):\n        count += min(mid // i, m)\n    return count\n\ndef find_kth_largest(n, m, k):\n    left, right = 1, n * m\n    while left < right:\n        mid = (left + right) // 2\n        if count_less_equal(mid, n, m) < k:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\nn, m, k = map(int, sys.stdin.readline().split())\nprint(find_kth_largest(n, m, n * m - k + 1))"}
{"solution": "def find_kth_digit(k):\n    length = 1\n    count = 9\n    start = 1\n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n\n    start += (k - 1) // length\n    return str(start)[(k - 1) % length]\n\nk = int(input())\nprint(find_kth_digit(k))"}
{"solution": "import sys\n\nn, m, r = map(int, sys.stdin.readline().split())\ns = list(map(int, sys.stdin.readline().split()))\nb = list(map(int, sys.stdin.readline().split()))\n\ns.sort()\nb.sort(reverse=True)\n\nmax_bourles = r\nfor i in range(n):\n    for j in range(m):\n        if s[i] < b[j]:\n            shares = r // s[i]\n            max_bourles = max(max_bourles, shares * b[j] + r % s[i])\n\nprint(max_bourles)"}
{"solution": "def find_error(s):\n    for i in range(1, len(s) // 2 + 1):\n        if s[:i] == s[-i:] and s[:len(s) - i].find(s[:i]) == -1:\n            return s[:len(s) - i]\n    return None\n\ns = input()\nresult = find_error(s)\nif result is None:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(result)"}
{"solution": "import math\n\ndef solve(n):\n    result = []\n    for i in range(1, int(math.sqrt(2 * n)) + 1):\n        x = 2 * n // i - i + 1\n        if x % 2 == 1 and x >= i and x * (x - 1) // 2 + x // 2 == n:\n            result.append(x)\n        y = 2 * n // i - i + 2\n        if y % 2 == 0 and y >= i and y * (y - 1) // 2 + y // 2 == n:\n            result.append(y)\n    return sorted(result)\n\nn = int(input())\nresult = solve(n)\nif not result:\n    print(-1)\nelse:\n    for num in result:\n        print(num)"}
{"solution": "n = int(input())\ns = input()\nbeauty = list(map(int, input().split()))\n\nchar_count = {}\nfor char in s:\n    char_count[char] = char_count.get(char, 0) + 1\n\nmax_beauty = 0\nfor char, count in char_count.items():\n    char_beauty = []\n    for i in range(n):\n        if s[i] == char:\n            char_beauty.append(beauty[i])\n    char_beauty.sort(reverse=True)\n    max_beauty += sum(char_beauty[:count // 2])\n\nprint(max_beauty)"}
{"solution": "def can_weight(w, m):\n    if m % w == 0:\n        return False\n    for i in range(1, 101):\n        if (m - w**i) % w == 0:\n            return True\n    return False\n\nw, m = map(int, input().split())\nprint(\"YES\" if can_weight(w, m) else \"NO\")"}
{"solution": "import sys\n\ndef solve(n, k):\n    if k > n:\n        return [-1] * k\n\n    if n.bit_length() < k:\n        return \"No\"\n\n    max_bit = n.bit_length() - 1\n    ans = []\n    while k > 0:\n        if n & (1 << max_bit):\n            ans.append(max_bit)\n            k -= 1\n            n -= 1 << max_bit\n        max_bit -= 1\n\n    if n:\n        return \"No\"\n\n    ans.sort(reverse=True)\n    return ans\n\nn, k = map(int, sys.stdin.readline().split())\nresult = solve(n, k)\nif result == \"No\":\n    print(\"No\")\nelse:\n    print(\"Yes\")\n    print(*result)"}
{"solution": "def champagne_pyramid():\n    n, t = map(int, input().split())\n    pyramid = [[0] * i for i in range(1, n + 1)]\n    pyramid[0][0] = t\n\n    for i in range(n):\n        for j in range(len(pyramid[i])):\n            if pyramid[i][j] > 1:\n                excess = (pyramid[i][j] - 1) / 2\n                pyramid[i][j] = 1\n                if i < n - 1:\n                    pyramid[i + 1][j] += excess\n                    pyramid[i + 1][j + 1] += excess\n\n    return sum(1 for row in pyramid for glass in row if glass >= 1)\n\n\nprint(champagne_pyramid())"}
{"solution": "def calculate_area(n, points):\n    if n < 2:\n        return -1\n\n    x_coords = [point[0] for point in points]\n    y_coords = [point[1] for point in points]\n\n    x_coords.sort()\n    y_coords.sort()\n\n    if n == 2:\n        if x_coords[0] == x_coords[1] or y_coords[0] == y_coords[1]:\n            return -1\n        else:\n            return abs(x_coords[0] - x_coords[1]) * abs(y_coords[0] - y_coords[1])\n\n    if n == 3:\n        if x_coords[0] == x_coords[1] == x_coords[2] or y_coords[0] == y_coords[1] == y_coords[2]:\n            return -1\n        else:\n            if x_coords[0] == x_coords[1]:\n                x_diff = abs(x_coords[2] - x_coords[0])\n            elif x_coords[1] == x_coords[2]:\n                x_diff = abs(x_coords[1] - x_coords[0])\n            else:\n                x_diff = abs(x_coords[2] - x_coords[1])\n\n            if y_coords[0] == y_coords[1]:\n                y_diff = abs(y_coords[2] - y_coords[0])\n            elif y_coords[1] == y_coords[2]:\n                y_diff = abs(y_coords[1] - y_coords[0])\n            else:\n                y_diff = abs(y_coords[2] - y_coords[1])\n\n            return x_diff * y_diff\n\n    if n == 4:\n        return abs(x_coords[0] - x_coords[3]) * abs(y_coords[0] - y_coords[3])\n\n\nn = int(input())\npoints = []\nfor _ in range(n):\n    x, y = map(int, input().split())\n    points.append((x, y))\n\nprint(calculate_area(n, points))"}
{"solution": "import math\n\nn = int(input())\na = int(input())\nb = int(input())\n\ntotal_length = 2 * (2 * a + b)\nnum_bars = math.ceil(total_length / n)\n\nprint(num_bars)"}
{"solution": "import sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().split()))\n    s = sys.stdin.readline().strip()\n\n    pos = [0] * (n + 1)\n    for i in range(n):\n        pos[a[i]] = i\n\n    for i in range(n - 1):\n        if pos[i + 1] < pos[i]:\n            if s[i] == '0':\n                print(\"NO\")\n                return\n            j = pos[i + 1]\n            while j < pos[i]:\n                pos[a[j]], pos[a[j + 1]] = pos[a[j + 1]], pos[a[j]]\n                j += 1\n\n    print(\"YES\")\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def solve():\n    s = input()\n    n = int(s[:-1])\n    seat = s[-1]\n    seats = 'fedcba'\n    seat_index = seats.index(seat)\n    row_diff = n % 2\n    if row_diff == 0:\n        row_diff = -1\n    row = (n + 1 - row_diff) // 2\n    time = (row - 1) * 6 + (row - 1)\n    if row_diff == -1:\n        time += 3 - seat_index\n    else:\n        time += 3 + seat_index\n    print(time)\n\nsolve()"}
{"solution": "def convert_to_decimal(digits, base):\n    decimal = 0\n    for i, digit in enumerate(reversed(digits)):\n        decimal += digit * (base ** i)\n    return decimal\n\nn, bx = map(int, input().split())\nx = list(map(int, input().split()))\n\nm, by = map(int, input().split())\ny = list(map(int, input().split()))\n\nx_decimal = convert_to_decimal(x, bx)\ny_decimal = convert_to_decimal(y, by)\n\nif x_decimal < y_decimal:\n    print('<')\nelif x_decimal > y_decimal:\n    print('>')\nelse:\n    print('=')"}
{"solution": "def nim_sum(nums):\n    result = 0\n    for num in nums:\n        result ^= num\n    return result\n\ndef can_win(nums):\n    if len(nums) == 1:\n        return nums[0] > 0\n    if len(nums) == 2:\n        return nums[0]!= nums[1] or nums[0] > 0\n    return nim_sum(nums)!= 0 or max(nums) > min(nums)\n\nn = int(input())\nnums = list(map(int, input().split()))\n\nif can_win(nums):\n    print(\"BitLGM\")\nelse:\n    print(\"BitAryo\")"}
{"solution": "from collections import defaultdict\nfrom math import sqrt\nfrom functools import reduce\n\ndef prime_factors(n):\n    factors = defaultdict(int)\n    while n % 2 == 0:\n        factors[2] += 1\n        n //= 2\n    for i in range(3, int(sqrt(n)) + 1, 2):\n        while n % i == 0:\n            factors[i] += 1\n            n //= i\n    if n > 2:\n        factors[n] += 1\n    return factors\n\ndef count_ways(n, k, a):\n    k_factors = prime_factors(k)\n    prefix_factors = [defaultdict(int) for _ in range(n + 1)]\n    suffix_factors = [defaultdict(int) for _ in range(n + 1)]\n\n    for i in range(n):\n        factors = prime_factors(a[i])\n        for p, c in factors.items():\n            prefix_factors[i + 1][p] = prefix_factors[i][p] + c\n            suffix_factors[n - i - 1][p] = suffix_factors[n - i][p] + c\n\n    ways = 0\n    for i in range(n):\n        prefix = prefix_factors[i + 1]\n        suffix = suffix_factors[n - i]\n        combined = {p: prefix[p] + suffix[p] for p in set(prefix) | set(suffix)}\n        if all(combined[p] >= c for p, c in k_factors.items()):\n            ways += 1\n\n    return ways\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nprint(count_ways(n, k, a))"}
{"solution": "n, k = map(int, input().split())\ns = input()\n\ncolor_counts = {}\nfor color in s:\n    if color in color_counts:\n        color_counts[color] += 1\n    else:\n        color_counts[color] = 1\n\nmax_count = max(color_counts.values())\nif max_count <= k:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nmin_val = min(a)\nmin_indices = [i for i, x in enumerate(a) if x == min_val]\n\nmin_distance = float('inf')\nfor i in range(len(min_indices) - 1):\n    min_distance = min(min_distance, min_indices[i + 1] - min_indices[i])\n\nprint(min_distance)"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nt, w, b = map(int, input().split())\n\ng = gcd(w, b)\nlcm = (w * b) // g\n\ncount = 0\nfor i in range(1, t + 1):\n    if i % w == 0 and i % b == 0:\n        count += 1\n\nif lcm > t:\n    count = 0\n\ngcd_count_t = gcd(count, t)\ncount //= gcd_count_t\nt //= gcd_count_t\n\nprint(f\"{count}/{t}\")"}
{"solution": "x, y, z = map(int, input().split())\n\nif x > y + z:\n    print(\"+\")\nelif x + z < y:\n    print(\"-\")\nelif x == y:\n    print(\"0\")\nelif x + z == y or x == y + z:\n    print(\"?\")\nelse:\n    print(\"+\") if x > y else print(\"-\")"}
{"solution": "def solve():\n    n = int(input())\n    s = input()\n    x, y = map(int, input().split())\n\n    dx = s.count('R') - s.count('L')\n    dy = s.count('U') - s.count('D')\n\n    if dx == x and dy == y:\n        return 0\n\n    if abs(x - dx) > s.count('L') + s.count('R') or abs(y - dy) > s.count('U') + s.count('D'):\n        return -1\n\n    ans = n\n\n    for i in range(n):\n        cur_x = 0\n        cur_y = 0\n        cnt = 0\n        for j in range(i, n):\n            if s[j] == 'R':\n                cur_x += 1\n            elif s[j] == 'L':\n                cur_x -= 1\n            elif s[j] == 'U':\n                cur_y += 1\n            elif s[j] == 'D':\n                cur_y -= 1\n\n            if cur_x == x and cur_y == y:\n                cnt = j - i + 1\n                break\n\n            if cur_x > x:\n                cur_x -= 2\n                cnt += 1\n            if cur_y > y:\n                cur_y -= 2\n                cnt += 1\n\n        if cur_x == x and cur_y == y:\n            ans = min(ans, cnt)\n\n    for i in range(n):\n        cur_x = 0\n        cur_y = 0\n        cnt = 0\n        for j in range(i, -1, -1):\n            if s[j] == 'R':\n                cur_x += 1\n            elif s[j] == 'L':\n                cur_x -= 1\n            elif s[j] == 'U':\n                cur_y += 1\n            elif s[j] == 'D':\n                cur_y -= 1\n\n            if cur_x == x and cur_y == y:\n                cnt = i - j + 1\n                break\n\n            if cur_x > x:\n                cur_x -= 2\n                cnt += 1\n            if cur_y > y:\n                cur_y -= 2\n                cnt += 1\n\n        if cur_x == x and cur_y == y:\n            ans = min(ans, cnt)\n\n    return ans\n\nprint(solve())"}
{"solution": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    s = sys.stdin.readline().strip()\n\n    cnt0 = s.count('0')\n    cnt1 = n - cnt0\n    balance = cnt0 - cnt1\n\n    if x % balance!= 0:\n        print(0)\n        return\n\n    k = x // balance\n    if k < 0:\n        k = -(-k)\n    if k > 0:\n        if balance > 0:\n            print(0)\n            return\n    else:\n        if balance < 0:\n            print(0)\n            return\n\n    ans = 0\n    cur_balance = 0\n    for i in range(n):\n        if s[i] == '0':\n            cur_balance += 1\n        else:\n            cur_balance -= 1\n        if cur_balance == x:\n            ans += 1\n        if cur_balance * balance < x:\n            break\n\n    if balance == 0:\n        if x == 0:\n            print(-1)\n        else:\n            print(ans)\n    elif balance > 0:\n        if cur_balance < x:\n            print(ans)\n        else:\n            print(-1)\n    else:\n        if cur_balance > x:\n            print(ans)\n        else:\n            print(-1)\n\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    solve()"}
{"solution": "import math\n\nn, k = map(int, input().split())\n\ndef count_digits(num):\n    return math.floor(math.log10(num)) + 1 if num!= 0 else 1\n\ndef is_divisible(num, k):\n    return num % (10 ** k) == 0\n\ndef remove_digits(num, k):\n    num_str = str(num)\n    k_str = '0' * k\n    min_count = float('inf')\n    for i in range(len(num_str)):\n        for j in range(i + 1, len(num_str) + 1):\n            substr = num_str[i:j]\n            if substr.endswith(k_str):\n                count = len(num_str) - len(substr)\n                min_count = min(min_count, count)\n    return min_count\n\nprint(remove_digits(n, k))"}
{"solution": "n, m, k, x, y = map(int, input().split())\n\nif n == 1:\n    max_val = (k + m - 1) // m\n    min_val = max_val - 1\n    if max_val > 1:\n        min_val += k - (max_val - 1) * m\n    else:\n        min_val = 1\n    ser_val = (k + y - 1) // m\nelse:\n    full_cycles = (k - 1) // (2 * n * m - 2 * m) + 1\n    max_val = full_cycles\n    min_val = full_cycles\n    if n % 2 == 0:\n        max_val += 1\n    else:\n        if full_cycles % 2 == 0:\n            max_val += 1\n        else:\n            min_val += 1\n    ser_val = 0\n    if x == 1 or x == n:\n        ser_val = full_cycles\n        if (full_cycles % 2 == 0 and x == 1) or (full_cycles % 2 == 1 and x == n):\n            ser_val += 1\n    else:\n        if full_cycles % 2 == 0:\n            ser_val = full_cycles\n        else:\n            ser_val = full_cycles + 1\n        if full_cycles % 2 == 1:\n            ser_val += (k - (2 * n * m - 2 * m) * full_cycles) // m\n        else:\n            ser_val += (k - (2 * n * m - 2 * m) * full_cycles - m) // m\n    ser_val += (k - (2 * n * m - 2 * m) * full_cycles - (x - 1) * m) // (2 * n * m - 2 * m)\n    if (k - (2 * n * m - 2 * m) * full_cycles - (x - 1) * m) % (2 * n * m - 2 * m) + 1 <= (2 * n - 2) * m + y:\n        ser_val += 1\n\nprint(max_val, min_val, ser_val)"}
{"solution": "def calculate_beauty(s, n):\n    if n >= len(s):\n        return len(s)\n\n    char_count = {}\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n\n    max_count = max(char_count.values())\n    max_char = [char for char, count in char_count.items() if count == max_count]\n\n    if len(max_char) > 1:\n        return max_count + n\n\n    max_char = max_char[0]\n    max_char_count = char_count[max_char]\n    other_char_count = len(s) - max_char_count\n\n    if other_char_count <= n:\n        return len(s)\n\n    return max_char_count + n\n\n\ndef main():\n    n = int(input())\n    kuro = input()\n    shiro = input()\n    katie = input()\n\n    kuro_beauty = calculate_beauty(kuro, n)\n    shiro_beauty = calculate_beauty(shiro, n)\n    katie_beauty = calculate_beauty(katie, n)\n\n    max_beauty = max(kuro_beauty, shiro_beauty, katie_beauty)\n\n    if kuro_beauty == max_beauty and shiro_beauty!= max_beauty and katie_beauty!= max_beauty:\n        print(\"Kuro\")\n    elif shiro_beauty == max_beauty and kuro_beauty!= max_beauty and katie_beauty!= max_beauty:\n        print(\"Shiro\")\n    elif katie_beauty == max_beauty and kuro_beauty!= max_beauty and shiro_beauty!= max_beauty:\n        print(\"Katie\")\n    else:\n        print(\"Draw\")\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def calculate_days(c, v0, v1, a, l):\n    days = 1\n    pages_read = v0\n    if pages_read >= c:\n        return days\n    speed = v0\n    while True:\n        speed = min(speed + a, v1)\n        pages_read += speed - l\n        days += 1\n        if pages_read >= c:\n            return days\n\nc, v0, v1, a, l = map(int, input().split())\nprint(calculate_days(c, v0, v1, a, l))"}
{"solution": "def is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\nn = int(input())\n\nif is_prime(n):\n    print(1)\n    print(n)\nelse:\n    for i in range(2, n):\n        if is_prime(i) and is_prime(n - i):\n            print(2)\n            print(i, n - i)\n            break\n    else:\n        for i in range(2, n - 2):\n            if is_prime(i) and is_prime(n - i - 2) and is_prime(2):\n                print(3)\n                print(i, 2, n - i - 2)\n                break"}
{"solution": "def solve():\n    n, m = map(int, input().split())\n    grid = [list(input()) for _ in range(n)]\n\n    rows = [sum(row.count('*') for row in grid)]\n    cols = [sum(grid[i][j] == '*' for i in range(n)) for j in range(m)]\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '*':\n                rows.append(rows[0] - rows[i] - cols[j] + 1)\n                cols.append(cols[0] - cols[j] - rows[i] + 1)\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if rows[i] + cols[j] == rows[0] + cols[0]:\n                print(\"YES\")\n                print(i, j)\n                return\n\n    print(\"NO\")\n\nsolve()"}
{"solution": "n, m, a, b = map(int, input().split())\nmod = n % m\nadd = (m - mod) % m\nremove = mod\nadd_cost = add * a\nremove_cost = remove * b\nmin_cost = min(add_cost, remove_cost)\nif n - remove < 0:\n    print(min_cost)\nelse:\n    print(min(min_cost, (m - (n % m)) * a if (n % m)!= 0 else 0))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nodd = [x for x in a if x % 2!= 0]\neven = [x for x in a if x % 2 == 0]\n\nodd.sort()\neven.sort(reverse=True)\n\nodd_sum = sum(odd)\neven_sum = sum(even)\n\nif odd_sum % 2 == 0:\n    if even_sum!= 0:\n        odd_sum -= odd[0]\n    else:\n        odd_sum -= odd[0] * 2\n\nprint(odd_sum + even_sum)"}
{"solution": "from collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef solve():\n    n, T = map(int, input().split())\n    songs = []\n    for _ in range(n):\n        t, g = map(int, input().split())\n        songs.append((t, g))\n\n    dp = defaultdict(lambda: defaultdict(int))\n    for t, g in songs:\n        dp[t][g] = 1\n\n    for _ in range(n - 1):\n        new_dp = defaultdict(lambda: defaultdict(int))\n        for t1 in dp:\n            for g1 in dp[t1]:\n                for t2, g2 in songs:\n                    if g1!= g2:\n                        new_dp[t1 + t2][g2] += dp[t1][g1]\n                        new_dp[t1 + t2][g2] %= MOD\n        dp = new_dp\n\n    ans = 0\n    for t in dp:\n        if t == T:\n            for g in dp[t]:\n                ans += dp[t][g]\n                ans %= MOD\n\n    print(ans)\n\nsolve()"}
{"solution": "MOD = 10**9 + 7\n\ndef mod_inverse(a, m):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef solve():\n    m = int(input())\n    if m == 1:\n        print(1)\n        return\n\n    phi = [i for i in range(m + 1)]\n    for i in range(2, m + 1):\n        if phi[i] == i:\n            for j in range(i, m + 1, i):\n                phi[j] -= phi[j] // i\n\n    prob = [0] * (m + 1)\n    prob[1] = 1\n    for i in range(2, m + 1):\n        prob[i] = phi[i] * mod_inverse(i, MOD) % MOD\n\n    dp = [0] * (m + 1)\n    dp[1] = 1\n    for i in range(2, m + 1):\n        dp[i] = (1 + sum(dp[j] * prob[i // j] for j in range(i, 0, -1))) % MOD * mod_inverse(1 - prob[i], MOD) % MOD\n\n    print(dp[m])\n\nsolve()"}
{"solution": "import math\n\ndef count_pairs(l, r, x, y):\n    if x > y or y % x!= 0 or y < x * x:\n        return 0\n\n    factors = prime_factors(y // x)\n    count = 0\n\n    for mask in range(1 << len(factors)):\n        a = x\n        for i in range(len(factors)):\n            if (mask >> i) & 1:\n                a *= factors[i]\n        b = y // a\n        if l <= a <= r and l <= b <= r:\n            count += 1\n        if a!= b and l <= b <= r and l <= a <= r:\n            count += 1\n\n    return count\n\ndef prime_factors(n):\n    factors = []\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\nl, r, x, y = map(int, input().split())\nprint(count_pairs(l, r, x, y))"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\na, b = map(int, input().split())\ng = gcd(a, b)\na //= g\nb //= g\n\nif a > b:\n    a, b = b, a\n\nif a == 1:\n    print(g - b % g)\nelse:\n    print(g * ((b // a) - 1) % a)"}
{"solution": "n, k = map(int, input().split())\nmarks = list(map(int, input().split()))\n\ntotal_marks = sum(marks)\nadditional_marks = 0\n\nwhile (total_marks + additional_marks * k) / (n + additional_marks) < k:\n    additional_marks += 1\n\nprint(additional_marks)"}
{"solution": "import math\n\nn = int(input())\na = list(map(int, input().split()))\n\ndef check(d):\n    count = sum(1 for x in a if x / d > 0)\n    return count >= math.ceil(n / 2)\n\nfor d in range(-1000, 1001):\n    if d!= 0 and check(d):\n        print(d)\n        break\nelse:\n    print(0)"}
{"solution": "import math\n\nn = int(input())\nk = int(math.log10(n))\nmax_nines = 10**k\nmax_nines_sum = (max_nines * (max_nines + 1)) // 2\n\nif n < max_nines_sum:\n    max_nines //= 10\n    max_nines_sum = (max_nines * (max_nines + 1)) // 2\n\npairs = 0\nfor i in range(1, max_nines):\n    pairs += min(n - i, i - 1)\n\nif n >= max_nines_sum:\n    pairs += (n - max_nines_sum + 1) // 2\n\nprint(pairs)"}
{"solution": "from collections import deque\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef solve(a, b, c, d):\n    queue = deque([(a, b, 0)])\n    visited = set((a, b))\n    while queue:\n        x, y, steps = queue.popleft()\n        if x * y == c * d:\n            return steps, x, y, c, d\n        if x % 2 == 0 and (x // 2, y) not in visited:\n            queue.append((x // 2, y, steps + 1))\n            visited.add((x // 2, y))\n        if y % 2 == 0 and (x, y // 2) not in visited:\n            queue.append((x, y // 2, steps + 1))\n            visited.add((x, y // 2))\n        if x % 3 == 0 and (x // 3, y) not in visited:\n            queue.append((x // 3, y, steps + 1))\n            visited.add((x // 3, y))\n        if y % 3 == 0 and (x, y // 3) not in visited:\n            queue.append((x, y // 3, steps + 1))\n            visited.add((x, y // 3))\n    return -1, -1, -1, -1, -1\n\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\nsteps, x, y, c, d = solve(a, b, c, d)\nif steps == -1:\n    steps, x, y, a, b = solve(c, d, a, b)\n\nif steps == -1:\n    print(-1)\nelse:\n    print(steps)\n    print(x, y)\n    print(a, b)"}
{"solution": "x_p, y_p, x_v, y_v = map(int, input().split())\n\nif x_p + y_p <= max(x_v, y_v):\n    print(\"Polycarp\")\nelif x_p <= x_v and y_p <= y_v:\n    print(\"Polycarp\")\nelse:\n    print(\"Vasiliy\")"}
{"solution": "def days_in_month(month):\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        return 31\n    elif month == 2:\n        return 28\n    else:\n        return 30\n\nm, d = map(int, input().split())\ndays = days_in_month(m)\nweeks = (days + d - 1) // 7\nprint(weeks + (1 if days % 7!= 0 and d > 1 else 0))"}
{"solution": "def count_binary_zeros(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef solve(a, b):\n    def dfs(n, pos, has_zero):\n        if n > b:\n            return 0\n        if pos == 0:\n            return 1 if has_zero and count_binary_zeros(n) == 1 else 0\n        res = 0\n        if has_zero:\n            res += dfs(n * 2 + 1, pos - 1, True)\n        res += dfs(n * 2, pos - 1, has_zero)\n        return res\n\n    return dfs(1, 60, False) - dfs(1, 60, False) + dfs(a, 60, True) - dfs(b + 1, 60, True)\n\na, b = map(int, input().split())\nprint(solve(a, b))"}
{"solution": "import math\n\nn = int(input())\nprint(math.ceil(n * (n + 1) / (2 * math.floor(math.sqrt(n * (n + 1))))))"}
{"solution": "import math\nimport sys\n\ndef read_ints():\n    return map(int, sys.stdin.readline().split())\n\ndef read_int():\n    return int(sys.stdin.readline())\n\ndef read_string():\n    return sys.stdin.readline().strip()\n\ndef read_strings():\n    return sys.stdin.readline().split()\n\ndef solve():\n    n, k, S = read_ints()\n    a = list(read_ints())\n    fact = [math.factorial(x) for x in a]\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j > 0 and fact[i - 1] <= S:\n                dp[i][j] += dp[i - 1][j - 1]\n            if a[i - 1] <= S:\n                dp[i][j] += dp[i - 1][j]\n    print(dp[n][k])\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "import sys\n\ndef solve(n, k, a):\n    for x in a:\n        p = 0\n        while x:\n            if x % k:\n                if x % k!= 1:\n                    return \"NO\"\n                x //= k\n                p += 1\n            else:\n                x //= k\n                p += 1\n        if p > 60:\n            return \"NO\"\n    return \"YES\"\n\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    print(solve(n, k, a))"}
{"solution": "def get_divisors(n):\n    divisors = [0] * (n + 1)\n    for i in range(1, n + 1):\n        for j in range(i, n + 1, i):\n            divisors[j] += 1\n    return divisors\n\ndef main():\n    a, b, c = map(int, input().split())\n    divisors = get_divisors(a * b * c)\n    result = 0\n    for i in range(1, a + 1):\n        for j in range(1, b + 1):\n            for k in range(1, c + 1):\n                result += divisors[i * j * k]\n                result %= 1073741824\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from collections import deque\n\ndef is_solvable(puzzle):\n    flat_list = [item for sublist in puzzle for item in sublist]\n    inversions = 0\n    for i in range(len(flat_list)):\n        if flat_list[i] == 'X':\n            continue\n        for j in range(i + 1, len(flat_list)):\n            if flat_list[j]!= 'X' and flat_list[i] > flat_list[j]:\n                inversions += 1\n    return inversions % 2 == 0\n\ndef main():\n    bessie_puzzle = [input() for _ in range(2)]\n    elsie_puzzle = [input() for _ in range(2)]\n    print(\"YES\" if is_solvable(bessie_puzzle) == is_solvable(elsie_puzzle) else \"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n = int(input())\nk = input()\n\nresult = 0\npower = 0\n\nfor digit in reversed(k):\n    result += int(digit) * (n ** power)\n    power += 1\n\nprint(result)"}
{"solution": "def is_unimodal(arr):\n    increasing = decreasing = False\n    for i in range(len(arr) - 1):\n        if arr[i] < arr[i + 1]:\n            if decreasing:\n                return False\n            increasing = True\n        elif arr[i] > arr[i + 1]:\n            decreasing = True\n    return True\n\nn = int(input())\narr = list(map(int, input().split()))\nprint(\"YES\" if is_unimodal(arr) else \"NO\")"}
{"solution": "def solve():\n    n, k = map(int, input().split())\n    if k > n:\n        print(0)\n        return\n    if k == n:\n        print(1)\n        return\n    if n == 1:\n        print(1)\n        return\n    if n == 2:\n        print(2)\n        return\n    if n == 3:\n        if k == 1:\n            print(3)\n        else:\n            print(1)\n        return\n    if n % 2 == 0:\n        if k <= n // 2:\n            print(n)\n            return\n        else:\n            print(solve_helper(n, k))\n            return\n    else:\n        if k <= (n - 1) // 2 + 1:\n            print(n)\n            return\n        else:\n            print(solve_helper(n, k))\n            return\n\n\ndef solve_helper(n, k):\n    if n % 2 == 0:\n        if k <= n // 2:\n            return n\n        else:\n            return solve_helper(n - 1, k - n // 2)\n    else:\n        if k <= (n - 1) // 2 + 1:\n            return n\n        else:\n            return solve_helper(n - 1, k - (n - 1) // 2 - 1)\n\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nn, m, x, y, vx, vy = map(int, input().split())\n\nif vx == 0:\n    if vy > 0:\n        print(x, m)\n    else:\n        print(x, 0)\nelif vy == 0:\n    if vx > 0:\n        print(n, y)\n    else:\n        print(0, y)\nelse:\n    dx = n - x if vx > 0 else x\n    dy = m - y if vy > 0 else y\n    g = gcd(dx, dy)\n    dx //= g\n    dy //= g\n    if dx == dy:\n        if vx > 0 and vy > 0:\n            print(n, m)\n        elif vx > 0 and vy < 0:\n            print(n, 0)\n        elif vx < 0 and vy > 0:\n            print(0, m)\n        else:\n            print(0, 0)\n    else:\n        print(-1)"}
{"solution": "def can_place_paintings(a1, b1, a2, b2, a3, b3):\n    # Check if the sum of the areas of the paintings is less than or equal to the area of the board\n    if a2 * b2 + a3 * b3 > a1 * b1:\n        return False\n\n    # Check all possible combinations of painting placements\n    for p1 in [(a2, b2), (b2, a2)]:\n        for p2 in [(a3, b3), (b3, a3)]:\n            # Check if the paintings can be placed side by side\n            if p1[0] + p2[0] <= a1 and max(p1[1], p2[1]) <= b1:\n                return True\n            # Check if the paintings can be placed one on top of the other\n            if p1[1] + p2[1] <= b1 and max(p1[0], p2[0]) <= a1:\n                return True\n\n    return False\n\n\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\na3, b3 = map(int, input().split())\n\nprint(\"YES\" if can_place_paintings(a1, b1, a2, b2, a3, b3) else \"NO\")"}
{"solution": "def solve():\n    b1, q, l, m = map(int, input().split())\n    bad = set(map(int, input().split()))\n\n    if b1 in bad:\n        return 0\n\n    if q == 0:\n        return 0 if b1 in bad else \"inf\"\n\n    if q == 1:\n        return \"inf\" if b1 not in bad else 0\n\n    if abs(q) == 1:\n        return \"inf\"\n\n    if q < 0:\n        q = -q\n        b1 = -b1\n\n    if b1 < 0:\n        b1 = -b1\n        q = -q\n\n    if b1 > l:\n        return 0\n\n    if q > 1:\n        count = 0\n        while b1 <= l:\n            if b1 not in bad:\n                count += 1\n            b1 *= q\n        return count\n\n    count = 0\n    while b1 <= l:\n        if b1 not in bad:\n            count += 1\n        b1 *= q\n    return count\n\nprint(solve())"}
{"solution": "def find_frame(n, m, screen):\n    min_x, max_x, min_y, max_y = float('inf'), float('-inf'), float('inf'), float('-inf')\n    for i in range(n):\n        for j in range(m):\n            if screen[i][j] == 'w':\n                min_x, max_x = min(min_x, j), max(max_x, j)\n                min_y, max_y = min(min_y, i), max(max_y, i)\n\n    size = max(max_x - min_x, max_y - min_y) + 1\n    if size == 1:\n        if screen[min_y][min_x] == 'w':\n            screen[min_y][min_x] = '+'\n        return screen\n\n    for i in range(min_y, max_y + 1):\n        if screen[i][min_x]!= 'w':\n            screen[i] = screen[i][:min_x] + '+' + screen[i][min_x + 1:]\n        if screen[i][max_x]!= 'w':\n            screen[i] = screen[i][:max_x] + '+' + screen[i][max_x + 1:]\n\n    for j in range(min_x, max_x + 1):\n        if screen[min_y][j]!= 'w':\n            screen[min_y] = screen[min_y][:j] + '+' + screen[min_y][j + 1:]\n        if screen[max_y][j]!= 'w':\n            screen[max_y] = screen[max_y][:j] + '+' + screen[max_y][j + 1:]\n\n    return screen\n\n\ndef check_frame(n, m, screen):\n    min_x, max_x, min_y, max_y = float('inf'), float('-inf'), float('inf'), float('-inf')\n    for i in range(n):\n        for j in range(m):\n            if screen[i][j] == 'w':\n                min_x, max_x = min(min_x, j), max(max_x, j)\n                min_y, max_y = min(min_y, i), max(max_y, i)\n\n    size = max(max_x - min_x, max_y - min_y) + 1\n    for i in range(min_y, max_y + 1):\n        if screen[i][min_x] == 'w' or screen[i][max_x] == 'w':\n            return False\n        if screen[i][min_x]!= '+' and screen[i][min_x]!= '.':\n            return False\n        if screen[i][max_x]!= '+' and screen[i][max_x]!= '.':\n            return False\n\n    for j in range(min_x, max_x + 1):\n        if screen[min_y][j] == 'w' or screen[max_y][j] == 'w':\n            return False\n        if screen[min_y][j]!= '+' and screen[min_y][j]!= '.':\n            return False\n        if screen[max_y][j]!= '+' and screen[max_y][j]!= '.':\n            return False\n\n    return True\n\n\ndef main():\n    n, m = map(int, input().split())\n    screen = [list(input()) for _ in range(n)]\n\n    min_x, max_x, min_y, max_y = float('inf'), float('-inf'), float('inf'), float('-inf')\n    for i in range(n):\n        for j in range(m):\n            if screen[i][j] == 'w':\n                min_x, max_x = min(min_x, j), max(max_x, j)\n                min_y, max_y = min(min_y, i), max(max_y, i)\n\n    size = max(max_x - min_x, max_y - min_y) + 1\n    if size == 1:\n        if screen[min_y][min_x] == 'w':\n            screen[min_y][min_x] = '+'\n        for i in range(n):\n            print(''.join(screen[i]))\n        return\n\n    for i in range(min_y, max_y + 1):\n        screen[i][min_x] = '+'\n        screen[i][max_x] = '+'\n\n    for j in range(min_x, max_x + 1):\n        screen[min_y][j] = '+'\n        screen[max_y][j] = '+'\n\n    if check_frame(n, m, screen):\n        for i in range(n):\n            print(''.join(screen[i]))\n    else:\n        print(-1)\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def extended_gcd(a, b):\n    if a == 0:\n        return b, 0, 1\n    else:\n        gcd, x, y = extended_gcd(b % a, a)\n        return gcd, y - (b // a) * x, x\n\ndef solve(n, a, b):\n    gcd, x, y = extended_gcd(a, b)\n    if n % gcd!= 0:\n        return None\n    x *= n // gcd\n    y *= n // gcd\n    k = a // gcd\n    x = x % k\n    if x < 0:\n        x += k\n    return x, y\n\nn = int(input())\na = int(input())\nb = int(input())\n\nresult = solve(n, a, b)\nif result is None:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(*result)"}
{"solution": "def int_to_words(num):\n    ones = ['', 'one', 'two', 'three', 'four', 'five','six','seven', 'eight', 'nine']\n    teens = ['ten', 'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen','sixteen','seventeen', 'eighteen', 'nineteen']\n    tens = ['', '', 'twenty', 'thirty', 'forty', 'fifty','sixty','seventy', 'eighty', 'ninety']\n\n    if num < 10:\n        return ones[num]\n    elif num < 20:\n        return teens[num - 10]\n    elif num < 100:\n        return tens[num // 10] + ('' if num % 10 == 0 else '-' + ones[num % 10])\n\nnum = int(input())\nprint(int_to_words(num))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nmax_erase = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        left = a[i] - 1\n        right = a[j] + 1\n        if left >= 1 and right <= 1000:\n            max_erase = max(max_erase, j - i - 1)\n\nprint(max_erase)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\ntotal_problems = sum(a)\nhalf_problems = total_problems / 2\ncurrent_problems = 0\n\nfor i, problems in enumerate(a):\n    current_problems += problems\n    if current_problems >= half_problems:\n        print(i + 1)\n        break"}
{"solution": "import sys\nfrom collections import deque\n\nN = int(input())\nA = [list(map(int, input().split())) for _ in range(N)]\n\npos = [[0] * (N * N + 1) for _ in range(2)]\nfor i in range(N):\n    for j in range(N):\n        pos[0][A[i][j]] = i\n        pos[1][A[i][j]] = j\n\ninf = 10 ** 9\ndp = [[[inf] * 3 for _ in range(N * N + 1)] for _ in range(2)]\ndq = deque()\n\ndef ok(x, y):\n    return 0 <= x < N and 0 <= y < N\n\ndef bfs(sx, sy, t):\n    q = deque()\n    q.append((sx, sy, 0))\n    dp[t][A[sx][sy]][0] = 0\n    while q:\n        x, y, d = q.popleft()\n        if d > dp[t][A[x][y]][0]:\n            continue\n        for dx, dy in [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]:\n            nx, ny = x + dx, y + dy\n            if ok(nx, ny) and d + 1 < dp[t][A[nx][ny]][0]:\n                dp[t][A[nx][ny]][0] = d + 1\n                q.append((nx, ny, d + 1))\n\ndef bfs2(sx, sy, t):\n    q = deque()\n    q.append((sx, sy, 0))\n    dp[t][A[sx][sy]][1] = 0\n    while q:\n        x, y, d = q.popleft()\n        if d > dp[t][A[x][y]][1]:\n            continue\n        for dx, dy in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]:\n            if dx == 0 or dy == 0:\n                continue\n            nx, ny = x + dx, y + dy\n            if ok(nx, ny) and d + 1 < dp[t][A[nx][ny]][1]:\n                dp[t][A[nx][ny]][1] = d + 1\n                q.append((nx, ny, d + 1))\n\ndef bfs3(sx, sy, t):\n    q = deque()\n    q.append((sx, sy, 0))\n    dp[t][A[sx][sy]][2] = 0\n    while q:\n        x, y, d = q.popleft()\n        if d > dp[t][A[x][y]][2]:\n            continue\n        for dx, dy in [(-1, 0), (0, -1), (0, 1), (1, 0)]:\n            nx, ny = x + dx, y + dy\n            if ok(nx, ny) and d + 1 < dp[t][A[nx][ny]][2]:\n                dp[t][A[nx][ny]][2] = d + 1\n                q.append((nx, ny, d + 1))\n\nbfs(pos[0][1], pos[1][1], 0)\nbfs2(pos[0][1], pos[1][1], 1)\nbfs3(pos[0][1], pos[1][1], 0)\nfor i in range(2, N * N + 1):\n    for j in range(3):\n        for k in range(3):\n            if j!= k:\n                dp[1][i][j] = min(dp[1][i][j], dp[0][i - 1][k] + 1)\n    for j in range(3):\n        dp[1][i][j] += dp[0][i][j]\n    for j in range(3):\n        dp[0][i][j] = dp[1][i][j]\n\nans = min(dp[1][N * N][0], dp[1][N * N][1], dp[1][N * N][2])\nfor i in range(3):\n    for j in range(3):\n        if i!= j:\n            ans = min(ans, dp[0][N * N][i] + 1)\n\nfor i in range(3):\n    for j in range(3):\n        if i!= j:\n            dp[0][N * N][j] = min(dp[0][N * N][j], dp[0][N * N][i] + 1)\n\nprint(ans, min(dp[0][N * N][0], dp[0][N * N][1], dp[0][N * N][2]))"}
{"solution": "import math\n\nn, m, k = map(int, input().split())\na, b = map(int, input().split())\n\ndef get_position(num):\n    return ((num - 1) // (m * k), (num - 1) % (m * k) // k, (num - 1) % k)\n\na_ent, a_floor, a_num = get_position(a)\nb_ent, b_floor, b_num = get_position(b)\n\ndef get_time(ent1, floor1, ent2, floor2):\n    dist = abs(ent1 - ent2)\n    dist = min(dist, n - dist)\n    return 10 + abs(floor1 - 1) + abs(floor2 - 1) + dist * 15, 5 * abs(floor1 - floor2) + dist * 15\n\nlift_time, stairs_time = get_time(a_ent, a_floor, b_ent, b_floor)\nprint(min(lift_time, stairs_time))"}
{"solution": "def is_divisible_by_64(s):\n    s = s.rstrip('0')\n    return s.endswith('000000') or s.endswith('1000000') or s.endswith('11000000') or s.endswith('111000000')\n\ns = input()\nprint('yes' if is_divisible_by_64(s) else 'no')"}
{"solution": "def solve(s):\n    result = []\n    target = 'abcdefghijklmnopqrstuvwxyz'\n    target_index = 0\n\n    for char in s:\n        if char >= target[target_index]:\n            result.append(char)\n            if char == target[target_index]:\n                target_index += 1\n                if target_index == len(target):\n                    break\n\n    if target_index < len(target):\n        return -1\n\n    remaining_chars = list(s)\n    for char in result:\n        remaining_chars.remove(char)\n\n    result.extend(remaining_chars)\n\n    for i in range(len(result)):\n        if result[i]!= 'z':\n            next_char = chr(ord(result[i]) + 1)\n            if next_char in target[target_index:]:\n                result[i] = next_char\n\n    return ''.join(result)\n\n\ns = input()\nprint(solve(s))"}
{"solution": "import sys\n\nn, m, r, k = map(int, sys.stdin.readline().split())\n\nif k == 1:\n    print(1 / ((n - r + 1) * (m - r + 1)))\n    sys.exit()\n\nif n < m:\n    n, m = m, n\n\nif n == r:\n    print(k / (n - r + 1))\n    sys.exit()\n\nif r == 1:\n    print(k / ((n - r + 1) * (m - r + 1)))\n    sys.exit()\n\nif k == n * m:\n    print(k / ((n - r + 1) * (m - r + 1)))\n    sys.exit()\n\nif n == m:\n    if r == 2:\n        if k == 4:\n            print(3.5 / ((n - r + 1) * (m - r + 1)))\n            sys.exit()\n        else:\n            print(4 / ((n - r + 1) * (m - r + 1)))\n            sys.exit()\n    elif r == 3:\n        if k == 9:\n            print(6.5 / ((n - r + 1) * (m - r + 1)))\n            sys.exit()\n        else:\n            print(9 / ((n - r + 1) * (m - r + 1)))\n            sys.exit()\n\nans = 0\nfor i in range(1, r):\n    for j in range(1, r):\n        if i * j > k:\n            break\n        x = r - i\n        y = r - j\n        a = (n - r + 1) * (m - r + 1)\n        b = (n - r + 1) * y + (m - r + 1) * x - x * y\n        c = x * y\n        d = i * j\n        e = k - d\n        f = a - b + c\n        g = a - b\n        h = (d * f + e * g) / a\n        ans = max(ans, h)\n\nprint(ans)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nnegatives = sum(1 for x in a if x < 0)\nzeros = sum(1 for x in a if x == 0)\n\nif zeros > 0:\n    print(*a)\nelif negatives % 2 == 0:\n    print(*[-x - 1 if x > 0 else x for x in a])\nelse:\n    min_abs = min(abs(x) for x in a)\n    if min_abs == 0:\n        print(*a)\n    else:\n        print(*[-x - 1 if x > 0 or abs(x)!= min_abs else x for x in a])"}
{"solution": "import math\n\ndef prime_factors(n):\n    factors = []\n    while n % 2 == 0:\n        factors.append(2)\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            factors.append(i)\n            n = n / i\n    if n > 2:\n        factors.append(n)\n    return factors\n\ndef divisors(n):\n    factors = prime_factors(n)\n    unique_factors = list(set(factors))\n    divisors = [1]\n    for factor in unique_factors:\n        new_divisors = []\n        for divisor in divisors:\n            for _ in range(factors.count(factor)):\n                new_divisors.append(divisor * factor)\n        divisors.extend(new_divisors)\n    return sorted(list(set(divisors)))\n\nn, k = map(int, input().split())\ndivs = divisors(n)\nprint(divs[k-1] if k <= len(divs) else -1)"}
{"solution": "from collections import defaultdict\nfrom itertools import permutations\n\ndef get_digits(cube):\n    digits = set(cube)\n    for i in range(6):\n        if cube[i] == 6:\n            digits.add(9)\n        elif cube[i] == 9:\n            digits.add(6)\n    return digits\n\ndef get_permutations(cubes, n):\n    perms = []\n    for p in permutations(cubes, n):\n        digits = [get_digits(cube) for cube in p]\n        perms.append(digits)\n    return perms\n\ndef check_number(num, digits):\n    num_str = str(num)\n    for digit in num_str:\n        if int(digit) not in digits[0]:\n            return False\n        digits = digits[1:]\n    return True\n\ndef solve(n, cubes):\n    max_num = 0\n    for i in range(1, n + 1):\n        perms = get_permutations(cubes, i)\n        for digits in perms:\n            for num in range(1, 10 ** i):\n                if check_number(num, digits):\n                    max_num = max(max_num, num)\n    return max_num\n\nn = int(input())\ncubes = []\nfor _ in range(n):\n    cube = list(map(int, input().split()))\n    cubes.append(cube)\n\nprint(solve(n, cubes))"}
{"solution": "import math\n\nn, k = map(int, input().split())\npower_of_ten = 10 ** k\nlcm = (n * power_of_ten) // math.gcd(n, power_of_ten)\nprint(lcm)"}
{"solution": "def solve():\n    n, m = map(int, input().split())\n    a = [list(map(int, input().split())) for _ in range(n)]\n\n    if any(a[i][j] == 1 and a[i+1][j] == 0 for i in range(n-1) for j in range(m)):\n        print(-1)\n        return\n\n    if any(a[i][j] == 1 and a[i][j+1] == 0 for i in range(n) for j in range(m-1)):\n        print(-1)\n        return\n\n    ans = []\n    for i in range(n-1):\n        for j in range(m-1):\n            if a[i][j] == 1 or a[i+1][j] == 1 or a[i][j+1] == 1 or a[i+1][j+1] == 1:\n                ans.append((i, j))\n                a[i][j] = a[i+1][j] = a[i][j+1] = a[i+1][j+1] = 1\n\n    print(len(ans))\n    for x, y in ans:\n        print(x+1, y+1)\n\nsolve()"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef solve():\n    r, s, p = read_ints()\n    total = r + s + p\n    lcm_r = lcm(r, total)\n    lcm_s = lcm(s, total)\n    lcm_p = lcm(p, total)\n    lcm_rs = lcm(lcm_r, lcm_s)\n    lcm_rp = lcm(lcm_r, lcm_p)\n    lcm_sp = lcm(lcm_s, lcm_p)\n    lcm_all = lcm(lcm_rs, lcm_p)\n\n    prob_r = lcm_all // lcm_r\n    prob_s = lcm_all // lcm_s\n    prob_p = lcm_all // lcm_p\n\n    prob_r -= lcm_all // lcm_rs + lcm_all // lcm_rp\n    prob_s -= lcm_all // lcm_rs + lcm_all // lcm_sp\n    prob_p -= lcm_all // lcm_rp + lcm_all // lcm_sp\n\n    prob_r += lcm_all // lcm_all\n    prob_s += lcm_all // lcm_all\n    prob_p += lcm_all // lcm_all\n\n    print(prob_r / lcm_all, prob_s / lcm_all, prob_p / lcm_all)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def calculate_time_together(l1, r1, l2, r2, k):\n    start = max(l1, l2)\n    end = min(r1, r2)\n    time_together = max(0, end - start + 1)\n    if k >= start and k <= end:\n        time_together -= 1\n    return time_together\n\nl1, r1, l2, r2, k = map(int, input().split())\nprint(calculate_time_together(l1, r1, l2, r2, k))"}
{"solution": "import sys\n\ndef main():\n    input = sys.stdin.readline\n\n    N, M = map(int, input().split())\n    A = []\n    B = []\n    C = []\n    D = []\n    E = []\n    F = []\n\n    for _ in range(N):\n        a, b, c = map(int, input().split())\n        A.append(a)\n        B.append(b)\n        C.append(c)\n\n    for _ in range(M):\n        d, e, f = map(int, input().split())\n        D.append(d)\n        E.append(e)\n        F.append(f)\n\n    def check(x):\n        for i in range(N):\n            if A[i] <= x <= B[i] and C[i] == 0:\n                return False\n        return True\n\n    def check2(y):\n        for i in range(M):\n            if E[i] <= y <= F[i] and D[i] == 0:\n                return False\n        return True\n\n    def calc(x):\n        left = -10**9\n        right = 10**9\n        for i in range(M):\n            if D[i] == x:\n                left = max(left, E[i])\n                right = min(right, F[i])\n        if left > right:\n            return 0\n        return right - left\n\n    def calc2(y):\n        left = -10**9\n        right = 10**9\n        for i in range(N):\n            if C[i] == y:\n                left = max(left, A[i])\n                right = min(right, B[i])\n        if left > right:\n            return 0\n        return right - left\n\n    left = -10**9\n    right = 10**9\n    for i in range(N):\n        if C[i] == 0:\n            left = max(left, A[i])\n            right = min(right, B[i])\n\n    if left > right:\n        print(\"INF\")\n        return\n\n    up = 10**9\n    down = -10**9\n    for i in range(M):\n        if D[i] == 0:\n            up = min(up, F[i])\n            down = max(down, E[i])\n\n    if up < down:\n        print(\"INF\")\n        return\n\n    ans = 0\n    for i in range(left, right + 1):\n        if not check(i):\n            continue\n        tmp = calc(i)\n        ans += tmp\n\n    for i in range(down, up + 1):\n        if not check2(i):\n            continue\n        tmp = calc2(i)\n        ans += tmp\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "t, s, x = map(int, input().split())\n\nif t == x or (x - t) % s == 0 or (x - t) % s == 1:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\ndef solve():\n    n = int(input())\n    segments = []\n    for i in range(n):\n        l, r = map(int, input().split())\n        segments.append((l, r, i + 1))\n\n    segments.sort()\n\n    min_r = sys.maxsize\n    min_idx = -1\n    for l, r, idx in segments:\n        if r <= min_r:\n            min_r = r\n            min_idx = idx\n        elif l >= min_r:\n            print(idx, min_idx)\n            return\n\n    print(-1, -1)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "n = int(input())\ns = input()\n\ncounts = {'A': 0, 'C': 0, 'G': 0, 'T': 0}\nfor char in s:\n    if char in counts:\n        counts[char] += 1\n\ntarget_count = (n + 3) // 4\nfor char in counts:\n    counts[char] = target_count - counts[char]\n\nif any(count < 0 for count in counts.values()):\n    print(\"===\")\nelse:\n    result = []\n    for char in s:\n        if char == '?':\n            for c in counts:\n                if counts[c] > 0:\n                    result.append(c)\n                    counts[c] -= 1\n                    break\n        else:\n            result.append(char)\n    print(\"\".join(result))"}
{"solution": "def check_win(board, symbol):\n    # Check rows\n    for row in board:\n        if row.count(symbol) == 3 and '.' in row:\n            return True\n\n    # Check columns\n    for col in range(4):\n        column = [row[col] for row in board]\n        if column.count(symbol) == 3 and '.' in column:\n            return True\n\n    # Check diagonals\n    diagonal1 = [board[i][i] for i in range(4)]\n    diagonal2 = [board[i][3-i] for i in range(4)]\n    if (diagonal1.count(symbol) == 3 and '.' in diagonal1) or (diagonal2.count(symbol) == 3 and '.' in diagonal2):\n        return True\n\n    return False\n\n\ndef main():\n    board = [input() for _ in range(4)]\n    print(\"YES\" if check_win(board, 'x') else \"NO\")\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def can_divide_array(n, a):\n    total_sum = sum(a)\n    if total_sum % 2!= 0:\n        return False\n\n    target_sum = total_sum // 2\n    prefix_sum = 0\n    for i in range(n):\n        prefix_sum += a[i]\n        if prefix_sum == target_sum:\n            return True\n        if prefix_sum > target_sum and prefix_sum - a[i] == target_sum - (total_sum - prefix_sum + a[i]):\n            return True\n        if prefix_sum < target_sum and prefix_sum + (total_sum - prefix_sum - a[i]) == target_sum - a[i]:\n            return True\n\n    return False\n\n\nn = int(input())\na = list(map(int, input().split()))\n\nif can_divide_array(n, a):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\na.sort()\nb.sort()\n\ni = 0\nj = 0\nincreasing = True\n\nwhile i < n and j < k:\n    if a[i] == 0:\n        a[i] = b[j]\n        j += 1\n    elif a[i] > a[i-1]:\n        increasing = False\n    i += 1\n\nif increasing:\n    print(\"No\")\nelse:\n    print(\"Yes\")"}
{"solution": "x, y, z = map(int, input().split())\na, b, c = map(int, input().split())\n\nandrew = min(x, a)\ndmitry = min(max(y - (a - andrew), 0), a - andrew + b)\nmichal = min(z, a - andrew - dmitry + b - dmitry + c)\n\nif andrew + dmitry + michal >= x + y + z:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def is_accident_possible():\n    parts = [list(map(int, input().split())) for _ in range(4)]\n\n    for i in range(4):\n        if parts[i][3] == 1 and (parts[i][0] == 1 or parts[i][1] == 1 or parts[i][2] == 1):\n            return \"YES\"\n        if parts[i][3] == 1 and (parts[(i-1)%4][2] == 1 or parts[(i+1)%4][0] == 1):\n            return \"YES\"\n\n    return \"NO\"\n\nprint(is_accident_possible())"}
{"solution": "def get_key_positions():\n    return {\n        '0': (0, 0), '1': (0, 1), '2': (0, 2),\n        '3': (1, 0), '4': (1, 1), '5': (1, 2),\n        '6': (2, 0), '7': (2, 1), '8': (2, 2), '9': (3, 1)\n    }\n\ndef get_finger_movements(number, key_positions):\n    movements = []\n    for i in range(len(number) - 1):\n        x1, y1 = key_positions[number[i]]\n        x2, y2 = key_positions[number[i + 1]]\n        movement = (x2 - x1, y2 - y1)\n        movements.append(movement)\n    return movements\n\ndef has_same_movements(number, key_positions):\n    movements = get_finger_movements(number, key_positions)\n    for i in range(10 ** len(number)):\n        new_number = str(i).zfill(len(number))\n        if new_number == number:\n            continue\n        if get_finger_movements(new_number, key_positions) == movements:\n            return True\n    return False\n\ndef main():\n    n = int(input())\n    number = input()\n    key_positions = get_key_positions()\n    if has_same_movements(number, key_positions):\n        print(\"NO\")\n    else:\n        print(\"YES\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\nn, f = map(int, sys.stdin.readline().split())\ndays = []\nfor _ in range(n):\n    k, l = map(int, sys.stdin.readline().split())\n    days.append((k, l))\n\ndays.sort(key=lambda x: min(x[0], x[1]) - min(x[0]*2, x[1]), reverse=True)\n\nsold = 0\nfor i, (k, l) in enumerate(days):\n    if i < f:\n        sold += min(k*2, l)\n    else:\n        sold += min(k, l)\n\nprint(sold)"}
{"solution": "import math\n\nn, k = map(int, input().split())\nk = min(k, n // 2)\nprint(k * (2 * n - 2 * k - 1))"}
{"solution": "import math\n\ndef solve():\n    n, m, k, l = map(int, input().split())\n    if n < m:\n        print(-1)\n        return\n    if n - k < l:\n        print(-1)\n        return\n    if n - k >= m:\n        print(math.ceil(l / m))\n        return\n    print(math.ceil((n - k) / (n - m + 1)))\n\nsolve()"}
{"solution": "def min_cells_to_paint(n, m, grid):\n    def is_valid_square(i, j, size):\n        for x in range(i, i + size):\n            for y in range(j, j + size):\n                if grid[x][y] == 'W':\n                    return False\n        return True\n\n    def count_cells_to_paint(i, j, size):\n        count = 0\n        for x in range(i, i + size):\n            for y in range(j, j + size):\n                if grid[x][y] == 'W':\n                    count += 1\n        return count\n\n    min_cells = float('inf')\n    for size in range(1, min(n, m) + 1):\n        for i in range(n - size + 1):\n            for j in range(m - size + 1):\n                if is_valid_square(i, j, size):\n                    cells_to_paint = count_cells_to_paint(i, j, size)\n                    min_cells = min(min_cells, cells_to_paint)\n\n    return min_cells if min_cells!= float('inf') else -1\n\n\nn, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\nprint(min_cells_to_paint(n, m, grid))"}
{"solution": "n = int(input())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\nif sum(x)!= sum(y):\n    print(\"No\")\nelse:\n    print(\"Yes\")"}
{"solution": "n = int(input())\nangles = list(map(int, input().split()))\n\ntotal_angle = sum(angles)\nmin_diff = float('inf')\ncurr_angle = 0\n\nfor angle in angles:\n    curr_angle += angle\n    diff = abs(curr_angle - (total_angle - curr_angle))\n    min_diff = min(min_diff, diff)\n\nprint(min_diff)"}
{"solution": "MOD = 10**9 + 7\n\ndef pow_mod(a, b):\n    res = 1\n    while b:\n        if b & 1:\n            res = (res * a) % MOD\n        a = (a * a) % MOD\n        b >>= 1\n    return res\n\ndef main():\n    n, m = map(int, input().split())\n    ans = 0\n    for i in range(m + 1):\n        ans += ((pow_mod(m, n) - pow_mod(m - i, n)) * pow_mod(-1, i) * pow_mod(pow_mod(m, i) * pow_mod(i + 1, MOD - 2) % MOD, MOD - 2)) % MOD\n        ans %= MOD\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\nn = int(input())\n\nif n == 1:\n    print(-1)\nelse:\n    found = False\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if (n * n - i * i) % (2 * i) == 0:\n            m = (n * n - i * i) // (2 * i)\n            k = math.sqrt(m * m + n * n)\n            if k == int(k):\n                print(m, int(k))\n                found = True\n                break\n    if not found:\n        for i in range(1, int(math.sqrt(n)) + 1):\n            if (n * n - i * i) > 0 and math.sqrt(n * n - i * i) == int(math.sqrt(n * n - i * i)):\n                print(i, int(math.sqrt(n * n - i * i)))\n                found = True\n                break\n    if not found:\n        print(-1)"}
{"solution": "def check_remainders(n, k):\n    for i in range(2, int(k**0.5) + 1):\n        if n % i == 0:\n            return \"No\"\n        if i * i > n:\n            break\n    for i in range(int(k**0.5) + 1, k + 1):\n        if n % i == 0:\n            return \"No\"\n    return \"Yes\"\n\nn, k = map(int, input().split())\nprint(check_remainders(n, k))"}
{"solution": "import sys\n\na = sys.stdin.readline().strip()\nb = sys.stdin.readline().strip()\n\nif len(a) > len(b):\n    print('>')\nelif len(a) < len(b):\n    print('<')\nelse:\n    if a > b:\n        print('>')\n    elif a < b:\n        print('<')\n    else:\n        print('=')"}
{"solution": "MOD = 10**9 + 7\n\ndef solve():\n    n, p = map(int, input().split())\n    c = list(map(int, input().split()))\n\n    dp = [[[[0, 0] for _ in range(2)] for _ in range(2)] for _ in range(n + 1)]\n    dp[0][0][0][0] = 1\n\n    for i in range(n):\n        for j in range(2):\n            for k in range(2):\n                for l in range(2):\n                    if dp[i][j][k][l] == 0:\n                        continue\n                    if c[i] == -1:\n                        for x in range(2):\n                            for y in range(i + 1, n + 1):\n                                dp[y][x][k ^ x][l ^ (y - i - 1) * x] += dp[i][j][k][l]\n                                dp[y][x][k ^ x][l ^ (y - i - 1) * x] %= MOD\n                            dp[i + 1][x][k ^ x][l] += dp[i][j][k][l]\n                            dp[i + 1][x][k ^ x][l] %= MOD\n                    elif c[i] == j:\n                        for y in range(i + 1, n + 1):\n                            dp[y][j][k ^ j][l ^ (y - i - 1) * j] += dp[i][j][k][l]\n                            dp[y][j][k ^ j][l ^ (y - i - 1) * j] %= MOD\n                        dp[i + 1][j][k ^ j][l] += dp[i][j][k][l]\n                        dp[i + 1][j][k ^ j][l] %= MOD\n\n    ans = 0\n    for i in range(2):\n        ans += dp[n][i][0][p]\n        ans %= MOD\n        ans += dp[n][i][1][p]\n        ans %= MOD\n\n    print(ans)\n\nsolve()"}
{"solution": "n, a, b, c = map(int, input().split())\n\ndef min_cost(n, a, b, c):\n    min_val = float('inf')\n    for i in range(4):\n        k = i - n % 4\n        if k < 0:\n            k += 4\n        cost = k * a\n        if k >= 2:\n            cost = min(cost, (k // 2) * b + (k % 2) * a)\n        if k >= 3:\n            cost = min(cost, (k // 3) * c + (k % 3) * a)\n        min_val = min(min_val, cost)\n    return min_val\n\nprint(min_cost(n, a, b, c))"}
{"solution": "from collections import defaultdict, deque\n\ndef dfs(graph, visited, stack, vertex):\n    visited[vertex] = True\n    for neighbor in graph[vertex]:\n        if not visited[neighbor]:\n            if dfs(graph, visited, stack, neighbor):\n                return True\n        elif stack[neighbor]:\n            return True\n    stack[vertex] = True\n    return False\n\ndef is_acyclic(graph, n):\n    visited = [False] * n\n    stack = [False] * n\n    for vertex in range(n):\n        if not visited[vertex]:\n            if dfs(graph, visited, stack, vertex):\n                return False\n    return True\n\ndef can_make_acyclic(graph, n, m):\n    for u in range(n):\n        for v in graph[u]:\n            graph[u].remove(v)\n            if is_acyclic(graph, n):\n                return True\n            graph[u].append(v)\n    return False\n\nn, m = map(int, input().split())\ngraph = defaultdict(list)\nfor _ in range(m):\n    u, v = map(int, input().split())\n    graph[u-1].append(v-1)\n\nif can_make_acyclic(graph, n, m):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef solve():\n    n, m = read_ints()\n    antennas = []\n    for _ in range(n):\n        x, s = read_ints()\n        antennas.append((x, s))\n\n    antennas.sort()\n\n    dp = [float('inf')] * (m + 1)\n    dp[0] = 0\n\n    for i in range(n):\n        x, s = antennas[i]\n        for j in range(x + s, m + 1):\n            dp[j] = min(dp[j], dp[max(0, j - 2 * s)] + max(0, x - j + s))\n\n        for j in range(x - s - 1, -1, -1):\n            dp[j] = min(dp[j], dp[max(0, j + 2 * s)] + max(0, j + s - x))\n\n    return dp[m]\n\nprint(solve())"}
{"solution": "def solve():\n    W = int(input())\n    cnt = list(map(int, input().split()))\n\n    dp = [0] * 9\n    dp[0] = 1\n\n    for i in range(8):\n        for j in range(8, -1, -1):\n            for k in range(cnt[i]):\n                if j + i + 1 >= 9:\n                    break\n                dp[j + i + 1] |= dp[j]\n\n    ans = 0\n    for i in range(9):\n        if dp[i]:\n            ans = max(ans, min(i, W))\n\n    print(ans)\n\nsolve()"}
{"solution": "import sys\n\ndef solve():\n    n, L = map(int, sys.stdin.readline().split())\n    c = list(map(int, sys.stdin.readline().split()))\n\n    ans = float('inf')\n    for mask in range(1 << n):\n        cost = 0\n        volume = 0\n        for i in range(n):\n            if (mask >> i) & 1:\n                volume += (1 << (i + 1)) - 1\n                cost += c[i]\n        if volume >= L:\n            ans = min(ans, cost)\n\n    print(ans)\n\nif __name__ == '__main__':\n    solve()"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\nmex = 1\nfor i in range(n):\n    if a[i] >= mex:\n        while i < n and a[i] >= mex:\n            i += 1\n        mex += 1\n    else:\n        mex = a[i] + 1\n\nprint(mex)"}
{"solution": "def is_lucky(n, ticket):\n    total_sum = sum(int(digit) for digit in ticket)\n    for segment_sum in range(1, total_sum):\n        segment_count = 0\n        current_sum = 0\n        for digit in ticket:\n            current_sum += int(digit)\n            if current_sum == segment_sum:\n                segment_count += 1\n                current_sum = 0\n            elif current_sum > segment_sum:\n                break\n        if current_sum == 0 and segment_count > 1:\n            return True\n    return False\n\nn = int(input())\nticket = input()\nprint(\"YES\" if is_lucky(n, ticket) else \"NO\")"}
{"solution": "username = input()\ndistinct_chars = set(username)\nif len(distinct_chars) % 2 == 0:\n    print(\"CHAT WITH HER!\")\nelse:\n    print(\"IGNORE HIM!\")"}
{"solution": "n, k = map(int, input().split())\ntabs = list(map(int, input().split()))\n\nmax_diff = 0\nfor i in range(n):\n    diff = 0\n    test_tabs = 0\n    social_tabs = 0\n    for j in range(n):\n        if (j - i) % k!= 0:\n            if tabs[j] == 1:\n                test_tabs += 1\n            else:\n                social_tabs += 1\n    diff = abs(test_tabs - social_tabs)\n    max_diff = max(max_diff, diff)\n\nprint(max_diff)"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef main():\n    n, c0, c1 = map(int, read_input().split())\n    if c0 == c1:\n        print(n * c0 * (n.bit_length() - 1))\n        return\n\n    if c0 < c1:\n        c0, c1 = c1, c0\n        swap = True\n    else:\n        swap = False\n\n    total_cost = 0\n    nodes = 1\n    while nodes < n:\n        total_cost += nodes * c1\n        nodes *= 2\n\n    remaining = n - nodes // 2\n    total_cost += remaining * (c1 + c0)\n\n    if swap:\n        c0, c1 = c1, c0\n\n    print(total_cost)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n, a, x, b, y = map(int, input().split())\n\ndef get_path(start, end, n):\n    if start < end:\n        return list(range(start, end + 1))\n    else:\n        return list(range(start, n + 1)) + list(range(1, end + 1))\n\ndaniel_path = get_path(a, x, n)\nvlad_path = get_path(b, y, n)\n\ncommon_stations = set(daniel_path) & set(vlad_path)\n\nprint(\"YES\" if common_stations else \"NO\")"}
{"solution": "def get_unlucky_years(x, y, start, end):\n    unlucky_years = set()\n    a = 0\n    while x ** a <= end:\n        b = 0\n        while x ** a + y ** b <= end:\n            if x ** a + y ** b >= start:\n                unlucky_years.add(x ** a + y ** b)\n            b += 1\n        a += 1\n    return unlucky_years\n\n\ndef get_golden_age(x, y, start, end):\n    unlucky_years = get_unlucky_years(x, y, start, end)\n    max_golden_age = 0\n    current_golden_age = 0\n    for year in range(start, end + 1):\n        if year in unlucky_years:\n            max_golden_age = max(max_golden_age, current_golden_age)\n            current_golden_age = 0\n        else:\n            current_golden_age += 1\n    return max(max_golden_age, current_golden_age)\n\n\nx, y, start, end = map(int, input().split())\nprint(get_golden_age(x, y, start, end))"}
{"solution": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef min_tax(n):\n    if is_prime(n):\n        return 1\n    if n % 2 == 0:\n        return 2\n    return 3\n\nn = int(input())\nprint(min_tax(n))"}
{"solution": "def fix_typos(word):\n    vowels = set('aeiou')\n    result = []\n    current_word = []\n    current_consonants = set()\n\n    for char in word:\n        if char in vowels:\n            current_word.append(char)\n            current_consonants.clear()\n        else:\n            if char in current_consonants and len(current_consonants) > 1 and len(current_word) - len(current_consonants) >= 2:\n                result.append(''.join(current_word))\n                current_word = [char]\n                current_consonants = {char}\n            else:\n                current_word.append(char)\n                current_consonants.add(char)\n\n    if current_word:\n        result.append(''.join(current_word))\n\n    return''.join(result)\n\nword = input()\nprint(fix_typos(word))"}
{"solution": "import sys\n\nn, m, k = map(int, sys.stdin.readline().split())\nx, s = map(int, sys.stdin.readline().split())\na = list(map(int, sys.stdin.readline().split()))\nb = list(map(int, sys.stdin.readline().split()))\nc = list(map(int, sys.stdin.readline().split()))\nd = list(map(int, sys.stdin.readline().split()))\n\nab = sorted(zip(a, b))\ncd = sorted(zip(c, d))\n\nmin_time = n * x\nfor ai, bi in ab:\n    if bi <= s:\n        for j in range(k):\n            if d[j] + bi <= s:\n                min_time = min(min_time, max(0, n - cd[j][0]) * ai + cd[j][0])\n            else:\n                break\n        min_time = min(min_time, n * ai)\n\nfor j in range(k):\n    if d[j] <= s:\n        min_time = min(min_time, max(0, n - cd[j][0]) * x + cd[j][0])\n\nprint(min_time)"}
{"solution": "import sys\n\ndef solve():\n    n, k, M = map(int, sys.stdin.readline().split())\n    t = list(map(int, sys.stdin.readline().split()))\n\n    dp = [float('inf')] * (k + 1)\n    dp[0] = 0\n    for i in range(k):\n        for j in range(i, -1, -1):\n            dp[j + 1] = min(dp[j + 1], dp[j] + t[i])\n\n    ans = 0\n    for i in range(k + 1):\n        if dp[i] <= M:\n            ans = max(ans, (n - 1) * (k + 1) + i)\n            M -= dp[i]\n            if M >= 0:\n                ans = max(ans, (n - 1) * (k + 1) + i + 1)\n        else:\n            break\n\n    for i in range(k):\n        if dp[i] <= M:\n            ans = max(ans, n * i + (M - dp[i]) // t[i])\n        else:\n            break\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "MOD = 998244353\n\ndef mod_inverse(a, m):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef mod_factorial(n):\n    result = 1\n    for i in range(1, n + 1):\n        result = (result * i) % MOD\n    return result\n\ndef mod_choose(n, k):\n    if k < 0 or k > n:\n        return 0\n    numerator = mod_factorial(n)\n    denominator = (mod_factorial(k) * mod_factorial(n - k)) % MOD\n    return (numerator * mod_inverse(denominator, MOD)) % MOD\n\ndef mod_catalan(n):\n    if n % 2 == 1:\n        return 0\n    n = n // 2\n    return (mod_choose(2 * n, n) * mod_inverse(n + 1, MOD)) % MOD\n\ndef solve(n):\n    if n % 2 == 1:\n        return 0\n    n = n // 2\n    return (mod_catalan(n) * mod_choose(n, n // 2) * mod_factorial(n) * mod_factorial(n)) % MOD\n\nn = int(input())\nprint(solve(n))"}
{"solution": "def calculate_position(n, m, k):\n    # Calculate the total number of cells\n    total_cells = n * m\n\n    # Calculate the number of full rows\n    full_rows = m // 2\n\n    # Calculate the remaining cells after full rows\n    remaining_cells = total_cells - full_rows * n * 2\n\n    # Calculate the number of rows Lara has moved in the remaining cells\n    rows_moved = k // (m * 2)\n\n    # Calculate the remaining moves after full rows\n    remaining_moves = k % (m * 2)\n\n    # Calculate the row position\n    row = rows_moved * 2 + (remaining_moves // m) * 2 + (remaining_moves % m > 0)\n\n    # Calculate the column position\n    column = (remaining_moves % m) + 1 if remaining_moves // m == 0 else m - (remaining_moves % m)\n\n    # Adjust the row and column positions based on the number of full rows\n    if rows_moved >= full_rows:\n        row = n - (rows_moved - full_rows) * 2 - (remaining_moves // m) * 2 - (remaining_moves % m > 0)\n        column = (remaining_moves % m) + 1 if remaining_moves // m == 0 else m - (remaining_moves % m)\n\n    return row, column\n\n\nn, m, k = map(int, input().split())\nrow, column = calculate_position(n, m, k)\nprint(row, column)"}
{"solution": "import math\n\ndef prime_factors(n):\n    factors = []\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef solve():\n    x = int(input())\n    factors = prime_factors(x)\n    a = 1\n    b = x\n    for p in set(factors):\n        if factors.count(p) > 1:\n            a *= p\n            b //= p\n    print(a, b)\n\nsolve()"}
{"solution": "a = int(input())\nb = int(input())\nc = int(input())\n\nratio = [1, 2, 4]\ntotal_fruits = [a, b, c]\n\nmin_multiple = float('inf')\nfor i in range(3):\n    multiple = total_fruits[i] // ratio[i]\n    min_multiple = min(min_multiple, multiple)\n\ntotal = min_multiple * sum(ratio)\nprint(total)"}
{"solution": "n = int(input())\nratings = sorted(map(int, input().split()))\n\nprint(\"YES\" if ratings[n-1] > ratings[n] else \"NO\")"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef is_coprime(a, b):\n    return gcd(a, b) == 1\n\ndef make_coprime_array(arr):\n    result = [arr[0]]\n    count = 0\n    for i in range(1, len(arr)):\n        if is_coprime(result[-1], arr[i]):\n            result.append(arr[i])\n        else:\n            count += 1\n            result.append(1)\n            result.append(arr[i])\n    return count, result\n\nn = int(input())\narr = list(map(int, input().split()))\ncount, result = make_coprime_array(arr)\nprint(count)\nprint(*result)"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef solve():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    g = a[0]\n    for i in range(1, n):\n        g = gcd(g, a[i])\n    print(g)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "import sys\n\nx = int(input())\nans = []\nwhile x!= 0 and len(ans) < 40:\n    if x & 1:\n        ans.append(0)\n        x += 1\n    else:\n        n = x.bit_length() - 1\n        ans.append(n)\n        x ^= (1 << n) - 1\nif x!= 0:\n    n = x.bit_length() - 1\n    ans.append(n)\n    x ^= (1 << n) - 1\nprint(len(ans))\nfor i in range(0, len(ans), 2):\n    print(ans[i], end=' ')"}
{"solution": "import math\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nmin_hours = float('inf')\nfor bucket in a:\n    if k % bucket == 0:\n        min_hours = min(min_hours, k // bucket)\n\nprint(min_hours)"}
{"solution": "from collections import deque\n\ndef can_reach_target(n, k, line):\n    start = line.index('G')\n    target = line.index('T')\n    visited = set([start])\n\n    queue = deque([start])\n\n    while queue:\n        current = queue.popleft()\n\n        if current == target:\n            return True\n\n        for jump in [current - k, current + k]:\n            if 0 <= jump < n and line[jump]!= '#' and jump not in visited:\n                queue.append(jump)\n                visited.add(jump)\n\n    return False\n\nn, k = map(int, input().split())\nline = input().strip()\n\nprint(\"YES\" if can_reach_target(n, k, line) else \"NO\")"}
{"solution": "import math\n\ndef calculate_xw(y1, y2, yw, xb, yb, r):\n    if yb - r <= y1 or yb + r >= y2:\n        return -1\n\n    xw = (xb * (y2 - y1) + (y2 + y1) * (yw - yb)) / (2 * (yw - yb))\n    return xw\n\ny1, y2, yw, xb, yb, r = map(float, input().split())\nxw = calculate_xw(y1, y2, yw, xb, yb, r)\nprint(\"{:.10f}\".format(xw))"}
{"solution": "b, d, s = map(int, input().split())\n\nif b == d == s:\n    print(0)\nelif b == d + 1 and s == d:\n    print(0)\nelif b == d and s == d + 1:\n    print(0)\nelif b == 0 and d == 0:\n    print(0)\nelif d == 0 and s == 0:\n    print(0)\nelif b == 0 and s == 0:\n    print(0)\nelse:\n    print(max(0, b - d - 1) + max(0, d - s - 1) + max(0, s - b - 1))"}
{"solution": "import math\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    min_x = 1\n    max_x = 10**9\n    min_y = 1\n    max_y = 10**9\n\n    for i in range(n - 1):\n        if a[i + 1] - a[i] > 0:\n            if a[i + 1] - a[i] == 1:\n                min_y = max(min_y, 2)\n            else:\n                min_x = max(min_x, (a[i + 1] - a[i]))\n        else:\n            if a[i] - a[i + 1] == 1:\n                min_y = max(min_y, 2)\n            else:\n                min_x = max(min_x, (a[i] - a[i + 1]))\n\n    for i in range(n - 1):\n        if a[i + 1] - a[i] > 0:\n            if a[i + 1] - a[i] == 1:\n                max_x = min(max_x, (a[i] - 1) // (min_y - 1) + 1)\n            else:\n                max_y = min(max_y, a[i] // min_x + 1)\n        else:\n            if a[i] - a[i + 1] == 1:\n                max_x = min(max_x, (a[i + 1] - 1) // (min_y - 1) + 1)\n            else:\n                max_y = min(max_y, a[i + 1] // min_x + 1)\n\n    if max_x < min_x or max_y < min_y:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(max_x, max_y)\n\nsolve()"}
{"solution": "def longest_subsequence(a, b):\n    i = 0\n    result = []\n    for char in a:\n        if i < len(b) and char == b[i]:\n            result.append(char)\n            i += 1\n    return ''.join(result) if result else '-'\n\na = input()\nb = input()\nprint(longest_subsequence(a, b))"}
{"solution": "n = int(input())\ns = input()\n\nminus_count = s.count('-')\nplus_count = s.count('+')\n\nmin_stones = 0\nfor i in range(minus_count):\n    if minus_count - i <= plus_count:\n        min_stones = plus_count - (minus_count - i)\n        break\n\nprint(max(min_stones, 0))"}
{"solution": "n = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\nglass_bottles = n // b\nremaining_money = n % b\nadditional_glass_bottles = remaining_money // (b - c)\nadditional_glass_bottles += glass_bottles - 1\nadditional_glass_bottles = max(additional_glass_bottles, 0)\ntotal_glass_bottles = glass_bottles + additional_glass_bottles\n\nplastic_bottles = n // a\n\nprint(max(total_glass_bottles, plastic_bottles))"}
{"solution": "def card_game(n, k1, cards1, k2, cards2):\n    seen = set()\n    turn = 0\n    while cards1 and cards2:\n        turn += 1\n        card1 = cards1.pop(0)\n        card2 = cards2.pop(0)\n        if (tuple(cards1), tuple(cards2)) in seen:\n            return -1\n        seen.add((tuple(cards1), tuple(cards2)))\n        if card1 > card2:\n            cards1.extend([card2, card1])\n        else:\n            cards2.extend([card1, card2])\n    return turn, 1 if cards1 else 2\n\nn = int(input())\nk1 = int(input().split()[0])\ncards1 = list(map(int, input().split()[1:]))\nk2 = int(input().split()[0])\ncards2 = list(map(int, input().split()[1:]))\n\nresult = card_game(n, k1, cards1, k2, cards2)\nprint(*result)"}
{"solution": "password = input()\n\ndef check_password(password):\n    if len(password) < 5:\n        return False\n    has_upper = False\n    has_lower = False\n    has_digit = False\n    for char in password:\n        if char.isupper():\n            has_upper = True\n        elif char.islower():\n            has_lower = True\n        elif char.isdigit():\n            has_digit = True\n    return has_upper and has_lower and has_digit\n\nprint(\"Correct\" if check_password(password) else \"Too weak\")"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\ncount_a = [0] * 6\ncount_b = [0] * 6\n\nfor i in a:\n    count_a[i] += 1\n\nfor i in b:\n    count_b[i] += 1\n\nexchanges = 0\nfor i in range(1, 6):\n    diff = abs(count_a[i] - count_b[i])\n    if diff % 2!= 0:\n        print(-1)\n        exit()\n    exchanges += diff // 2\n\nprint(exchanges)"}
{"solution": "from collections import deque\n\ndef is_valid_move(grid, visited, i, j, direction):\n    if direction == 'v' or direction == '^':\n        for k in range(len(grid[0])):\n            if grid[i][k] == '<' and not visited[i][k]:\n                return True\n            if grid[i][k] == '>' and not visited[i][k]:\n                return True\n    else:\n        for k in range(len(grid)):\n            if grid[k][j] == 'v' and not visited[k][j]:\n                return True\n            if grid[k][j] == '^' and not visited[k][j]:\n                return True\n    return False\n\ndef bfs(grid, i, j, direction):\n    queue = deque([(i, j)])\n    visited = [[False for _ in range(len(grid[0]))] for _ in range(len(grid))]\n    visited[i][j] = True\n    while queue:\n        x, y = queue.popleft()\n        if direction == 'v':\n            if x + 1 < len(grid) and grid[x + 1][y] == 'v' and not visited[x + 1][y]:\n                queue.append((x + 1, y))\n                visited[x + 1][y] = True\n            if is_valid_move(grid, visited, x, y, direction):\n                return True\n        elif direction == '^':\n            if x - 1 >= 0 and grid[x - 1][y] == '^' and not visited[x - 1][y]:\n                queue.append((x - 1, y))\n                visited[x - 1][y] = True\n            if is_valid_move(grid, visited, x, y, direction):\n                return True\n        elif direction == '<':\n            if y - 1 >= 0 and grid[x][y - 1] == '<' and not visited[x][y - 1]:\n                queue.append((x, y - 1))\n                visited[x][y - 1] = True\n            if is_valid_move(grid, visited, x, y, direction):\n                return True\n        elif direction == '>':\n            if y + 1 < len(grid[0]) and grid[x][y + 1] == '>' and not visited[x][y + 1]:\n                queue.append((x, y + 1))\n                visited[x][y + 1] = True\n            if is_valid_move(grid, visited, x, y, direction):\n                return True\n    return False\n\ndef is_reachable(grid):\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if not bfs(grid, i, j, grid[i][j]):\n                return False\n    return True\n\nn, m = map(int, input().split())\ngrid = [list(input()) for _ in range(2)]\nif is_reachable(grid):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    if a[0] == 0:\n        print(\"YES\")\n        print(a[0])\n        return\n\n    for i in range(1, n):\n        if a[i] == 0:\n            print(\"YES\")\n            print(\"(\" * (i - 1) + \"->\".join(map(str, a[:i])) + \")\" + \"->\" + str(a[i]))\n            return\n\n    print(\"NO\")\n\nsolve()"}
{"solution": "a, b = map(int, input().split())\n\nwhile a > 0 and b > 0:\n    if a >= 2 * b:\n        a -= 2 * b\n    elif b >= 2 * a:\n        b -= 2 * a\n\nprint(a, b)"}
{"solution": "k, a, b = map(int, input().split())\nprint((b // k) - ((a - 1) // k))"}
{"solution": "def find_kth_digit():\n    k = int(input())\n    length = 0\n    count = 0\n    num = 1\n\n    while length < k:\n        length += len(str(num))\n        count += 1\n        if length >= k:\n            break\n        num += 1\n\n    index = k - (length - len(str(num)))\n    return int(str(num)[index - 1])\n\nprint(find_kth_digit())"}
{"solution": "n = int(input())\ns = input()\n\neights = s.count('8')\nif eights < 2:\n    print(\"NO\")\nelse:\n    first_eight = s.find('8')\n    second_eight = s.find('8', first_eight + 1)\n    if second_eight - first_eight > n - 11:\n        print(\"NO\")\n    else:\n        print(\"YES\")"}
{"solution": "MOD = 10**9 + 7\n\ndef binpow(a, b):\n    res = 1\n    while b > 0:\n        if b & 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b >>= 1\n    return res\n\ndef fact(n):\n    res = 1\n    for i in range(1, n + 1):\n        res = res * i % MOD\n    return res\n\ndef solve():\n    n, x, pos = map(int, input().split())\n    if pos == 0:\n        print(fact(n - 1))\n        return\n    if pos == n - 1:\n        print(0)\n        return\n    if x == 1:\n        print(0)\n        return\n    if x == n:\n        print(fact(n - 1) * binpow(2, pos) % MOD)\n        return\n    ans = fact(pos) * fact(n - pos - 1) % MOD\n    ans = ans * binpow(2, pos) % MOD\n    ans = ans * binpow(x - 1, pos) % MOD\n    ans = ans * binpow(n - x, n - pos - 1) % MOD\n    print(ans)\n\nsolve()"}
{"solution": "def solve():\n    s = input()\n    k = int(input())\n    n = len(s)\n    dp = [[False] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(n):\n        if s[i].isalpha():\n            for j in range(k + 1):\n                if dp[i][j]:\n                    dp[i + 1][j] = True\n                    dp[i + 1][j + 1] = True\n        elif s[i] == '*':\n            for j in range(k + 1):\n                if dp[i - 1][j]:\n                    dp[i + 1][j] = True\n                    if j < k:\n                        dp[i + 1][j + 1] = True\n                        dp[i + 1][j + 2] = True\n        elif s[i] == '?':\n            for j in range(k + 1):\n                if dp[i - 1][j]:\n                    dp[i + 1][j] = True\n                    if j < k:\n                        dp[i + 1][j + 1] = True\n    if not dp[n][k]:\n        print(\"Impossible\")\n        return\n    res = []\n    i, j = n, k\n    while i > 0 and j > 0:\n        if s[i - 1].isalpha():\n            res.append(s[i - 1])\n            if dp[i - 1][j - 1]:\n                i -= 1\n                j -= 1\n            else:\n                i -= 2\n                j -= 1\n        elif s[i - 1] == '*':\n            if dp[i - 2][j - 1]:\n                res.append(s[i - 2])\n                i -= 2\n                j -= 1\n            elif dp[i - 2][j - 2]:\n                res.append(s[i - 2] * 2)\n                i -= 2\n                j -= 2\n            else:\n                i -= 2\n        elif s[i - 1] == '?':\n            if dp[i - 2][j - 1]:\n                res.append(s[i - 2])\n                i -= 2\n                j -= 1\n            else:\n                i -= 2\n    print(''.join(reversed(res)))\n\nsolve()"}
{"solution": "import math\n\nx = int(input())\nx = x % 360\nif x < 0:\n    x += 360\nx = (360 - x) % 360\nprint(min(math.ceil(x / 90), 4 - math.ceil(x / 90)))"}
{"solution": "a, b, c = map(int, input().split())\nx, y, z = map(int, input().split())\n\ndef can_transform(a, b, c, x, y, z):\n    if a >= x and b >= y and c >= z:\n        return True\n    if a % 2 == b % 2 == c % 2:\n        return (a + b + c) // 2 >= (x + y + z) // 2\n    return False\n\nprint(\"Yes\" if can_transform(a, b, c, x, y, z) else \"No\")"}
{"solution": "def modPow(a, n, mod):\n    res = 1\n    while n > 0:\n        if n % 2 == 1:\n            res = (res * a) % mod\n        a = (a * a) % mod\n        n //= 2\n    return res\n\ndef solve():\n    n, k, m = map(int, input().split())\n    dp = [0] * k\n    dp[0] = 1\n    for _ in range(n - 1):\n        ndp = [0] * k\n        for i in range(k):\n            for j in range(10):\n                ndp[(i * 10 + j) % k] = (ndp[(i * 10 + j) % k] + dp[i]) % m\n        dp = ndp\n    ans = 0\n    for i in range(1, k):\n        ans = (ans + dp[i] * modPow(10, n - 1, m)) % m\n    print(ans)\n\nsolve()"}
{"solution": "l, r, a = map(int, input().split())\nmin_lr = min(l, r)\nmax_lr = max(l, r)\ndiff = max_lr - min_lr\nif diff > a:\n    ans = min_lr * 2 + a * 2\nelse:\n    ans = (min_lr + diff // 2) * 2 + (a - diff // 2) * 2 if diff % 2 == 0 else (min_lr + diff // 2 + 1) * 2\nprint(ans)"}
{"solution": "import sys\n\ndef solve(n, k):\n    dp = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        dp[i][0] = 2 * i - 1\n    for i in range(1, n + 1):\n        for j in range(1, i + 1):\n            dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + 2)\n            if j < i:\n                dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1)\n    ans = float('inf')\n    for i in range(n + 1):\n        ans = min(ans, dp[n][i] + abs(i - k))\n    return ans\n\nn, k = map(int, sys.stdin.readline().split())\nprint(solve(n, k))"}
{"solution": "def min_height(n, m):\n    two_blocks = set(2 * i for i in range(1, n + 1))\n    three_blocks = set(3 * i for i in range(1, m + 1))\n    used = two_blocks.union(three_blocks)\n    i = 1\n    while True:\n        if i not in used:\n            if len(used) == n + m:\n                return i\n            used.add(i)\n            if i % 2 == 0:\n                two_blocks.add(i)\n            else:\n                three_blocks.add(i)\n        i += 1\n\nn, m = map(int, input().split())\nprint(min_height(n, m))"}
{"solution": "n = int(input())\na = [int(input()) for _ in range(n)]\ncount = {}\nfor num in a:\n    if num in count:\n        count[num] += 1\n    else:\n        count[num] = 1\npairs = [num for num, freq in count.items() if freq == n // 2]\nif len(pairs) >= 2:\n    print(\"YES\")\n    print(pairs[0], pairs[1])\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\ndef solve(n, k, a):\n    a.sort(reverse=True)\n    dp = [0] * (1 << k)\n    for i in range(1 << k):\n        cnt = bin(i).count('1')\n        for j in range(k):\n            if (i >> j) & 1:\n                continue\n            if i == 0:\n                if a[j] <= 8 * n - 8 * (cnt + 1) + 2:\n                    dp[i | (1 << j)] |= 1\n            else:\n                if a[j] <= 8 * n - 8 * (cnt + 1) + 2 and dp[i] & 1:\n                    dp[i | (1 << j)] |= 1\n                if a[j] <= 8 * n - 8 * (cnt + 1) + 4 and dp[i] & 2:\n                    dp[i | (1 << j)] |= 2\n                if a[j] <= 8 * n - 8 * (cnt + 1) + 6 and dp[i] & 4:\n                    dp[i | (1 << j)] |= 4\n    return dp[-1] & 1\n\nn, k = map(int, sys.stdin.readline().split())\na = list(map(int, sys.stdin.readline().split()))\nprint(\"YES\" if solve(n, k, a) else \"NO\")"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\nmin_cost = float('inf')\noptimal_t = 0\n\nfor t in range(1, 101):\n    cost = sum(min(abs(x - t), abs(x - (t - 1)), abs(x - (t + 1))) for x in a)\n    if cost < min_cost:\n        min_cost = cost\n        optimal_t = t\n\nprint(optimal_t, min_cost)"}
{"solution": "n, m = map(int, input().split())\nsky_map = [input() for _ in range(n)]\n\nmin_row = float('inf')\nmax_row = float('-inf')\nmin_col = float('inf')\nmax_col = float('-inf')\n\nfor i in range(n):\n    for j in range(m):\n        if sky_map[i][j] == '*':\n            min_row = min(min_row, i)\n            max_row = max(max_row, i)\n            min_col = min(min_col, j)\n            max_col = max(max_col, j)\n\nside = max(max_row - min_row + 1, max_col - min_col + 1)\nprint(side)"}
{"solution": ""}
{"solution": "x, y = map(int, input().split())\nprint(2 * (x - y) - min(0, x - 2 * y))"}
{"solution": "import math\n\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\ndet = a * d - b * c\n\nif det == 0:\n    print(0)\nelse:\n    x1 = abs(det / (a + c))\n    x2 = abs(det / (a + d))\n    x3 = abs(det / (b + c))\n    x4 = abs(det / (b + d))\n\n    print(min(x1, x2, x3, x4))"}
{"solution": "n, a, b = map(int, input().split())\nt = list(map(int, input().split()))\n\ndenied = 0\noccupied_two_seater = 0\n\nfor i in t:\n    if i == 1:\n        if a > 0:\n            a -= 1\n        elif b > 0:\n            b -= 1\n            occupied_two_seater += 1\n        elif occupied_two_seater > 0:\n            occupied_two_seater -= 1\n        else:\n            denied += 1\n    else:\n        if b > 0:\n            b -= 1\n        else:\n            denied += 2\n\nprint(denied)"}
{"solution": "A, B, C, N = map(int, input().split())\ntotal_visited = A + B - C\nif total_visited > N or total_visited == N or A < C or B < C or C < 0:\n    print(-1)\nelse:\n    print(N - total_visited)"}
{"solution": "MOD = 10**9 + 7\n\nx, k = map(int, input().split())\n\nresult = x\nfor _ in range(k):\n    result = (result * 2 + (result * 2) % 2) % MOD\n\nprint(result)"}
{"solution": "MOD = 998244353\n\ndef pow_mod(a, b):\n    res = 1\n    while b:\n        if b & 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b >>= 1\n    return res\n\ndef inv(a):\n    return pow_mod(a, MOD - 2)\n\nn = int(input())\nl, r = [0] * n, [0] * n\nfor i in range(n):\n    l[i], r[i] = map(int, input().split())\n\nans = 1\nfor i in range(n):\n    ans = ans * inv(r[i] - l[i] + 1) % MOD\n    for j in range(i + 1, n):\n        if r[i] >= l[j]:\n            ans = ans * inv(r[i] - l[j] + 1) % MOD\n            l[j] = max(l[j], r[i] + 1)\n\nprint(ans)"}
{"solution": "import math\n\ndef count_ways(n):\n    count = 0\n    for a in range(1, n // 4 + 1):\n        for b in range(a, (n - 2 * a) // 2 + 1):\n            c = n - 2 * a - 2 * b\n            if c < b:\n                break\n            if c == b:\n                if 2 * a == b or 2 * b == a:\n                    continue\n                count += 3\n            elif c > b:\n                if 2 * a == c or 2 * b == c or 2 * a == b:\n                    continue\n                count += 6\n    return count\n\nn = int(input())\nprint(count_ways(n))"}
{"solution": "import sys\n\ndef binary_search(arr, s):\n    left, right = 0, min(min(arr), s // len(arr))\n    while left <= right:\n        mid = (left + right) // 2\n        total = sum(min(mid, x) for x in arr)\n        if total <= s:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left - 1 if left > 0 else -1\n\nn, s = map(int, sys.stdin.readline().split())\narr = list(map(int, sys.stdin.readline().split()))\n\nprint(binary_search(arr, s))"}
{"solution": "h1, h2 = map(int, input().split())\na, b = map(int, input().split())\n\nday_progress = 12 * a - 14 * b\nnight_progress = -14 * b\n\nif day_progress <= 0:\n    print(-1)\nelse:\n    days = (h2 - h1 - night_progress) // day_progress\n    if (h2 - h1 - night_progress) % day_progress!= 0:\n        days += 1\n    if days == 0:\n        if h1 + 8 * a >= h2:\n            print(0)\n        else:\n            print(1)\n    else:\n        print(days)"}
{"solution": "def max_joy_units():\n    C, Hr, Hb, Wr, Wb = map(int, input().split())\n    max_joy = 0\n\n    for r in range(C // Wr + 1):\n        w = C - r * Wr\n        if w % Wb == 0:\n            b = w // Wb\n            joy = r * Hr + b * Hb\n            max_joy = max(max_joy, joy)\n\n    print(max_joy)\n\nmax_joy_units()"}
{"solution": "x1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\n\nprint(max(abs(x2 - x1), abs(y2 - y1)))"}
{"solution": "n = int(input())\ns = input()\n\ndef solve(n, s):\n    d_count = s.count('D')\n    r_count = n - d_count\n\n    if d_count == r_count:\n        return 'R' if s[-1] == 'R' else 'D'\n    else:\n        return 'D' if d_count > r_count else 'R'\n\nprint(solve(n, s))"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\na, b, x, y = map(int, input().split())\ng = gcd(x, y)\nx //= g\ny //= g\n\nans = 0\nfor k in range(1, int(math.sqrt(a)) + 1):\n    if a % k == 0:\n        if k * y <= b and x * k <= a:\n            ans += 1\n        k2 = a // k\n        if k2 * y <= b and x * k2 <= a and k2!= k:\n            ans += 1\n\nprint(ans)"}
{"solution": "import math\n\ndef count_trailing_zeros(n, b):\n    count = 0\n    i = 1\n    while True:\n        p = b ** i\n        if p > n:\n            break\n        count += n // p\n        i += 1\n    return count\n\nn, b = map(int, input().split())\nprint(count_trailing_zeros(n, b))"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nm, a, b = map(int, input().split())\ng = gcd(a, b)\nlcm = a * b // g\n\nif a < b:\n    a, b = b, a\n\nif a == 1:\n    print((m + 1) * (m + 2) // 2)\nelse:\n    ans = m // lcm * (lcm // a + 1) + (m % lcm) // a + 1\n    ans += m // (a + b) * (a + b) // a\n    ans += (m % (a + b)) // a * ((m % (a + b)) // a + 1) // 2\n    print(ans)"}
{"solution": "def can_divide_into_odd_subsegments(n, sequence):\n    if n % 2 == 0 and sequence[0] % 2!= 0 and sequence[-1] % 2!= 0:\n        return False\n\n    odd_count = 0\n    for num in sequence:\n        if num % 2!= 0:\n            odd_count += 1\n\n    if odd_count < (n + 1) // 2:\n        return False\n\n    return True\n\n\nn = int(input())\nsequence = list(map(int, input().split()))\n\nif can_divide_into_odd_subsegments(n, sequence):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "x1, y1, x2, y2 = map(int, input().split())\n\nif x1 == x2:\n    x3, x4 = x1, x1\n    y3, y4 = y1 + abs(x2 - x1), y2 - abs(x2 - x1)\nelif y1 == y2:\n    x3, x4 = x1 + abs(y2 - y1), x2 - abs(y2 - y1)\n    y3, y4 = y1, y1\nelse:\n    if abs(x2 - x1)!= abs(y2 - y1):\n        print(-1)\n        exit()\n    x3, x4 = x1 + abs(x2 - x1), x2 - abs(x2 - x1)\n    y3, y4 = y1 + abs(y2 - y1), y2 - abs(y2 - y1)\n\nprint(x3, y3, x4, y4)"}
{"solution": "def matrix_multiply(a, b, mod):\n    c = [[0, 0], [0, 0]]\n    for i in range(2):\n        for j in range(2):\n            for k in range(2):\n                c[i][j] += a[i][k] * b[k][j]\n            c[i][j] %= mod\n    return c\n\ndef matrix_power(matrix, n, mod):\n    if n == 1:\n        return matrix\n    if n % 2 == 0:\n        half_pow = matrix_power(matrix, n // 2, mod)\n        return matrix_multiply(half_pow, half_pow, mod)\n    else:\n        half_pow = matrix_power(matrix, n // 2, mod)\n        return matrix_multiply(matrix_multiply(half_pow, half_pow, mod), matrix, mod)\n\ndef solve():\n    x, y = map(int, input().split())\n    n = int(input())\n    mod = 1000000007\n    if n == 1:\n        print(x % mod)\n        return\n    if n == 2:\n        print(y % mod)\n        return\n    matrix = [[1, 1], [1, 0]]\n    result_matrix = matrix_power(matrix, n - 2, mod)\n    result = (result_matrix[0][0] * y - result_matrix[0][1] * x) % mod\n    if result < 0:\n        result += mod\n    print(result)\n\nsolve()"}
{"solution": "def split_array(n, arr):\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + arr[i]\n\n    if prefix_sum[n] == 0:\n        print(\"NO\")\n        return\n\n    result = []\n    start = 0\n    for i in range(n + 1):\n        if prefix_sum[i]!= 0 and prefix_sum[n] - prefix_sum[i]!= 0:\n            result.append((start + 1, i))\n            start = i\n\n    print(\"YES\")\n    print(len(result))\n    for start, end in result:\n        print(start, end)\n\n\nn = int(input())\narr = list(map(int, input().split()))\nsplit_array(n, arr)"}
{"solution": "def pow_mod(a, b, mod):\n    res = 1\n    while b > 0:\n        if b & 1:\n            res = (res * a) % mod\n        a = (a * a) % mod\n        b >>= 1\n    return res\n\ndef solve():\n    mod = 1000000009\n    n, m, k = map(int, input().split())\n    if m < n - m + 1:\n        print(m)\n        return\n    ans = m - (n - m + 1)\n    ans += (n - m + 1) * 2\n    ans -= (n - m + 1) // (k - 1) * 2\n    ans -= (n - m + 1) // (k - 1) % 2\n    ans += (n - m + 1) // (k - 1) // 2 * 2\n    ans %= mod\n    print(ans)\n\nsolve()"}
{"solution": "def is_divisible_by_8(num):\n    return num % 8 == 0\n\ndef find_divisible_substring(num_str):\n    for length in range(1, 4):\n        for i in range(len(num_str) - length + 1):\n            substring = num_str[i:i+length]\n            if substring[0]!= '0' and is_divisible_by_8(int(substring)):\n                return substring\n    return None\n\nnum_str = input()\ndivisible_substring = find_divisible_substring(num_str)\n\nif divisible_substring:\n    print(\"YES\")\n    print(divisible_substring)\nelse:\n    print(\"NO\")"}
{"solution": "import math\n\nn, m = map(int, input().split())\nmemories = [list(map(int, input().split())) for _ in range(m)]\n\nmin_flats_per_floor = 1\nmax_flats_per_floor = n\n\nfor flat, floor in memories:\n    min_flats_per_floor = max(min_flats_per_floor, math.ceil(flat / floor))\n    max_flats_per_floor = min(max_flats_per_floor, math.floor((flat - 1) / (floor - 1)) if floor > 1 else n)\n\nmin_floor = math.ceil(n / min_flats_per_floor)\nmax_floor = math.ceil(n / max_flats_per_floor)\n\nprint(min_floor if min_floor == max_floor else -1)"}
{"solution": "def count_bishwocks(board):\n    n = len(board[0])\n    count = 0\n\n    for i in range(n - 1):\n        if board[0][i] == '0' and board[0][i + 1] == '0' and board[1][i] == '0':\n            count += 1\n            i += 1\n        elif board[0][i] == '0' and board[1][i] == '0' and board[1][i + 1] == '0':\n            count += 1\n            i += 1\n\n    for i in range(n - 1):\n        if board[1][i] == '0' and board[1][i + 1] == '0' and board[0][i] == '0':\n            count += 1\n            i += 1\n        elif board[1][i] == '0' and board[0][i] == '0' and board[0][i + 1] == '0':\n            count += 1\n            i += 1\n\n    return count // 2\n\n\nboard = [input(), input()]\nprint(count_bishwocks(board))"}
{"solution": "def max_pretty_set(n, s):\n    dp = [[0] * 27 for _ in range(n + 1)]\n    last_lower = [-1] * 27\n\n    for i in range(n):\n        if s[i].islower():\n            idx = ord(s[i]) - ord('a')\n            dp[i + 1][idx] = max(dp[i + 1][idx], dp[i][26] + 1)\n            dp[i + 1][26] = max(dp[i + 1][26], dp[i][26])\n            for j in range(26):\n                if last_lower[j]!= -1 and last_lower[j] < i:\n                    dp[i + 1][idx] = max(dp[i + 1][idx], dp[last_lower[j] + 1][j] + 1)\n            last_lower[idx] = i\n        else:\n            dp[i + 1][26] = dp[i][26]\n\n    return max(dp[n])\n\nn = int(input())\ns = input()\nprint(max_pretty_set(n, s))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\na.sort()\nprint(sum(a[n//2:]))"}
{"solution": "a, b, f, k = map(int, input().split())\n\nif 2 * a > b:\n    if f * 2 > b:\n        if (a - f) * 2 > b:\n            print(-1)\n        else:\n            ans = 0\n            if f > b / 2:\n                ans += k * 2\n            else:\n                if (2 * a - b) > 0:\n                    ans += (2 * a - b) // (b - 2 * f) + 1\n                    if (2 * a - b) % (b - 2 * f) == 0 and (2 * a - b)!= 0:\n                        ans -= 1\n                ans += (k - 1) * 2\n            print(ans)\n    else:\n        ans = 0\n        if (2 * a - b) > 0:\n            ans += (2 * a - b) // (b - 2 * f) + 1\n            if (2 * a - b) % (b - 2 * f) == 0 and (2 * a - b)!= 0:\n                ans -= 1\n        ans += (k - 1) * 2\n        print(ans)\nelse:\n    print(0)"}
{"solution": "def split_string(n, p, q, s):\n    result = []\n    i = 0\n    while i < n:\n        if i + q <= n:\n            result.append(s[i:i+q])\n            i += q\n        elif i + p <= n:\n            result.append(s[i:i+p])\n            i += p\n        else:\n            return \"-1\"\n    return str(len(result)) + \"\\n\" + \"\\n\".join(result)\n\nn, p, q = map(int, input().split())\ns = input()\nprint(split_string(n, p, q, s))"}
{"solution": "import sys\n\ndef solve():\n    n, m, s, d = map(int, sys.stdin.readline().split())\n    obstacles = list(map(int, sys.stdin.readline().split()))\n    obstacles.sort()\n\n    i = 0\n    pos = 0\n    while i < n:\n        if obstacles[i] - pos < s:\n            if obstacles[i] + d < m:\n                print(\"IMPOSSIBLE\")\n                return\n            else:\n                print(f\"RUN {obstacles[i] - pos}\")\n                pos = obstacles[i]\n                while i < n and pos + d >= obstacles[i]:\n                    i += 1\n                if i < n:\n                    print(f\"JUMP {min(obstacles[i] - pos, d)}\")\n                    pos = min(obstacles[i], pos + d)\n                else:\n                    print(f\"JUMP {m - pos}\")\n                    pos = m\n        else:\n            print(f\"RUN {s}\")\n            pos += s\n            print(f\"JUMP {min(obstacles[i] - pos, d)}\")\n            pos = min(obstacles[i], pos + d)\n        i += 1\n\n    if pos < m:\n        print(f\"RUN {m - pos}\")\n\nsolve()"}
{"solution": "def count_pairs(s, x):\n    if s < x or (s & 1)!= (x & 1):\n        return 0\n\n    y = s - x\n    count = 1\n    for i in range(41):\n        if (x >> i) & 1:\n            if (y >> i) & 1:\n                return 0\n        elif (y >> i) & 1:\n            count *= 2\n\n    if x == 0 and y == 0:\n        return 1\n    elif x == y:\n        return count - 2\n    else:\n        return count\n\n\ns, x = map(int, input().split())\nprint(count_pairs(s, x))"}
{"solution": "def solve(n, k):\n    if n <= 2 * k:\n        return [1]\n    elif n == 2 * k + 1:\n        return [1, n]\n    else:\n        result = []\n        if n % 2 == 0:\n            for i in range(1, n, 2 * k + 1):\n                result.append(i)\n                if i + 2 * k + 1 <= n:\n                    result.append(i + 2 * k + 1)\n        else:\n            for i in range(1, n, 2 * k + 1):\n                result.append(i)\n                if i + 2 * k + 1 <= n:\n                    result.append(i + 2 * k)\n        return result\n\nn, k = map(int, input().split())\nresult = solve(n, k)\nprint(len(result))\nprint(*result)"}
{"solution": "from collections import defaultdict\n\ndef min_operations(n):\n    squares = set()\n    i = 1\n    while i * i <= n:\n        squares.add(str(i * i))\n        i += 1\n\n    def dp(i, target):\n        if i == len(n):\n            return 0 if target == \"0\" else float(\"inf\")\n        if (i, target) in memo:\n            return memo[(i, target)]\n        ans = float(\"inf\")\n        if n[i] == target[0]:\n            ans = dp(i + 1, target[1:])\n        ans = min(ans, 1 + dp(i + 1, target))\n        memo[(i, target)] = ans\n        return ans\n\n    memo = defaultdict(lambda: float(\"inf\"))\n    ans = float(\"inf\")\n    for square in squares:\n        ans = min(ans, dp(0, square))\n    return ans if ans!= float(\"inf\") else -1\n\nn = input()\nprint(min_operations(n))"}
{"solution": "import math\n\nMOD = 10**9 + 7\nMAXN = 10**6 + 5\n\ndef sieve_of_eratosthenes(n):\n    is_prime = [True] * (n + 1)\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n + 1, i):\n                is_prime[j] = False\n    return is_prime\n\ndef count_permutations(n):\n    is_prime = sieve_of_eratosthenes(n)\n    primes = [i for i in range(2, n + 1) if is_prime[i]]\n    k = len(primes)\n    if n == 2:\n        return 1\n    elif n == 3:\n        return 4\n    elif n == 4:\n        return 12\n    elif n == 5:\n        return 60\n    else:\n        result = 1\n        for i in range(2, n + 1):\n            result = (result * i) % MOD\n        for i in range(k - 1):\n            result = (result * (primes[i] - 1)) % MOD\n        return result\n\nn = int(input())\nprint(count_permutations(n))"}
{"solution": "def min_jump_ability(s):\n    vowels = set('AEIOUY')\n    max_distance = 0\n    prev_vowel_index = -1\n\n    for i, char in enumerate(s):\n        if char in vowels:\n            if prev_vowel_index!= -1:\n                max_distance = max(max_distance, i - prev_vowel_index)\n            prev_vowel_index = i\n\n    return max_distance\n\n\ns = input()\nprint(min_jump_ability(s))"}
{"solution": "def can_distribute_candies(a):\n    total_sum = sum(a)\n    if total_sum % 2!= 0:\n        return \"NO\"\n\n    target_sum = total_sum // 2\n    a.sort(reverse=True)\n\n    def dfs(index, current_sum):\n        if current_sum == target_sum:\n            return True\n        if current_sum > target_sum or index == len(a):\n            return False\n\n        return dfs(index + 1, current_sum + a[index]) or dfs(index + 1, current_sum)\n\n    return \"YES\" if dfs(0, 0) else \"NO\"\n\na = list(map(int, input().split()))\nprint(can_distribute_candies(a))"}
{"solution": "def pie_rule(n, slices):\n    dp = [[[-1 for _ in range(2)] for _ in range(n+1)] for _ in range(n+1)]\n    \n    def dfs(i, j, k):\n        if i > n:\n            return 0\n        if dp[i][j][k]!= -1:\n            return dp[i][j][k]\n        \n        if k == 0:\n            dp[i][j][k] = max(slices[i-1] + dfs(i+1, j, 1-k), dfs(i+1, j, k))\n        else:\n            dp[i][j][k] = min(slices[i-1] + dfs(i+1, j+1, 1-k), dfs(i+1, j, k))\n        \n        return dp[i][j][k]\n    \n    alice = dfs(1, 0, 0)\n    bob = sum(slices) - alice\n    \n    return alice, bob\n\nn = int(input())\nslices = list(map(int, input().split()))\n\nalice, bob = pie_rule(n, slices)\nprint(alice, bob)"}
{"solution": "import sys\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    dp = [0] * (1 << n)\n    for i in range(n):\n        dp[1 << i] = a[i]\n    for mask in range(1 << n):\n        for i in range(n):\n            if (mask >> i) & 1:\n                for j in range(i):\n                    if (mask >> j) & 1:\n                        for k in range(n):\n                            if not ((mask >> k) & 1):\n                                if dp[mask] + dp[mask ^ (1 << k)] <= a[-1]:\n                                    dp[mask ^ (1 << k)] = max(dp[mask ^ (1 << k)], dp[mask] + dp[mask ^ (1 << k)])\n    ans = 1\n    while ans < n and dp[(1 << ans) - 1]!= a[ans - 1]:\n        ans += 1\n    if ans == n:\n        print(-1)\n    else:\n        print(ans)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\na.sort()\nif a[0] == a[n//2]:\n    print(\"Bob\")\nelse:\n    print(\"Alice\")"}
{"solution": "import math\n\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\nif n == 1 or a[0] == a[-1]:\n    print(\"YES\")\nelse:\n    x = a[-1] - a[0]\n    for i in range(1, n - 1):\n        if (a[i] - a[0]) % x!= 0 or (a[i] - a[0]) // x > 1 or (a[-1] - a[i]) % x!= 0 or (a[-1] - a[i]) // x > 1:\n            print(\"NO\")\n            break\n    else:\n        print(\"YES\")"}
{"solution": "def max_repeated_substring_length(n, s):\n    max_length = 0\n    for length in range(1, n // 2 + 1):\n        for i in range(n - length):\n            substring = s[i:i + length]\n            if s.find(substring, i + length)!= -1:\n                max_length = max(max_length, length)\n    return max_length\n\nn = int(input())\ns = input()\nprint(max_repeated_substring_length(n, s))"}
{"solution": "n, a = map(int, input().split())\nprint(min((a + 1) // 2, n // 2 - (a - 2) // 2 + 1))"}
{"solution": "n, m = map(int, input().split())\ncolors = list(map(int, input().split()))\nk = list(map(int, input().split()))\n\ndef can_form_interval(colors, k):\n    color_counts = {i: 0 for i in range(1, m + 1)}\n    required_counts = {i: k[i - 1] for i in range(1, m + 1)}\n    left = 0\n    for right in range(n):\n        color_counts[colors[right]] += 1\n        while not all(color_counts[i] <= required_counts[i] for i in range(1, m + 1)):\n            color_counts[colors[left]] -= 1\n            left += 1\n        if all(color_counts[i] == required_counts[i] for i in range(1, m + 1)):\n            return True\n    return False\n\nprint(\"YES\" if can_form_interval(colors, k) else \"NO\")"}
{"solution": "n = int(input())\nmishka_wins = 0\nchris_wins = 0\n\nfor _ in range(n):\n    mishka, chris = map(int, input().split())\n    if mishka > chris:\n        mishka_wins += 1\n    elif chris > mishka:\n        chris_wins += 1\n\nif mishka_wins > chris_wins:\n    print(\"Mishka\")\nelif chris_wins > mishka_wins:\n    print(\"Chris\")\nelse:\n    print(\"Friendship is magic!^^\")"}
{"solution": "def is_valid_field(n, m, field):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                continue\n            count = 0\n            for d in directions:\n                ni, nj = i + d[0], j + d[1]\n                if 0 <= ni < n and 0 <= nj < m and field[ni][nj] == '*':\n                    count += 1\n            if field[i][j] == '.':\n                if count!= 0:\n                    return False\n            else:\n                if int(field[i][j])!= count:\n                    return False\n    return True\n\n\nn, m = map(int, input().split())\nfield = [input() for _ in range(n)]\n\nprint(\"YES\" if is_valid_field(n, m, field) else \"NO\")"}
{"solution": "def calculate_vasya_candies(n, k):\n    vasya_candies = 0\n    while n > 0:\n        vasya_candies += min(k, n)\n        n -= min(k, n)\n        n -= n // 10\n    return vasya_candies\n\ndef find_min_k(n):\n    target = (n + 1) // 2\n    left, right = 1, n\n    while left < right:\n        mid = (left + right) // 2\n        if calculate_vasya_candies(n, mid) < target:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\nn = int(input())\nprint(find_min_k(n))"}
{"solution": "def can_rejoin_necklace(necklace):\n    pearls = necklace.count('o')\n    links = len(necklace) - pearls\n\n    if pearls == 0:\n        return True\n\n    links_per_pearl = links // pearls\n    remaining_links = links % pearls\n\n    if remaining_links!= 0:\n        return False\n\n    pearl_index = 0\n    while pearl_index < len(necklace):\n        if necklace[pearl_index]!= 'o':\n            return False\n\n        link_count = 0\n        pearl_index += 1\n        while pearl_index < len(necklace) and necklace[pearl_index]!= 'o':\n            link_count += 1\n            pearl_index += 1\n\n        if link_count!= links_per_pearl:\n            return False\n\n    return True\n\n\nnecklace = input()\nprint(\"YES\" if can_rejoin_necklace(necklace) else \"NO\")"}
{"solution": "def max_pillows(n, m, k):\n    min_pillows = m // n\n    max_pillows = min_pillows + (m % n > 0)\n    frodo_pillows = min_pillows\n\n    if k == 1 or k == n:\n        frodo_pillows = max_pillows\n    elif k == 2 or k == n - 1:\n        frodo_pillows = max_pillows - 1\n    else:\n        frodo_pillows = max_pillows - 2\n\n    return frodo_pillows\n\n\nn, m, k = map(int, input().split())\nprint(max_pillows(n, m, k))"}
{"solution": "import math\n\ndef solve():\n    n, m, k = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    dp = [[-math.inf] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + a[i - 1])\n        for j in range(m + 1):\n            dp[i][j] = max(dp[i][j], dp[i - 1][j] - k)\n\n    ans = 0\n    for i in range(n + 1):\n        for j in range(m + 1):\n            ans = max(ans, dp[i][j])\n\n    print(ans)\n\nsolve()"}
{"solution": "n, m = map(int, input().split())\n\nif n == 0 and m == 0:\n    print(\"0 0\")\n    print(\"1 1\")\n    print(\"0 1\")\n    print(\"1 0\")\nelif n == 0:\n    print(f\"0 {m}\")\n    print(f\"0 {m-1}\")\n    print(f\"0 0\")\n    print(f\"0 1\")\nelif m == 0:\n    print(f\"{n} 0\")\n    print(f\"{n-1} 0\")\n    print(f\"0 0\")\n    print(f\"1 0\")\nelse:\n    print(f\"{n} {m}\")\n    print(f\"0 {m}\")\n    print(f\"0 0\")\n    print(f\"{n} 0\")"}
{"solution": ""}
{"solution": "n, m, min_val, max_val = map(int, input().split())\ntemperatures = list(map(int, input().split()))\n\nif min(temperatures) < min_val or max(temperatures) > max_val:\n    print(\"Incorrect\")\nelif min_val in temperatures and max_val in temperatures:\n    print(\"Correct\")\nelif min_val not in temperatures and max_val not in temperatures and n - m >= 2:\n    print(\"Correct\")\nelif min_val not in temperatures and max_val in temperatures and n - m >= 1:\n    print(\"Correct\")\nelif min_val in temperatures and max_val not in temperatures and n - m >= 1:\n    print(\"Correct\")\nelse:\n    print(\"Incorrect\")"}
{"solution": "import math\n\ndef find_trailing_zeros(m):\n    count = 0\n    result = []\n    i = 5\n    while True:\n        if m > 0:\n            temp = m\n            while temp >= i:\n                temp //= i\n                count += temp\n            if count == m:\n                result.append(i-1)\n                break\n            elif count > m:\n                break\n            i *= 5\n        else:\n            break\n    if result:\n        start = result[0]\n        end = start\n        while True:\n            end += 1\n            if math.floor(end/5) + math.floor(end/25) + math.floor(end/125) + math.floor(end/625) + math.floor(end/3125) + math.floor(end/15625) + math.floor(end/78125) + math.floor(end/390625) + math.floor(end/1953125) + math.floor(end/9765625) + math.floor(end/48828125) + math.floor(end/244140625) == m:\n                pass\n            else:\n                break\n        print(end - start)\n        print(*range(start, end))\n    else:\n        print(0)\n\nm = int(input())\nfind_trailing_zeros(m)"}
{"solution": "import heapq\nimport sys\n\ndef read_ints():\n    return map(int, sys.stdin.readline().split())\n\ndef dijkstra(graph, start, special):\n    n = len(graph)\n    dist = [float('inf')] * n\n    dist[start] = 0\n    pq = [(0, start)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, w in graph[u]:\n            if dist[v] > max(d, w):\n                dist[v] = max(d, w)\n                heapq.heappush(pq, (dist[v], v))\n    return [dist[i] for i in special]\n\nn, m, k = read_ints()\nspecial = list(read_ints())\ngraph = [[] for _ in range(n)]\nfor _ in range(m):\n    u, v, w = read_ints()\n    u -= 1\n    v -= 1\n    graph[u].append((v, w))\n    graph[v].append((u, w))\n\ndist1 = dijkstra(graph, special[0] - 1, special)\ndist2 = dijkstra(graph, dist1.index(max(dist1)), special)\nprint(*dist2)"}
{"solution": "n = int(input())\nx = int(input())\n\nif n % 2 == 0:\n    if x == 0:\n        print(2)\n    elif x == 2:\n        print(0)\n    else:\n        print(1)\nelse:\n    if x == 0:\n        print(1)\n    elif x == 1:\n        print(0)\n    else:\n        print(2)"}
{"solution": "def is_square(rectangles):\n    x_coords = set()\n    y_coords = set()\n    for x1, y1, x2, y2 in rectangles:\n        x_coords.add(x1)\n        x_coords.add(x2)\n        y_coords.add(y1)\n        y_coords.add(y2)\n\n    if len(x_coords)!= 2 or len(y_coords)!= 2:\n        return False\n\n    x1, x2 = sorted(x_coords)\n    y1, y2 = sorted(y_coords)\n\n    return x2 - x1 == y2 - y1\n\n\nn = int(input())\nrectangles = [list(map(int, input().split())) for _ in range(n)]\n\nprint(\"YES\" if is_square(rectangles) else \"NO\")"}
{"solution": "def digit_sum(x):\n    return sum(int(digit) for digit in str(x))\n\ndef count_big_numbers(n, s):\n    count = 0\n    for i in range(1, n + 1):\n        if i - digit_sum(i) >= s:\n            count += 1\n    return count\n\nn, s = map(int, input().split())\nprint(count_big_numbers(n, s))"}
{"solution": "from collections import defaultdict\nfrom math import gcd\n\ndef slope(p1, p2):\n    x1, y1 = p1\n    x2, y2 = p2\n    if x1 == x2:\n        return float('inf')\n    return (y2 - y1) / (x2 - x1)\n\ndef solve(points):\n    n = len(points)\n    if n <= 2:\n        return True\n\n    slopes = defaultdict(set)\n    for i in range(n):\n        for j in range(i + 1, n):\n            s = slope(points[i], points[j])\n            slopes[s].update([i, j])\n\n    max_cover = 0\n    for s in slopes:\n        max_cover = max(max_cover, len(slopes[s]))\n\n    if max_cover == n:\n        return True\n\n    for s in slopes:\n        if len(slopes[s]) < n // 2:\n            continue\n        for s2 in slopes:\n            if s == s2:\n                continue\n            if len(slopes[s2]) + len(slopes[s]) >= n:\n                return True\n\n    return False\n\ndef main():\n    n = int(input())\n    points = []\n    for _ in range(n):\n        x, y = map(int, input().split())\n        points.append((x, y))\n\n    if solve(points):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "MOD = 10**9 + 7\n\ndef add(a, b):\n    return (a + b) % MOD\n\ndef mul(a, b):\n    return (a * b) % MOD\n\ndef pow(a, b):\n    res = 1\n    while b > 0:\n        if b & 1:\n            res = mul(res, a)\n        a = mul(a, a)\n        b >>= 1\n    return res\n\ndef inv(a):\n    return pow(a, MOD - 2)\n\ndef C(n, k):\n    if k < 0 or k > n:\n        return 0\n    return mul(fact[n], mul(inv(fact[k]), inv(fact[n - k])))\n\nfact = [1] * 200001\nfor i in range(1, 200001):\n    fact[i] = mul(fact[i - 1], i)\n\na, b, k, t = map(int, input().split())\nres = 0\nfor i in range(1, 2 * k * t + 1):\n    res = add(res, mul(C(2 * k * t, i + a - b), C(2 * k * t - i, t)))\nprint(res)"}
{"solution": "def can_measure(distances, x, y):\n    for i in range(len(distances)):\n        for j in range(i, len(distances)):\n            if distances[j] - distances[i] == x and x!= y:\n                for k in range(len(distances)):\n                    for last in range(k, len(distances)):\n                        if distances[last] - distances[k] == y:\n                            return True\n            elif distances[j] - distances[i] == y and x!= y:\n                for k in range(len(distances)):\n                    for last in range(k, len(distances)):\n                        if distances[last] - distances[k] == x:\n                            return True\n            elif distances[j] - distances[i] == x and x == y:\n                return True\n    return False\n\n\ndef find_additional_mark(distances, x, y):\n    for i in range(len(distances)):\n        if distances[i] + x <= distances[-1] and distances[i] + x not in distances:\n            return distances[i] + x\n        if distances[i] + y <= distances[-1] and distances[i] + y not in distances:\n            return distances[i] + y\n        if distances[i] - x >= 0 and distances[i] - x not in distances:\n            return distances[i] - x\n        if distances[i] - y >= 0 and distances[i] - y not in distances:\n            return distances[i] - y\n    return None\n\n\ndef find_additional_marks(distances, x, y):\n    additional_marks = []\n    if x not in [distances[j] - distances[i] for i in range(len(distances)) for j in range(i, len(distances))]:\n        additional_marks.append(x)\n    if y not in [distances[j] - distances[i] for i in range(len(distances)) for j in range(i, len(distances))]:\n        additional_marks.append(y)\n    return additional_marks\n\n\nn, l, x, y = map(int, input().split())\ndistances = list(map(int, input().split()))\n\nif can_measure(distances, x, y):\n    print(0)\nelse:\n    additional_mark = find_additional_mark(distances, x, y)\n    if additional_mark is not None:\n        print(1)\n        print(additional_mark)\n    else:\n        additional_marks = find_additional_marks(distances, x, y)\n        print(len(additional_marks))\n        print(*additional_marks)"}
{"solution": "import math\n\nn = int(input())\ncakes = []\nfor _ in range(n):\n    r, h = map(int, input().split())\n    cakes.append((math.pi * r * r * h, r, h))\n\ncakes.sort()\n\ndp = [0] * n\ndp[0] = cakes[0][0]\n\nfor i in range(1, n):\n    max_volume = 0\n    for j in range(i):\n        if cakes[i][1] > cakes[j][1] and cakes[i][2] > cakes[j][2]:\n            max_volume = max(max_volume, dp[j])\n    dp[i] = max(max_volume + cakes[i][0], dp[i-1])\n\nprint(dp[-1])"}
{"solution": "import sys\nimport math\n\ndef input():\n    return sys.stdin.readline().strip()\n\ndef read_int():\n    return int(input())\n\ndef read_ints():\n    return map(int, input().split())\n\ndef solve():\n    n, k = read_ints()\n    h = list(read_ints())\n    h.sort()\n\n    def check(x):\n        cost = 0\n        for i in range(n):\n            cost += max(0, h[i] - x)\n        return cost <= k\n\n    def binary_search():\n        lo, hi = 1, h[-1]\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if check(mid):\n                lo = mid + 1\n            else:\n                hi = mid\n        return lo - 1\n\n    x = binary_search()\n    cost = 0\n    for i in range(n):\n        cost += max(0, h[i] - x)\n\n    ans = math.ceil(cost / k)\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\nprefix_sum = [0] * (n + 1)\nfor i in range(n):\n    prefix_sum[i + 1] = prefix_sum[i] + a[i]\n\nmin_left = [0] * n\nmin_left[0] = a[0]\nfor i in range(1, n):\n    min_left[i] = min(min_left[i - 1], a[i])\n\nmin_right = [0] * n\nmin_right[n - 1] = a[n - 1]\nfor i in range(n - 2, -1, -1):\n    min_right[i] = min(min_right[i + 1], a[i])\n\nmax_sum = float('-inf')\nfor i in range(n):\n    for j in range(i, n):\n        current_sum = prefix_sum[j + 1] - prefix_sum[i] - min(min_left[j], min_right[i])\n        max_sum = max(max_sum, current_sum)\n\nprint(max(max_sum, 0))"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\nk1, k2, k3 = map(int, input().split())\n\nlcm12 = lcm(k1, k2)\nlcm23 = lcm(k2, k3)\nlcm13 = lcm(k1, k3)\n\nif max(lcm12, lcm23, lcm13) <= k1 + k2 + k3 - max(k1, k2, k3):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n = int(input())\ns = input()\n\ndp = [[0] * 26 for _ in range(n + 1)]\n\nfor i in range(n - 1, -1, -1):\n    for j in range(26):\n        dp[i][j] = dp[i + 1][j]\n    dp[i][ord(s[i]) - ord('a')] = min(dp[i + 1][ord(s[i]) - ord('a')] + 1, dp[i + 1][ord(s[i + 1]) - ord('a')] + 1 if i < n - 1 else 1)\n\nprint(dp[0][ord(s[0]) - ord('a')])"}
{"solution": "from collections import Counter\n\nn = int(input())\nboys = Counter(map(int, input().split()))\n\nm = int(input())\ngirls = Counter(map(int, input().split()))\n\npairs = 0\nfor skill in set(list(boys.keys()) + list(girls.keys())):\n    pairs += min(boys[skill], girls[skill])\n    pairs += min(boys[skill - 1] if skill - 1 in boys else 0, girls[skill] if skill in girls else 0)\n    pairs += min(boys[skill], girls[skill + 1] if skill + 1 in girls else 0)\n\nprint(pairs)"}
{"solution": "def determine_winner():\n    team1 = [list(map(int, input().split())) for _ in range(2)]\n    team2 = [list(map(int, input().split())) for _ in range(2)]\n\n    team1_defence = max(team1[0][0], team1[1][0])\n    team1_attack = min(team1[0][1], team1[1][1])\n\n    team2_defence = max(team2[0][0], team2[1][0])\n    team2_attack = min(team2[0][1], team2[1][1])\n\n    if team1_defence > team2_attack and team1_attack > team2_defence:\n        return \"Team 1\"\n    elif team2_defence > team1_attack and team2_attack > team1_defence:\n        return \"Team 2\"\n    else:\n        return \"Draw\"\n\nprint(determine_winner())"}
{"solution": "import math\nimport sys\n\ndef dist(x1, y1, x2, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef check(x, y, k, arr):\n    times = []\n    for x1, y1, c in arr:\n        times.append(c * dist(x, y, x1, y1))\n    times.sort()\n    return times[k - 1]\n\ndef solve():\n    n, k = map(int, input().split())\n    arr = []\n    for _ in range(n):\n        x, y, c = map(int, input().split())\n        arr.append((x, y, c))\n\n    ans = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1, _ = arr[i]\n            x2, y2, _ = arr[j]\n            for x in [x1, x2, (x1 + x2) / 2]:\n                for y in [y1, y2, (y1 + y2) / 2]:\n                    ans = min(ans, check(x, y, k, arr))\n\n    print(f\"{ans:.7f}\")\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def solve():\n    n = int(input())\n    s = input()\n    a = [int(c) if c!= '?' else 0 for c in s]\n    diff = sum(a[:n//2]) - sum(a[n//2:])\n    unknown_a = s[:n//2].count('?')\n    unknown_b = s[n//2:].count('?')\n    if diff % 10!= 0:\n        return \"Monocarp\"\n    if diff == 0:\n        return \"Bicarp\"\n    if unknown_a == unknown_b:\n        return \"Bicarp\"\n    if abs(diff) <= 9 * abs(unknown_a - unknown_b):\n        return \"Bicarp\"\n    return \"Monocarp\"\n\nprint(solve())"}
{"solution": "import math\n\nn, t = map(int, input().split())\nmin_time = float('inf')\nmin_index = -1\n\nfor i in range(n):\n    s, d = map(int, input().split())\n    time = s + (t - s + d - 1) // d * d\n    if time < min_time:\n        min_time = time\n        min_index = i + 1\n\nprint(min_index)"}
{"solution": "def count_ones(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\ndef solve(m, k):\n    n = 1\n    while True:\n        count = 0\n        for i in range(n + 1, 2 * n + 1):\n            if count_ones(i) == k:\n                count += 1\n        if count == m:\n            return n\n        n += 1\n\nm, k = map(int, input().split())\nprint(solve(m, k))"}
{"solution": "def is_good_level(level):\n    n = len(level)\n    for i in range(n):\n        for jump in range(1, n // 4):\n            if i + 4 * jump < n and all(level[i + k * jump] == '*' for k in range(5)):\n                return True\n    return False\n\nn = int(input())\nlevel = input().strip()\nprint(\"yes\" if is_good_level(level) else \"no\")"}
{"solution": "def calculate_magic_constant(n, grid):\n    total_sum = sum(sum(row) for row in grid)\n    return (n * (n ** 2 + 1)) // 2 - total_sum\n\ndef check_magic_square(n, grid, magic_constant):\n    for i in range(n):\n        row_sum = sum(grid[i])\n        col_sum = sum(grid[j][i] for j in range(n))\n        if row_sum!= magic_constant or col_sum!= magic_constant:\n            return False\n\n    diagonal_sum1 = sum(grid[i][i] for i in range(n))\n    diagonal_sum2 = sum(grid[i][n - i - 1] for i in range(n))\n    if diagonal_sum1!= magic_constant or diagonal_sum2!= magic_constant:\n        return False\n\n    return True\n\ndef find_empty_cell(n, grid):\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 0:\n                return i, j\n\ndef main():\n    n = int(input())\n    grid = [list(map(int, input().split())) for _ in range(n)]\n\n    magic_constant = calculate_magic_constant(n, grid)\n    if magic_constant < 1:\n        print(-1)\n        return\n\n    empty_row, empty_col = find_empty_cell(n, grid)\n    grid[empty_row][empty_col] = magic_constant\n\n    if check_magic_square(n, grid, sum(grid[0])):\n        print(magic_constant)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n = int(input())\nm = int(input())\na = [int(input()) for _ in range(n)]\n\nmin_k = max(max(a), (m + sum(a) - 1) // n + 1)\nmax_k = max(a) + m\n\nprint(min_k, max_k)"}
{"solution": "MOD = 10**9 + 7\n\ndef mod_inverse(a, m):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, _ = extended_gcd(a, m)\n    if gcd!= 1:\n        return None\n    else:\n        return x % m\n\ndef mod_power(a, b, m):\n    result = 1\n    while b > 0:\n        if b % 2 == 1:\n            result = (result * a) % m\n        a = (a * a) % m\n        b //= 2\n    return result\n\ndef mod_factorial(n, m):\n    result = 1\n    for i in range(1, n + 1):\n        result = (result * i) % m\n    return result\n\ndef mod_combination(n, k, m):\n    if k > n:\n        return 0\n    numerator = mod_factorial(n, m)\n    denominator = (mod_factorial(k, m) * mod_factorial(n - k, m)) % m\n    return (numerator * mod_inverse(denominator, m)) % m\n\ndef solve(n, m):\n    result = 0\n    for k in range(m + 1):\n        combination = mod_combination(m, k, MOD)\n        power = mod_power(2, k, MOD)\n        power2 = mod_power(2, m - k, MOD)\n        result = (result + combination * power * power2 * mod_power(n - k + 1, k, MOD)) % MOD\n    return result\n\nn, m = map(int, input().split())\nprint(solve(n, m))"}
{"solution": "from collections import defaultdict\nfrom itertools import combinations\n\ndef solve():\n    n, m = map(int, input().split())\n    friends = []\n    for _ in range(n):\n        f, *b = map(int, input().split())\n        friends.append(set(b))\n\n    pizzas = []\n    for i in range(m):\n        c, r, *a = map(int, input().split())\n        pizzas.append((c, set(a), i + 1))\n\n    pizzas.sort()\n\n    max_friends = 0\n    min_cost = float('inf')\n    ans = None\n\n    for i, j in combinations(range(m), 2):\n        ci, ai, _ = pizzas[i]\n        cj, aj, _ = pizzas[j]\n        union = ai.union(aj)\n        friends_satisfied = sum(1 for f in friends if f.issubset(union))\n        if friends_satisfied > max_friends or (friends_satisfied == max_friends and ci + cj < min_cost):\n            max_friends = friends_satisfied\n            min_cost = ci + cj\n            ans = (pizzas[i][2], pizzas[j][2])\n\n    print(*ans)\n\nsolve()"}
{"solution": "def find_min_max(m, s):\n    if s == 0 and m > 1:\n        return \"-1 -1\"\n    if s < m or s > 9 * m:\n        return \"-1 -1\"\n\n    min_num = ''\n    max_num = ''\n\n    remaining_sum = s\n    for i in range(m):\n        if i == 0:\n            min_num += str(min(9, remaining_sum))\n            remaining_sum -= int(min_num[-1])\n        else:\n            min_num += str(min(9, remaining_sum))\n            remaining_sum -= int(min_num[-1])\n\n    remaining_sum = s\n    for i in range(m):\n        if i == 0:\n            max_num += str(min(9, remaining_sum))\n            remaining_sum -= int(max_num[-1])\n        else:\n            max_num += str(max(0, remaining_sum))\n            remaining_sum -= int(max_num[-1])\n\n    max_num = max_num[::-1]\n\n    return min_num +'' + max_num\n\n\nm, s = map(int, input().split())\nprint(find_min_max(m, s))"}
{"solution": "MOD = 998244353\n\ndef count(x, k):\n    if k == 1:\n        return x // 9 * 9 + (x % 9) * (x % 9 + 1) // 2\n    elif k == 2:\n        return x * (x + 1) // 2 - 9 * x // 9 * (x // 9 + 1) // 2\n    elif k == 3:\n        return x * (x + 1) // 2 - 9 * x // 9 * (x // 9 + 1) // 2 + 9 * x // 81 * (x // 81 + 1) // 2\n    elif k == 4:\n        return x * (x + 1) // 2 - 9 * x // 9 * (x // 9 + 1) // 2 + 9 * x // 81 * (x // 81 + 1) // 2 - 9 * x // 729 * (x // 729 + 1) // 2\n    elif k == 5:\n        return x * (x + 1) // 2 - 9 * x // 9 * (x // 9 + 1) // 2 + 9 * x // 81 * (x // 81 + 1) // 2 - 9 * x // 729 * (x // 729 + 1) // 2 + 9 * x // 6561 * (x // 6561 + 1) // 2\n    elif k == 6:\n        return x * (x + 1) // 2 - 9 * x // 9 * (x // 9 + 1) // 2 + 9 * x // 81 * (x // 81 + 1) // 2 - 9 * x // 729 * (x // 729 + 1) // 2 + 9 * x // 6561 * (x // 6561 + 1) // 2 - 9 * x // 59049 * (x // 59049 + 1) // 2\n    elif k == 7:\n        return x * (x + 1) // 2 - 9 * x // 9 * (x // 9 + 1) // 2 + 9 * x // 81 * (x // 81 + 1) // 2 - 9 * x // 729 * (x // 729 + 1) // 2 + 9 * x // 6561 * (x // 6561 + 1) // 2 - 9 * x // 59049 * (x // 59049 + 1) // 2 + 9 * x // 531441 * (x // 531441 + 1) // 2\n    elif k == 8:\n        return x * (x + 1) // 2 - 9 * x // 9 * (x // 9 + 1) // 2 + 9 * x // 81 * (x // 81 + 1) // 2 - 9 * x // 729 * (x // 729 + 1) // 2 + 9 * x // 6561 * (x // 6561 + 1) // 2 - 9 * x // 59049 * (x // 59049 + 1) // 2 + 9 * x // 531441 * (x // 531441 + 1) // 2 - 9 * x // 4782969 * (x // 4782969 + 1) // 2\n    elif k == 9:\n        return x * (x + 1) // 2 - 9 * x // 9 * (x // 9 + 1) // 2 + 9 * x // 81 * (x // 81 + 1) // 2 - 9 * x // 729 * (x // 729 + 1) // 2 + 9 * x // 6561 * (x // 6561 + 1) // 2 - 9 * x // 59049 * (x // 59049 + 1) // 2 + 9 * x // 531441 * (x // 531441 + 1) // 2 - 9 * x // 4782969 * (x // 4782969 + 1) // 2 + 9 * x // 43046721 * (x // 43046721 + 1) // 2\n    elif k == 10:\n        return x * (x + 1) // 2\n\ndef solve():\n    l, r, k = map(int, input().split())\n    print((count(r, k) - count(l - 1, k)) % MOD)\n\nsolve()"}
{"solution": "import sys\n\ndef main():\n    n, k, d = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    a.sort()\n\n    left = 0\n    while left < n:\n        right = left + 1\n        while right < n and a[right] - a[left] <= d:\n            right += 1\n        if right - left >= k:\n            left = right\n        else:\n            return \"NO\"\n    return \"YES\"\n\nprint(main())"}
{"solution": "def count_dead_bulbs(s):\n    colors = ['R', 'B', 'Y', 'G']\n    dead_bulbs = [0, 0, 0, 0]\n    for i in range(len(s)):\n        if s[i] == '!':\n            dead_bulbs[colors.index(s[(i + 1) % len(s)])] += 1\n        else:\n            continue\n    return dead_bulbs\n\ns = input()\ndead_bulbs = count_dead_bulbs(s)\nprint(*dead_bulbs)"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_int():\n    return int(read_input())\n\ndef read_ints():\n    return list(map(int, read_input().split()))\n\ndef main():\n    n, m = read_ints()\n    graph = [[] for _ in range(n)]\n    rev_graph = [[] for _ in range(n)]\n    for _ in range(m):\n        s, t = read_ints()\n        s -= 1\n        t -= 1\n        graph[s].append(t)\n        rev_graph[t].append(s)\n\n    deg = [len(graph[i]) for i in range(n)]\n    prob = [1.0 / deg[i] if deg[i] > 0 else 0.0 for i in range(n)]\n    prob[n - 1] = 0.0\n\n    f = [0.0] * n\n    f[n - 1] = 0.0\n    for _ in range(n):\n        for i in range(n - 1, -1, -1):\n            if i == n - 1:\n                continue\n            f[i] = 1.0\n            for j in graph[i]:\n                f[i] += prob[i] * f[j]\n\n    ans = f[0]\n    for i in range(n - 1):\n        if len(graph[i]) == 1:\n            continue\n        for j in graph[i]:\n            deg[i] -= 1\n            prob[i] = 1.0 / deg[i]\n            f[i] = 1.0\n            for k in graph[i]:\n                f[i] += prob[i] * f[k]\n            ans = min(ans, f[0])\n            deg[i] += 1\n            prob[i] = 1.0 / deg[i]\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n = int(input())\nprint(n - (n % 10))"}
{"solution": "def find_swapped_keys(s, t):\n    swaps = {}\n    for i in range(len(s)):\n        if s[i]!= t[i]:\n            if s[i] in swaps:\n                if swaps[s[i]]!= t[i]:\n                    return -1\n            elif t[i] in swaps.values():\n                return -1\n            else:\n                swaps[s[i]] = t[i]\n                swaps[t[i]] = s[i]\n    return swaps\n\n\ndef main():\n    s = input()\n    t = input()\n    swaps = find_swapped_keys(s, t)\n    if swaps == -1:\n        print(-1)\n    else:\n        distinct_swaps = set()\n        for key, value in swaps.items():\n            if key < value:\n                distinct_swaps.add((key, value))\n        print(len(distinct_swaps))\n        for swap in distinct_swaps:\n            print(swap[0], swap[1])\n\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef earliest_login(first_name, last_name):\n    earliest = first_name[0] + last_name[0]\n    for i in range(1, len(first_name)):\n        for j in range(1, len(last_name)):\n            login = first_name[:i] + last_name[:j]\n            if login < earliest:\n                earliest = login\n    return earliest\n\nfirst_name, last_name = input().split()\nprint(earliest_login(first_name, last_name))"}
{"solution": "def draw_brackets(s):\n    stack = []\n    max_depth = 0\n    for c in s:\n        if c == '[':\n            stack.append(len(stack))\n            max_depth = max(max_depth, len(stack))\n        else:\n            depth = stack.pop()\n    lines = [[''for _ in range(len(s) * 2 + 1)] for _ in range(max_depth)]\n    for i, c in enumerate(s):\n        if c == '[':\n            depth = len(stack)\n            lines[depth][i * 2] = '+'\n            lines[depth][i * 2 + 1] = '-'\n            for j in range(depth):\n                lines[j][i * 2] = '|'\n        else:\n            depth = stack[-1]\n            lines[depth][i * 2] = '+'\n            lines[depth][i * 2 + 1] = '-'\n            for j in range(depth):\n                lines[j][i * 2] = '|'\n    for i in range(max_depth):\n        lines[i] = ''.join(lines[i])\n    return '\\n'.join(lines)\n\nn = int(input())\ns = input()\nprint(draw_brackets(s))"}
{"solution": "import math\n\ndef golden_system(s):\n    q = (math.sqrt(5) + 1) / 2\n    result = 0\n    for i, c in enumerate(reversed(s)):\n        result += int(c) * (q ** i)\n    return result\n\ns1 = input()\ns2 = input()\n\nif golden_system(s1) > golden_system(s2):\n    print(\">\")\nelif golden_system(s1) < golden_system(s2):\n    print(\"<\")\nelse:\n    print(\"=\")"}
{"solution": "n = int(input())\ncolors = [input() for _ in range(n)]\ngems = {\n    \"purple\": \"Power\",\n    \"green\": \"Time\",\n    \"blue\": \"Space\",\n    \"orange\": \"Soul\",\n    \"red\": \"Reality\",\n    \"yellow\": \"Mind\"\n}\nabsent_gems = [gems[color] for color in gems if color not in colors]\nprint(len(absent_gems))\nfor gem in absent_gems:\n    print(gem)"}
{"solution": "import math\n\nn, a, b = map(int, input().split())\n\nrounds = int(math.log2(n))\n\nfor i in range(rounds):\n    if (a + (1 << i) - 1) // (1 << i) == (b + (1 << i) - 1) // (1 << i):\n        if i == rounds - 1:\n            print(\"Final!\")\n        else:\n            print(i + 1)\n        break"}
{"solution": "def solve():\n    n = int(input())\n    p = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    cnt = sum(b) % 2\n    vis = [0] * (n + 1)\n    res = 0\n\n    for i in range(1, n + 1):\n        if not vis[i]:\n            j = i\n            while not vis[j]:\n                vis[j] = 1\n                j = p[j - 1]\n            res += 1\n\n    if res > 1:\n        res -= 1\n    if cnt:\n        res += 1\n    else:\n        res += 2 - (res > 0)\n\n    print(res)\n\nsolve()"}
{"solution": "v1, v2 = map(int, input().split())\nt, d = map(int, input().split())\n\nif v1 < v2:\n    v1, v2 = v2, v1\n\ntotal_distance = 0\nfor i in range(t):\n    if i == 0:\n        total_distance += v1\n    elif i == t - 1:\n        total_distance += v2\n    else:\n        if v1 - d > v2:\n            total_distance += v1 - d\n            v1 = v1 - d\n        else:\n            total_distance += v2\n            v1 = v2\n\nprint(total_distance)"}
{"solution": "import sys\nimport itertools\n\ndef solve(weights, segments):\n    n = len(weights)\n    m = len(segments)\n    min_distance = float('inf')\n\n    for order in itertools.permutations(range(n)):\n        order_weights = [weights[i] for i in order]\n        order_weights.sort()\n\n        max_weight = sum(order_weights[1:-1])\n        if max_weight > segments[0][1]:\n            continue\n\n        distance = 0\n        for i in range(m):\n            length, capacity = segments[i]\n            if i == m - 1:\n                break\n\n            if capacity < max_weight:\n                continue\n\n            remaining_capacity = capacity - max_weight\n            if remaining_capacity < order_weights[-1]:\n                continue\n\n            distance += length\n\n            if i == m - 2:\n                min_distance = min(min_distance, distance)\n\n    if min_distance == float('inf'):\n        return -1\n    else:\n        return min_distance\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    weights = list(map(int, sys.stdin.readline().split()))\n    segments = [tuple(map(int, sys.stdin.readline().split())) for _ in range(m)]\n\n    print(solve(weights, segments))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\na, b = map(int, input().split())\n\nif a == 0:\n    print(0)\n    exit()\n\nif b < 10:\n    print(int(math.factorial(b) / math.factorial(a)) % 10)\nelse:\n    print(int((math.factorial(b) // math.factorial(b - 10)) / (math.factorial(a) // math.factorial(a - 10))) % 10)"}
{"solution": "from collections import deque\n\nn, d = map(int, input().split())\ns = input()\n\ndef min_jumps(n, d, s):\n    queue = deque([(1, 0)])\n    visited = set([1])\n\n    while queue:\n        pos, jumps = queue.popleft()\n\n        if pos == n:\n            return jumps\n\n        for i in range(1, d + 1):\n            if pos + i <= n and s[pos + i - 1] == '1' and pos + i not in visited:\n                queue.append((pos + i, jumps + 1))\n                visited.add(pos + i)\n\n    return -1\n\nprint(min_jumps(n, d, s))"}
{"solution": "def is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\nn = int(input())\nfor m in range(1, 1001):\n    if not is_prime(n * m + 1):\n        print(m)\n        break"}
{"solution": "def can_spend_all_coins(n):\n    for a in range(n // 1234567 + 1):\n        remaining_coins = n - a * 1234567\n        if remaining_coins < 0:\n            break\n        for b in range(remaining_coins // 123456 + 1):\n            remaining_coins_2 = remaining_coins - b * 123456\n            if remaining_coins_2 < 0:\n                break\n            if remaining_coins_2 % 1234 == 0:\n                return True\n    return False\n\nn = int(input())\nprint(\"YES\" if can_spend_all_coins(n) else \"NO\")"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef read_int():\n    return int(read_input())\n\ndef solve():\n    n = read_int()\n    x1, x2 = read_ints()\n    lines = []\n    for _ in range(n):\n        k, b = read_ints()\n        lines.append((k, b))\n\n    lines.sort()\n\n    events = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            if lines[i][0] == lines[j][0]:\n                continue\n            x = (lines[j][1] - lines[i][1]) / (lines[i][0] - lines[j][0])\n            if x1 < x < x2:\n                events.append((x, 1))\n                events.append((x1, -1))\n                events.append((x2, -1))\n\n    events.sort()\n\n    cnt = 0\n    for _, val in events:\n        cnt += val\n        if cnt >= 2:\n            print(\"Yes\")\n            return\n\n    print(\"No\")\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "import math\n\nn = int(input())\n\nweights = set()\n\nfor i in range(1, int(math.sqrt(n)) + 1):\n    if n % i == 0:\n        weights.add(i)\n        weights.add(n // i)\n\nprint(len(weights))"}
{"solution": "n, k = map(int, input().split())\n\nif k == 0 or k == 1 or n < k:\n    print(0, 0)\nelif k == n:\n    print(0, 0)\nelse:\n    min_val = 1 if n - k >= k - 1 else n - k\n    max_val = n - k - 1 if n - k >= k else n - k\n    print(min_val, max_val)"}
{"solution": "def fibonacci(n):\n    a, b = 0, 1\n    while a < n:\n        a, b = b, a + b\n    return a\n\ndef find_max_games(n):\n    i = 0\n    while True:\n        fib = fibonacci(i)\n        if fib > n:\n            return i - 1\n        i += 1\n\nn = int(input())\nprint(find_max_games(n))"}
{"solution": "def max_vk(s):\n    vk_count = s.count(\"VK\")\n    kv_count = s.count(\"KV\")\n    vv_count = s.count(\"VV\")\n    kk_count = s.count(\"KK\")\n\n    max_count = vk_count\n    if vv_count > 0:\n        max_count = max(max_count, vk_count + 1)\n    if kk_count > 0:\n        max_count = max(max_count, vk_count + 1)\n    if kv_count > 0:\n        max_count = max(max_count, vk_count + 1)\n\n    return max_count\n\ns = input()\nprint(max_vk(s))"}
{"solution": "import math\n\nn = int(input())\nif n == 1:\n    print(2)\nelse:\n    print(2 * math.isqrt(n) + (n - math.isqrt(n) ** 2) // math.isqrt(n))"}
{"solution": "a, b = map(int, input().split())\nyears = 0\n\nwhile a <= b:\n    a *= 3\n    b *= 2\n    years += 1\n\nprint(years)"}
{"solution": "def solve(h, n):\n    if h == 1:\n        return 2 if n == 2 else 1\n\n    nodes = 2 ** h\n    mid = nodes // 2\n    left = mid\n    right = nodes - mid\n\n    if n <= left:\n        return solve(h - 1, n) + 2 * (h - 1) + 1\n    else:\n        return solve(h - 1, n - left) + 2 * (h - 1) + 2\n\nh, n = map(int, input().split())\nprint(solve(h, n))"}
{"solution": "import math\n\ndef get_divisors(x):\n    divisors = set()\n    for i in range(1, int(math.sqrt(x)) + 1):\n        if x % i == 0:\n            divisors.add(i)\n            divisors.add(x // i)\n    return divisors\n\ndef get_tables(x):\n    tables = []\n    for n in range(1, int(math.sqrt(x)) + 1):\n        if (x - n) % (n + 1) == 0:\n            m = (x - n) // (n + 1) + 1\n            tables.append((n, m))\n    return tables\n\ndef get_symmetric_tables(tables):\n    symmetric_tables = []\n    for n, m in tables:\n        if n!= m:\n            symmetric_tables.append((m, n))\n    return symmetric_tables\n\ndef main():\n    x = int(input())\n    tables = get_tables(x)\n    symmetric_tables = get_symmetric_tables(tables)\n    tables.extend(symmetric_tables)\n    tables.sort()\n    print(len(tables))\n    for n, m in tables:\n        print(n, m)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_leap(year):\n    return year % 4 == 0 and (year % 100!= 0 or year % 400 == 0)\n\ndef get_months(year):\n    months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    if is_leap(year):\n        months[1] = 29\n    return months\n\ndef check_sequence(sequence, months, start):\n    for i in range(len(sequence)):\n        if sequence[i]!= months[(start + i) % 12]:\n            return False\n    return True\n\nn = int(input())\nsequence = list(map(int, input().split()))\n\nfor year in range(2000, 2005):\n    months = get_months(year)\n    for start in range(12):\n        if check_sequence(sequence, months, start):\n            print(\"YES\")\n            exit()\n\nprint(\"NO\")"}
{"solution": "import math\n\ndef get_divisors(n):\n    divisors = []\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i!= n // i:\n                divisors.append(n // i)\n    return divisors\n\ndef get_sequence(n):\n    sequence = []\n    divisors = get_divisors(n)\n    for divisor in divisors:\n        if divisor!= n:\n            sequence.append((1, divisor))\n            sequence.append((divisor - 1, divisor))\n    return sequence\n\ndef get_sum(sequence):\n    total = 0\n    for a, b in sequence:\n        total += a / b\n    return total\n\ndef solve(n):\n    sequence = get_sequence(n)\n    total = get_sum(sequence)\n    if total == 1 - 1 / n:\n        return sequence\n    else:\n        return None\n\ndef main():\n    n = int(input())\n    sequence = solve(n)\n    if sequence is None:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(len(sequence))\n        for a, b in sequence:\n            print(a, b)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef read_ints():\n    return map(int, sys.stdin.readline().split())\n\ndef read_int():\n    return int(sys.stdin.readline())\n\ndef solve():\n    n = read_int()\n    a, b = read_ints()\n    h = list(read_ints())\n\n    total = sum(h)\n    if a < 0 or b < 0 or a + b < total:\n        print(-1)\n        return\n\n    dp = [[[float('inf')] * (total + 1) for _ in range(2)] for _ in range(n + 1)]\n    dp[0][0][0] = 0\n    dp[0][1][0] = 0\n\n    for i in range(n):\n        for j in range(2):\n            for k in range(total + 1):\n                if dp[i][j][k] == float('inf'):\n                    continue\n                dp[i + 1][j][k] = min(dp[i + 1][j][k], dp[i][j][k])\n                if k + h[i] <= total:\n                    dp[i + 1][1 - j][k + h[i]] = min(dp[i + 1][1 - j][k + h[i]], dp[i][j][k] + h[i])\n\n    ans = float('inf')\n    for i in range(total + 1):\n        if i <= a and total - i <= b:\n            ans = min(ans, dp[n][0][i], dp[n][1][i])\n\n    print(ans if ans!= float('inf') else -1)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nn, m, k = map(int, input().split())\n\nif n % 2 == 0 and m % 2 == 0 and k % 2 == 0:\n    k //= 2\n    n //= 2\n    m //= 2\n\ng = gcd(n, m)\nn //= g\nm //= g\nk = (k * g) // math.gcd(k, g)\n\nif n * m < k:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(\"0 0\")\n    print(\"0\", m)\n    print(n, \"0\")"}
{"solution": "n, k = map(int, input().split())\nprint(\"YES\" if (n - 1) // k > n // (2 * k) else \"NO\")"}
{"solution": "n = int(input())\nexercises = list(map(int, input().split()))\n\nchest = sum(exercises[i] for i in range(0, n, 3))\nbiceps = sum(exercises[i] for i in range(1, n, 3))\nback = sum(exercises[i] for i in range(2, n, 3))\n\nmax_exercise = max(chest, biceps, back)\n\nif max_exercise == chest:\n    print(\"chest\")\nelif max_exercise == biceps:\n    print(\"biceps\")\nelse:\n    print(\"back\")"}
{"solution": "n = int(input())\ngrades = list(map(int, input().split()))\n\ntotal = sum(grades)\ncount = 0\n\nwhile (total + count * (5 - grades[count % n])) / (n + count) < 4.5:\n    count += 1\n\nprint(count)"}
{"solution": "def solve(u, v):\n    if u > v:\n        return None\n    if u % 2!= v % 2:\n        return None\n    if u == 0 and v == 0:\n        return []\n    if u == v:\n        return [u]\n    if v - u <= u:\n        return [v - u, u]\n    if v - u == 2 * u + 1:\n        return [1, 1, v - 2]\n    if v - u == 2 * u + 2:\n        return [2, v - 2 * u - 2, u]\n    if v - u == 2 * u:\n        return [2, v - 2 * u, u - 1, 1]\n    return None\n\nu, v = map(int, input().split())\nres = solve(u, v)\nif res is None:\n    print(-1)\nelse:\n    print(len(res))\n    print(*res)"}
{"solution": "def min_ones(n):\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for i in range(1, n + 1):\n        j, count = i, 0\n        while j > 0:\n            count += 1\n            j //= 10\n            if i - j >= 0:\n                dp[i] = min(dp[i], dp[i - j] + count)\n    return dp[n]\n\nn = int(input())\nprint(min_ones(n))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nx1, y1, x2, y2 = map(int, input().split())\nx, y = map(int, input().split())\n\ndx = abs(x2 - x1)\ndy = abs(y2 - y1)\n\nif dx == 0 and dy % y == 0:\n    print(\"YES\")\nelif dy == 0 and dx % x == 0:\n    print(\"YES\")\nelif dx == 0 or dy == 0 or gcd(dx, x) == gcd(dy, y):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "from math import factorial\nfrom collections import Counter\n\ndef calculate_permutations(n, digits):\n    permutations = factorial(n)\n    for digit in digits:\n        permutations //= factorial(digits[digit])\n    return permutations\n\ndef main():\n    n = input().strip()\n    digits = Counter(n)\n    total_permutations = 0\n    for i in range(1, len(n) + 1):\n        for j in range(i, len(n) + 1):\n            temp_digits = digits.copy()\n            temp_permutations = 1\n            for k in range(i, j):\n                if n[k] in temp_digits and temp_digits[n[k]] > 0:\n                    temp_digits[n[k]] -= 1\n                    temp_permutations *= calculate_permutations(j - i, temp_digits)\n                    temp_digits[n[k]] += 1\n                else:\n                    temp_permutations = 0\n                    break\n            if temp_permutations > 0:\n                total_permutations += temp_permutations\n    print(total_permutations)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "a = int(input())\nb = int(input())\nc = int(input())\nd = int(input())\ne = int(input())\nf = int(input())\n\nmin_jacket = min(a, d)\nmin_second_type = min(b, c, d)\n\nfirst_type = min(min_jacket, d - min_second_type)\nsecond_type = min(min_second_type, a - first_type)\n\nprint(first_type * e + second_type * f)"}
{"solution": "import math\n\ndef exgcd(a, b):\n    if b == 0:\n        return a, 1, 0\n    else:\n        gcd, x, y = exgcd(b, a % b)\n        return gcd, y, x - (a // b) * y\n\ndef mod_inverse(a, p):\n    gcd, x, y = exgcd(a, p)\n    return x % p\n\ndef solve():\n    a, b, p, x = map(int, input().split())\n    if b == 0:\n        if a == 1:\n            print(x)\n        else:\n            print(0)\n        return\n    if a == 1:\n        if b == 1:\n            print(x)\n        else:\n            print(0)\n        return\n    if a == b:\n        print(x)\n        return\n    phi = p - 1\n    k = phi\n    while k % 2 == 0:\n        k //= 2\n    l = phi // k\n    inv_a = mod_inverse(a, p)\n    inv_b = mod_inverse(b, p)\n    inv_a_l = pow(inv_a, l, p)\n    inv_b_l = pow(inv_b, l, p)\n    inv_a_k = pow(inv_a, k, p)\n    inv_b_k = pow(inv_b, k, p)\n    c = (inv_b_l * pow(a, l, p)) % p\n    d = (inv_a_k * pow(b, k, p)) % p\n    if c == d:\n        ans = 0\n        for i in range(1, x + 1):\n            if pow(a, i, p) == b * pow(i, -1, p) % p:\n                ans += 1\n        print(ans)\n    else:\n        print(0)\n\nsolve()"}
{"solution": "k2, k3, k5, k6 = map(int, input().split())\nans = 0\nans += min(k5, k2, k6) * 256\nk2 -= min(k5, k2, k6)\nk5 -= min(k5, k2, k6)\nk6 -= min(k5, k2, k6)\nans += min(k2, k3) * 32\nprint(ans)"}
{"solution": "import math\n\nn, x, y, c = map(int, input().split())\n\nif c == 1:\n    print(0)\nelse:\n    if n % 2 == 0:\n        max_cells = n * n\n    else:\n        max_cells = n * n - 1\n\n    if c > max_cells:\n        print(-1)\n    else:\n        if n == 1:\n            print(-1)\n        else:\n            if c <= 4:\n                print(1)\n            else:\n                if n == 2:\n                    print(-1)\n                else:\n                    if n == 3:\n                        if c == 5:\n                            print(1)\n                        elif c == 6:\n                            print(2)\n                        elif c == 7:\n                            print(1)\n                        elif c == 8:\n                            print(2)\n                        elif c == 9:\n                            print(1)\n                    else:\n                        if c <= n * n - 4 * (n - 2):\n                            print(2)\n                        else:\n                            if c <= n * n - 2 * (n - 2):\n                                print(3)\n                            else:\n                                if c == n * n:\n                                    print(n - 1)\n                                else:\n                                    print(n - 2 + math.ceil((c - (n - 2) * (n - 2)) / (4 * (n - 2))))"}
{"solution": "def max_xor(l, r):\n    if l == r:\n        return 0\n\n    max_val = 0\n    i = 0\n    while (1 << i) <= r:\n        i += 1\n\n    for j in range(i - 1, -1, -1):\n        if (l & (1 << j)) == 0 and (r & (1 << j))!= 0:\n            max_val |= (1 << j)\n        elif (l & (1 << j)) == 0 and (r & (1 << j)) == 0:\n            break\n\n    return max_val | ((1 << (j + 1)) - 1)\n\nl, r = map(int, input().split())\nprint(max_xor(l, r))"}
{"solution": "def check(n, k, h):\n    return (n * h) + (h - 1) * h <= 2 * k\n\ndef solve(n, k):\n    l, r = 0, 10**18\n    while l < r:\n        mid = (l + r) // 2\n        if check(n, k, mid):\n            l = mid + 1\n        else:\n            r = mid\n    return l\n\nn, k = map(int, input().split())\nprint(solve(n, k))"}
{"solution": "x, y, z, t1, t2, t3 = map(int, input().split())\n\nstairs_time = abs(y - x) * t1\nelevator_time = abs(z - x) * t2 + 2 * t3 + abs(y - z) * t2\n\nprint(\"YES\" if elevator_time <= stairs_time else \"NO\")"}
{"solution": "n, m = map(int, input().split())\n\nif m == 1:\n    print(2)\nelif m == n:\n    print(n - 1)\nelse:\n    if m - 1 >= n - m:\n        print(m - 1)\n    else:\n        print(m + 1)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\ncount = 0\ni = 0\nwhile i < n:\n    if a[i] == 1:\n        count += 1\n        while i < n and a[i] == 1:\n            count += 1\n            i += 1\n    elif i + 1 < n and a[i + 1] == 1:\n        count += 1\n        i += 1\n    i += 1\n\nprint(count)"}
{"solution": "n, k = map(int, input().split())\ncandies = list(map(int, input().split()))\n\ntotal_candies = 0\ndays = 0\n\nfor candy in candies:\n    total_candies += candy\n    days += 1\n    given_candies = min(total_candies, (total_candies // 8) * 8 + min(total_candies % 8, k))\n    if given_candies >= k:\n        break\n\nprint(days if given_candies >= k else -1)"}
{"solution": "def min_additional_walks(n, k, a):\n    b = [max(k, a[0])]\n    additional_walks = b[0] - a[0]\n    \n    for i in range(1, n):\n        b.append(max(k - b[i-1], a[i]))\n        additional_walks += b[i] - a[i]\n    \n    return additional_walks, b\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nadditional_walks, b = min_additional_walks(n, k, a)\n\nprint(additional_walks)\nprint(*b)"}
{"solution": "n = int(input())\nprint(2*n**2 - 2*n + 1)"}
{"solution": "def is_pangram(s):\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    return set(alphabet).issubset(set(s.lower()))\n\nn = int(input())\ns = input()\nprint(\"YES\" if is_pangram(s) else \"NO\")"}
{"solution": "def calculate_time(time_str, minutes):\n    h, m = map(int, time_str.split(':'))\n    total_minutes = h * 60 + m + minutes\n    new_h = (total_minutes // 60) % 24\n    new_m = total_minutes % 60\n    return f\"{new_h:02d}:{new_m:02d}\"\n\ntime_str = input()\nminutes = int(input())\nprint(calculate_time(time_str, minutes))"}
{"solution": "def solve():\n    n, m = map(int, input().split())\n    a = [input() for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            a[i] = a[i][:j] + '0' + a[i][j+1:]\n        if all(any(a[k][j] == '1' for k in range(n)) for j in range(m)):\n            return True\n        for j in range(m):\n            a[i] = a[i][:j] + '1' + a[i][j+1:]\n    return False\n\nprint(\"YES\" if solve() else \"NO\")"}
{"solution": "n = int(input())\ndominoes = [list(map(int, input().split())) for _ in range(n)]\n\ndef is_even_sum(dominoes):\n    upper_sum = sum(x for x, y in dominoes)\n    lower_sum = sum(y for x, y in dominoes)\n    return upper_sum % 2 == 0 and lower_sum % 2 == 0\n\ndef rotate_domino(dominoes, i):\n    dominoes[i][0], dominoes[i][1] = dominoes[i][1], dominoes[i][0]\n\ndef min_rotations(dominoes):\n    if is_even_sum(dominoes):\n        return 0\n    for i in range(len(dominoes)):\n        rotate_domino(dominoes, i)\n        if is_even_sum(dominoes):\n            return 1\n        rotate_domino(dominoes, i)\n    return -1\n\nprint(min_rotations(dominoes))"}
{"solution": "import math\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef solve():\n    a, b = map(int, input().split())\n    area = a**2 - b**2\n    if is_prime(area):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nt = int(input())\nfor _ in range(t):\n    solve()"}
{"solution": "import sys\n\nn = int(sys.stdin.readline())\npoints = [tuple(map(int, sys.stdin.readline().split())) for _ in range(n)]\n\ndef orientation(p, q, r):\n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0  # Collinear\n    elif val > 0:\n        return 1  # Clockwise\n    else:\n        return 2  # Counterclockwise\n\ndef convex_hull(points):\n    n = len(points)\n    if n < 3:\n        raise ValueError(\"Convex hull not possible\")\n\n    hull = []\n    l = 0\n    for i in range(1, n):\n        if points[i][0] < points[l][0]:\n            l = i\n\n    p = l\n    while True:\n        hull.append(points[p])\n        q = (p + 1) % n\n\n        for i in range(n):\n            if orientation(points[p], points[i], points[q]) == 2:\n                q = i\n\n        p = q\n        if p == l:\n            break\n\n    return hull\n\nhull = convex_hull(points)\n\nif len(hull) == n:\n    print(\"No\")\nelse:\n    print(\"Yes\")"}
{"solution": "import math\n\na, b = map(int, input().split())\nprint(math.factorial(min(a, b)))"}
{"solution": "n = int(input())\nif n % 2 == 0:\n    print(n + 9, 9)\nelse:\n    print(n + 15, 15)"}
{"solution": "import sys\nimport heapq\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_int():\n    return int(read_input())\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef read_list():\n    return list(map(int, read_input().split()))\n\ndef solve():\n    n, m, p = read_ints()\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b, c = read_ints()\n        a -= 1\n        b -= 1\n        adj[a].append((b, c))\n\n    dist = [float('inf')] * n\n    dist[0] = 0\n    pq = [(0, 0)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, c in adj[u]:\n            if dist[v] > dist[u] + 1:\n                dist[v] = dist[u] + 1\n                heapq.heappush(pq, (dist[v], v))\n\n    if dist[-1] == float('inf'):\n        print(-1)\n        return\n\n    dp = [[-float('inf')] * (n + 1) for _ in range(n)]\n    dp[-1][dist[-1]] = 0\n    for u in range(n - 1, -1, -1):\n        for d in range(n + 1):\n            if dp[u][d] == -float('inf'):\n                continue\n            for v, c in adj[u]:\n                if d + 1 <= n:\n                    dp[v][d + 1] = max(dp[v][d + 1], dp[u][d] + c)\n\n    ans = -float('inf')\n    for d in range(1, n + 1):\n        coins = dp[-1][d]\n        if coins < p * d:\n            continue\n        ans = max(ans, coins - p * d)\n        if p * d <= dp[-1][d]:\n            ans = max(ans, dp[-1][d] - p * d)\n            break\n    print(ans)\n\nif __name__ == '__main__':\n    solve()"}
{"solution": "from collections import defaultdict\nfrom sys import stdin, stdout\n\ndef is_palindrome(s):\n    return s == s[::-1]\n\ndef can_form_palindrome(s1, s2):\n    return is_palindrome(s1 + s2)\n\ndef min_cost_to_palindrome(strings, costs):\n    n = len(strings)\n    dp = defaultdict(lambda: float('inf'))\n    dp[0] = 0\n\n    for mask in range(1, 1 << n):\n        for i in range(n):\n            if (mask >> i) & 1:\n                prev_mask = mask ^ (1 << i)\n                if prev_mask == 0 or can_form_palindrome(''.join([strings[j] for j in range(n) if (prev_mask >> j) & 1]), strings[i]):\n                    dp[mask] = min(dp[mask], dp[prev_mask] + costs[i])\n\n    min_cost = float('inf')\n    for mask in range(1, 1 << n):\n        palindrome = ''.join([strings[i] for i in range(n) if (mask >> i) & 1])\n        if is_palindrome(palindrome):\n            min_cost = min(min_cost, dp[mask])\n\n    return min_cost if min_cost!= float('inf') else -1\n\nn = int(stdin.readline())\nstrings = []\ncosts = []\nfor _ in range(n):\n    s, c = stdin.readline().split()\n    strings.append(s)\n    costs.append(int(c))\n\nstdout.write(str(min_cost_to_palindrome(strings, costs)) + '\\n')"}
{"solution": "def max_xor(n, k):\n    result = 0\n    for i in range(63, -1, -1):\n        if (result ^ (1 << i)) <= n:\n            n -= (result ^ (1 << i))\n            result ^= (1 << i)\n            k -= 1\n            if k == 0:\n                break\n    return result\n\nn, k = map(int, input().split())\nprint(max_xor(n, k))"}
{"solution": "import sys\n\nn = int(input())\nx = []\ny = []\nfor _ in range(n):\n    xi, yi = map(int, input().split())\n    x.append(xi)\n    y.append(yi)\n\nmax_x = max(x)\nmax_y = max(y)\nmin_side = min(max_x, max_y)\n\nl, r = 0, max(max_x, max_y)\nwhile l < r:\n    mid = (l + r) // 2\n    if all(min_side >= xi or min_side >= yi or xi + yi <= mid for xi, yi in zip(x, y)):\n        r = mid\n    else:\n        l = mid + 1\n\nprint(l)"}
{"solution": "def count_nineteens(s):\n    nineteen = \"nineteen\"\n    nineteen_count = {}\n    for char in nineteen:\n        nineteen_count[char] = nineteen_count.get(char, 0) + 1\n\n    s_count = {}\n    for char in s:\n        s_count[char] = s_count.get(char, 0) + 1\n\n    min_count = float('inf')\n    for char, count in nineteen_count.items():\n        if char not in s_count:\n            return 0\n        min_count = min(min_count, s_count[char] // count)\n\n    return min_count\n\ns = input()\nprint(count_nineteens(s))"}
{"solution": "def highest_branch(p, y):\n    def can_reach(x):\n        for i in range(2, p + 1):\n            if x % i == 0 and x // i <= y // i:\n                return True\n        return False\n\n    for i in range(y, 1, -1):\n        if not can_reach(i):\n            return i\n    return -1\n\np, y = map(int, input().split())\nprint(highest_branch(p, y))"}
{"solution": "n, m, k = map(int, input().split())\nhouses = list(map(int, input().split()))\n\nmin_distance = float('inf')\n\nfor i in range(n):\n    if houses[i]!= 0 and houses[i] <= k:\n        distance = abs(m - 1 - i) * 10\n        min_distance = min(min_distance, distance)\n\nprint(min_distance)"}
{"solution": "from collections import defaultdict\n\ndef solve():\n    n, m = map(int, input().split())\n    a = [list(map(int, input().split())) for _ in range(n)]\n    b = [list(map(int, input().split())) for _ in range(n)]\n\n    cnt_a = defaultdict(int)\n    cnt_b = defaultdict(int)\n\n    for i in range(n):\n        for j in range(m):\n            cnt_a[(a[i][j], i)] += 1\n            cnt_b[(b[i][j], i)] += 1\n            cnt_a[(a[i][j], j)] += 1\n            cnt_b[(b[i][j], j)] += 1\n\n    for key in cnt_a:\n        if cnt_a[key]!= cnt_b[key]:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n\nsolve()"}
{"solution": "def longest_uncommon_subsequence(a, b):\n    if a == b:\n        return -1\n    else:\n        return max(len(a), len(b))\n\na = input()\nb = input()\n\nprint(longest_uncommon_subsequence(a, b))"}
{"solution": "import math\n\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\ndef lcm(a, b):\n    return abs(a*b) // math.gcd(a, b)\n\nlcm_value = lcm(a, c)\nm = (d - b) % lcm_value\n\nif m!= 0:\n    print(-1)\nelse:\n    k = (d - b) // a\n    print(b + a * k)"}
{"solution": "n = int(input())\nif n % 3 == 0:\n    print(1, (n - 1) // 3 * 2, (n - 1) // 3)\nelse:\n    print((n - 2) // 3, (n - 2) // 3, n - (n - 2) // 3 * 2)"}
{"solution": "def solve(n, a, b, c, d):\n    if a + b + c + d!= 2 * (a + b):\n        return 0\n    if a + b > 2 * n:\n        return 0\n\n    x = a + b - d\n    if x < 1 or x > n:\n        return 0\n\n    if x == a:\n        return n - (a + b - n) + 1\n    else:\n        return n - (a + b - n)\n\nn, a, b, c, d = map(int, input().split())\nprint(solve(n, a, b, c, d))"}
{"solution": "w, h = map(int, input().split())\nu1, d1 = map(int, input().split())\nu2, d2 = map(int, input().split())\n\nstones = {d1: u1, d2: u2}\n\nfor i in range(h, 0, -1):\n    w += i\n    if i in stones:\n        w -= stones[i]\n        if w < 0:\n            w = 0\n\nprint(w)"}
{"solution": "m = int(input())\nc = list(map(int, input().split()))\nx, y = map(int, input().split())\n\ntotal_students = sum(c)\nfor k in range(1, m + 1):\n    beginner_group = sum(c[:k])\n    intermediate_group = total_students - beginner_group\n    if x <= beginner_group <= y and x <= intermediate_group <= y:\n        print(k)\n        break\nelse:\n    print(0)"}
{"solution": "import math\n\nn = int(input())\nk = int(input())\nA = int(input())\nB = int(input())\n\ndef min_coins(n, k, A, B):\n    coins = 0\n    while n > 1:\n        if n % k == 0:\n            coins += min(A * (n % k), B)\n            n = n // k\n        else:\n            coins += A\n            n -= 1\n    return coins\n\nprint(min_coins(n, k, A, B))"}
{"solution": "from collections import deque\n\ndef prime_factors(n):\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef min_operations(n):\n    factors = prime_factors(n)\n    unique_factors = set(factors)\n    min_value = 1\n    for factor in unique_factors:\n        if factors.count(factor) % 2 == 1:\n            min_value *= factor\n    queue = deque([(n, 0)])\n    visited = set([n])\n    while queue:\n        current, steps = queue.popleft()\n        if current == min_value:\n            return min_value, steps\n        sqrt = int(current ** 0.5)\n        if sqrt ** 2 == current and sqrt not in visited:\n            queue.append((sqrt, steps + 1))\n            visited.add(sqrt)\n        for factor in unique_factors:\n            if current % factor == 0 and current // factor not in visited:\n                queue.append((current // factor, steps + 1))\n                visited.add(current // factor)\n\nn = int(input())\nmin_value, min_steps = min_operations(n)\nprint(min_value, min_steps)"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef read_string():\n    return read_input()\n\ndef solve():\n    n, k = read_ints()\n    r, s, p = read_ints()\n    t = read_string()\n\n    scores = {'r': p,'s': r, 'p': s}\n    wins = {'r':'s','s': 'p', 'p': 'r'}\n    memo = {}\n\n    def dp(i, last):\n        if i >= n:\n            return 0\n        if (i, last) in memo:\n            return memo[(i, last)]\n\n        max_score = 0\n        for hand in 'rsp':\n            if hand == last and i >= k:\n                continue\n            if t[i] == hand:\n                max_score = max(max_score, dp(i + 1, hand))\n            else:\n                max_score = max(max_score, scores[hand] + dp(i + 1, hand))\n\n        memo[(i, last)] = max_score\n        return max_score\n\n    print(dp(0, ''))\n\nif __name__ == '__main__':\n    solve()"}
{"solution": "a, b, c = map(int, input().split())\nx = min(a, b)\ny = min(x, c)\na -= y\nb -= y\nc -= y\nprint(2 * c + 2 * min(a, b) + abs(a - b))"}
{"solution": "import sys\n\nn, k, p, x, y = map(int, input().split())\na = sorted(map(int, input().split()))\n\ntotal = sum(a)\nmedian_index = (n + 1) // 2\nmedian_count = median_index - k\n\nif total + (n - k) * p <= x:\n    if median_count > 0:\n        remaining = [y] * median_count + [1] * (n - k - median_count)\n    else:\n        remaining = [1] * (n - k)\nelif total + (n - k) * 1 <= x:\n    if median_count > 0:\n        remaining = [y] * median_count\n        remaining += [1] * (n - k - median_count)\n        remaining.sort(reverse=True)\n        for i in range(n - k):\n            if total + remaining[i] > x:\n                remaining[i] = x - total\n                break\n            total += remaining[i]\n    else:\n        remaining = [1] * (n - k)\n        remaining.sort(reverse=True)\n        for i in range(n - k):\n            if total + remaining[i] > x:\n                remaining[i] = x - total\n                break\n            total += remaining[i]\nelse:\n    print(-1)\n    sys.exit()\n\nfor i in range(k, n):\n    if a[i - k] > remaining[i - k]:\n        remaining.insert(i - k, a[i - k])\n    else:\n        remaining.insert(i - k, remaining[i - k])\n\nif sorted(remaining)[median_index - 1] < y:\n    print(-1)\n    sys.exit()\n\nprint(*remaining[k:])"}
{"solution": "def is_berlanese(word):\n    vowels = set('aeiou')\n    for i in range(len(word) - 1):\n        if word[i] not in vowels and word[i]!= 'n' and word[i + 1] not in vowels:\n            return False\n    if word[-1] not in vowels and word[-1]!= 'n':\n        return False\n    return True\n\nword = input()\nprint(\"YES\" if is_berlanese(word) else \"NO\")"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef solve():\n    n, m = read_ints()\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = read_ints()\n        u -= 1\n        v -= 1\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def check(deg):\n        if deg == 0:\n            return True\n        if deg == 1:\n            return False\n        if deg % 2 == 1:\n            return False\n        return True\n\n    def dfs(u, color, colors):\n        if colors[u]!= -1:\n            return colors[u] == color\n        colors[u] = color\n        for v in graph[u]:\n            if not dfs(v, 1 - color, colors):\n                return False\n        return True\n\n    def is_bipartite():\n        colors = [-1] * n\n        for u in range(n):\n            if colors[u]!= -1:\n                continue\n            if not dfs(u, 0, colors):\n                return False\n        return True\n\n    if not is_bipartite():\n        return 0\n\n    ans = 0\n    for u in range(n):\n        deg = len(graph[u])\n        if check(deg):\n            ans += deg // 2\n\n    return ans\n\nprint(solve())"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef main():\n    n, m = read_ints()\n    prices = list(read_ints())\n    auction_questions = set(read_ints())\n\n    prices = sorted(enumerate(prices), key=lambda x: x[1], reverse=True)\n\n    score = 0\n    current_score = 0\n    for i, (index, price) in enumerate(prices):\n        if index + 1 in auction_questions:\n            if current_score > price:\n                score += current_score\n                current_score = 0\n            else:\n                score += price\n                current_score += price\n        else:\n            if i % 2 == 0:\n                score += price\n            else:\n                current_score += price\n\n    print(score)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def calculate_score(max_points, time, wrong_submissions):\n    return max(0.3 * max_points, (1 - time / 250) * max_points - 50 * wrong_submissions)\n\ndef main():\n    times = list(map(int, input().split()))\n    wrong_submissions = list(map(int, input().split()))\n    successful_hacks, unsuccessful_hacks = map(int, input().split())\n\n    max_points = [500, 1000, 1500, 2000, 2500]\n    total_score = sum(calculate_score(max_points[i], times[i], wrong_submissions[i]) for i in range(5))\n\n    total_score += 100 * successful_hacks\n    total_score -= 50 * unsuccessful_hacks\n\n    print(int(total_score))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "MOD = 998244353\n\ndef qpow(a, b):\n    res = 1\n    while b:\n        if b & 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b >>= 1\n    return res\n\ndef main():\n    n, m, L, R = map(int, input().split())\n    if n & 1 and m & 1:\n        print(qpow(R - L + 1, 1))\n    elif (n & 1) or (m & 1):\n        sum_val = 0\n        for i in range(L, R + 1, 2):\n            sum_val = (sum_val + qpow(R - i + 1, 1)) % MOD\n        print(sum_val)\n    else:\n        sum_val = 0\n        for i in range(L, R + 1, 2):\n            sum_val = (sum_val + qpow(R - i + 1, 1) * 2) % MOD\n        print(sum_val)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def check(matrix):\n    n, m = len(matrix), len(matrix[0])\n    for i in range(n):\n        for j in range(m - 1):\n            if matrix[i][j] >= matrix[i][j + 1]:\n                return False\n    for j in range(m):\n        for i in range(n - 1):\n            if matrix[i][j] >= matrix[i + 1][j]:\n                return False\n    return True\n\ndef solve():\n    n, m = map(int, input().split())\n    a = [list(map(int, input().split())) for _ in range(n)]\n    b = [list(map(int, input().split())) for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] > b[i][j]:\n                a[i][j], b[i][j] = b[i][j], a[i][j]\n    if check(a) and check(b):\n        print(\"Possible\")\n    else:\n        print(\"Impossible\")\n\nsolve()"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\na.sort(reverse=True)\nans = 0\nfor i in range(n):\n    if a[i] > 0:\n        if i > 0 and a[i-1] == a[i]:\n            a[i] -= 1\n        ans += a[i]\n        a[i] = 0\n    else:\n        break\n\nprint(ans)"}
{"solution": "import heapq\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort()\nheap = []\nheapq.heappush(heap, -k)\n\ncnt = 0\nfor num in a:\n    while -heap[0] < num // 2:\n        if -heap[0] * 2 < num:\n            heapq.heappush(heap, -num // 2)\n            cnt += 1\n        else:\n            heapq.heappop(heap)\n    heapq.heappop(heap)\n\nprint(cnt)"}
{"solution": "n = int(input())\nmin_1, max_1 = map(int, input().split())\nmin_2, max_2 = map(int, input().split())\nmin_3, max_3 = map(int, input().split())\n\nfirst = min(max_1, n - min_2 - min_3)\nsecond = min(max_2, n - first - min_3)\nthird = n - first - second\n\nprint(first, second, third)"}
{"solution": "def get_next_moon_state(n, a):\n    moon_cycle = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n    if n < 30:\n        if a[-1] < 15 and a[-1] > 0:\n            if a[-1] < a[-2]:\n                return -1\n            else:\n                return \"UP\"\n        elif a[-1] == 15:\n            return \"DOWN\"\n        elif a[-1] == 0:\n            return \"UP\"\n    else:\n        if a[-1] < a[-31]:\n            return \"DOWN\"\n        elif a[-1] > a[-31]:\n            return \"UP\"\n        else:\n            return -1\n\nn = int(input())\na = list(map(int, input().split()))\nprint(get_next_moon_state(n, a))"}
{"solution": "def can_transform(s, t):\n    vowels = set('aeiou')\n    if len(s)!= len(t):\n        return False\n    for i in range(len(s)):\n        if (s[i] in vowels and t[i] not in vowels) or (s[i] not in vowels and t[i] in vowels):\n            return False\n    return True\n\ns = input()\nt = input()\nprint(\"Yes\" if can_transform(s, t) else \"No\")"}
{"solution": "def min_steps(board, color):\n    min_steps = float('inf')\n    for row in range(8):\n        for col in range(8):\n            if board[row][col] == color:\n                if color == 'W':\n                    min_steps = min(min_steps, row)\n                else:\n                    min_steps = min(min_steps, 8 - row - 1)\n    return min_steps\n\nboard = [input() for _ in range(8)]\nmin_steps_A = min_steps(board, 'W')\nmin_steps_B = min_steps(board, 'B')\n\nif min_steps_A <= min_steps_B:\n    print('A')\nelse:\n    print('B')"}
{"solution": "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    m = int(input())\n    b = list(map(int, input().split()))\n\n    sa = [0] * (n + 1)\n    sb = [0] * (m + 1)\n    for i in range(n):\n        sa[i + 1] = sa[i] + a[i]\n    for i in range(m):\n        sb[i + 1] = sb[i] + b[i]\n\n    if sa[n]!= sb[m]:\n        print(-1)\n        return\n\n    ans = 0\n    i = 0\n    j = 0\n    while i < n and j < m:\n        k = i\n        t = 0\n        while k < n and t < sb[j + 1]:\n            t += a[k]\n            k += 1\n        if t == sb[j + 1]:\n            ans += 1\n            i = k\n            j += 1\n        else:\n            i += 1\n\n    i = n - 1\n    j = m - 1\n    while i >= 0 and j >= 0:\n        k = i\n        t = 0\n        while k >= 0 and t < sb[j + 1]:\n            t += a[k]\n            k -= 1\n        if t == sb[j + 1]:\n            ans += 1\n            i = k\n            j -= 1\n        else:\n            i -= 1\n\n    print(ans)\n\nsolve()"}
{"solution": "def is_contest_problem(problem_name):\n    friends = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\n    for friend in friends:\n        if problem_name.count(friend) == 1:\n            return \"YES\"\n    return \"NO\"\n\nproblem_name = input()\nprint(is_contest_problem(problem_name))"}
{"solution": "import math\n\ndef sieve_of_eratosthenes(n):\n    primes = [True] * (n + 1)\n    primes[0] = primes[1] = False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if primes[i]:\n            for j in range(i * i, n + 1, i):\n                primes[j] = False\n    return primes\n\ndef min_length(a, b, k):\n    primes = sieve_of_eratosthenes(b)\n    prime_count = [0] * (b + 1)\n    for i in range(2, b + 1):\n        if primes[i]:\n            prime_count[i] = prime_count[i - 1] + 1\n        else:\n            prime_count[i] = prime_count[i - 1]\n    min_length = float('inf')\n    for i in range(a, b + 1):\n        left, right = i, b\n        while left <= right:\n            mid = (left + right) // 2\n            if prime_count[mid] - prime_count[i - 1] >= k:\n                min_length = min(min_length, mid - i + 1)\n                right = mid - 1\n            else:\n                left = mid + 1\n    return min_length if min_length!= float('inf') else -1\n\na, b, k = map(int, input().split())\nprint(min_length(a, b, k))"}
{"solution": "import math\n\ndef min_x(a, h, w):\n    min_val = float('inf')\n    for n in range(1, w // a + 1):\n        m = math.floor((w - n * a) / (n + 1))\n        if m < 0:\n            continue\n        x = (w - n * a - m) / (n + 1)\n        if x < 0:\n            continue\n        if h >= a * (math.floor((h - a) / (a + x)) + 1) + x:\n            min_val = min(min_val, x)\n    for m in range(1, h // a + 1):\n        n = math.floor((h - m * a) / (m + 1))\n        if n < 0:\n            continue\n        x = (h - m * a - n) / (m + 1)\n        if x < 0:\n            continue\n        if w >= a * (math.floor((w - a) / (a + x)) + 1) + x:\n            min_val = min(min_val, x)\n    if min_val == float('inf'):\n        return -1\n    return min_val\n\na, h, w = map(int, input().split())\nprint(min_x(a, h, w))"}
{"solution": "n = int(input())\nchapters = [list(map(int, input().split())) for _ in range(n)]\nk = int(input())\n\ncount = 0\nfor chapter in chapters:\n    if chapter[0] >= k or (chapter[0] < k and chapter[1] >= k):\n        count += 1\n\nprint(count)"}
{"solution": "def is_substring(s, word):\n    return s.startswith(word) or s.endswith(word) or word in s\n\ndef is_substring_with_one_part_removed(s, word):\n    for i in range(len(s)):\n        if is_substring(s[:i] + s[i+1:], word):\n            return True\n    return False\n\ndef is_substring_with_two_parts_removed(s, word):\n    for i in range(len(s)):\n        for j in range(i+1, len(s)):\n            if is_substring(s[:i] + s[i+1:j] + s[j+1:], word):\n                return True\n    return False\n\ndef solve(s):\n    word = \"CODEFORCES\"\n    if is_substring(s, word):\n        return \"YES\"\n    if is_substring_with_one_part_removed(s, word):\n        return \"YES\"\n    if is_substring_with_two_parts_removed(s, word):\n        return \"YES\"\n    return \"NO\"\n\ns = input()\nprint(solve(s))"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_int():\n    return int(read_input())\n\ndef read_ints():\n    return list(map(int, read_input().split()))\n\ndef solve():\n    n = read_int()\n    dp = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        dp[i][i] = 0\n        dp[i][i + 1] = 0\n    for length in range(2, n):\n        for i in range(1, n - length + 1):\n            j = i + length\n            for k in range(i + 1, j):\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + i * k * j)\n    print(dp[1][n] + sum(range(1, n + 1)))\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def count_digits(n):\n    count = 0\n    for i in range(1, n + 1):\n        count += len(str(i))\n    return count\n\nn = int(input())\nprint(count_digits(n))"}
{"solution": "def solve():\n    n, A = map(int, input().split())\n    c = list(map(int, input().split()))\n\n    cnt = {}\n    cnt[A] = 0\n    for i in range(n):\n        cnt[c[i]] = cnt.get(c[i], 0) + 1\n\n    max_cnt = 0\n    for i in range(1, 10**6 + 1):\n        if i not in cnt:\n            cnt[i] = 0\n\n    for i in range(n):\n        cnt[c[i]] -= 1\n        if c[i] == A and cnt[A] < max_cnt:\n            return -1\n        max_cnt = max(max_cnt, cnt[c[i]])\n\n    for i in range(1, 10**6 + 1):\n        if i!= A and cnt[i] >= max_cnt:\n            return i\n\n    return -1\n\nprint(solve())"}
{"solution": "n, x = map(int, input().split())\na = list(map(int, input().split()))\n\ntotal_sum = sum(a)\nif total_sum > x or (total_sum == x and n > 1):\n    print(\"NO\")\nelif total_sum < x and (x - total_sum - n + 1) > 1:\n    print(\"NO\")\nelse:\n    print(\"YES\")"}
{"solution": "import math\n\nn, S = map(int, input().split())\nprint(math.ceil(S / (n + 1)))"}
{"solution": "from collections import Counter\n\ns = input()\nn = len(s)\ncnt = Counter(s)\n\nodd = sum(val % 2 for val in cnt.values())\nif odd > 1:\n    for char, val in cnt.items():\n        if val % 2 == 1 and char!= 'a':\n            cnt[char] -= 1\n            cnt['a'] += 1\n            break\n\nfirst_half = ''.join(char * (val // 2) for char, val in sorted(cnt.items()))\nsecond_half = first_half[::-1]\n\nif n % 2 == 1:\n    for char, val in sorted(cnt.items()):\n        if val % 2 == 1:\n            mid = char\n            break\n    print(first_half + mid + second_half)\nelse:\n    print(first_half + second_half)"}
{"solution": "def calculate_position_weight(board):\n    weights = {\n        'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'P': 1,\n        'q': -9, 'r': -5, 'b': -3, 'n': -3, 'p': -1\n    }\n    return sum(weights.get(piece, 0) for row in board for piece in row)\n\ndef main():\n    board = [input() for _ in range(8)]\n    weight = calculate_position_weight(board)\n    if weight > 0:\n        print(\"White\")\n    elif weight < 0:\n        print(\"Black\")\n    else:\n        print(\"Draw\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from collections import deque\n\ndef solve():\n    n, m = map(int, input().split())\n    s = input()\n\n    dist = [float('inf')] * (n + 1)\n    prev = [-1] * (n + 1)\n    dist[0] = 0\n\n    q = deque([0])\n    while q:\n        u = q.popleft()\n        for i in range(1, m + 1):\n            v = u + i\n            if v > n or s[v] == '1':\n                continue\n            if dist[v] > dist[u] + 1:\n                dist[v] = dist[u] + 1\n                prev[v] = i\n                q.append(v)\n\n    if dist[n] == float('inf'):\n        print(-1)\n        return\n\n    path = []\n    u = n\n    while u!= 0:\n        path.append(prev[u])\n        u -= prev[u]\n\n    print(*path[::-1])\n\nsolve()"}
{"solution": "import sys\n\ndef solve():\n    k = int(input())\n    x, y = map(int, input().split())\n\n    if abs(x) % k == 0 and abs(y) % k == 0:\n        if abs(x) // k + abs(y) // k == 1:\n            print(1)\n            print(x, y)\n        else:\n            print(-1)\n    elif (abs(x) + abs(y)) % k == 0:\n        ans = []\n        if x > 0:\n            ans.append((k, 0))\n            x -= k\n        else:\n            ans.append((-k, 0))\n            x += k\n        if y > 0:\n            ans.append((x, y))\n        else:\n            ans.append((x, y))\n        while abs(x) + abs(y) > k:\n            if x > 0:\n                ans.append((x - k, y))\n                x -= k\n            else:\n                ans.append((x + k, y))\n                x += k\n            if y > 0:\n                ans.append((x, y - k))\n                y -= k\n            else:\n                ans.append((x, y + k))\n                y += k\n        print(len(ans))\n        for i in ans:\n            print(*i)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "import math\n\ndef find_n(m):\n    n = 1\n    while True:\n        count = 0\n        for k in range(2, int(math.sqrt(n)) + 2):\n            a = 1\n            for _ in range(3):\n                a *= k\n                if a > n:\n                    break\n            else:\n                count += 1\n        if count == m:\n            return n\n        if n > m * 100:\n            return -1\n        n += 1\n\nm = int(input())\nprint(find_n(m))"}
{"solution": "import math\n\ndef circle_intersection_area(x1, y1, r1, x2, y2, r2):\n    d = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n    if d >= r1 + r2:\n        return 0\n    if d <= abs(r1 - r2):\n        return math.pi * min(r1, r2) ** 2\n    a = (r1 ** 2 - r2 ** 2 + d ** 2) / (2 * d)\n    h = math.sqrt(r1 ** 2 - a ** 2)\n    return r1 ** 2 * math.acos(a / r1) - a * h + r2 ** 2 * math.acos((d - a) / r2) - (d - a) * h\n\nx1, y1, r1 = map(int, input().split())\nx2, y2, r2 = map(int, input().split())\n\nprint(circle_intersection_area(x1, y1, r1, x2, y2, r2))"}
{"solution": "import math\n\ndef solve():\n    n = int(input())\n    if n == 1:\n        print(1)\n    elif n % 2 == 1:\n        print(1)\n    else:\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i!= 0:\n                print(1)\n                return\n        print(2)\n\nsolve()"}
{"solution": "from collections import defaultdict\n\ndef dfs(node, graph, a, dp):\n    if dp[node]!= -1:\n        return dp[node]\n    if not graph[node]:\n        dp[node] = a[node]\n        return dp[node]\n    min_val = float('inf')\n    for child in graph[node]:\n        min_val = min(min_val, dfs(child, graph, a, dp))\n    dp[node] = a[node] + min_val\n    return dp[node]\n\ndef solve():\n    n = int(input())\n    p = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    graph = defaultdict(list)\n    for i in range(n-1):\n        graph[p[i]].append(i+2)\n    dp = [-1]*(n+1)\n    ans = float('inf')\n    for child in graph[1]:\n        ans = min(ans, dfs(child, graph, a, dp))\n    print(ans + a[0])\n\nsolve()"}
{"solution": "def count_common_words(n, s, t):\n    def get_prefix(s, t):\n        prefix = 0\n        while prefix < n and s[prefix] == t[prefix]:\n            prefix += 1\n        return prefix\n\n    def get_suffix(s, t):\n        suffix = 0\n        while suffix < n and s[n - suffix - 1] == t[n - suffix - 1]:\n            suffix += 1\n        return suffix\n\n    prefix = get_prefix(s, t)\n    suffix = get_suffix(s, t)\n    if prefix + suffix >= n - 1:\n        return 2 if s[prefix] == t[prefix + 1] and s[prefix + 1] == t[prefix] else 1\n    else:\n        return 0\n\nn = int(input())\ns = input()\nt = input()\nprint(count_common_words(n, s, t))"}
{"solution": "import sys\ninput = sys.stdin.readline\n\ndef dfs(u, p):\n    for v in graph[u]:\n        if v!= p:\n            dfs(v, u)\n            dp[u] = max(dp[u], dp[v] + 1)\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    graph = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        u -= 1\n        v -= 1\n        graph[u].append(v)\n        graph[v].append(u)\n\n    dp = [1] * n\n    dfs(0, -1)\n\n    ans = float('-inf')\n    for i in range(n):\n        ans = max(ans, a[i] + dp[i] - 1)\n\n    print(ans)\n\nsolve()"}
{"solution": "n, m = map(int, input().split())\nprint(min(m, n - m + (m > 0)))"}
{"solution": "import math\n\nk, r = map(int, input().split())\n\ndef min_shovels(k, r):\n    for i in range(1, 11):\n        total = k * i\n        if (total - r) % 10 == 0:\n            return i\n    return 10\n\nprint(min_shovels(k, r))"}
{"solution": "def is_valid(x, y, n, m):\n    return 0 <= x < n and 0 <= y < m\n\ndef dfs(grid, x, y, n, m, visited):\n    if not is_valid(x, y, n, m) or grid[x][y] == '.' or visited[x][y]:\n        return\n    visited[x][y] = True\n    dfs(grid, x - 1, y, n, m, visited)\n    dfs(grid, x + 1, y, n, m, visited)\n    dfs(grid, x, y - 1, n, m, visited)\n    dfs(grid, x, y + 1, n, m, visited)\n\ndef check_rectangle(grid, n, m):\n    top = float('inf')\n    bottom = float('-inf')\n    left = float('inf')\n    right = float('-inf')\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'X':\n                top = min(top, i)\n                bottom = max(bottom, i)\n                left = min(left, j)\n                right = max(right, j)\n    for i in range(top, bottom + 1):\n        for j in range(left, right + 1):\n            if grid[i][j] == '.':\n                return False\n    return True\n\ndef solve():\n    n, m = map(int, input().split())\n    grid = [list(input()) for _ in range(n)]\n    visited = [[False] * m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'X' and not visited[i][j]:\n                dfs(grid, i, j, n, m, visited)\n    if not check_rectangle(grid, n, m):\n        print(\"NO\")\n        return\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'X':\n                grid[i][j] = '.'\n                if not check_rectangle(grid, n, m):\n                    print(\"NO\")\n                    return\n                grid[i][j] = 'X'\n    print(\"YES\")\n\nsolve()"}
{"solution": "def min_segments():\n    points = [tuple(map(int, input().split())) for _ in range(3)]\n    x_coords = [point[0] for point in points]\n    y_coords = [point[1] for point in points]\n\n    x_unique = len(set(x_coords))\n    y_unique = len(set(y_coords))\n\n    if x_unique == 1 or y_unique == 1:\n        return 1\n    elif x_unique == 2 and y_unique == 2:\n        return 2\n    else:\n        return 3\n\nprint(min_segments())"}
{"solution": "import sys\n\ndef main():\n    k = int(input())\n\n    if k == 1:\n        print(\"YES\")\n        print(\"2 1\")\n        print(\"1 2\")\n        return\n\n    if k == 2:\n        print(\"NO\")\n        return\n\n    n = k + 2\n    m = n * k // 2\n\n    print(\"YES\")\n    print(n, m)\n\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            if (j - i) % 2 == 1:\n                print(i, j)\n\n    print(1, 2)\n    print(1, n)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef prefix_function(s):\n    n = len(s)\n    p = [0] * n\n    for i in range(1, n):\n        j = p[i - 1]\n        while j > 0 and s[i]!= s[j]:\n            j = p[j - 1]\n        if s[i] == s[j]:\n            j += 1\n        p[i] = j\n    return p\n\ndef kmp(s, t):\n    p = prefix_function(t)\n    n, m = len(s), len(t)\n    j = 0\n    count = 0\n    for i in range(n):\n        while j > 0 and s[i]!= t[j]:\n            j = p[j - 1]\n        if s[i] == t[j]:\n            j += 1\n        if j == m:\n            count += 1\n            j = p[j - 1]\n    return count\n\ndef solve():\n    n, m, q = map(int, sys.stdin.readline().split())\n    s = sys.stdin.readline().strip()\n    t = sys.stdin.readline().strip()\n    p = prefix_function(t)\n    dp = [0] * (n + 1)\n    j = 0\n    for i in range(n):\n        while j > 0 and s[i]!= t[j]:\n            j = p[j - 1]\n        if s[i] == t[j]:\n            j += 1\n        if j == m:\n            dp[i + 1] = dp[i] + 1\n            j = p[j - 1]\n        else:\n            dp[i + 1] = dp[i]\n    for _ in range(q):\n        l, r = map(int, sys.stdin.readline().split())\n        print(dp[r] - dp[l - 1])\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "MOD = 10**9 + 7\n\ndef solve():\n    n, k, d = map(int, input().split())\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            for x in range(1, min(i // j + 1, k + 1)):\n                dp[i][j] = (dp[i][j] + dp[i - j * x][x]) % MOD\n    ans = sum(dp[n][i] for i in range(d, k + 1)) % MOD\n    print(ans)\n\nsolve()"}
{"solution": "n = int(input())\nrow = input()\n\ngroups = []\ncurrent_group = 0\n\nfor square in row:\n    if square == 'B':\n        current_group += 1\n    elif current_group > 0:\n        groups.append(current_group)\n        current_group = 0\n\nif current_group > 0:\n    groups.append(current_group)\n\nprint(len(groups))\nprint(*groups)"}
{"solution": "import sys\n\ndef main():\n    n, m, p = map(int, sys.stdin.readline().split())\n    s = sys.stdin.readline().strip()\n    q = sys.stdin.readline().strip()\n\n    st = []\n    for i in range(n):\n        if s[i] == '(':\n            st.append(i)\n        else:\n            st.append(st.pop())\n\n    pos = p - 1\n    for op in q:\n        if op == 'L':\n            pos -= 1\n        elif op == 'R':\n            pos += 1\n        else:\n            to = st[pos]\n            if pos < to:\n                for i in range(pos, to + 1):\n                    if s[i] == '(':\n                        st.remove(st[st.index(i)])\n                s = s[:pos] + s[to + 1:]\n                n -= to - pos + 1\n                pos = max(0, pos - 1)\n            else:\n                for i in range(to, pos + 1):\n                    if s[i] == '(':\n                        st.remove(st[st.index(i)])\n                s = s[:to] + s[pos + 1:]\n                n -= pos - to + 1\n                pos = to\n\n    print(s)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\nn = int(input())\nlower_bound = -2 * (10 ** 9)\nupper_bound = 2 * (10 ** 9)\n\nfor _ in range(n):\n    sign, x, answer = input().split()\n    x = int(x)\n\n    if sign == \">\":\n        if answer == \"Y\":\n            lower_bound = max(lower_bound, x + 1)\n        else:\n            upper_bound = min(upper_bound, x)\n    elif sign == \"<\":\n        if answer == \"Y\":\n            upper_bound = min(upper_bound, x - 1)\n        else:\n            lower_bound = max(lower_bound, x)\n    elif sign == \">=\":\n        if answer == \"Y\":\n            lower_bound = max(lower_bound, x)\n        else:\n            upper_bound = min(upper_bound, x - 1)\n    elif sign == \"<=\":\n        if answer == \"Y\":\n            upper_bound = min(upper_bound, x)\n        else:\n            lower_bound = max(lower_bound, x + 1)\n\nif lower_bound <= upper_bound:\n    print(lower_bound)\nelse:\n    print(\"Impossible\")"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef count_periods(a, b):\n    total = a + b\n    count = 0\n    for i in range(1, total + 1):\n        if total % i == 0:\n            if a % (total // i) == 0 and b % (total // i) == 0:\n                count += 1\n            elif gcd(a, total // i) == gcd(b, total // i) == gcd(a + b, total // i):\n                count += 1\n    return count\n\na, b = map(int, input().split())\nprint(count_periods(a, b))"}
{"solution": "import string\n\ndef generate_name():\n    for i in range(26):\n        for j in range(26):\n            yield f\"{string.ascii_uppercase[i]}{string.ascii_lowercase[j]}\"\n\ndef solve():\n    n, k = map(int, input().split())\n    notes = input().split()\n    names = []\n    gen = generate_name()\n    for i in range(k - 1):\n        names.append(next(gen))\n    for note in notes:\n        if note == \"YES\":\n            names.append(next(gen))\n        else:\n            names.append(names[-k + 1])\n    print(\" \".join(names))\n\nsolve()"}
{"solution": "from math import gcd\nfrom functools import reduce\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef min_operations(a, b):\n    if a == b:\n        return 0\n    if a < b:\n        a, b = b, a\n\n    ops = 0\n    while a!= b:\n        if a % 2 == 0:\n            a //= 2\n            ops += 1\n        elif a % 3 == 0:\n            a *= 2\n            a //= 3\n            ops += 1\n        elif a % 5 == 0:\n            a *= 4\n            a //= 5\n            ops += 1\n        else:\n            return -1\n\n        if a < b:\n            a, b = b, a\n\n    return ops\n\na, b = map(int, input().split())\nprint(min_operations(a, b))"}
{"solution": "n, a, b = map(int, input().split())\nc = list(map(int, input().split()))\n\ncost = 0\nfor i in range(n // 2):\n    if c[i]!= c[n - i - 1]:\n        if c[i] == 2:\n            c[i] = c[n - i - 1]\n        elif c[n - i - 1] == 2:\n            c[n - i - 1] = c[i]\n        elif c[i]!= c[n - i - 1]:\n            print(-1)\n            exit()\n\nfor i in range(n // 2):\n    if c[i] == 2:\n        if c[n - i - 1] == 0:\n            cost += a\n        elif c[n - i - 1] == 1:\n            cost += b\n    elif c[i] == 0 and c[n - i - 1] == 2:\n        cost += a\n    elif c[i] == 1 and c[n - i - 1] == 2:\n        cost += b\n\nif n % 2 == 1 and c[n // 2] == 2:\n    if sum(c[:n // 2]) >= n // 2:\n        cost += b\n    else:\n        cost += a\n\nprint(cost)"}
{"solution": "import sys\n\nk = int(input())\n\nif k == 1:\n    print(-1)\n    sys.exit()\n\nfor i in range(k):\n    for j in range(k):\n        for z in range(k):\n            if (i + j + z) % 2 == 0:\n                print('b', end='')\n            else:\n                print('w', end='')\n        print()\n    print()"}
{"solution": "import math\n\ndef largest_lovely_number(n):\n    i = 2\n    while i * i <= n:\n        if n % (i * i) == 0:\n            while n % (i * i) == 0:\n                n //= i * i\n        i += 1\n    return n\n\nn = int(input())\nprint(largest_lovely_number(n))"}
{"solution": "n = int(input())\nseating = input()\n\ndef is_maximal(seating):\n    seating = '0' + seating + '0'\n    for i in range(1, len(seating) - 1):\n        if seating[i] == '1':\n            if seating[i-1] == '1' or seating[i+1] == '1':\n                return False\n            if seating[i-2] == '0' and seating[i+2] == '0':\n                return False\n    return True\n\nprint(\"Yes\" if is_maximal(seating) else \"No\")"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nn = int(input())\na = list(map(int, input().split()))\n\ndiffs = [a[i] - a[i - 1] for i in range(1, n)]\n\npossible_k = set(range(1, n + 1))\n\nfor k in range(1, n):\n    if n % k!= 0:\n        continue\n    for i in range(k, n):\n        if diffs[i]!= diffs[i - k]:\n            possible_k.discard(k)\n            break\n\nfor k in range(1, n):\n    if n % k == 0 and k in possible_k:\n        for j in range(k, n, k):\n            if diffs[j]!= diffs[j - 1]:\n                possible_k.discard(n // k)\n                break\n\nprint(len(possible_k))\nprint(*sorted(possible_k))"}
{"solution": "import itertools\n\ndef can_form_equal_teams(scores):\n    total_sum = sum(scores)\n    if total_sum % 2!= 0:\n        return False\n\n    target_sum = total_sum // 2\n    for combination in itertools.combinations(scores, 3):\n        if sum(combination) == target_sum:\n            return True\n\n    return False\n\nscores = list(map(int, input().split()))\nprint(\"YES\" if can_form_equal_teams(scores) else \"NO\")"}
{"solution": "def count_2_3_integers():\n    l, r = map(int, input().split())\n    count = 0\n    for x in range(31):\n        for y in range(20):\n            num = 2**x * 3**y\n            if l <= num <= r:\n                count += 1\n    print(count)\n\ncount_2_3_integers()"}
{"solution": "import math\n\nn, k = map(int, input().split())\n\ndef solve(n, k):\n    if n == 1:\n        return 0\n    if k == 0:\n        return n - 1\n\n    x = (1 + math.sqrt(1 + 8 * (n - k))) / 2\n    x = math.floor(x)\n\n    total = x * (x + 1) // 2\n    return n - x - (total - k)\n\nprint(solve(n, k))"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\nfor i in range(n - 2):\n    if a[i] + a[i + 1] > a[i + 2]:\n        print(\"YES\")\n        sys.exit()\n\nprint(\"NO\")"}
{"solution": "x, y = map(int, input().split())\n\nif y == 1 and x > 0:\n    print(\"No\")\nelif y - 1 > x:\n    print(\"No\")\nelse:\n    print(\"Yes\" if (x - (y - 1)) % 2 == 0 else \"No\")"}
{"solution": "import sys\n\nn, k = map(int, sys.stdin.readline().split())\na = list(map(int, sys.stdin.readline().split()))\n\nskills = {}\nfor i in range(n):\n    skill = a[i] // 10\n    skills[skill] = skills.get(skill, 0) + 1\n\ntotal_rating = sum(skill * count for skill, count in skills.items())\nremaining_skills = {skill: count for skill, count in skills.items() if skill < 10}\n\nwhile k > 0 and remaining_skills:\n    next_skill = max(remaining_skills.keys())\n    if next_skill * 10 + skills[next_skill] > k + next_skill * 10:\n        points_to_next_skill = 10 - (next_skill * 10) % 10\n        if k >= points_to_next_skill * skills[next_skills]:\n            total_rating += skills[next_skill]\n            k -= points_to_next_skill * skills[next_skill]\n            del remaining_skills[next_skill]\n        else:\n            total_rating += k // points_to_next_skill\n            k = 0\n    else:\n        points_to_next_skill = 10 - (next_skill * 10) % 10\n        total_rating += 1\n        k -= points_to_next_skill\n        remaining_skills[next_skill] -= 1\n        if remaining_skills[next_skill] == 0:\n            del remaining_skills[next_skill]\n\nprint(total_rating)"}
{"solution": "n, m = map(int, input().split())\na = sorted(map(int, input().split()))\nb = sorted(map(int, input().split()))\n\ncommon = set(a) & set(b)\nif common:\n    print(min(common))\nelse:\n    min_a = min(a)\n    min_b = min(b)\n    print(min_a * 10 + min_b if min_a < min_b else min_b * 10 + min_a)"}
{"solution": "n, k = map(int, input().split())\ntotal_time = 240 - k\nproblems_solved = 0\ntime_spent = 0\n\nfor i in range(1, n + 1):\n    time_required = 5 * i\n    if time_spent + time_required <= total_time:\n        time_spent += time_required\n        problems_solved += 1\n    else:\n        break\n\nprint(problems_solved)"}
{"solution": "import sys\n\nn, x, y = map(int, sys.stdin.readline().split())\na = list(map(int, sys.stdin.readline().split()))\n\na.sort()\n\ndef check(k):\n    need = sum((a[i] + 1) // 2 for i in range(k))\n    return need <= x + y\n\nl, r = 0, n\nwhile l < r:\n    mid = (l + r + 1) // 2\n    if check(mid):\n        l = mid\n    else:\n        r = mid - 1\n\nprint(l)"}
{"solution": "import math\n\ndef count_divisors(n):\n    divisors = set()\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return divisors\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef main():\n    b = int(input())\n    divisors = count_divisors(b)\n    result = 0\n    for d in divisors:\n        result += 1\n        for p in range(2, int(math.sqrt(b)) + 1):\n            if d % p == 0 and b % p!= 0:\n                result += 1\n                break\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n = int(input())\ns = input()\n\ndef simulate(start):\n    while 0 <= start < n:\n        if s[start] == '<':\n            start -= 1\n        else:\n            start += 1\n        if start < 0 or start >= n:\n            return True\n    return False\n\ndef solve():\n    count = 0\n    for i in range(n):\n        if simulate(i):\n            count += 1\n    return count\n\nprint(solve())"}
{"solution": "from collections import defaultdict\n\nn = int(input())\nsticks = list(map(int, input().split()))\n\nfreq = defaultdict(int)\nfor stick in sticks:\n    freq[stick] += 1\n\ndp = [0] * (10**6 + 2)\nfor stick in sorted(freq.keys(), reverse=True):\n    dp[stick] = max(dp[stick], freq[stick] // 2 * stick * stick)\n    dp[stick - 1] = max(dp[stick - 1], dp[stick] + (freq[stick] % 2) * stick * (stick - 1))\n    dp[stick - 2] = max(dp[stick - 2], dp[stick] + (freq[stick] % 2) * (stick - 1) * (stick - 2))\n\nprint(dp[0])"}
{"solution": "from collections import defaultdict\n\nn = int(input())\ns = [input() for _ in range(n)]\n\ncnt = defaultdict(int)\nfor si in s:\n    for c in si:\n        cnt[c] += 1\n\norder = sorted(cnt, key=cnt.get, reverse=True)\nd = {order[i]: str(i) for i in range(len(order))}\n\nans = 0\nfor si in s:\n    num = ''.join(d[c] for c in si)\n    ans += int(num)\n\nprint(ans)"}
{"solution": "n, m = map(int, input().split())\n\na = min(n, m // 2)\nm -= a * 2\nn -= a\n\nb = min(m, n // 2)\n\nprint(a + b)"}
{"solution": "def solve(s):\n    ab = s.find(\"AB\")\n    ba = s.find(\"BA\")\n    if ab!= -1 and ba!= -1:\n        if ab > ba:\n            return \"YES\" if ab + 1 > ba + 1 else \"NO\"\n        else:\n            return \"YES\" if ab + 1 < ba else \"NO\"\n    return \"NO\"\n\ns = input()\nprint(solve(s))"}
{"solution": "import sys\n\ndef solve(n, a, k, b):\n    if sum(a)!= sum(b):\n        print(\"NO\")\n        return\n\n    result = []\n    i = 0\n    j = 0\n    while i < n and j < k:\n        if a[i] == b[j]:\n            i += 1\n            j += 1\n        elif a[i] < b[j]:\n            if i + 1 < n:\n                a[i] += a[i + 1]\n                result.append((i + 1, 'L'))\n                a.pop(i + 1)\n                n -= 1\n            else:\n                print(\"NO\")\n                return\n        else:\n            print(\"NO\")\n            return\n\n    while i < n:\n        if i + 1 < n:\n            a[i] += a[i + 1]\n            result.append((i + 1, 'L'))\n            a.pop(i + 1)\n            n -= 1\n        else:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n    for x, direction in result:\n        print(x, direction)\n\nn = int(input())\na = list(map(int, input().split()))\nk = int(input())\nb = list(map(int, input().split()))\n\nsolve(n, a, k, b)"}
{"solution": "def orientation(p, q, r):\n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0  # Collinear\n    elif val > 0:\n        return 1  # Clockwise\n    else:\n        return 2  # Counterclockwise\n\ndef intersect(p1, q1, p2, q2):\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    if (o1!= o2 and o3!= o4):\n        return True\n\n    if (o1 == 0 and on_segment(p1, p2, q1)):\n        return True\n\n    if (o2 == 0 and on_segment(p1, q2, q1)):\n        return True\n\n    if (o3 == 0 and on_segment(p2, p1, q2)):\n        return True\n\n    if (o4 == 0 and on_segment(p2, q1, q2)):\n        return True\n\n    return False\n\ndef on_segment(p, q, r):\n    if (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and\n        q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1])):\n        return True\n    return False\n\ndef is_valid(edges, n):\n    for i in range(n):\n        for j in range(i + 1, n):\n            if intersect(edges[i][0], edges[i][1], edges[j][0], edges[j][1]):\n                return False\n    return True\n\nR, B = map(int, input().split())\nspaceships = []\nbases = []\n\nfor _ in range(R):\n    x, y = map(int, input().split())\n    spaceships.append((x, y))\n\nfor _ in range(B):\n    x, y = map(int, input().split())\n    bases.append((x, y))\n\nif R!= B:\n    print(\"No\")\nelse:\n    edges = list(zip(spaceships, bases))\n    if is_valid(edges, R):\n        print(\"Yes\")\n    else:\n        print(\"No\")"}
{"solution": "import math\n\nn = int(input())\na = list(map(int, input().split()))\n\ndef max_power_of_two(x):\n    return 2 ** math.floor(math.log2(x))\n\nmax_power = max(map(max_power_of_two, a))\ncount = sum(1 for x in a if x % max_power == 0)\n\nprint(max_power, count)"}
{"solution": "n, m = map(int, input().split())\ncount = 0\n\nwhile m > n:\n    if m % 2 == 0:\n        m //= 2\n    else:\n        m += 1\n    count += 1\n\nprint(count + n - m)"}
{"solution": "import sys\n\nclass DSU:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, x):\n        if self.parent[x]!= x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x!= root_y:\n            if self.rank[root_x] > self.rank[root_y]:\n                self.parent[root_y] = root_x\n            elif self.rank[root_x] < self.rank[root_y]:\n                self.parent[root_x] = root_y\n            else:\n                self.parent[root_y] = root_x\n                self.rank[root_x] += 1\n\ndef solve():\n    n = int(sys.stdin.readline())\n    segments = []\n    for _ in range(n):\n        l, r = map(int, sys.stdin.readline().split())\n        segments.append((l, r))\n\n    dsu = DSU(n)\n    events = []\n    for i, (l, r) in enumerate(segments):\n        events.append((l, 0, i))\n        events.append((r, 1, i))\n\n    events.sort()\n\n    active = set()\n    for _, type, i in events:\n        if type == 0:\n            for j in active:\n                if not (segments[j][1] <= segments[i][0] or segments[i][1] <= segments[j][0]):\n                    dsu.union(i, j)\n            active.add(i)\n        else:\n            active.remove(i)\n\n    if len(set(dsu.find(i) for i in range(n))) == 1 and len(active) == 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "import sys\n\nn = int(input())\nr = list(map(int, input().split()))\n\nmax_len = 0\nfor i in range(n):\n    total = 0\n    for j in range(i, n):\n        total += r[j]\n        if total > 100 * (j - i + 1):\n            max_len = max(max_len, j - i + 1)\n\nprint(max_len)"}
{"solution": "def check_dissatisfaction(n, k, episodes):\n    max_dissatisfaction = 0\n    current_dissatisfaction = 0\n\n    for episode in episodes:\n        if episode == 'N':\n            current_dissatisfaction += 1\n            max_dissatisfaction = max(max_dissatisfaction, current_dissatisfaction)\n        else:\n            current_dissatisfaction = 0\n\n    if max_dissatisfaction > k:\n        return \"NO\"\n\n    if max_dissatisfaction < k:\n        for i in range(n - k + 1):\n            if episodes[i] == 'Y':\n                continue\n            if episodes[i:i+k].count('N') == 0:\n                return \"YES\"\n\n    return \"NO\" if max_dissatisfaction < k else \"YES\"\n\n\nn, k = map(int, input().split())\nepisodes = input()\n\nprint(check_dissatisfaction(n, k, episodes))"}
{"solution": "import sys\n\ndef main():\n    n, x, d = map(int, sys.stdin.readline().split())\n    if d == 0:\n        print(1 if n % 2 == 0 else 2)\n        return\n    print(2 * (n - 1) * abs(d) + 1 + abs((n - 1) * d))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def get_color(rating):\n    if rating >= 2400:\n        return \"red\"\n    elif rating >= 2200:\n        return \"orange\"\n    elif rating >= 2000:\n        return \"blue\"\n    elif rating >= 1800:\n        return \"violet\"\n    elif rating >= 1500:\n        return \"indigo\"\n    else:\n        return \"gray\"\n\nn = int(input())\nres = \"NO\"\n\nfor _ in range(n):\n    name, before, after = input().split()\n    before, after = int(before), int(after)\n    if get_color(before) == \"red\" and after > before:\n        res = \"YES\"\n        break\n\nprint(res)"}
{"solution": "import math\n\ns = input()\nn = len(s)\nans = 0\nfor i in range(n):\n    if s[i] == '1':\n        ans = i\n        break\nprint(math.floor(math.log2(2**(n-ans-1)))//2 + 1)"}
{"solution": "def min_rows(matrix):\n    n = len(matrix)\n    m = len(matrix[0])\n    rows = n\n\n    for i in range(n // 2):\n        if matrix[i] == matrix[n - i - 1]:\n            rows -= 1\n        else:\n            break\n\n    return rows\n\n\nn, m = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\nprint(min_rows(matrix))"}
{"solution": "import sys\n\ndef solve():\n    n = int(sys.stdin.readline())\n    orders = []\n    for _ in range(n):\n        l, r = map(int, sys.stdin.readline().split())\n        orders.append((l, r))\n\n    orders.sort(key=lambda x: x[1])\n    end_time = -1\n    count = 0\n    for l, r in orders:\n        if l > end_time:\n            count += 1\n            end_time = r\n    print(count)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def solve():\n    n, k = map(int, input().split())\n    x = list(map(int, input().split()))\n    y = list(map(int, input().split()))\n\n    x_prev, y_prev = 0, 0\n    for i in range(n):\n        x_prev, y_prev = x[i] + x_prev, y[i] + y_prev\n        if x_prev > k * (i + 1) or y_prev > k * (i + 1):\n            print(\"NO\")\n            return\n        if x[i] > k or y[i] > k:\n            print(\"NO\")\n            return\n        if x_prev + k < x[i + 1] if i < n - 1 else False:\n            print(\"NO\")\n            return\n        if y_prev + k < y[i + 1] if i < n - 1 else False:\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n\nsolve()"}
{"solution": "def main():\n    n, k = map(int, input().split())\n    coefficients = [input().strip() for _ in range(n + 1)]\n\n    p_k = sum(int(coeff) * (k ** i) for i, coeff in enumerate(coefficients) if coeff!= '?')\n\n    if p_k % (n + 1)!= 0:\n        print(\"Yes\")\n        return\n\n    count = sum(coeff == '?' for coeff in coefficients)\n    if count % 2 == 1:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef smallest_multiple(p, x):\n    return (x + p - 1) // p * p\n\ndef smallest_start(x2):\n    min_x0 = x2\n    for p in range(2, x2):\n        if is_prime(p):\n            x1 = smallest_multiple(p, x2)\n            if x1 < x2:\n                for q in range(2, x1):\n                    if is_prime(q):\n                        x0 = smallest_multiple(q, x1)\n                        if x0 < x1:\n                            min_x0 = min(min_x0, x0)\n    return min_x0\n\nx2 = int(input())\nprint(smallest_start(x2))"}
{"solution": "def solve(n, p):\n    for i in range(1, n + 1):\n        if bin(n - i * p).count('1') <= i:\n            return i\n    return -1\n\nn, p = map(int, input().split())\nprint(solve(n, p))"}
{"solution": "n, k = map(int, input().split())\ns = input()\n\nif k == 0:\n    print(s)\nelse:\n    s = list(s)\n    if s[0]!= '1':\n        s[0] = '1'\n        k -= 1\n    for i in range(1, n):\n        if k > 0 and s[i]!= '0':\n            s[i] = '0'\n            k -= 1\n    print(''.join(s))"}
{"solution": "def min_presents(cnt_1, cnt_2, x, y):\n    def count_not_divisible_by_x_or_y(n):\n        return n - n // x - n // y + n // (x * y)\n\n    def count_not_divisible_by_x(n):\n        return n - n // x\n\n    def count_not_divisible_by_y(n):\n        return n - n // y\n\n    left, right = 0, 10**9\n    while left < right:\n        mid = (left + right) // 2\n        if count_not_divisible_by_x_or_y(mid) < cnt_1 + cnt_2:\n            left = mid + 1\n        else:\n            right = mid\n\n    if count_not_divisible_by_x(left) >= cnt_1:\n        return left\n    else:\n        return left + (cnt_1 - count_not_divisible_by_x(left))\n\n    if count_not_divisible_by_y(left) >= cnt_2:\n        return left\n    else:\n        return left + (cnt_2 - count_not_divisible_by_y(left))\n\ncnt_1, cnt_2, x, y = map(int, input().split())\nprint(min_presents(cnt_1, cnt_2, x, y))"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip().split()\n\ndef main():\n    n, sx, sy, dx, dy, t = map(int, read_input())\n\n    x, y = sx, sy\n    for _ in range(min(t, 2 * n + 2)):\n        k = x + y + _\n        dx += k\n        dy += k\n        x = ((x + dx - 1) % n) + 1\n        y = ((y + dy - 1) % n) + 1\n\n    if t > 2 * n + 2:\n        period = 2 * n + 2\n        t %= period\n        x, y = sx, sy\n        dx, dy = dx, dy\n        for _ in range(t):\n            k = x + y + _\n            dx += k\n            dy += k\n            x = ((x + dx - 1) % n) + 1\n            y = ((y + dy - 1) % n) + 1\n\n    print(x, y)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from string import ascii_uppercase\n\ndef solve(s):\n    n = len(s)\n    if n < 26:\n        return -1\n\n    s = list(s)\n    for i in range(n):\n        if s[i]!= '?':\n            continue\n        for c in ascii_uppercase:\n            if c not in s[max(0, i-25):i]:\n                s[i] = c\n                break\n\n    for i in range(n-25):\n        if len(set(s[i:i+26])) == 26:\n            return ''.join(s)\n\n    return -1\n\ns = input()\nprint(solve(s))"}
{"solution": "n = int(input())\nweights = list(map(int, input().split()))\n\ntotal_weight = sum(weights)\nif total_weight % 2!= 0:\n    print(\"NO\")\nelse:\n    target_weight = total_weight // 2\n    weights.sort(reverse=True)\n    first_person_weight = 0\n    for weight in weights:\n        if first_person_weight + weight <= target_weight:\n            first_person_weight += weight\n        else:\n            break\n    print(\"YES\" if first_person_weight == target_weight else \"NO\")"}
{"solution": "import sys\n\ndef min_time_to_turn_off_lights(n, m, building):\n    total_time = 0\n    for i in range(n):\n        floor = building[i]\n        left_index = -1\n        right_index = -1\n        for j in range(1, m + 1):\n            if floor[j] == '1':\n                if left_index == -1:\n                    left_index = j\n                right_index = j\n        if left_index!= -1:\n            if i > 0:\n                total_time += 1\n            total_time += min(left_index, m + 1 - right_index) + (right_index - left_index)\n            if right_index == m:\n                total_time += 1\n    return total_time\n\nn, m = map(int, sys.stdin.readline().split())\nbuilding = [sys.stdin.readline().strip() for _ in range(n)]\n\nprint(min_time_to_turn_off_lights(n, m, building))"}
{"solution": "from collections import defaultdict, deque\n\ndef dfs(node, graph, cost, visited):\n    if visited[node]:\n        return\n    visited[node] = True\n    if graph[node]!= -1:\n        dfs(graph[node], graph, cost, visited)\n\ndef find_cycle(node, graph, cost, visited, cycle):\n    if visited[node]:\n        cycle.append(node)\n        return\n    visited[node] = True\n    cycle.append(node)\n    if graph[node]!= -1:\n        find_cycle(graph[node], graph, cost, visited, cycle)\n\ndef solve():\n    n = int(input())\n    cost = list(map(int, input().split()))\n    graph = list(map(lambda x: int(x) - 1, input().split()))\n\n    visited = [False] * n\n    cycles = defaultdict(list)\n\n    for i in range(n):\n        if not visited[i]:\n            cycle = []\n            find_cycle(i, graph, cost, visited, cycle)\n            min_cost = min(cost[j] for j in cycle)\n            min_node = cycle[cost.index(min_cost)]\n            cycles[min_node].append(min_cost)\n\n    total_cost = 0\n    for node, costs in cycles.items():\n        total_cost += min(costs)\n\n    print(total_cost)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "n, a, b = map(int, input().split())\nprint((a + b - 1) % n + 1)"}
{"solution": "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    ans = 1\n    i = 0\n    while i < n:\n        if a[i] == -1:\n            i += 1\n            continue\n        j = i + 1\n        while j < n and a[j]!= -1:\n            j += 1\n        if j == n:\n            break\n        if j - i == 1:\n            i = j\n            continue\n        d = a[i + 1] - a[i]\n        k = i + 2\n        while k < j and a[k] - a[k - 1] == d:\n            k += 1\n        if k == j:\n            i = j\n            continue\n        if a[k] == -1:\n            l = k + 1\n            while l < j and a[l] == -1:\n                l += 1\n            if l == j:\n                i = j\n                continue\n            if a[l] - a[k - 1] == d:\n                i = l\n                continue\n        ans += 1\n        i = j\n    print(ans)\n\nsolve()"}
{"solution": "def max_beauty(n, k, s):\n    def max_beauty_with_char(c):\n        max_len = 0\n        window_start = 0\n        k_remaining = k\n\n        for window_end in range(n):\n            if s[window_end]!= c:\n                if k_remaining > 0:\n                    k_remaining -= 1\n                else:\n                    window_start = window_end\n\n            max_len = max(max_len, window_end - window_start + 1)\n\n        return max_len\n\n    return max(max_beauty_with_char('a'), max_beauty_with_char('b'))\n\nn, k = map(int, input().split())\ns = input()\n\nprint(max_beauty(n, k, s))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\ntotal_seats = sum(a)\nmajority_seats = (total_seats + 1) // 2\n\nif a[0] >= majority_seats:\n    print(1)\n    print(1)\nelse:\n    coalition = [1]\n    current_seats = a[0]\n    for i in range(1, n):\n        if a[i] * 2 <= a[0] and current_seats + a[i] <= majority_seats:\n            coalition.append(i + 1)\n            current_seats += a[i]\n    if current_seats >= majority_seats:\n        print(len(coalition))\n        print(*coalition)\n    else:\n        print(0)"}
{"solution": "import sys\n\nn = int(sys.stdin.readline())\ntotal = 0\nwhile n > 0:\n    total += n / (n + 1) if n > 1 else 1\n    n -= 1\nprint(f\"{total:.15f}\")"}
{"solution": "import math\n\nn = int(input())\n\nk = int(math.sqrt(2 * n))\n\nwhile (k * (k + 1)) // 2 > n:\n    k -= 1\n\nprint(k)\nprint(*[i for i in range(1, k + 1) if (k * (k + 1)) // 2 - n!= i], n - (k * (k + 1)) // 2 + k)"}
{"solution": "n = int(input())\nm = int(input())\nprint(m % (1 << n))"}
{"solution": "n = int(input())\ns = input()\nvowels = 'aeiouy'\n\nwhile True:\n    corrected = False\n    for i in range(len(s) - 1):\n        if s[i] in vowels and s[i + 1] in vowels:\n            s = s[:i] + s[i + 1:]\n            corrected = True\n            break\n    if not corrected:\n        break\n\nprint(s)"}
{"solution": "import sys\n\nn, a, b = map(int, input().split())\ns = input()\n\nempty = []\ncurr = 0\nfor i in range(n):\n    if s[i] == '*':\n        if curr > 0:\n            empty.append(curr)\n        curr = 0\n    else:\n        curr += 1\nif curr > 0:\n    empty.append(curr)\n\nans = 0\nfor e in empty:\n    if e % 2 == 0:\n        ans += e\n    else:\n        ans += e - 1\n\nif a > b:\n    a, b = b, a\nif ans <= 2 * a + b:\n    print(ans)\nelse:\n    print(2 * a + b)"}
{"solution": "import math\n\ndef solve():\n    r = int(input())\n    for x in range(1, int(math.sqrt(r)) + 1):\n        if (r - x**2 - x - 1) % (2*x + 1) == 0:\n            y = (r - x**2 - x - 1) // (2*x + 1)\n            if y > 0:\n                print(x, y)\n                return\n    print(\"NO\")\n\nsolve()"}
{"solution": "import itertools\n\ndef solve(n, a):\n    total_sum = sum(a)\n    if n == 1 or total_sum % 2 == 0 and a[0] == a[-1]:\n        return [-1]\n\n    for k in range(1, n):\n        for combination in itertools.combinations(range(n), k):\n            combination_sum = sum(a[i] for i in combination)\n            if combination_sum!= total_sum - combination_sum:\n                return [k] + [i + 1 for i in combination]\n\n    return [-1]\n\nn = int(input())\na = list(map(int, input().split()))\nprint(*solve(n, a))"}
{"solution": "n = int(input())\nfor i in range(9, 0, -1):\n    count = n // i\n    if count > 0:\n        print(count)\n        print(*([i] * count))\n        break"}
{"solution": "import sys\n\ndef sieve_of_eratosthenes(n):\n    primes = [True] * (n + 1)\n    primes[0] = primes[1] = False\n    p = 2\n    while p * p <= n:\n        if primes[p]:\n            for i in range(p * p, n + 1, p):\n                primes[i] = False\n        p += 1\n    return primes\n\ndef is_prime(n, primes):\n    return primes[n]\n\ndef find_simple_subset(a, primes):\n    a.sort()\n    n = len(a)\n    max_size = 0\n    max_subset = []\n    for i in range(n):\n        subset = [a[i]]\n        for j in range(i + 1, n):\n            if is_prime(a[i] + a[j], primes):\n                subset.append(a[j])\n        if len(subset) > max_size:\n            max_size = len(subset)\n            max_subset = subset\n    return max_size, max_subset\n\ndef main():\n    n = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().split()))\n    primes = sieve_of_eratosthenes(2 * 10**6)\n    max_size, max_subset = find_simple_subset(a, primes)\n    print(max_size)\n    print(*max_subset)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef is_beautiful(n):\n    binary = bin(n)[2:]\n    k = 0\n    while k < len(binary) and binary[k] == '1':\n        k += 1\n    if k == 0:\n        return False\n    while k < len(binary) and binary[k] == '0':\n        k += 1\n    return k == len(binary)\n\ndef greatest_beautiful_divisor(n):\n    for i in range(int(math.sqrt(n)), 0, -1):\n        if n % i == 0:\n            if is_beautiful(i):\n                return i\n            if is_beautiful(n // i):\n                return n // i\n    return 1\n\nn = int(input())\nprint(greatest_beautiful_divisor(n))"}
{"solution": "MOD = 10**9 + 7\n\ndef add(a, b):\n    return (a + b) % MOD\n\ndef mul(a, b):\n    return (a * b) % MOD\n\ndef pow(a, b):\n    res = 1\n    while b > 0:\n        if b & 1:\n            res = mul(res, a)\n        a = mul(a, a)\n        b >>= 1\n    return res\n\ndef solve(m, d, a, b):\n    n = len(a)\n    dp = [[0] * m for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(m):\n            for k in range(10):\n                if (i & 1) and k!= d:\n                    continue\n                if not (i & 1) and k == d:\n                    continue\n                dp[i][(j * 10 + k) % m] = add(dp[i][(j * 10 + k) % m], dp[i - 1][j])\n\n    def get(x):\n        res = 0\n        for i in range(1, len(x) + 1):\n            for j in range(int(x[i - 1]) if i > 1 else 1, 10):\n                if (i & 1) and j!= d:\n                    continue\n                if not (i & 1) and j == d:\n                    continue\n                res = add(res, dp[i - 1][(j * pow(10, len(x) - i)) % m])\n        return res\n\n    return add(get(b), MOD - get(a))\n\nm, d = map(int, input().split())\na = input()\nb = input()\nprint(solve(m, d, a, b))"}
{"solution": "import sys\n\nn, m = map(int, sys.stdin.readline().split())\na = list(map(int, sys.stdin.readline().split()))\n\ni = 0\nwhile True:\n    a[i] -= m\n    if a[i] <= 0:\n        if i == n - 1:\n            print(n)\n            break\n        else:\n            a.pop(i)\n            n -= 1\n            if n == 0:\n                print(i + 1)\n                break\n    else:\n        a.append(a.pop(i))"}
{"solution": "n = int(input())\nbills = [100, 20, 10, 5, 1]\ncount = 0\n\nfor bill in bills:\n    count += n // bill\n    n %= bill\n\nprint(count)"}
{"solution": "MOD = 1000000007\n\ndef solve(n, k):\n    if k > n or (n - k) % 2!= 0:\n        return 0\n\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(i + 1):\n            if j > 0:\n                dp[i][j] += dp[i - 1][j - 1]\n            if j < i:\n                dp[i][j] += (i - j - 1) * dp[i - 1][j]\n            dp[i][j] %= MOD\n\n    return dp[n][k]\n\nn, k = map(int, input().split())\nprint(solve(n, k))"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef read_ints():\n    return map(int, read_input().split())\n\ndef read_int_list():\n    return list(map(int, read_input().split()))\n\ndef solve():\n    n, k = read_ints()\n    b = read_int_list()\n    c = read_input()\n\n    red = []\n    white = []\n    orange = []\n\n    for i in range(n):\n        if c[i] == 'R':\n            red.append(b[i])\n        elif c[i] == 'W':\n            white.append(b[i])\n        else:\n            orange.append(b[i])\n\n    red.sort(reverse=True)\n    white.sort(reverse=True)\n    orange.sort(reverse=True)\n\n    def get_max(red, white, k):\n        if k == 1:\n            return -1\n        if len(red) == 0 or len(white) == 0:\n            return -1\n        if k == 2:\n            return red[0] + white[0]\n        max_val = -1\n        for i in range(1, min(len(red), k)):\n            for j in range(1, min(len(white), k - i)):\n                if i + j == k:\n                    max_val = max(max_val, sum(red[:i]) + sum(white[:j]))\n        return max_val\n\n    max_val = -1\n    if len(orange) > 0:\n        for i in range(1, min(len(orange), k)):\n            max_val = max(max_val, get_max(red, orange, k - i))\n            max_val = max(max_val, get_max(white, orange, k - i))\n    else:\n        max_val = max(get_max(red, white, k), max_val)\n\n    print(max_val)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef simplify(p, q):\n    g = gcd(p, q)\n    return p // g, q // g\n\ndef continued_fraction(a):\n    p, q = a[-1], 1\n    for i in range(len(a) - 2, -1, -1):\n        p, q = a[i] * p + q, p\n    return p, q\n\np, q = map(int, input().split())\nn = int(input())\na = list(map(int, input().split()))\n\np1, q1 = continued_fraction(a)\np1, q1 = simplify(p1, q1)\np, q = simplify(p, q)\n\nprint(\"YES\" if (p, q) == (p1, q1) else \"NO\")"}
{"solution": "def solve():\n    s = input()\n    a, b, c = s.split('+')[0], s.split('=')[0].split('+')[1], s.split('=')[1]\n    a, b, c = a.count('|'), b.count('|'), c.count('|')\n    if a + b == c:\n        print(s)\n        return\n    for i in range(len(s)):\n        if s[i] == '|':\n            t = list(s)\n            t[i] = '.'\n            temp = ''.join(t)\n            for j in range(len(temp)):\n                if temp[j] == '.':\n                    t[j] = '|'\n                    temp = ''.join(t)\n                    if temp.split('+')[0].count('|') + temp.split('=')[0].split('+')[1].count('|') == temp.split('=')[1].count('|'):\n                        print(temp)\n                        return\n                    t[j] = '.'\n                    temp = ''.join(t)\n            t[i] = '|'\n    print(\"Impossible\")\n\nsolve()"}
{"solution": "MOD = 10**9 + 7\n\ndef main():\n    n, k = map(int, input().split())\n    dp = [[[0] * (n * n + 1) for _ in range(n + 1)] for _ in range(2)]\n    dp[0][0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(i + 1):\n            for odd in range(i * i + 1):\n                if odd - i >= 0:\n                    dp[i % 2][j][odd] += dp[(i - 1) % 2][j][odd - i]\n                if j > 0 and odd - i + 1 >= 0:\n                    dp[i % 2][j][odd] += j * dp[(i - 1) % 2][j - 1][odd - i + 1]\n                dp[i % 2][j][odd] %= MOD\n    print(dp[n % 2][0][k])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef solve():\n    n = int(input())\n    points = []\n    for _ in range(n):\n        x, y = map(int, input().split())\n        points.append((x, y))\n\n    def check(x, y):\n        for i in range(n):\n            if abs(points[i][0] - x) + abs(points[i][1] - y)!= m:\n                return False\n        return True\n\n    for m in range(1, 41):\n        for x in range(-m, m + 1):\n            for y in range(-m, m + 1):\n                if check(x, y):\n                    ans = []\n                    for i in range(n):\n                        dx = points[i][0] - x\n                        dy = points[i][1] - y\n                        path = []\n                        if dx > 0:\n                            path += ['R'] * dx\n                        elif dx < 0:\n                            path += ['L'] * (-dx)\n                        if dy > 0:\n                            path += ['U'] * dy\n                        elif dy < 0:\n                            path += ['D'] * (-dy)\n                        path += ['L'] * (m - len(path))\n                        ans.append(''.join(path))\n                    print(m)\n                    print('1'* m)\n                    for i in ans:\n                        print(i)\n                    return\n    print(-1)\n\nif __name__ == '__main__':\n    solve()"}
{"solution": "import re\n\nn = int(input())\ns = input()\n\nprint(re.sub('o(go)+', '***', s))"}
{"solution": "def prime_factors(n):\n    i = 2\n    factors = {}\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors[i] = factors.get(i, 0) + 1\n    if n > 1:\n        factors[n] = factors.get(n, 0) + 1\n    return factors\n\ndef g(y, p):\n    k = 0\n    while y % p == 0:\n        y //= p\n        k += 1\n    return p ** k\n\ndef f(x, y):\n    factors = prime_factors(x)\n    result = 1\n    for p in factors:\n        result = (result * g(y, p)) % (10**9 + 7)\n    return result\n\ndef main():\n    x, n = map(int, input().split())\n    factors = prime_factors(x)\n    result = 1\n    for p in factors:\n        k = factors[p]\n        sum_p_k = (p ** k * (n // (p ** k) * (p - 1) + (n % (p ** k) - 1) // (p - 1))) % (10**9 + 7)\n        result = (result * sum_p_k) % (10**9 + 7)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef solve(a, b, c):\n    solutions = set()\n    for x in range(1, 10**9):\n        if x == b * (sum_of_digits(x) ** a) + c:\n            solutions.add(x)\n    return sorted(list(solutions))\n\na, b, c = map(int, input().split())\nsolutions = solve(a, b, c)\nprint(len(solutions))\nprint(*solutions)"}
{"solution": "def is_solved(cube):\n    for i in range(0, 24, 4):\n        if len(set(cube[i:i+4]))!= 1:\n            return False\n    return True\n\ndef rotate_face(cube, face):\n    faces = {\n        0: [0, 1, 2, 3],\n        1: [4, 5, 6, 7],\n        2: [8, 9, 10, 11],\n        3: [12, 13, 14, 15],\n        4: [16, 17, 18, 19],\n        5: [20, 21, 22, 23]\n    }\n    face = faces[face]\n    cube[face[0]], cube[face[1]], cube[face[2]], cube[face[3]] = cube[face[3]], cube[face[0]], cube[face[1]], cube[face[2]]\n    return cube\n\ndef is_possible(cube):\n    for i in range(6):\n        if is_solved(rotate_face(cube[:], i)):\n            return True\n    return False\n\ncube = list(map(int, input().split()))\nprint(\"YES\" if is_possible(cube) else \"NO\")"}
{"solution": "def get_score(s):\n    i = (s // 50) % 475\n    for _ in range(25):\n        i = (i * 96 + 42) % 475\n        yield 26 + i\n\ndef solve():\n    p, x, y = map(int, input().split())\n    p -= 1\n    best = float('inf')\n    for s in range(x, y - 1, -1):\n        if s % 50 == 0:\n            continue\n        scores = list(get_score(s))\n        if p in scores:\n            best = min(best, (s - x + 99) // 100)\n    for s in range(y, y + 2500):\n        scores = list(get_score(s))\n        if p in scores:\n            best = min(best, (s - x + 99) // 100)\n    print(best)\n\nsolve()"}
{"solution": "n = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\nif n == 1:\n    print(0)\nelse:\n    print(min((n-1)*a + (n-2)*c, (n-1)*b + (n-2)*c, (n-1)*c + (n-2)*a, (n-1)*c + (n-2)*b))"}
{"solution": "x1, x2, x3 = map(int, input().split())\nprint(sum(abs(x - sorted([x1, x2, x3])[1]) for x in [x1, x2, x3]))"}
{"solution": "import sys\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    s = set()\n    for i in range(n):\n        a[i] &= x\n        s.add(a[i])\n\n    if len(s) < n:\n        print(0)\n        return\n\n    s = set()\n    for i in range(n):\n        if a[i] in s:\n            print(1)\n            return\n        s.add(a[i])\n\n    print(-1)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "def check_plus(grid, center):\n    h, w = len(grid), len(grid[0])\n    cx, cy = center\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    for dx, dy in directions:\n        x, y = cx + dx, cy + dy\n        while 0 <= x < h and 0 <= y < w and grid[x][y] == '*':\n            x += dx\n            y += dy\n        if (x, y) == (cx + dx, cy + dy):\n            return False\n    return True\n\ndef check_empty(grid, center):\n    h, w = len(grid), len(grid[0])\n    cx, cy = center\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    for dx, dy in directions:\n        x, y = cx + dx, cy + dy\n        while 0 <= x < h and 0 <= y < w and grid[x][y] == '*':\n            x += dx\n            y += dy\n        while 0 <= x < h and 0 <= y < w:\n            if grid[x][y] == '*':\n                return False\n            x += dx\n            y += dy\n    return True\n\ndef solve():\n    h, w = map(int, input().split())\n    grid = [list(input()) for _ in range(h)]\n    centers = [(i, j) for i in range(h) for j in range(w) if grid[i][j] == '*']\n    if len(centers) == 0:\n        print(\"NO\")\n        return\n    cx, cy = centers[0]\n    if not check_plus(grid, (cx, cy)) or not check_empty(grid, (cx, cy)):\n        print(\"NO\")\n        return\n    for x, y in centers[1:]:\n        if (x, y)!= (cx, cy):\n            print(\"NO\")\n            return\n    print(\"YES\")\n\nsolve()"}
{"solution": "import sys\n\ndef solve(n, a, b):\n    if a == 1 and b == 1:\n        return \"NO\"\n    if a == 1:\n        if b > 2:\n            return \"NO\"\n        matrix = [[1]*n for _ in range(n)]\n        for i in range(n):\n            matrix[i][i] = 0\n        if b == 2:\n            matrix[0][1] = 0\n            matrix[1][0] = 0\n        return \"YES\\n\" + \"\\n\".join(\"\".join(map(str, row)) for row in matrix)\n    if b == 1:\n        if a > 2:\n            return \"NO\"\n        matrix = [[0]*n for _ in range(n)]\n        if a == 2:\n            matrix[0][1] = 1\n            matrix[1][0] = 1\n        return \"YES\\n\" + \"\\n\".join(\"\".join(map(str, row)) for row in matrix)\n    if a + b > n + 1:\n        return \"NO\"\n    matrix = [[0]*n for _ in range(n)]\n    for i in range(a-1):\n        for j in range(i+1, a):\n            matrix[i][j] = 1\n            matrix[j][i] = 1\n    for i in range(a, a+b-1):\n        for j in range(i+1, a+b):\n            matrix[i][j] = 1\n            matrix[j][i] = 1\n    return \"YES\\n\" + \"\\n\".join(\"\".join(map(str, row)) for row in matrix)\n\nn, a, b = map(int, sys.stdin.readline().split())\nprint(solve(n, a, b))"}
{"solution": "import math\n\nc, d = map(int, input().split())\nn, m = map(int, input().split())\nk = int(input())\n\nmain_rounds = math.ceil((n * m - k) / n)\nadditional_rounds = max(0, (n * m - k) % n)\n\ntotal_problems = main_rounds * c + additional_rounds * d\n\nprint(total_problems)"}
{"solution": "def solve(s):\n    if len(s)!= 27:\n        return \"Impossible\"\n\n    grid = [[' ']*13 for _ in range(2)]\n    grid[0][0] = s[0]\n    grid[1][0] = s[1]\n    grid[0][12] = s[2]\n    grid[1][12] = s[3]\n\n    for i in range(4, 27):\n        for j in range(2):\n            for k in range(13):\n                if grid[j][k] == s[i-1]:\n                    for x, y in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]:\n                        nx, ny = j+x, k+y\n                        if 0 <= nx < 2 and 0 <= ny < 13 and grid[nx][ny] =='':\n                            grid[nx][ny] = s[i]\n                            break\n                    else:\n                        return \"Impossible\"\n                    break\n            else:\n                continue\n            break\n        else:\n            return \"Impossible\"\n\n    return '\\n'.join(''.join(row) for row in grid)\n\ns = input()\nprint(solve(s))"}
{"solution": "import math\n\nx, y = map(int, input().split())\n\nif x == y:\n    print('=')\nelif x > y:\n    if math.log(x) / y > math.log(y) / x:\n        print('>')\n    else:\n        print('<')\nelse:\n    if math.log(x) / y < math.log(y) / x:\n        print('>')\n    else:\n        print('<')"}
{"solution": "import math\n\nr, h = map(int, input().split())\n\ndef calculate_balloons_in_semicircle(r):\n    return math.floor((math.pi * r**2) / (2 * (r/2)**2))\n\ndef calculate_balloons_in_rectangle(r, h):\n    return math.floor((h * r) / (r/2)**2)\n\nballoons_in_semicircle = calculate_balloons_in_semicircle(r)\nballoons_in_rectangle = calculate_balloons_in_rectangle(r, h - r)\n\nprint(balloons_in_semicircle + balloons_in_rectangle)"}
{"solution": "import sys\n\nnumbers = list(map(int, input().split()))\nnumbers.sort()\n\nmin_sum = sum(numbers)\n\n# Check if we can discard two cards with the same number\nif numbers[0] == numbers[1]:\n    min_sum = min(min_sum, sum(numbers[2:]))\n\n# Check if we can discard three cards with the same number\nif numbers[0] == numbers[2]:\n    min_sum = min(min_sum, sum(numbers[3:]))\n\n# Check if we can discard two cards with the same number from the end\nif numbers[3] == numbers[4]:\n    min_sum = min(min_sum, sum(numbers[:3]))\n\nprint(min_sum)"}
{"solution": "import sys\n\ndef main():\n    n, a = map(int, sys.stdin.readline().split())\n    x = sorted(map(int, sys.stdin.readline().split()))\n\n    idx = next((i for i, val in enumerate(x) if val >= a), len(x))\n    left = x[:idx]\n    right = x[idx:]\n\n    left_dist = sum(abs(a - val) for val in left[:-1]) if left else 0\n    right_dist = sum(abs(a - val) for val in right[:-1]) if right else 0\n\n    if len(left) > len(right):\n        left_dist += abs(a - left[-1]) if left else 0\n    elif len(right) > len(left):\n        right_dist += abs(a - right[-1]) if right else 0\n\n    print(min(left_dist, right_dist))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef solve(n):\n    x = math.isqrt(n)\n    while x * x <= n:\n        s_x = sum_of_digits(x)\n        if x * x + s_x * x - n == 0:\n            return x\n        x += 1\n    return -1\n\nn = int(input())\nprint(solve(n))"}
{"solution": "def calculate_bed_time(current_time, sleep_time):\n    current_hours, current_minutes = map(int, current_time.split(':'))\n    sleep_hours, sleep_minutes = map(int, sleep_time.split(':'))\n\n    total_minutes = current_hours * 60 + current_minutes - sleep_hours * 60 - sleep_minutes\n    if total_minutes < 0:\n        total_minutes += 24 * 60\n\n    bed_hours = total_minutes // 60 % 24\n    bed_minutes = total_minutes % 60\n\n    return f\"{bed_hours:02d}:{bed_minutes:02d}\"\n\ncurrent_time = input()\nsleep_time = input()\n\nprint(calculate_bed_time(current_time, sleep_time))"}
{"solution": "import sys\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    max_sum = float('-inf')\n    max_len = 0\n    curr_sum = 0\n    curr_len = 0\n\n    for i in range(n):\n        if curr_sum < 0:\n            curr_sum = a[i]\n            curr_len = 1\n        else:\n            curr_sum += a[i]\n            curr_len += 1\n\n        if curr_sum * max_len > max_sum * curr_len:\n            max_sum = curr_sum\n            max_len = curr_len\n\n    print(max_len)\n\nif __name__ == \"__main__\":\n    solve()"}
{"solution": "MOD = 998244353\n\ndef main():\n    n, m, k = map(int, input().split())\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[1][0] = m\n\n    for i in range(2, n + 1):\n        for j in range(min(i, k) + 1):\n            if j == 0:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = (dp[i - 1][j - 1] * (m - 1) + dp[i - 1][j]) % MOD\n\n    ans = 0\n    for j in range(k + 1):\n        ans = (ans + dp[n][j]) % MOD\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_magic_number(n):\n    n = str(n)\n    i = 0\n    while i < len(n):\n        if n[i:i+1] == '1':\n            i += 1\n        elif n[i:i+2] == '14':\n            i += 2\n        elif n[i:i+3] == '144':\n            i += 3\n        else:\n            return 'NO'\n    return 'YES'\n\nn = int(input())\nprint(is_magic_number(n))"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef solve():\n    n, m, i, j, a, b = map(int, input().split())\n\n    corners = [(1, m), (n, 1), (n, m), (1, 1)]\n    min_moves = float('inf')\n\n    for x, y in corners:\n        dx = abs(i - x)\n        dy = abs(j - y)\n\n        if dx % a!= 0 or dy % b!= 0:\n            continue\n\n        moves = dx // a + dy // b\n        min_moves = min(min_moves, moves)\n\n    if min_moves == float('inf'):\n        print(\"Poor Inna and pony!\")\n    else:\n        print(min_moves)\n\nsolve()"}
{"solution": "def remove_chars(s):\n    dp = [[0] * 26 for _ in range(len(s))]\n    for i in range(len(s)):\n        for j in range(26):\n            if i == 0:\n                dp[i][j] = 1 if ord(s[i]) - ord('a') == j else 0\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i-1][j+1] + 1 if j < 25 and ord(s[i]) - ord('a') == j else 0)\n    return max(dp[-1])\n\nn = int(input())\ns = input()\nprint(remove_chars(s))"}
{"solution": "import sys\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nq = int(input())\n\nfor _ in range(q):\n    x = int(input())\n    ans = float('inf')\n\n    for i in range(n):\n        for j in range(i, n):\n            for u in range(k + 1):\n                for v in range(k + 1):\n                    if u + v > k:\n                        break\n                    if a[i] * u + a[j] * v == x:\n                        ans = min(ans, u + v)\n\n    if ans == float('inf'):\n        print(-1)\n    else:\n        print(ans)"}
{"solution": "import math\n\ns, x1, x2 = map(int, input().split())\nt1, t2 = map(int, input().split())\np, d = map(int, input().split())\n\nif x1 < x2:\n    if d == 1:\n        wait_time = max(0, (p - x1) * t1)\n        tram_time = (x2 - p) * t1\n        walk_time = (x2 - x1) * t2\n        time = min(wait_time + tram_time, walk_time)\n    else:\n        tram_time = (s - p) * t1 + (s - x2) * t1\n        wait_time = max(0, (s - p + x1) * t1)\n        walk_time = (x2 - x1) * t2\n        time = min(wait_time + tram_time, walk_time)\nelse:\n    if d == -1:\n        wait_time = max(0, (p - x1) * t1)\n        tram_time = (p - x2) * t1\n        walk_time = (x1 - x2) * t2\n        time = min(wait_time + tram_time, walk_time)\n    else:\n        tram_time = (p + s - x2) * t1\n        wait_time = max(0, (x1 - p + s) * t1)\n        walk_time = (x1 - x2) * t2\n        time = min(wait_time + tram_time, walk_time)\n\nprint(int(time))"}
{"solution": "import math\n\nn, x = map(int, input().split())\ncount = 0\n\nfor i in range(1, int(math.sqrt(x)) + 1):\n    if x % i == 0:\n        if i <= n and x // i <= n:\n            count += 1\n        if i!= x // i and i <= n and x // i <= n:\n            count += 1\n\nprint(count)"}
{"solution": "import string\n\nn, k = map(int, input().split())\npassword = string.ascii_lowercase[:k]\nif k == 2:\n    print((password[0] + password[1]) * (n // 2) + password[0] * (n % 2))\nelse:\n    print(password * (n // k) + password[:n % k])"}
{"solution": "import sys\n\nn = int(sys.stdin.readline())\ndirections = sys.stdin.readline().strip()\npositions = list(map(int, sys.stdin.readline().split()))\n\nmin_collision_time = float('inf')\n\nfor i in range(n - 1):\n    if (directions[i] == 'L' and directions[i + 1] == 'R') or (directions[i] == 'R' and directions[i + 1] == 'L'):\n        collision_time = abs(positions[i] - positions[i + 1]) // 2\n        min_collision_time = min(min_collision_time, collision_time)\n\nif min_collision_time == float('inf'):\n    print(-1)\nelse:\n    print(min_collision_time)"}
{"solution": "import sys\n\nn, a, b = map(int, sys.stdin.readline().split())\nseals = []\nfor _ in range(n):\n    x, y = map(int, sys.stdin.readline().split())\n    seals.append((min(x, y), max(x, y)))\n\nseals.sort(key=lambda x: x[0], reverse=True)\nseals.sort(key=lambda x: x[1], reverse=True)\n\nmax_area = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        if seals[i][0] + seals[j][0] <= a and max(seals[i][1], seals[j][1]) <= b:\n            max_area = max(max_area, seals[i][0] * seals[i][1] + seals[j][0] * seals[j][1])\n        if seals[i][0] + seals[j][0] <= b and max(seals[i][1], seals[j][1]) <= a:\n            max_area = max(max_area, seals[i][0] * seals[i][1] + seals[j][0] * seals[j][1])\n        if max(seals[i][0], seals[j][0]) <= a and seals[i][1] + seals[j][1] <= b:\n            max_area = max(max_area, seals[i][0] * seals[i][1] + seals[j][0] * seals[j][1])\n        if max(seals[i][0], seals[j][0]) <= b and seals[i][1] + seals[j][1] <= a:\n            max_area = max(max_area, seals[i][0] * seals[i][1] + seals[j][0] * seals[j][1])\n\nprint(max_area)"}
{"solution": "n = int(input())\npoints = [list(map(int, input().split())) for _ in range(4*n + 1)]\n\nx_coords = [point[0] for point in points]\ny_coords = [point[1] for point in points]\n\nmin_x, max_x = min(x_coords), max(x_coords)\nmin_y, max_y = min(y_coords), max(y_coords)\n\nfor point in points:\n    if min_x < point[0] < max_x and min_y < point[1] < max_y:\n        print(*point)\n        break"}
{"solution": "import math\n\ndef digit_product(n):\n    product = 1\n    while n > 0:\n        product *= n % 10\n        n //= 10\n    return product\n\ndef max_digit_product(n):\n    max_product = 0\n    for i in range(1, n + 1):\n        max_product = max(max_product, digit_product(i))\n    return max_product\n\ndef max_digit_product_optimized(n):\n    max_product = 0\n    for i in range(9, 0, -1):\n        if str(i) in str(n):\n            max_product = max(max_product, i)\n            n = int(str(n).replace(str(i), '', 1))\n    return max_product * (9 ** (len(str(n)) - 1))\n\ndef main():\n    n = int(input())\n    if n < 10:\n        print(n)\n    else:\n        max_product = 0\n        for i in range(1, 10):\n            for j in range(1, 10):\n                for k in range(1, 10):\n                    num = int(str(i) + str(j) + str(k))\n                    if num <= n:\n                        max_product = max(max_product, i * j * k)\n        if n >= 1000:\n            max_product = max(max_product, 9 * 9 * 9 * max_digit_product_optimized(n // 1000))\n        print(max_product)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\ntotal_votes_elodreip = sum(a)\nmax_votes_elodreip = max(a)\n\nk = max_votes_elodreip\nwhile True:\n    total_votes_awruk = sum(k - ai for ai in a)\n    if total_votes_awruk > total_votes_elodreip:\n        break\n    k += 1\n\nprint(k)"}
{"solution": "def min_operations(s):\n    stack = []\n    operations = 0\n\n    for color in s:\n        if stack and stack[-1][0]!= color:\n            while stack and stack[-1][0]!= color:\n                stack.pop()\n            if stack:\n                stack[-1][1] += 1\n        else:\n            stack.append([color, 1])\n\n    while True:\n        temp = []\n        changed = False\n        for i in range(len(stack)):\n            if i > 0 and stack[i-1][0]!= stack[i][0]:\n                temp.append([stack[i][0], 1])\n                changed = True\n            elif i < len(stack) - 1 and stack[i+1][0]!= stack[i][0]:\n                temp.append([stack[i][0], 1])\n                changed = True\n            else:\n                temp.append(stack[i])\n        if changed:\n            operations += 1\n            stack = temp\n        else:\n            break\n\n    return operations\n\ns = input()\nprint(min_operations(s))"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\nmin_product = a[0] * a[1] * a[2]\nmin_product_count = 1\n\nfor i in range(3, n):\n    if a[0] * a[1] * a[i] == min_product:\n        min_product_count += 1\n    elif a[0] * a[1] * a[i] < min_product:\n        min_product = a[0] * a[1] * a[i]\n        min_product_count = 1\n\nif a[0] == a[1] == a[2]:\n    print(n * (n - 1) * (n - 2) // 6)\nelif a[0] == a[1]:\n    print(min_product_count * (n - 2))\nelse:\n    print(min_product_count)"}
{"solution": "import math\n\ndef min_cuts(n):\n    if n < 4:\n        return n\n    return math.ceil(math.sqrt(n + 1))\n\nn = int(input())\nprint(min_cuts(n))"}
{"solution": "def remove_last_digit(n):\n    return int(str(n)[:-1])\n\ndef remove_second_last_digit(n):\n    return int(str(n)[:-2] + str(n)[-1])\n\nn = int(input())\nif n < 0:\n    n_str = str(n)[1:]\n    if len(n_str) > 1:\n        n_str = n_str[:-1]\n        if int(n_str[-1]) > int(n_str[-2]):\n            n_str = n_str[:-2] + n_str[-1]\n    print(-int(n_str))\nelse:\n    n_str = str(n)\n    if len(n_str) > 1:\n        if int(n_str[-1]) < int(n_str[-2]):\n            n_str = n_str[:-1]\n        elif int(n_str[-1]) > int(n_str[-2]):\n            n_str = n_str[:-2] + n_str[-1]\n    print(int(n_str))"}
{"solution": "def spinner_direction():\n    positions = {'v': 0, '<': 1, '^': 2, '>': 3}\n    start, end = input().split()\n    n = int(input())\n\n    start_pos = positions[start]\n    end_pos = positions[end]\n\n    clockwise_diff = (end_pos - start_pos) % 4\n    counter_clockwise_diff = (start_pos - end_pos) % 4\n\n    if (n - clockwise_diff) % 4 == 0:\n        return 'cw'\n    elif (n - counter_clockwise_diff) % 4 == 0:\n        return 'ccw'\n    else:\n        return 'undefined'\n\nprint(spinner_direction())"}
{"solution": "n = int(input())\ns = input()\n\nleft = [0] * n\nright = [0] * n\n\nfor i in range(1, n):\n    if s[i - 1] == 'R':\n        left[i] = left[i - 1] + 1\n    else:\n        left[i] = left[i - 1]\n\nfor i in range(n - 2, -1, -1):\n    if s[i + 1] == 'L':\n        right[i] = right[i + 1] + 1\n    else:\n        right[i] = right[i + 1]\n\nans = 0\nfor i in range(n):\n    if s[i] == '.':\n        if left[i] == right[i]:\n            ans += 1\n    elif s[i] == 'L':\n        if left[i] > 0:\n            ans += 1\n    else:\n        if right[i] > 0:\n            ans += 1\n\nprint(ans)"}
{"solution": "def solve(n, m, leaders):\n    permutation = [0] * n\n    for i in range(n):\n        permutation[i] = i + 1\n\n    for i in range(m - 1):\n        leader_index = leaders[i] - 1\n        next_leader_index = leaders[i + 1] - 1\n        diff = (next_leader_index - leader_index) % n\n        if diff == 0:\n            permutation[leader_index] = n\n        else:\n            permutation[leader_index] = diff\n\n    for i in range(n):\n        if permutation[i] == 0:\n            permutation[i] = n\n\n    for i in range(m - 1):\n        leader_index = leaders[i] - 1\n        next_leader_index = leaders[i + 1] - 1\n        diff = (next_leader_index - leader_index) % n\n        if permutation[leader_index]!= diff and permutation[leader_index]!= n:\n            return [-1]\n\n    return permutation\n\n\nn, m = map(int, input().split())\nleaders = list(map(int, input().split()))\nresult = solve(n, m, leaders)\nprint(*result)"}
{"solution": "def largest_number(a, k):\n    a = list(a)\n    n = len(a)\n    result = []\n\n    for i in range(n):\n        if k == 0:\n            result.extend(a[i:])\n            break\n\n        max_digit = a[i]\n        max_index = i\n\n        for j in range(i + 1, min(i + k + 1, n)):\n            if a[j] > max_digit:\n                max_digit = a[j]\n                max_index = j\n\n        if max_index!= i:\n            k -= max_index - i\n\n        result.append(max_digit)\n        a[i:max_index + 1] = a[i + 1:max_index + 1] + [a[i]]\n\n    return ''.join(result)\n\n\na, k = input().split()\nk = int(k)\nprint(largest_number(a, k))"}
{"solution": "def is_arithmetic_progression(sequence):\n    diff = sequence[1] - sequence[0]\n    for i in range(2, len(sequence)):\n        if sequence[i] - sequence[i-1]!= diff:\n            return False\n    return True\n\ndef is_geometric_progression(sequence):\n    ratio = sequence[1] / sequence[0]\n    for i in range(2, len(sequence)):\n        if sequence[i] / sequence[i-1]!= ratio:\n            return False\n    return True\n\ndef next_arithmetic_progression(sequence):\n    diff = sequence[1] - sequence[0]\n    return sequence[-1] + diff\n\ndef next_geometric_progression(sequence):\n    ratio = sequence[1] / sequence[0]\n    return sequence[-1] * ratio\n\ndef main():\n    sequence = list(map(int, input().split()))\n    if is_arithmetic_progression(sequence):\n        next_num = next_arithmetic_progression(sequence)\n        if next_num == int(next_num):\n            print(int(next_num))\n        else:\n            print(42)\n    elif is_geometric_progression(sequence):\n        next_num = next_geometric_progression(sequence)\n        if next_num == int(next_num):\n            print(int(next_num))\n        else:\n            print(42)\n    else:\n        print(42)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\nn = int(input())\ncolors = list(map(int, input().split()))\n\nfirst = {}\nlast = {}\n\nfor i, color in enumerate(colors):\n    if color not in first:\n        first[color] = i\n    last[color] = i\n\nmax_distance = 0\n\nfor color in first:\n    if first[color]!= last[color]:\n        max_distance = max(max_distance, last[color] - first[color])\n\nif max_distance == 0:\n    max_distance = n - 1\n    for color in first:\n        if first[color]!= 0 and last[color]!= n - 1:\n            max_distance = max(max_distance, max(first[color], n - 1 - last[color]))\nelse:\n    for color in first:\n        if first[color]!= 0 and last[color]!= n - 1:\n            max_distance = max(max_distance, max(last[color] - 0, n - 1 - first[color]))\n\nprint(max_distance)"}
{"solution": "n, m, k = map(int, input().split())\nlane = (k + 1) // (2 * m)\ndesk = ((k - 1) % (2 * m)) // 2 + 1\nside = 'L' if (k - 1) % 2 == 0 else 'R'\nprint(lane, desk, side)"}
{"solution": "n = int(input())\ns = input()\n\ncolors = {'B': 0, 'G': 0, 'R': 0}\nfor color in s:\n    colors[color] += 1\n\npossible_colors = set()\nfor color in colors:\n    if colors[color] % 2 == n % 2:\n        possible_colors.add(color)\n\nprint(''.join(sorted(possible_colors)))"}
