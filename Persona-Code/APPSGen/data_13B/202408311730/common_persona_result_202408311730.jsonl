{"solution": "import sys\n\ndef is_accordion(s):\n    if len(s) < 4:\n        return False\n    if s[0]!= '[' or s[-1]!= ']':\n        return False\n    if s[1]!= ':' or s[-2]!= ':':\n        return False\n    for i in range(2, len(s) - 2):\n        if s[i]!= '|':\n            return False\n    return True\n\ndef get_max_accordion_length(s):\n    if not is_accordion(s):\n        return -1\n    return len(s) - 2\n\nif __name__ == '__main__':\n    s = sys.stdin.readline().strip()\n    print(get_max_accordion_length(s))"}
{"solution": "import math\n\ndef get_max_sum_of_digits(x):\n    # Convert x to a string\n    x_str = str(x)\n    \n    # Initialize the maximum sum of digits\n    max_sum = 0\n    \n    # Iterate through the digits of x\n    for digit in x_str:\n        # Convert the digit to an integer\n        digit_int = int(digit)\n        \n        # Add the digit to the sum\n        max_sum += digit_int\n    \n    # Return the maximum sum of digits\n    return max_sum\n\n# Test the function\nx = 100\nprint(get_max_sum_of_digits(x))"}
{"solution": "def find_next_lucky_year(current_year):\n    # Initialize a variable to store the number of years to the next lucky year\n    years_to_next_lucky_year = 0\n\n    # Loop through each year from the current year to 10^9\n    for year in range(current_year, 10**9):\n        # Check if the year is a lucky year\n        if is_lucky_year(year):\n            # If it is, break the loop and return the number of years to the next lucky year\n            break\n        else:\n            # If it is not, increment the number of years to the next lucky year\n            years_to_next_lucky_year += 1\n\n    # Return the number of years to the next lucky year\n    return years_to_next_lucky_year\n\ndef is_lucky_year(year):\n    # Initialize a variable to store the number of non-zero digits in the year\n    non_zero_digits = 0\n\n    # Loop through each digit in the year\n    for digit in str(year):\n        # Check if the digit is not zero\n        if digit!= '0':\n            # If it is not, increment the number of non-zero digits\n            non_zero_digits += 1\n\n    # Return True if the number of non-zero digits is less than or equal to 1, False otherwise\n    return non_zero_digits <= 1\n\n# Test the function with the given examples\nprint(find_next_lucky_year(4))  # Output: 1\nprint(find_next_lucky_year(201))  # Output: 99\nprint(find_next_lucky_year(4000))  # Output: 1000"}
{"solution": "import sys\n\nn, q = map(int, input().split())\npainters = []\nfor i in range(q):\n    l, r = map(int, input().split())\n    painters.append((l, r))\n\n# Sort painters by left endpoint\npainters.sort(key=lambda x: x[0])\n\n# Initialize variables\nmax_painted = 0\ncurrent_painted = 0\ncurrent_painter = 0\n\n# Iterate through painters and calculate maximum number of painted sections\nfor i in range(q):\n    painter = painters[i]\n    current_painter = painter[0]\n    current_painted += 1\n    if current_painter == painter[1]:\n        max_painted = max(max_painted, current_painted)\n        current_painted = 0\n\nprint(max_painted)"}
{"solution": "import sys\n\ndef get_lucky_time(hh, mm, x):\n    # Calculate the time difference between the wake-up time and the alarm time\n    diff = (hh * 60 + mm) - (x * 60)\n\n    # Check if the time difference is a multiple of 7\n    if diff % 7 == 0:\n        return diff // 7\n\n    # If the time difference is not a multiple of 7, find the smallest number of times the snooze button needs to be pressed\n    snooze_count = 0\n    while diff > 0:\n        diff -= 7\n        snooze_count += 1\n\n    return snooze_count\n\nif __name__ == \"__main__\":\n    x = int(input())\n    hh, mm = map(int, input().split())\n    print(get_lucky_time(hh, mm, x))"}
{"solution": "n, pos, l, r = map(int, input().split())\n\n# Check if the segment [l, r] covers the entire range of tabs\nif l == 1 and r == n:\n    print(0)\n    exit()\n\n# Check if the left boundary (l) is greater than 1\nif l > 1:\n    # Move the cursor to the left boundary\n    pos = l\n    # Close the tabs to the left\n    for i in range(l, pos):\n        print(abs(pos - i) + 1)\n\n# Check if the right boundary (r) is less than n\nif r < n:\n    # Move the cursor to the right boundary\n    pos = r\n    # Close the tabs to the right\n    for i in range(pos, r):\n        print(abs(pos - i) + 1)\n\n# Print the minimum number of seconds required\nprint(min(abs(pos - l), abs(pos - r)) + (r - l) + 2)"}
{"solution": "import sys\n\ndef get_min_blows(n, x, d, h):\n    # Initialize variables\n    cur_x = x\n    num_blows = 0\n    \n    # Loop through each type of blow\n    for i in range(n):\n        # Calculate the number of heads after dealing the current blow\n        new_x = cur_x - min(d[i], cur_x) + h[i]\n        \n        # If the number of heads is still positive, deal the next blow\n        if new_x > 0:\n            cur_x = new_x\n            num_blows += 1\n        # Otherwise, break the loop and return the current number of blows\n        else:\n            break\n    \n    # Return the minimum number of blows\n    return num_blows\n\n# Read the input\nt = int(input())\nfor _ in range(t):\n    n, x = map(int, input().split())\n    d = [int(x) for x in input().split()]\n    h = [int(x) for x in input().split()]\n    \n    # Calculate the minimum number of blows\n    min_blows = get_min_blows(n, x, d, h)\n    \n    # Print the output\n    print(min_blows)"}
{"solution": "n, m = map(int, input().split())\n\n# Initialize the number of grains in the barn\ngrains = n\n\n# Initialize the number of sparrows that have eaten grain\nsparrows = 0\n\n# Initialize the number of days\ndays = 0\n\n# Loop until the barn is empty\nwhile grains > 0:\n    # Bring m grains to the barn\n    grains += m\n\n    # If the barn becomes full, remove one grain\n    if grains > n:\n        grains -= 1\n\n    # Increment the number of sparrows that have eaten grain\n    sparrows += 1\n\n    # Increment the number of days\n    days += 1\n\n    # If the barn is empty, break the loop\n    if grains == 0:\n        break\n\n# Print the number of the day when the barn becomes empty\nprint(days)"}
{"solution": "def min_draws_to_win(tiles):\n    # Parse the input tiles\n    tile1, tile2, tile3 = tiles.split()\n    \n    # Extract numbers and suits\n    num1, suit1 = int(tile1[0]), tile1[1]\n    num2, suit2 = int(tile2[0]), tile2[1]\n    num3, suit3 = int(tile3[0]), tile3[1]\n    \n    # Check for koutsu (triplet)\n    if tile1 == tile2 == tile3:\n        return 0\n    \n    # Check for shuntsu (sequence)\n    def is_shuntsu(n1, n2, n3):\n        return sorted([n1, n2, n3]) in [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7], [6, 7, 8], [7, 8, 9]]\n    \n    if suit1 == suit2 == suit3 and is_shuntsu(num1, num2, num3):\n        return 0\n    \n    # Check for possible koutsu with one more draw\n    if tile1 == tile2 or tile1 == tile3 or tile2 == tile3:\n        return 1\n    \n    # Check for possible shuntsu with one more draw\n    def needs_one_for_shuntsu(n1, n2):\n        return abs(n1 - n2) == 1 or abs(n1 - n2) == 2\n    \n    if suit1 == suit2 and needs_one_for_shuntsu(num1, num2):\n        return 1\n    if suit1 == suit3 and needs_one_for_shuntsu(num1, num3):\n        return 1\n    if suit2 == suit3 and needs_one_for_shuntsu(num2, num3):\n        return 1\n    \n    # If no koutsu or shuntsu can be formed with one more draw, return 2\n    return 2"}
{"solution": "import sys\n\ndef find_sofa(n, m, d, x, y, cnt_l, cnt_r, cnt_t, cnt_b):\n    # Initialize a matrix to store the positions of the sofas\n    sofa_matrix = [[0 for _ in range(m)] for _ in range(n)]\n\n    # Fill the matrix with the positions of the sofas\n    for i in range(d):\n        sofa_matrix[x[i]][y[i]] = i + 1\n\n    # Initialize a variable to store the number of the sofa that meets the conditions\n    sofa_number = -1\n\n    # Iterate through the matrix and find the sofa that meets the conditions\n    for i in range(n):\n        for j in range(m):\n            if sofa_matrix[i][j]!= 0:\n                # Check if the sofa is to the left of the grandpa's sofa\n                if sofa_matrix[i][j - 1] == 0 and cnt_l == 0:\n                    sofa_number = sofa_matrix[i][j]\n                    break\n                # Check if the sofa is to the right of the grandpa's sofa\n                elif sofa_matrix[i][j + 1] == 0 and cnt_r == 0:\n                    sofa_number = sofa_matrix[i][j]\n                    break\n                # Check if the sofa is to the top of the grandpa's sofa\n                elif sofa_matrix[i - 1][j] == 0 and cnt_t == 0:\n                    sofa_number = sofa_matrix[i][j]\n                    break\n                # Check if the sofa is to the bottom of the grandpa's sofa\n                elif sofa_matrix[i + 1][j] == 0 and cnt_b == 0:\n                    sofa_number = sofa_matrix[i][j]\n                    break\n\n    return sofa_number\n\nif __name__ == '__main__':\n    n, m, d = map(int, input().split())\n    x = [int(x) for x in input().split()]\n    y = [int(y) for y in input().split()]\n    cnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\n    sofa_number = find_sofa(n, m, d, x, y, cnt_l, cnt_r, cnt_t, cnt_b)\n\n    print(sofa_number)"}
{"solution": "def mars_days_off(n):\n    full_weeks = n // 7\n    remaining_days = n % 7\n    \n    min_days_off = full_weeks * 2\n    max_days_off = full_weeks * 2 + min(remaining_days, 2)\n    \n    return min_days_off, max_days_off\n\nn = int(input())\nmin_days_off, max_days_off = mars_days_off(n)\nprint(min_days_off, max_days_off)"}
{"solution": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    long long n, a, b, p, q;\n    cin >> n >> a >> b >> p >> q;\n\n    long long redTiles = 0, blueTiles = 0, bothTiles = 0;\n    for (long long i = 1; i <= n; i++) {\n        if (i % a == 0 && i % b == 0) {\n            bothTiles++;\n        } else if (i % a == 0) {\n            redTiles++;\n        } else if (i % b == 0) {\n            blueTiles++;\n        }\n    }\n\n    long long totalChocolates = redTiles * p + blueTiles * q + bothTiles * max(p, q);\n\n    cout << totalChocolates << endl;\n\n    return 0;\n}"}
{"solution": "n = int(input())\ntrophies = input()\n\n# Initialize the maximum length of the longest subsegment of golden trophies\nmax_length = 0\n\n# Iterate through the trophies and check if the current subsegment is the longest one\nfor i in range(n):\n    if trophies[i] == 'G':\n        current_length = 1\n        for j in range(i+1, n):\n            if trophies[j] == 'G':\n                current_length += 1\n        if current_length > max_length:\n            max_length = current_length\n\nprint(max_length)"}
{"solution": "import sys\n\nn, k = map(int, input().split())\nmain_courses = set(map(int, input().split()))\n\ncourses = []\nfor i in range(n):\n    t = int(input())\n    courses.append(set(map(int, input().split())))\n\ndef get_order(courses, main_courses):\n    order = []\n    for course in courses:\n        if course in main_courses:\n            order.append(course)\n            main_courses.remove(course)\n        elif not courses[course]:\n            order.append(course)\n    return order\n\norder = get_order(courses, main_courses)\nif not order:\n    print(-1)\nelse:\n    print(len(order))\n    print(*order)"}
{"solution": "import sys\n\nn, k = map(int, input().split())\np = list(map(int, input().split()))\n\n# Initialize the stack and the remaining elements of the permutation\nstack = []\nremaining = [i for i in range(1, n + 1) if i not in p[:k]]\n\n# Sort the first k elements of the permutation in non-descending order\np.sort()\n\n# Iterate through the remaining elements of the permutation\nfor i in range(k, n):\n    # If the current element is greater than the top element of the stack, push it onto the stack\n    if p[i] > stack[-1]:\n        stack.append(p[i])\n    # If the current element is less than or equal to the top element of the stack, pop elements from the stack until the top element is less than or equal to the current element\n    else:\n        while stack and stack[-1] > p[i]:\n            stack.pop()\n        # If the stack is empty, the permutation is not stack-sortable\n        if not stack:\n            print(-1)\n            sys.exit()\n        # Push the current element onto the stack\n        stack.append(p[i])\n\n# If the stack is not empty, the permutation is stack-sortable\nif stack:\n    # Print the lexicographically maximal permutation\n    print(\" \".join(map(str, p)))\nelse:\n    print(-1)"}
{"solution": "def does_b_appear_in_sequence(a, b, c):\n    if c == 0:\n        return \"YES\" if a == b else \"NO\"\n    else:\n        if (b - a) % c == 0 and (b - a) // c >= 0:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n# Example usage:\na, b, c = map(int, input().split())\nprint(does_b_appear_in_sequence(a, b, c))"}
{"solution": "def can_form_regular_sequence(cnt_1, cnt_2, cnt_3, cnt_4):\n    if cnt_1 == cnt_4:\n        return 1\n    else:\n        return 0\n\n# Example usage:\ncnt_1 = int(input())\ncnt_2 = int(input())\ncnt_3 = int(input())\ncnt_4 = int(input())\n\nprint(can_form_regular_sequence(cnt_1, cnt_2, cnt_3, cnt_4))"}
{"solution": "import sys\n\nn, k, t = map(int, sys.stdin.readline().split())\n\n# Initialize the number of standing spectators to 0\nstanding_spectators = 0\n\n# Iterate through the time steps\nfor i in range(t):\n    # If the current time step is a multiple of k, increase the number of standing spectators\n    if i % k == 0:\n        standing_spectators += 1\n\n# Print the number of standing spectators at time t\nprint(standing_spectators)"}
{"solution": "def lexicographically_minimal_string(s):\n    t = []\n    u = []\n    min_char = min(s)\n    s = list(s)\n    \n    while s or t:\n        if t and (not s or t[-1] <= min_char):\n            u.append(t.pop())\n        else:\n            char = s.pop(0)\n            t.append(char)\n            if s:\n                min_char = min(s)\n    \n    return ''.join(u)\n\n# Example usage:\ns = input().strip()\nprint(lexicographically_minimal_string(s))"}
{"solution": "import sys\n\ndef is_correct_sequence(stats):\n    # Check if the number of plays and clears are consistent\n    for i in range(len(stats) - 1):\n        if stats[i][0]!= stats[i + 1][0] and stats[i][1]!= stats[i + 1][1]:\n            return False\n    return True\n\ndef main():\n    num_test_cases = int(input())\n    for i in range(num_test_cases):\n        num_moments = int(input())\n        stats = []\n        for j in range(num_moments):\n            plays, clears = map(int, input().split())\n            stats.append((plays, clears))\n        if is_correct_sequence(stats):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import re\n\ndef is_palindrome(time):\n    return time == time[::-1]\n\ndef get_next_palindrome(time):\n    h, m = map(int, time.split(':'))\n    while not is_palindrome(time):\n        m += 1\n        if m == 60:\n            h += 1\n            m = 0\n        time = f'{h:02d}:{m:02d}'\n    return time\n\ndef get_minutes_to_next_palindrome(time):\n    next_palindrome = get_next_palindrome(time)\n    h, m = map(int, time.split(':'))\n    next_h, next_m = map(int, next_palindrome.split(':'))\n    return (next_h - h) * 60 + (next_m - m)\n\nif __name__ == '__main__':\n    time = input()\n    print(get_minutes_to_next_palindrome(time))"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Find the minimum and maximum elements\nmin_idx = a.index(min(a))\nmax_idx = a.index(max(a))\n\n# Calculate the distance between the minimum and maximum elements\ndistance = abs(min_idx - max_idx)\n\n# Swap the minimum and maximum elements\na[min_idx], a[max_idx] = a[max_idx], a[min_idx]\n\n# Calculate the new distance between the minimum and maximum elements\nnew_distance = abs(a.index(min(a)) - a.index(max(a)))\n\n# Print the maximum possible distance\nprint(max(distance, new_distance))"}
{"solution": "def is_s_palindrome(s):\n    n = len(s)\n    mid = n // 2\n    if n % 2 == 0:\n        first_half = s[:mid]\n        second_half = s[mid:]\n    else:\n        first_half = s[:mid]\n        second_half = s[mid+1:]\n    \n    if first_half == second_half[::-1]:\n        return \"TAK\"\n    else:\n        return \"NIE\"\n\n# Example usage:\ns = input().strip()\nprint(is_s_palindrome(s))"}
{"solution": "import sys\n\na, b = map(int, sys.stdin.readline().split())\n\n# Convert a to a list of digits\na_digits = [int(x) for x in str(a)]\n\n# Sort the digits in descending order\na_digits.sort(reverse=True)\n\n# Create a new list to store the permutations\npermutations = []\n\n# Iterate through the digits of a and create permutations\nfor i in range(len(a_digits)):\n    permutations.append(a_digits[i])\n    a_digits.remove(a_digits[i])\n\n# Sort the permutations in descending order\npermutations.sort(reverse=True)\n\n# Find the first permutation that is not greater than b\nfor i in range(len(permutations)):\n    if permutations[i] <= b:\n        print(permutations[i])\n        break\nelse:\n    print(-1)"}
{"solution": "def check_win(matrix):\n    # Check if there is a horizontal line of length 5 or more\n    for i in range(10):\n        for j in range(8):\n            if matrix[i][j] == 'X' and matrix[i][j+1] == 'X' and matrix[i][j+2] == 'X' and matrix[i][j+3] == 'X' and matrix[i][j+4] == 'X':\n                return 'YES'\n    \n    # Check if there is a vertical line of length 5 or more\n    for i in range(10):\n        for j in range(8):\n            if matrix[j][i] == 'X' and matrix[j+1][i] == 'X' and matrix[j+2][i] == 'X' and matrix[j+3][i] == 'X' and matrix[j+4][i] == 'X':\n                return 'YES'\n    \n    # Check if there is a diagonal line of length 5 or more\n    for i in range(10):\n        for j in range(8):\n            if matrix[i-j][j] == 'X' and matrix[i-j+1][j+1] == 'X' and matrix[i-j+2][j+2] == 'X' and matrix[i-j+3][j+3] == 'X' and matrix[i-j+4][j+4] == 'X':\n                return 'YES'\n    \n    return 'NO'"}
{"solution": "def solve(n, k):\n    # Initialize the matrix with zeroes\n    matrix = [[0] * n for _ in range(n)]\n\n    # Place the k ones in the matrix symmetrically and lexicographically maximally\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] = 1\n            elif i + j == n - 1:\n                matrix[i][j] = 1\n            else:\n                matrix[i][j] = 0\n\n    # Check if the resulting matrix is symmetrical with respect to the main diagonal\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j]!= matrix[j][i]:\n                return -1\n\n    # Check if the resulting matrix is lexicographically maximal\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] > matrix[j][i]:\n                return -1\n\n    return matrix"}
{"solution": "import math\n\ndef get_max_expression(x, y, z):\n    expressions = [\n        x**y**z,\n        x**z**y,\n        (x**y)**z,\n        (x**z)**y,\n        y**x**z,\n        y**z**x,\n        (y**x)**z,\n        (y**z)**x,\n        z**x**y,\n        z**y**x,\n        (z**x)**y,\n        (z**y)**x\n    ]\n    return max(expressions)\n\ndef get_expression_string(expression):\n    if expression == x**y**z:\n        return \"x^y^z\"\n    elif expression == x**z**y:\n        return \"x^z^y\"\n    elif expression == (x**y)**z:\n        return \"(x^y)^z\"\n    elif expression == (x**z)**y:\n        return \"(x^z)^y\"\n    elif expression == y**x**z:\n        return \"y^x^z\"\n    elif expression == y**z**x:\n        return \"y^z^x\"\n    elif expression == (y**x)**z:\n        return \"(y^x)^z\"\n    elif expression == (y**z)**x:\n        return \"(y^z)^x\"\n    elif expression == z**x**y:\n        return \"z^x^y\"\n    elif expression == z**y**x:\n        return \"z^y^x\"\n    elif expression == (z**x)**y:\n        return \"(z^x)^y\"\n    elif expression == (z**y)**x:\n        return \"(z^y)^x\"\n\ndef main():\n    x, y, z = map(float, input().split())\n    expression = get_max_expression(x, y, z)\n    expression_string = get_expression_string(expression)\n    print(expression_string)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n = int(input())\ns = input()\n\n# Initialize variables\noperations = 0\ncopy_count = 0\n\n# Iterate through the string\nfor i in range(n):\n    # If the current character is the same as the previous character, increment the copy count\n    if i > 0 and s[i] == s[i-1]:\n        copy_count += 1\n    # If the copy count is greater than 0, copy the string and append the current character\n    if copy_count > 0:\n        s += s[:copy_count] + s[i]\n        copy_count = 0\n    # Increment the operation count\n    operations += 1\n\n# Print the minimum number of operations\nprint(operations)"}
{"solution": "import sys\n\nn = int(input())\nfiles = []\n\nfor i in range(n):\n    name, type = input().split()\n    files.append((name, int(type)))\n\n# Sort the files by type\nfiles.sort(key=lambda x: x[1])\n\n# Initialize the output\noutput = []\n\n# Iterate through the files and generate the output\nfor i, (name, type) in enumerate(files):\n    if type == 1:\n        # If the file is an example, rename it to a distinct integer\n        new_name = str(i + 1)\n    else:\n        # If the file is a regular test, rename it to a distinct integer\n        # after the last example\n        new_name = str(len(files) - i)\n    output.append(f\"move {name} {new_name}\")\n\n# Print the output\nprint(len(output))\nprint(\"\\n\".join(output))"}
{"solution": "def get_min_replacements(ticket):\n    # Initialize variables\n    first_sum = 0\n    last_sum = 0\n    replacements = 0\n\n    # Calculate the sum of the first three digits\n    for i in range(3):\n        first_sum += int(ticket[i])\n\n    # Calculate the sum of the last three digits\n    for i in range(3, 6):\n        last_sum += int(ticket[i])\n\n    # Check if the sums are equal\n    if first_sum == last_sum:\n        return 0\n\n    # If the sums are not equal, calculate the minimum number of replacements needed\n    for i in range(6):\n        if ticket[i] == '0':\n            replacements += 1\n        elif ticket[i]!= '0' and first_sum > last_sum:\n            replacements += 1\n            first_sum -= int(ticket[i])\n            last_sum += int(ticket[i])\n        elif ticket[i]!= '0' and first_sum < last_sum:\n            replacements += 1\n            first_sum += int(ticket[i])\n            last_sum -= int(ticket[i])\n\n    return replacements"}
{"solution": "def minimum_traps(m, x):\n    return m - 1"}
{"solution": "  import math\n\ndef birthday_paradox(n, k):\n    # Calculate the probability of at least two people having the same birthday\n    probability = 1 - math.factorial(2**n) / (math.factorial(2**n - k) * math.factorial(k))\n\n    # Calculate the values of A and B\n    A = int(probability * (10**6 + 3))\n    B = int(10**6 + 3)\n\n    # Return the values of A and B\n    return A, B\n\n# Test the function with the given input\nn = 3\nk = 2\nprint(birthday_paradox(n, k))\n# Output: (1, 8)\n\nn = 1\nk = 3\nprint(birthday_paradox(n, k))\n# Output: (1, 1)\n\nn = 4\nk = 3\nprint(birthday_paradox(n, k))\n# Output: (23, 128)"}
{"solution": "n = int(input())\n\n# Initialize the position of Limak as the North Pole\nposition = \"North\"\n\n# Iterate through the n parts of the journey\nfor i in range(n):\n    # Get the length and direction of the i-th part of the journey\n    t, dir = map(int, input().split())\n    \n    # Check if Limak is on the North or South Pole\n    if position == \"North\":\n        # Limak is on the North Pole, so he can only move South\n        if dir == \"South\":\n            # Update the position and move the required distance\n            position = \"South\"\n            t -= 20000\n        else:\n            # Limak cannot move North from the North Pole\n            print(\"NO\")\n            break\n    elif position == \"South\":\n        # Limak is on the South Pole, so he can only move North\n        if dir == \"North\":\n            # Update the position and move the required distance\n            position = \"North\"\n            t -= 20000\n        else:\n            # Limak cannot move South from the South Pole\n            print(\"NO\")\n            break\n    \n    # Check if the journey ends on the North Pole\n    if t == 0 and position == \"North\":\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "import sys\n\ndef solve(a1, b1, a2, b2, L, R):\n    # Find the common elements in the two progressions\n    common_elements = set(range(L, R+1)).intersection(set(a1*k + b1 for k in range(L, R+1)))\n    common_elements = set(common_elements).intersection(set(a2*l + b2 for l in range(L, R+1)))\n\n    # Return the number of common elements\n    return len(common_elements)\n\nif __name__ == \"__main__\":\n    a1, b1, a2, b2, L, R = map(int, sys.stdin.readline().split())\n    print(solve(a1, b1, a2, b2, L, R))"}
{"solution": "n, a, b = map(int, input().split())\n\n# Initialize the number of pieces on each plate to 0\nplates = [0] * n\n\n# Initialize the number of pieces of each cake to 0\ncake1 = 0\ncake2 = 0\n\n# Loop through each plate\nfor i in range(n):\n    # If the current plate is not full, add a piece of cake to it\n    if plates[i] < a:\n        plates[i] += 1\n        cake1 += 1\n    # If the current plate is full, add a piece of cake to the next plate\n    else:\n        plates[i + 1] += 1\n        cake2 += 1\n\n# Print the maximum number of pieces on each plate\nprint(max(plates))"}
{"solution": "n, m = map(int, input().split())\nfield = [input() for _ in range(n)]\n\n# Check if the field is rectangular\nif len(set(map(len, field)))!= 1:\n    print(\"NO\")\n    exit()\n\n# Check if the field has three colors\nif len(set(field[0]))!= 3:\n    print(\"NO\")\n    exit()\n\n# Check if the stripes are equal in width and height\nif not all(len(row) == len(field[0]) for row in field):\n    print(\"NO\")\n    exit()\n\n# Check if each color is used exactly once\nif not all(len(row) == len(set(row)) for row in field):\n    print(\"NO\")\n    exit()\n\n# Check if the stripes are parralel to each other and to the sides of the flag\nif not all(row[0] == row[-1] for row in field):\n    print(\"NO\")\n    exit()\n\nprint(\"YES\")"}
{"solution": "import math\n\ndef spiral_moves(n):\n    # Calculate the number of moves in each direction\n    moves_right = int(n / 2)\n    moves_left = int(n / 2)\n    moves_up = int(n / 2)\n    moves_down = int(n / 2)\n\n    # Calculate the current position\n    x = 0\n    y = 0\n\n    # Iterate through the moves\n    for i in range(n):\n        # Move right\n        if i < moves_right:\n            x += 1\n        # Move left\n        elif i < moves_right + moves_left:\n            x -= 1\n        # Move up\n        elif i < moves_right + moves_left + moves_up:\n            y += 1\n        # Move down\n        else:\n            y -= 1\n\n    return x, y\n\nn = int(input())\nx, y = spiral_moves(n)\nprint(x, y)"}
{"solution": "import math\n\ndef can_break_shield(a, b, c):\n    # Calculate the greatest common divisor of a and b\n    gcd_ab = math.gcd(a, b)\n    \n    # Check if c is divisible by the gcd of a and b\n    if c % gcd_ab == 0:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read input values\na, b, c = map(int, input().split())\n\n# Output the result\nprint(can_break_shield(a, b, c))"}
{"solution": "n, L = map(int, input().split())\nkefa_barriers = list(map(int, input().split()))\nsasha_barriers = list(map(int, input().split()))\n\n# Calculate distances between consecutive barriers for Kefa\nkefa_distances = [(kefa_barriers[(i + 1) % n] - kefa_barriers[i]) % L for i in range(n)]\n# Calculate distances between consecutive barriers for Sasha\nsasha_distances = [(sasha_barriers[(i + 1) % n] - sasha_barriers[i]) % L for i in range(n)]\n\n# Double the kefa_distances to handle circular rotation\ndoubled_kefa_distances = kefa_distances + kefa_distances\n\n# Check if sasha_distances is a sublist of doubled_kefa_distances\nfor i in range(n):\n    if doubled_kefa_distances[i:i + n] == sasha_distances:\n        print(\"YES\")\n        break\nelse:\n    print(\"NO\")"}
{"solution": "def longest_non_palindromic_substring(s):\n    # Initialize variables\n    max_length = 0\n    current_length = 0\n    is_palindrome = True\n\n    # Iterate through the string\n    for i in range(len(s)):\n        # Check if the substring is a palindrome\n        if s[i] == s[len(s) - i - 1]:\n            current_length += 1\n        else:\n            # If the substring is not a palindrome, check if it's longer than the current maximum\n            if current_length > max_length:\n                max_length = current_length\n                is_palindrome = False\n            current_length = 0\n\n    # If the entire string is a palindrome, return 0\n    if is_palindrome:\n        return 0\n\n    # Otherwise, return the maximum length of the non-palindromic substring\n    return max_length"}
{"solution": "n = int(input())\na = [int(input()) for _ in range(n)]\nb = [int(input()) for _ in range(n)]\n\nif any(a[i]!= b[i] for i in range(n)):\n    print(\"rated\")\nelif all(a[i] == b[i] for i in range(n)):\n    print(\"unrated\")\nelse:\n    print(\"maybe\")"}
{"solution": "def find_nearest_zero(arr):\n    n = len(arr)\n    d = [0] * n\n    for i in range(n):\n        if arr[i] == 0:\n            d[i] = 0\n        else:\n            j = i + 1\n            while j < n and arr[j]!= 0:\n                j += 1\n            d[i] = j - i\n    return d"}
{"solution": "def count_distinct_cyclical_strings(n, s):\n    from itertools import product\n    \n    def is_substring_in_cyclical_shifts(t, s):\n        t_extended = t + t\n        return any(s in t_extended[i:i+len(t)] for i in range(len(t)))\n    \n    distinct_cyclical_strings = set()\n    \n    for bits in product('01', repeat=n):\n        t = ''.join(bits)\n        if is_substring_in_cyclical_shifts(t, s):\n            distinct_cyclical_strings.add(t)\n    \n    return len(distinct_cyclical_strings)\n\n# Example usage\nn = int(input())\ns = input().strip()\nprint(count_distinct_cyclical_strings(n, s))"}
{"solution": "import sys\n\nn = int(input())\nvectors = []\n\nfor i in range(n):\n    x, y = map(int, input().split())\n    vectors.append((x, y))\n\n# Calculate the angle between each pair of vectors\nangles = []\nfor i in range(n):\n    for j in range(i+1, n):\n        angle = calculate_angle(vectors[i], vectors[j])\n        angles.append((i, j, angle))\n\n# Find the pair with the minimal non-oriented angle\nmin_angle = float('inf')\nmin_pair = None\nfor pair in angles:\n    if pair[2] < min_angle:\n        min_angle = pair[2]\n        min_pair = pair\n\n# Print the indices of the vectors with the minimal non-oriented angle\nprint(min_pair[0], min_pair[1])\n\ndef calculate_angle(v1, v2):\n    # Calculate the dot product of the two vectors\n    dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n\n    # Calculate the magnitude of the two vectors\n    mag1 = (v1[0] ** 2 + v1[1] ** 2) ** 0.5\n    mag2 = (v2[0] ** 2 + v2[1] ** 2) ** 0.5\n\n    # Calculate the cosine of the angle between the two vectors\n    cos_angle = dot_product / (mag1 * mag2)\n\n    # Calculate the angle between the two vectors\n    angle = math.acos(cos_angle)\n\n    return angle"}
{"solution": "def minimal_time(d, k, a, b, t):\n    if d <= k:\n        return d * a\n    \n    # Full segments\n    full_segments = d // k\n    remaining_distance = d % k\n    \n    # Time for full segments\n    time_for_full_segments = full_segments * k * a + (full_segments - 1) * t\n    \n    # Time for remaining distance\n    if remaining_distance == 0:\n        return time_for_full_segments\n    else:\n        # Option 1: Drive the remaining distance\n        time_drive_remaining = remaining_distance * a + t\n        # Option 2: Walk the remaining distance\n        time_walk_remaining = remaining_distance * b\n        \n        return time_for_full_segments + min(time_drive_remaining, time_walk_remaining)"}
{"solution": "import sys\n\nn, k = map(int, input().split())\n\n# Initialize the sequence with the first element\nsequence = [1]\n\n# Loop through the remaining elements\nfor i in range(1, k):\n    # Find the next element in the sequence\n    next_element = find_next_element(sequence, n)\n\n    # Add the next element to the sequence\n    sequence.append(next_element)\n\n# Print the sequence\nprint(sequence)\n\ndef find_next_element(sequence, n):\n    # Find the greatest common divisor of the sequence\n    gcd = find_gcd(sequence)\n\n    # Find the next element in the sequence\n    next_element = find_next_element_helper(sequence, n, gcd)\n\n    return next_element\n\ndef find_gcd(sequence):\n    # Initialize the greatest common divisor\n    gcd = 1\n\n    # Loop through the elements of the sequence\n    for element in sequence:\n        # Find the greatest common divisor of the element and the current gcd\n        gcd = find_gcd_helper(element, gcd)\n\n    return gcd\n\ndef find_gcd_helper(element, gcd):\n    # Find the greatest common divisor of the element and the current gcd\n    gcd = max(gcd, element)\n\n    # Loop through the factors of the element\n    for factor in range(2, element):\n        # If the factor is a divisor of the element and the current gcd\n        if element % factor == 0 and gcd % factor == 0:\n            # Update the greatest common divisor\n            gcd = factor\n\n    return gcd\n\ndef find_next_element_helper(sequence, n, gcd):\n    # Initialize the next element\n    next_element = 1\n\n    # Loop through the elements of the sequence\n    for element in sequence:\n        # Find the next element in the sequence\n        next_element = find_next_element_helper_helper(element, next_element, n, gcd)\n\n    return next_element\n\ndef find_next_element_helper_helper(element, next_element, n, gcd):\n    # Find the next element in the sequence\n    next_element = element + 1\n\n    # Loop through the factors of the element\n    for factor in range(2, element):\n        # If the factor is a divisor of the element and the current gcd\n        if element % factor == 0 and gcd % factor == 0:\n            # Update the next element\n            next_element = factor\n\n    return next_element"}
{"solution": "import sys\n\nn, m = map(int, input().split())\n\ncount = 0\nfor x in range(1, n+1):\n    for y in range(1, m+1):\n        if (x + y) % 5 == 0:\n            count += 1\n\nprint(count)"}
{"solution": "import sys\n\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Initialize the maximum beauty of the array to 0\nmax_beauty = 0\n\n# Iterate over all possible subarrays\nfor i in range(n):\n    for j in range(i, n):\n        # Calculate the sum of the subarray\n        subarray_sum = sum(a[i:j+1])\n        # Multiply the subarray by x\n        subarray_sum *= x\n        # Calculate the beauty of the subarray\n        subarray_beauty = subarray_sum - sum(a[i:j+1])\n        # Update the maximum beauty of the array\n        max_beauty = max(max_beauty, subarray_beauty)\n\n# Print the maximum beauty of the array\nprint(max_beauty)"}
{"solution": "def find_kth_largest(n, m, k):\n    def count_less_equal(x):\n        count = 0\n        for i in range(1, n + 1):\n            count += min(m, x // i)\n        return count\n\n    low, high = 1, n * m\n    while low < high:\n        mid = (low + high) // 2\n        if count_less_equal(mid) < k:\n            low = mid + 1\n        else:\n            high = mid\n    return low"}
{"solution": "import sys\n\nk = int(sys.stdin.readline())\n\n# Initialize the sequence with the first 10 numbers\nsequence = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n# Iterate through the sequence and calculate the next number\nfor i in range(10, k):\n    sequence.append(sequence[i-1] + sequence[i-2])\n\n# Print the k-th digit of the sequence\nprint(sequence[k-1])"}
{"solution": "import sys\n\nn, m, r = map(int, input().split())\ns = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Initialize the maximum number of bourles to 0\nmax_bourles = 0\n\n# Loop through each opportunity to buy shares\nfor i in range(n):\n    # Calculate the number of shares that can be bought with the current opportunity\n    num_shares = r // s[i]\n    \n    # Update the maximum number of bourles based on the current opportunity\n    max_bourles = max(max_bourles, num_shares * s[i])\n\n# Loop through each opportunity to sell shares\nfor i in range(m):\n    # Calculate the number of shares that can be sold with the current opportunity\n    num_shares = min(r // b[i], num_shares)\n    \n    # Update the maximum number of bourles based on the current opportunity\n    max_bourles = max(max_bourles, num_shares * b[i])\n\n# Print the maximum number of bourles\nprint(max_bourles)"}
{"solution": "def find_original_message(t):\n    n = len(t)\n    \n    # \u041f\u0435\u0440\u0435\u0431\u0438\u0440\u0430\u0435\u043c \u0432\u0441\u0435 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u0434\u043b\u0438\u043d\u044b \u043d\u0430\u043b\u043e\u0436\u0435\u043d\u0438\u044f\n    for overlap in range(1, n // 2 + 1):\n        # \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u0441\u043e\u0432\u043f\u0430\u0434\u0430\u044e\u0442 \u043b\u0438 \u043d\u0430\u0447\u0430\u043b\u043e \u0441\u0442\u0440\u043e\u043a\u0438 t \u0434\u043b\u0438\u043d\u043e\u0439 overlap \u0438 \u043a\u043e\u043d\u0435\u0446 \u0441\u0442\u0440\u043e\u043a\u0438 t \u0434\u043b\u0438\u043d\u043e\u0439 overlap\n        if t[:overlap] == t[-overlap:]:\n            s = t[:-overlap]\n            if s + t[-overlap:] == t:\n                return \"YES\", s\n    \n    return \"NO\", None\n\n# \u0427\u0442\u0435\u043d\u0438\u0435 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\nt = input().strip()\n\n# \u041f\u043e\u0438\u0441\u043a \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0433\u043e \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f s\nresult, s = find_original_message(t)\n\n# \u0412\u044b\u0432\u043e\u0434 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430\nprint(result)\nif result == \"YES\":\n    print(s)"}
{"solution": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    int teams = 1;\n    int games = 0;\n\n    while (games < n) {\n        if (teams % 2 == 0) {\n            games += teams / 2;\n        } else {\n            games += (teams - 1) / 2;\n        }\n        teams++;\n    }\n\n    if (games == n) {\n        cout << teams << endl;\n    } else {\n        cout << -1 << endl;\n    }\n\n    return 0;\n}"}
{"solution": "import sys\n\nn = int(input())\ns = input()\nb = list(map(int, input().split()))\n\n# Initialize the maximum beauty as 0\nmax_beauty = 0\n\n# Iterate through each permutation of the string\nfor i in range(len(s)):\n    # Check if the permutation is antipalindromic\n    if is_antipalindromic(s[i:]):\n        # Calculate the beauty of the permutation\n        beauty = sum(b[i:])\n        # Update the maximum beauty if necessary\n        if beauty > max_beauty:\n            max_beauty = beauty\n\n# Print the maximum beauty\nprint(max_beauty)\n\n# Function to check if a string is antipalindromic\ndef is_antipalindromic(s):\n    # Check if the length of the string is even\n    if len(s) % 2 == 0:\n        # Iterate through each character in the string\n        for i in range(len(s)):\n            # Check if the character is not equal to the character at the opposite index\n            if s[i]!= s[len(s) - i - 1]:\n                # If the character is not equal, return False\n                return False\n        # If all characters are equal, return True\n        return True\n    # If the length of the string is odd, return False\n    return False"}
{"solution": "import sys\n\ndef can_weight(weights, item_mass):\n    # Initialize a dictionary to store the weights and their counts\n    weight_counts = {}\n    for weight in weights:\n        if weight not in weight_counts:\n            weight_counts[weight] = 1\n        else:\n            weight_counts[weight] += 1\n\n    # Initialize a set to store the weights that have been used\n    used_weights = set()\n\n    # Iterate through the weights and their counts\n    for weight, count in weight_counts.items():\n        # If the weight has been used, continue to the next weight\n        if weight in used_weights:\n            continue\n\n        # If the weight is not a factor of the item mass, continue to the next weight\n        if item_mass % weight!= 0:\n            continue\n\n        # If the weight is a factor of the item mass, add it to the used weights set\n        used_weights.add(weight)\n\n        # If the weight is a factor of the item mass and it has not been used, continue to the next weight\n        if weight not in used_weights:\n            continue\n\n        # If the weight is a factor of the item mass and it has been used, subtract it from the item mass\n        item_mass -= weight\n\n    # If the item mass is 0, return True\n    if item_mass == 0:\n        return True\n\n    # If the item mass is not 0, return False\n    return False\n\nif __name__ == \"__main__\":\n    # Read the input from stdin\n    weights = list(map(int, input().split()))\n    item_mass = int(input())\n\n    # Call the can_weight function and print the result\n    print(\"YES\" if can_weight(weights, item_mass) else \"NO\")"}
{"solution": "  import sys\n\nn, k = map(int, input().split())\n\ndef find_sequence(n, k):\n    # Initialize the sequence with the largest possible value\n    sequence = [10**18] * k\n    \n    # Start from the largest power of 2 and work backwards\n    for i in range(k-1, -1, -1):\n        # Find the largest power of 2 that is less than or equal to n\n        power = 2**i\n        while power > n:\n            power //= 2\n        \n        # Add the power to the sequence\n        sequence[i] = power\n        n -= power\n    \n    # If there is still some value left, it is not possible to find a sequence\n    if n > 0:\n        return None\n    \n    # Return the sequence\n    return sequence\n\nsequence = find_sequence(n, k)\n\nif sequence is None:\n    print(\"No\")\nelse:\n    print(\"Yes\")\n    print(\" \".join(map(str, sequence)))"}
{"solution": ""}
{"solution": "n = int(input())\nvertices = [tuple(map(int, input().split())) for _ in range(n)]\n\nif n == 1:\n    return -1\nelif n == 2:\n    x1, y1 = vertices[0]\n    x2, y2 = vertices[1]\n    if x1!= x2 and y1!= y2:\n        return abs(x1 - x2) * abs(y1 - y2)\n    else:\n        return -1\nelif n == 3:\n    x_coords = set()\n    y_coords = set()\n    for x, y in vertices:\n        x_coords.add(x)\n        y_coords.add(y)\n    if len(x_coords) == 2 and len(y_coords) == 2:\n        x1, x2 = x_coords\n        y1, y2 = y_coords\n        return abs(x1 - x2) * abs(y1 - y2)\n    else:\n        return -1\nelif n == 4:\n    x_coords = set()\n    y_coords = set()\n    for x, y in vertices:\n        x_coords.add(x)\n        y_coords.add(y)\n    if len(x_coords) == 2 and len(y_coords) == 2:\n        x1, x2 = x_coords\n        y1, y2 = y_coords\n        return abs(x1 - x2) * abs(y1 - y2)\n    else:\n        return -1"}
{"solution": "n = int(input())\na = int(input())\nb = int(input())\n\n# Calculate the total length of the sides of the frames\ntotal_length = 2 * a + 2 * b\n\n# Calculate the number of wooden bars needed\nnum_bars = total_length // n\n\n# Print the output\nprint(num_bars)"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\nswap_allowed = input()\n\n# Check if the array is already sorted\nif a == sorted(a):\n    print(\"YES\")\n    sys.exit()\n\n# Check if the array can be sorted by swapping adjacent elements\nfor i in range(n - 1):\n    if swap_allowed[i] == \"1\":\n        a[i], a[i + 1] = a[i + 1], a[i]\n        if a == sorted(a):\n            print(\"YES\")\n            sys.exit()\n\n# Check if the array can be sorted by swapping non-adjacent elements\nfor i in range(n - 2):\n    for j in range(i + 2, n):\n        if swap_allowed[i] == \"1\" and swap_allowed[j] == \"1\":\n            a[i], a[j] = a[j], a[i]\n            if a == sorted(a):\n                print(\"YES\")\n                sys.exit()\n\nprint(\"NO\")"}
{"solution": "import sys\n\ndef get_wait_time(seat):\n    row, col = seat\n    row = int(row)\n    col = ord(col) - ord('a') + 1\n    if col <= 3:\n        return row * 2 - 1\n    else:\n        return row * 2\n\nif __name__ == '__main__':\n    seat = sys.stdin.readline().strip()\n    print(get_wait_time(seat))"}
{"solution": "def compare_numbers(x, y):\n    x_base = x[0]\n    y_base = y[0]\n    x_digits = x[1:]\n    y_digits = y[1:]\n\n    if x_base == y_base:\n        return \"=\"\n    elif x_base > y_base:\n        return \">\"\n    else:\n        return \"<\"\n\n\nif __name__ == \"__main__\":\n    x = [int(i) for i in input().split()]\n    y = [int(i) for i in input().split()]\n    print(compare_numbers(x, y))"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(\"BitLGM\")\nelif n == 2:\n    if a[0] == a[1]:\n        print(\"BitAryo\")\n    else:\n        print(\"BitLGM\")\nelse:\n    # Find the minimum element in the list\n    min_element = min(a)\n\n    # Find the index of the minimum element\n    min_index = a.index(min_element)\n\n    # Decrease the minimum element by 1\n    a[min_index] -= 1\n\n    # Find the new minimum element\n    new_min_element = min(a)\n\n    # If the new minimum element is 0, then the other player wins\n    if new_min_element == 0:\n        print(\"BitAryo\")\n    # Otherwise, the current player wins\n    else:\n        print(\"BitLGM\")"}
{"solution": "import sys\n\nn, k = map(int, input().split())\ncards = list(map(int, input().split()))\n\n# Initialize the number of valid ways to choose x and y\nvalid_ways = 0\n\n# Iterate over all possible values of x and y\nfor x in range(n):\n    for y in range(n):\n        # Check if the resulting deck is valid\n        if is_valid_deck(cards, x, y, k):\n            valid_ways += 1\n\nprint(valid_ways)\n\ndef is_valid_deck(cards, x, y, k):\n    # Remove the top x cards and bottom y cards from the deck\n    deck = cards[x:n-y]\n\n    # Calculate the product of all numbers written on the cards in the deck\n    product = 1\n    for card in deck:\n        product *= card\n\n    # Check if the product is divisible by k\n    return product % k == 0"}
{"solution": "n, k = map(int, input().split())\ns = input()\n\n# Initialize a dictionary to keep track of the colors and their counts\ncolors = {}\nfor c in s:\n    if c not in colors:\n        colors[c] = 1\n    else:\n        colors[c] += 1\n\n# Check if any color has an odd number of balloons\nfor c, count in colors.items():\n    if count % 2 == 1:\n        print(\"NO\")\n        exit()\n\n# If all colors have even number of balloons, print YES\nprint(\"YES\")"}
{"solution": "import sys\n\nn = int(input())\narr = list(map(int, input().split()))\n\n# find the positions of the minimum values in the array\nmin_positions = []\nfor i in range(n):\n    if arr[i] == min(arr[i:n]):\n        min_positions.append(i)\n\n# calculate the distance between the two closest minimums\nmin_distance = sys.maxsize\nfor i in range(len(min_positions)):\n    for j in range(i+1, len(min_positions)):\n        distance = abs(min_positions[i] - min_positions[j])\n        if distance < min_distance:\n            min_distance = distance\n\nprint(min_distance)"}
{"solution": "import random\n\ndef get_probability(t, w, b):\n    total_steps = t // min(w, b)\n    tie_cases = 0\n    for i in range(total_steps):\n        if i % w == 0 and i % b == 0:\n            tie_cases += 1\n    return tie_cases / total_steps\n\nt = int(input())\nw = int(input())\nb = int(input())\n\nprobability = get_probability(t, w, b)\n\nprint(f\"{probability:.6f}\")"}
{"solution": "import sys\n\ndef main():\n    x, y, z = map(int, input().split())\n    if x > y:\n        print(\"+\")\n    elif y > x:\n        print(\"-\")\n    else:\n        print(\"0\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def solve(n, sequence, x, y):\n    # Initialize variables\n    min_length = 0\n    max_length = 0\n    changed_subsegment = []\n\n    # Iterate through the sequence\n    for i in range(n):\n        # Check if the current operation is in the changed subsegment\n        if i in changed_subsegment:\n            # If it is, add it to the changed subsegment\n            changed_subsegment.append(i)\n        else:\n            # If it's not, check if it's in the target cell\n            if sequence[i] == 'U' and x == 0 and y == i:\n                # If it is, add it to the changed subsegment\n                changed_subsegment.append(i)\n            elif sequence[i] == 'D' and x == 0 and y == -i:\n                # If it is, add it to the changed subsegment\n                changed_subsegment.append(i)\n            elif sequence[i] == 'L' and y == 0 and x == -i:\n                # If it is, add it to the changed subsegment\n                changed_subsegment.append(i)\n            elif sequence[i] == 'R' and y == 0 and x == i:\n                # If it is, add it to the changed subsegment\n                changed_subsegment.append(i)\n\n    # Calculate the minimum length of the changed subsegment\n    min_length = max(changed_subsegment) - min(changed_subsegment) + 1\n\n    # Return the minimum length\n    return min_length"}
{"solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    \n    results = []\n    \n    for _ in range(T):\n        n = int(data[index])\n        x = int(data[index + 1])\n        s = data[index + 2]\n        index += 3\n        \n        balance_s = s.count('0') - s.count('1')\n        prefix_balances = [0] * (n + 1)\n        \n        for i in range(n):\n            prefix_balances[i + 1] = prefix_balances[i] + (1 if s[i] == '0' else -1)\n        \n        if balance_s == 0:\n            if x in prefix_balances:\n                results.append(-1)\n            else:\n                results.append(0)\n        else:\n            count = 0\n            for b in prefix_balances:\n                if (x - b) % balance_s == 0 and (x - b) // balance_s >= 0:\n                    count += 1\n            results.append(count)\n    \n    for result in results:\n        print(result)"}
{"solution": "import math\n\ndef get_min_digits_to_delete(n, k):\n    # Convert the number to a string\n    n_str = str(n)\n    \n    # Find the length of the number\n    n_len = len(n_str)\n    \n    # Initialize the minimum number of digits to delete\n    min_digits = 0\n    \n    # Iterate through the digits of the number\n    for i in range(n_len):\n        # Get the current digit\n        digit = int(n_str[i])\n        \n        # Check if the digit is divisible by 10^k\n        if digit % (10 ** k) == 0:\n            # If it is, increment the minimum number of digits to delete\n            min_digits += 1\n    \n    # Return the minimum number of digits to delete\n    return min_digits\n\n# Test the function\nn = 30020\nk = 3\nprint(get_min_digits_to_delete(n, k))"}
{"solution": "import sys\n\nn, m, k, x, y = map(int, sys.stdin.readline().split())\n\n# Calculate the maximum number of questions a particular pupil is asked\nmax_questions = 0\nfor i in range(n):\n    for j in range(m):\n        if i == x and j == y:\n            continue\n        max_questions = max(max_questions, k // (n * m - 1))\n\n# Calculate the minimum number of questions a particular pupil is asked\nmin_questions = k // (n * m - 1)\n\n# Calculate how many times the teacher asked Sergei\nsergei_questions = k % (n * m - 1)\n\nprint(max_questions, min_questions, sergei_questions)"}
{"solution": "n = int(input())\n\nribbon_kuro = input()\nribbon_shiro = input()\nribbon_katie = input()\n\ndef get_beauty(ribbon):\n    beauty = 0\n    for i in range(len(ribbon)):\n        if ribbon[i] == ribbon[i-1]:\n            beauty += 1\n    return beauty\n\nbeauty_kuro = get_beauty(ribbon_kuro)\nbeauty_shiro = get_beauty(ribbon_shiro)\nbeauty_katie = get_beauty(ribbon_katie)\n\nif beauty_kuro > beauty_shiro and beauty_kuro > beauty_katie:\n    print(\"Kuro\")\nelif beauty_shiro > beauty_kuro and beauty_shiro > beauty_katie:\n    print(\"Shiro\")\nelif beauty_katie > beauty_kuro and beauty_katie > beauty_shiro:\n    print(\"Katie\")\nelse:\n    print(\"Draw\")"}
{"solution": "  def calculate_days(c, v_0, v_1, a, l):\n    days = 0\n    pages_read = 0\n    while pages_read < c:\n        pages_read += v_0\n        v_0 += a\n        if v_0 > v_1:\n            v_0 = v_1\n        days += 1\n        if pages_read - l >= 0:\n            pages_read -= l\n    return days\n\nprint(calculate_days(5, 5, 10, 5, 4))\nprint(calculate_days(12, 4, 12, 4, 1))\nprint(calculate_days(15, 1, 100, 0, 0))"}
{"solution": "import math\n\ndef find_prime_representation(n):\n    # Find all prime numbers less than or equal to the given number\n    prime_numbers = [2]\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if all(i % p!= 0 for p in prime_numbers):\n            prime_numbers.append(i)\n\n    # Find the prime representation of the given number\n    for k in range(1, 4):\n        for combination in itertools.combinations(prime_numbers, k):\n            if sum(combination) == n:\n                return k, combination\n\n    # If no prime representation is found, return 0\n    return 0, []\n\nn = int(input())\nk, combination = find_prime_representation(n)\nprint(k)\nprint(*combination)"}
{"solution": "import sys\n\nn, m = map(int, input().split())\nfield = [list(input()) for _ in range(n)]\n\n# Count the number of walls in each row and column\nrow_walls = [0] * n\ncol_walls = [0] * m\nfor i in range(n):\n    for j in range(m):\n        if field[i][j] == '*':\n            row_walls[i] += 1\n            col_walls[j] += 1\n\n# Check if there exists a cell (x, y) such that the sum of walls in row x and column y equals the total number of walls\nfor i in range(n):\n    for j in range(m):\n        if row_walls[i] + col_walls[j] == sum(row_walls) + sum(col_walls):\n            print(\"YES\")\n            print(i, j)\n            sys.exit()\n\nprint(\"NO\")"}
{"solution": "import sys\n\nn, m, a, b = map(int, sys.stdin.readline().split())\n\n# Initialize the number of boxes to be divisible by m\nnum_boxes = n\n\n# Initialize the total cost to be paid\ntotal_cost = 0\n\n# While the number of boxes is not divisible by m\nwhile num_boxes % m!= 0:\n    # If the number of boxes is less than m\n    if num_boxes < m:\n        # Build m - num_boxes boxes\n        num_boxes += m - num_boxes\n        total_cost += a * (m - num_boxes)\n    # If the number of boxes is greater than m\n    else:\n        # Demolish num_boxes - m boxes\n        num_boxes -= num_boxes - m\n        total_cost += b * (num_boxes - m)\n\nprint(total_cost)"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Find the maximum odd sum subsequence\nmax_sum = 0\nfor i in range(n):\n    for j in range(i, n):\n        sum = 0\n        for k in range(i, j+1):\n            sum += a[k]\n        if sum % 2 == 1 and sum > max_sum:\n            max_sum = sum\n\nprint(max_sum)"}
{"solution": "import sys\n\ndef count_valid_playlists(n, T, songs):\n    # Initialize a dictionary to store the number of valid playlists for each song\n    valid_playlists = {}\n\n    # Iterate over each song and calculate the number of valid playlists for that song\n    for i in range(n):\n        # Calculate the number of valid playlists for the current song\n        valid_playlists[i] = count_valid_playlists_helper(i, T, songs)\n\n    # Return the sum of the number of valid playlists for all songs\n    return sum(valid_playlists.values())\n\ndef count_valid_playlists_helper(i, T, songs):\n    # Base case: if the current song is the last song, return 1 if the total duration is valid, otherwise return 0\n    if i == n - 1:\n        return 1 if T == songs[i][0] else 0\n\n    # Recursive case: calculate the number of valid playlists for the current song and the remaining songs\n    valid_playlists = 0\n    for j in range(i + 1, n):\n        # If the current song and the next song have the same genre, skip this combination\n        if songs[i][1] == songs[j][1]:\n            continue\n\n        # Calculate the number of valid playlists for the current song and the next song\n        valid_playlists += count_valid_playlists_helper(j, T - songs[i][0], songs)\n\n    return valid_playlists\n\nif __name__ == \"__main__\":\n    n, T = map(int, input().split())\n    songs = []\n    for i in range(n):\n        t, g = map(int, input().split())\n        songs.append((t, g))\n    print(count_valid_playlists(n, T, songs))"}
{"solution": "import math\n\ndef solve(m):\n    # Initialize variables\n    a = []\n    x = 0\n    gcd = 0\n    P = 0\n    Q = 0\n\n    # Perform the algorithm\n    while True:\n        # Select a random integer x uniformly in range from 1 to m\n        x = random.randint(1, m)\n\n        # Append x to the end of a\n        a.append(x)\n\n        # Compute the greatest common divisor of integers in a\n        gcd = math.gcd(a)\n\n        # If gcd equals to 1, break\n        if gcd == 1:\n            break\n\n    # Compute the expected length of a\n    expected_length = 0\n    for i in range(1, len(a)):\n        expected_length += (len(a) - i) / math.factorial(i)\n\n    # Compute P and Q\n    P = math.floor(expected_length)\n    Q = math.floor(math.factorial(len(a)) / math.factorial(len(a) - expected_length))\n\n    # Compute the final result\n    result = P * math.pow(Q, -1, 1000000007) % 1000000007\n\n    # Print the result\n    print(result)\n\n# Test the function\nsolve(1)\nsolve(2)\nsolve(4)"}
{"solution": "import sys\n\ndef gcd(a, b):\n    while b!= 0:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_good_pairs(l, r, x, y):\n    count = 0\n    for a in range(l, r + 1):\n        for b in range(a, r + 1):\n            if gcd(a, b) == x and lcm(a, b) == y:\n                count += 1\n    return count\n\nif __name__ == '__main__':\n    l, r, x, y = map(int, sys.stdin.readline().split())\n    print(count_good_pairs(l, r, x, y))"}
{"solution": "  import sys\n\ndef get_lcm(a, b):\n    if a == 0 or b == 0:\n        return 0\n    else:\n        lcm = 1\n        for i in range(1, max(a, b) + 1):\n            if i % a == 0 and i % b == 0:\n                lcm = i\n                break\n        return lcm\n\ndef get_smallest_k(a, b):\n    k = 0\n    while True:\n        lcm = get_lcm(a + k, b + k)\n        if lcm == 0:\n            break\n        k += 1\n    return k\n\nif __name__ == \"__main__\":\n    a, b = map(int, sys.stdin.readline().split())\n    print(get_smallest_k(a, b))"}
{"solution": "n, k = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Calculate the current average mark\ncurrent_average = sum(marks) / len(marks)\n\n# Calculate the number of marks needed to reach the desired average\nneeded_marks = k - current_average\n\n# Round up the number of marks needed to the nearest integer\nneeded_marks = int(needed_marks) + 1\n\n# Print the output\nprint(needed_marks)"}
{"solution": "import sys\n\nn = int(input())\narr = list(map(int, input().split()))\n\n# Initialize the number of positive numbers to 0\npositive_count = 0\n\n# Iterate through the array and count the number of positive numbers\nfor i in range(n):\n    if arr[i] > 0:\n        positive_count += 1\n\n# Find the value of d that satisfies the condition\nd = 0\nwhile positive_count < n / 2:\n    d += 1\n    for i in range(n):\n        arr[i] /= d\n        if arr[i] > 0:\n            positive_count += 1\n\n# Print the value of d\nprint(d)"}
{"solution": "import sys\n\nn = int(input())\n\n# Initialize a dictionary to store the number of pairs for each number of nines\nnum_pairs = {0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0}\n\n# Iterate through all possible pairs of shovels\nfor i in range(n):\n    for j in range(i+1, n):\n        # Calculate the sum of the costs of the two shovels\n        cost = i + j\n        \n        # Calculate the number of nines at the end of the sum\n        num_nines = 0\n        while cost % 10 == 9:\n            cost //= 10\n            num_nines += 1\n        \n        # Increment the number of pairs for the corresponding number of nines\n        num_pairs[num_nines] += 1\n\n# Print the number of pairs for the maximum number of nines\nprint(num_pairs[max(num_pairs)])"}
{"solution": "import math\n\ndef solve(a1, b1, a2, b2):\n    # Calculate the total number of squares in both bars\n    total_squares_1 = a1 * b1\n    total_squares_2 = a2 * b2\n\n    # Calculate the difference between the total number of squares in both bars\n    diff = abs(total_squares_1 - total_squares_2)\n\n    # If the difference is odd, there is no solution\n    if diff % 2 == 1:\n        return -1\n\n    # Calculate the minimum number of minutes required to make the bars have the same number of squares\n    minutes = diff // 2\n\n    # Calculate the possible sizes of the bars after the process\n    size_1 = (a1 + b1) // 2\n    size_2 = (a2 + b2) // 2\n\n    return minutes, size_1, size_2\n\na1, b1, a2, b2 = map(int, input().split())\nprint(*solve(a1, b1, a2, b2))"}
{"solution": "import sys\n\ndef solve(x_p, y_p, x_v, y_v):\n    # Initialize the winner to None\n    winner = None\n\n    # While the pawns are not in the same cell\n    while x_p!= x_v or y_p!= y_v:\n        # If Polycarp's pawn is in the cell (0, 0)\n        if x_p == 0 and y_p == 0:\n            # The winner is Polycarp\n            winner = \"Polycarp\"\n            break\n\n        # If Vasiliy's pawn is in the cell (0, 0)\n        if x_v == 0 and y_v == 0:\n            # The winner is Vasiliy\n            winner = \"Vasiliy\"\n            break\n\n        # If Polycarp's pawn is in the cell (x_p - 1, y_p) or (x_p, y_p - 1)\n        if x_p - 1 == x_v and y_p == y_v or x_p == x_v and y_p - 1 == y_v:\n            # Move Polycarp's pawn to (x_p - 1, y_p - 1)\n            x_p -= 1\n            y_p -= 1\n\n        # If Vasiliy's pawn is in the cell (x_v - 1, y_v) or (x_v, y_v - 1)\n        if x_v - 1 == x_p and y_v == y_p or x_v == x_p and y_v - 1 == y_p:\n            # Move Vasiliy's pawn to (x_v - 1, y_v - 1)\n            x_v -= 1\n            y_v -= 1\n\n    # Return the winner\n    return winner\n\n# Read the input\nx_p, y_p, x_v, y_v = map(int, sys.stdin.readline().split())\n\n# Solve the problem\nwinner = solve(x_p, y_p, x_v, y_v)\n\n# Print the output\nprint(winner)"}
{"solution": "import sys\n\ndef get_number_of_columns(month, weekday):\n    # Calculate the number of days in the month\n    days_in_month = 31\n    if month in [4, 6, 9, 11]:\n        days_in_month = 30\n    elif month == 2:\n        days_in_month = 28\n\n    # Calculate the number of weeks in the month\n    weeks_in_month = days_in_month // 7\n    if days_in_month % 7!= 0:\n        weeks_in_month += 1\n\n    # Calculate the number of columns needed\n    columns = weeks_in_month\n    if weekday!= 1:\n        columns += 1\n\n    return columns\n\nif __name__ == \"__main__\":\n    month, weekday = map(int, sys.stdin.readline().split())\n    print(get_number_of_columns(month, weekday))"}
{"solution": "import sys\n\ndef count_years(a, b):\n    count = 0\n    for year in range(a, b+1):\n        binary = bin(year)[2:]\n        if binary.count('0') == 1:\n            count += 1\n    return count\n\na, b = map(int, sys.stdin.readline().split())\nprint(count_years(a, b))"}
{"solution": "def minimal_layers(N):\n    return (N * (N + 1)) // 2\n\nN = int(input())\nprint(minimal_layers(N))"}
{"solution": "import itertools\n\ndef solve(n, k, S, a):\n    # Calculate the factorial of each number\n    factorials = [1] * (n + 1)\n    for i in range(2, n + 1):\n        factorials[i] = factorials[i - 1] * i\n    \n    # Calculate the sum of the factorials of the numbers\n    sum_factorials = sum(factorials[a[i] - 1] for i in range(n))\n    \n    # Calculate the number of ways to choose some number of cubes and stick exclamation marks on some of them\n    num_ways = 0\n    for combination in itertools.combinations(range(n), k):\n        # Calculate the sum of the numbers on the chosen cubes\n        sum_chosen = sum(a[i] for i in combination)\n        \n        # Check if the sum is equal to S\n        if sum_chosen == S:\n            num_ways += 1\n    \n    return num_ways\n\nn, k, S = map(int, input().split())\na = list(map(int, input().split()))\nprint(solve(n, k, S, a))"}
{"solution": "import sys\n\ndef can_make_array(v, a, k):\n    # Initialize the array with zeroes\n    v = [0] * len(v)\n    \n    # Loop through each element in a\n    for i, elem in enumerate(a):\n        # If the element is not zero, add k^i to the corresponding position in v\n        if elem!= 0:\n            v[i] += k**i\n    \n    # Return True if v is equal to a, False otherwise\n    return v == a\n\nif __name__ == '__main__':\n    # Read the input from stdin\n    input_lines = sys.stdin.read().splitlines()\n    \n    # Get the number of test cases\n    num_test_cases = int(input_lines[0])\n    \n    # Loop through each test case\n    for i in range(1, num_test_cases + 1):\n        # Get the size of the arrays and the value of k\n        n, k = map(int, input_lines[2*i - 1].split())\n        \n        # Get the array a\n        a = list(map(int, input_lines[2*i].split()))\n        \n        # Call the can_make_array function and print the result\n        print(\"YES\" if can_make_array(v, a, k) else \"NO\")"}
{"solution": "import sys\n\ndef get_divisors(n):\n    divisors = []\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i * i!= n:\n                divisors.append(n // i)\n    divisors.sort()\n    return divisors\n\ndef get_sum_of_divisors(n):\n    divisors = get_divisors(n)\n    return sum(divisors)\n\ndef get_sum_of_divisors_of_combinations(a, b, c):\n    return sum(get_sum_of_divisors(i * j * k) for i in range(1, a + 1) for j in range(1, b + 1) for k in range(1, c + 1))\n\ndef main():\n    a, b, c = map(int, sys.stdin.readline().split())\n    print(get_sum_of_divisors_of_combinations(a, b, c) % (2**30))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from collections import deque\n\ndef get_neighbors(state):\n    neighbors = []\n    idx = state.index('X')\n    if idx == 0:\n        neighbors.append(swap(state, 0, 1))\n        neighbors.append(swap(state, 0, 2))\n    elif idx == 1:\n        neighbors.append(swap(state, 1, 0))\n        neighbors.append(swap(state, 1, 3))\n    elif idx == 2:\n        neighbors.append(swap(state, 2, 0))\n        neighbors.append(swap(state, 2, 3))\n    elif idx == 3:\n        neighbors.append(swap(state, 3, 1))\n        neighbors.append(swap(state, 3, 2))\n    return neighbors\n\ndef swap(state, i, j):\n    state = list(state)\n    state[i], state[j] = state[j], state[i]\n    return ''.join(state)\n\ndef bfs(start):\n    queue = deque([start])\n    visited = set([start])\n    while queue:\n        current = queue.popleft()\n        for neighbor in get_neighbors(current):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    return visited\n\ndef can_be_same_configuration(bessie, elsie):\n    bessie_start = ''.join(bessie)\n    elsie_start = ''.join(elsie)\n    \n    bessie_reachable = bfs(bessie_start)\n    elsie_reachable = bfs(elsie_start)\n    \n    return not bessie_reachable.isdisjoint(elsie_reachable)\n\n# Input reading\nbessie = [input().strip() for _ in range(2)]\nelsie = [input().strip() for _ in range(2)]\n\nif can_be_same_configuration(bessie, elsie):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\nn = int(sys.stdin.readline().strip())\nk = int(sys.stdin.readline().strip())\n\n# Convert k to a list of digits in the base n system\nk_list = []\nwhile k > 0:\n    k_list.append(k % n)\n    k //= n\nk_list.reverse()\n\n# Find the minimum decimal number that converts to k in the base n system\nx = 0\nfor i in range(len(k_list)):\n    x += k_list[i] * n**i\n\nprint(x)"}
{"solution": "n = int(input())\narr = list(map(int, input().split()))\n\n# Check if the array is unimodal\nif len(arr) < 3:\n    print(\"NO\")\nelse:\n    # Check if the first block is strictly increasing\n    if arr[0] < arr[1]:\n        increasing = True\n        for i in range(1, len(arr) - 1):\n            if arr[i] < arr[i + 1]:\n                increasing = True\n            else:\n                increasing = False\n                break\n        if increasing:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n    # Check if the last block is strictly decreasing\n    if arr[-1] > arr[-2]:\n        decreasing = True\n        for i in range(len(arr) - 2, 0, -1):\n            if arr[i] > arr[i - 1]:\n                decreasing = True\n            else:\n                decreasing = False\n                break\n        if decreasing:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n    # Check if the middle block is constant\n    if arr[len(arr) // 2] == arr[len(arr) // 2 - 1]:\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "import sys\n\nn, k = map(int, sys.stdin.readline().split())\n\ndef f(x):\n    if x % 2 == 0:\n        return x // 2\n    else:\n        return x - 1\n\ndef path(x):\n    result = [x]\n    while x!= 1:\n        x = f(x)\n        result.append(x)\n    return result\n\npaths = [path(x) for x in range(1, n + 1)]\n\nmax_value = 0\nfor value in set(x for path in paths for x in path):\n    if paths.count(value) >= k:\n        max_value = max(max_value, value)\n\nprint(max_value)"}
{"solution": "import sys\n\nn, m, x, y, vx, vy = map(int, sys.stdin.readline().split())\n\n# Check if the ball is initially in a pocket\nif x in range(n) and y in range(m):\n    print(x, y)\n    sys.exit()\n\n# Check if the ball will move indefinitely\nif vx == 0 and vy == 0:\n    print(-1)\n    sys.exit()\n\n# Check if the ball will fall into a pocket\npocket_x = [0, n, 0, n]\npocket_y = [0, 0, m, m]\n\nfor i in range(4):\n    if x == pocket_x[i] and y == pocket_y[i]:\n        print(x, y)\n        sys.exit()\n\n# Check if the ball will move along a side\nif vx == 0 or vy == 0:\n    if vx == 0:\n        x = pocket_x[0] if x < pocket_x[0] else pocket_x[1]\n    else:\n        y = pocket_y[0] if y < pocket_y[0] else pocket_y[1]\n    print(x, y)\n    sys.exit()\n\n# Check if the ball will move diagonally\nif vx!= 0 and vy!= 0:\n    if vx > 0:\n        x = pocket_x[2] if x < pocket_x[2] else pocket_x[3]\n    else:\n        x = pocket_x[0] if x > pocket_x[0] else pocket_x[1]\n    if vy > 0:\n        y = pocket_y[2] if y < pocket_y[2] else pocket_y[3]\n    else:\n        y = pocket_y[0] if y > pocket_y[0] else pocket_y[1]\n    print(x, y)\n    sys.exit()\n\n# If the ball reaches this point, it will never fall into a pocket\nprint(-1)"}
{"solution": "def can_place_paintings(a1, b1, a2, b2, a3, b3):\n    # Check if two rectangles (a2, b2) and (a3, b3) can fit in (a1, b1)\n    def fits(w1, h1, w2, h2, W, H):\n        return (w1 + w2 <= W and max(h1, h2) <= H) or (h1 + h2 <= H and max(w1, w2) <= W)\n    \n    # Check all combinations of orientations\n    if (fits(a2, b2, a3, b3, a1, b1) or fits(b2, a2, a3, b3, a1, b1) or\n        fits(a2, b2, b3, a3, a1, b1) or fits(b2, a2, b3, a3, a1, b1) or\n        fits(a3, b3, a2, b2, a1, b1) or fits(b3, a3, a2, b2, a1, b1) or\n        fits(a3, b3, b2, a2, a1, b1) or fits(b3, a3, b2, a2, a1, b1)):\n        return \"YES\"\n    else:\n        return \"NO\""}
{"solution": "import sys\n\ndef solve(b_1, q, l, m, a):\n    # Initialize variables\n    terms = 0\n    current_term = b_1\n    while True:\n        # Check if the current term is a \"bad\" integer\n        if current_term in a:\n            # Skip the term and move to the next one\n            current_term = current_term - 1 * q\n            continue\n        \n        # Check if the current term exceeds the limit by absolute value\n        if abs(current_term) > l:\n            # Break the loop and print \"inf\"\n            print(\"inf\")\n            break\n        \n        # Increment the number of terms\n        terms += 1\n        \n        # Move to the next term\n        current_term = current_term - 1 * q\n    \n    # Print the number of terms\n    print(terms)\n\n# Read input\nb_1, q, l, m = map(int, input().split())\na = list(map(int, input().split()))\n\n# Solve the problem\nsolve(b_1, q, l, m, a)"}
{"solution": "import sys\n\ndef find_frame(n, m, pixels):\n    # Initialize the frame size to 1\n    frame_size = 1\n    # Initialize the frame position to (0, 0)\n    frame_position = (0, 0)\n    # Initialize the minimum frame size to infinity\n    min_frame_size = float('inf')\n    # Iterate over all possible frame positions\n    for i in range(n - frame_size + 1):\n        for j in range(m - frame_size + 1):\n            # Check if the frame is within the borders of the screen\n            if i + frame_size <= n and j + frame_size <= m:\n                # Check if all white pixels are located on the frame\n                if all(pixels[i + k][j + l] == 'w' for k in range(frame_size) for l in range(frame_size)):\n                    # Check if the frame size is smaller than the minimum frame size\n                    if frame_size < min_frame_size:\n                        # Update the minimum frame size and position\n                        min_frame_size = frame_size\n                        frame_position = (i, j)\n    # If the required frame doesn't exist, return -1\n    if min_frame_size == float('inf'):\n        return -1\n    # Otherwise, return the frame position and size\n    return (frame_position, min_frame_size)\n\n# Read the input\nn, m = map(int, input().split())\npixels = [input() for _ in range(n)]\n\n# Find the frame\nframe = find_frame(n, m, pixels)\n\n# Print the output\nif frame == -1:\n    print(-1)\nelse:\n    for i in range(n):\n        for j in range(m):\n            if pixels[i][j] == 'w':\n                print('w', end='')\n            elif i >= frame[0][0] and i < frame[0][0] + frame[1] and j >= frame[0][1] and j < frame[0][1] + frame[1]:\n                print('+', end='')\n            else:\n                print('.', end='')\n        print()"}
{"solution": "import sys\n\nn, a, b = map(int, sys.stdin.readline().split())\n\nif n % a == 0 and n % b == 0:\n    x = n // a\n    y = n // b\n    print(\"YES\")\n    print(x, y)\nelse:\n    print(\"NO\")"}
{"solution": "def number_to_words(s):\n    ones = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n\n    if 0 <= s <= 9:\n        return ones[s]\n    elif 10 <= s <= 19:\n        return teens[s - 10]\n    elif 20 <= s <= 99:\n        if s % 10 == 0:\n            return tens[s // 10]\n        else:\n            return tens[s // 10] + \"-\" + ones[s % 10]\n\n# Example usage:\ns = int(input())\nprint(number_to_words(s))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Find the longest consecutive sequence of elements that can be erased\nmax_length = 0\ncurrent_length = 0\nfor i in range(n - 1):\n    if a[i] + 1 == a[i + 1]:\n        current_length += 1\n    else:\n        max_length = max(max_length, current_length)\n        current_length = 0\n\n# Print the maximum number of consecutive elements that can be erased\nprint(max_length)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Calculate the cumulative sum of problems solved each day\ncumulative_sum = [0]\nfor i in range(n):\n    cumulative_sum.append(cumulative_sum[i] + a[i])\n\n# Find the day when Polycarp will celebrate the equator\nfor i in range(n):\n    if cumulative_sum[i] >= (n + 1) / 2:\n        print(i + 1)\n        break\nelse:\n    print(-1)"}
{"solution": "import sys\n\nN = int(input())\nboard = []\nfor i in range(N):\n    board.append(list(map(int, input().split())))\n\n# Initialize the starting piece as a knight\nstarting_piece = 'K'\n\n# Initialize the number of steps and replacements\nnum_steps = 0\nnum_replacements = 0\n\n# Initialize the current position as (1, 1)\ncurrent_position = (1, 1)\n\n# Initialize the visited squares as an empty set\nvisited_squares = set()\n\n# Initialize the possible moves for each piece\npossible_moves = {\n    'K': [(2, 1), (1, 2)],\n    'B': [(1, 1), (1, -1), (-1, 1), (-1, -1)],\n    'R': [(1, 0), (0, 1), (-1, 0), (0, -1)]\n}\n\n# Initialize the current piece as the starting piece\ncurrent_piece = starting_piece\n\n# While the current position is not (N, N)\nwhile current_position!= (N, N):\n    # If the current position is not in the visited squares set, add it to the set\n    if current_position not in visited_squares:\n        visited_squares.add(current_position)\n\n    # If the current position is the destination, increment the number of steps and break\n    if current_position == (N, N):\n        num_steps += 1\n        break\n\n    # If the current position is not the destination, find the possible moves for the current piece\n    possible_moves_for_current_piece = possible_moves[current_piece]\n\n    # If there are no possible moves for the current piece, replace it with a different piece\n    if not possible_moves_for_current_piece:\n        num_replacements += 1\n        current_piece = 'K' if current_piece == 'B' else 'B'\n        possible_moves_for_current_piece = possible_moves[current_piece]\n\n    # Find the next position by randomly selecting a possible move\n    next_position = possible_moves_for_current_piece[0]\n\n    # Update the current position and piece\n    current_position = next_position\n    current_piece = current_piece\n\n# Print the number of steps and replacements\nprint(num_steps, num_replacements)"}
{"solution": "n, m, k = map(int, input().split())\na, b = map(int, input().split())\n\n# Initialize the time variables\ntime_to_reach_a = 0\ntime_to_reach_b = 0\n\n# Calculate the time to reach a from the current floor\nif a // k == b // k:\n    time_to_reach_a = (a % k) * 5\nelse:\n    time_to_reach_a = (a % k) * 5 + (a // k - b // k) * 15\n\n# Calculate the time to reach b from the current floor\nif b // k == a // k:\n    time_to_reach_b = (b % k) * 5\nelse:\n    time_to_reach_b = (b % k) * 5 + (b // k - a // k) * 15\n\n# Print the minimum time\nprint(min(time_to_reach_a, time_to_reach_b))"}
{"solution": "import sys\n\ndef is_divisible_by_64(binary_string):\n    # Check if the string is empty\n    if not binary_string:\n        return \"no\"\n\n    # Check if the string is divisible by 64\n    if len(binary_string) % 64 == 0:\n        return \"yes\"\n\n    # Check if the string can be manipulated to be divisible by 64\n    for i in range(len(binary_string)):\n        if binary_string[i] == \"1\":\n            # Remove the digit at position i\n            binary_string = binary_string[:i] + binary_string[i+1:]\n            # Check if the remaining string is divisible by 64\n            if len(binary_string) % 64 == 0:\n                return \"yes\"\n\n    # If the string cannot be manipulated to be divisible by 64, return \"no\"\n    return \"no\"\n\nif __name__ == \"__main__\":\n    binary_string = sys.stdin.readline().strip()\n    print(is_divisible_by_64(binary_string))"}
{"solution": "def get_subsequence(s):\n    # Initialize a list to store the characters of the input string\n    chars = list(s)\n    # Initialize a list to store the characters of the output string\n    output = []\n    # Iterate through the characters of the input string\n    for char in chars:\n        # If the character is not 'z', replace it with the next character in the alphabet\n        if char!= 'z':\n            output.append(chr(ord(char) + 1))\n        # If the character is 'z', append it to the output string as is\n        else:\n            output.append(char)\n    # Join the characters of the output string into a single string\n    output_str = ''.join(output)\n    # Check if the output string contains the English alphabet as a subsequence\n    if 'abcdefghijklmnopqrstuvwxyz' in output_str:\n        return output_str\n    else:\n        return '-1'"}
{"solution": "import math\n\ndef solve(n, m, r, k):\n    # Calculate the total number of cells in the pond\n    total_cells = n * m\n    \n    # Calculate the number of possible positions for the scoop-net\n    possible_positions = (n - r + 1) * (m - r + 1)\n    \n    # Calculate the expected value for each position\n    expected_values = []\n    for i in range(possible_positions):\n        # Calculate the number of fishes in each cell\n        fishes_in_cells = [0] * total_cells\n        for j in range(k):\n            # Calculate the index of the cell where the fish will be placed\n            cell_index = (i * k + j) % total_cells\n            fishes_in_cells[cell_index] += 1\n        \n        # Calculate the expected value for this position\n        expected_value = 0\n        for fishes in fishes_in_cells:\n            expected_value += fishes / total_cells\n        \n        expected_values.append(expected_value)\n    \n    # Return the maximum expected value\n    return max(expected_values)\n\nn = 3\nm = 3\nr = 2\nk = 3\nprint(solve(n, m, r, k))"}
{"solution": "  import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize the maximum product to be 0\nmax_product = 0\n\n# Iterate through all possible indices\nfor i in range(n):\n    # Calculate the product of the array elements after applying the operation to the current index\n    product = 1\n    for j in range(n):\n        if j == i:\n            product *= -a[j] - 1\n        else:\n            product *= a[j]\n    \n    # If the current product is greater than the maximum product, update the maximum product and the corresponding array elements\n    if product > max_product:\n        max_product = product\n        max_array = a.copy()\n        max_array[i] = -a[i] - 1\n\n# Print the array with the maximum product of elements\nprint(*max_array)"}
{"solution": "n, k = map(int, input().split())\n\ndivisors = []\nfor i in range(1, int(n**0.5) + 1):\n    if n % i == 0:\n        divisors.append(i)\n        if n // i!= i:\n            divisors.append(n // i)\n\ndivisors.sort()\n\nif k > len(divisors):\n    print(-1)\nelse:\n    print(divisors[k - 1])"}
{"solution": "n = int(input())\ncubes = []\nfor i in range(n):\n    cubes.append(list(map(int, input().split())))\n\n# Initialize the maximum number x to 0\nx = 0\n\n# Iterate through all possible combinations of digits on the cubes\nfor i in range(10**n):\n    # Convert the current combination to a string\n    combination = str(i)\n    \n    # Check if the current combination is a valid number\n    if combination.isdigit() and combination[0]!= '0':\n        # Check if the current combination is a consecutive number\n        if combination in range(x+1, x+10):\n            # Update the maximum number x\n            x = int(combination)\n\n# Print the maximum number x\nprint(x)"}
{"solution": "import math\n\ndef k_rounding(n, k):\n    # Calculate the number of digits in n\n    num_digits = int(math.log10(n)) + 1\n    \n    # Calculate the number of zeros needed to end with k or more zeros\n    num_zeros = k - (num_digits % k)\n    \n    # Multiply n by 10^num_zeros to get the k-rounded number\n    k_rounded = n * (10 ** num_zeros)\n    \n    return k_rounded\n\nn, k = map(int, input().split())\nprint(k_rounding(n, k))"}
{"solution": "def transform_matrix(n, m, A):\n    operations = []\n    B = [[0] * m for _ in range(n)]\n    \n    for i in range(n - 1):\n        for j in range(m - 1):\n            if A[i][j] == 1 and A[i][j + 1] == 1 and A[i + 1][j] == 1 and A[i + 1][j + 1] == 1:\n                operations.append((i + 1, j + 1))\n                B[i][j] = B[i][j + 1] = B[i + 1][j] = B[i + 1][j + 1] = 1\n    \n    for i in range(n):\n        for j in range(m):\n            if A[i][j]!= B[i][j]:\n                return -1\n    \n    return operations\n\n# Input reading\nn, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\n\n# Process the transformation\nresult = transform_matrix(n, m, A)\n\n# Output the result\nif result == -1:\n    print(-1)\nelse:\n    print(len(result))\n    for x, y in result:\n        print(x, y)"}
{"solution": "import math\n\ndef get_probabilities(r, s, p):\n    # Calculate the total number of individuals\n    total = r + s + p\n\n    # Calculate the probability of each species being the sole survivor\n    prob_r = r / total\n    prob_s = s / total\n    prob_p = p / total\n\n    # Calculate the probability of each species being the sole survivor, given that it is the only one left\n    prob_r_alone = prob_r * (1 - prob_s - prob_p)\n    prob_s_alone = prob_s * (1 - prob_r - prob_p)\n    prob_p_alone = prob_p * (1 - prob_r - prob_s)\n\n    # Calculate the probability of each species being the sole survivor, given that it is the only one left, and that it is the only one left\n    prob_r_alone_alone = prob_r_alone * (1 - prob_s - prob_p)\n    prob_s_alone_alone = prob_s_alone * (1 - prob_r - prob_p)\n    prob_p_alone_alone = prob_p_alone * (1 - prob_r - prob_s)\n\n    # Calculate the final probabilities\n    prob_r_final = prob_r_alone_alone + prob_r_alone * prob_s_alone_alone + prob_r_alone * prob_p_alone_alone\n    prob_s_final = prob_s_alone_alone + prob_s_alone * prob_r_alone_alone + prob_s_alone * prob_p_alone_alone\n    prob_p_final = prob_p_alone_alone + prob_p_alone * prob_r_alone_alone + prob_p_alone * prob_s_alone_alone\n\n    return prob_r_final, prob_s_final, prob_p_final\n\n\nif __name__ == \"__main__\":\n    r, s, p = map(int, input().split())\n    prob_r, prob_s, prob_p = get_probabilities(r, s, p)\n    print(f\"{prob_r:.9f} {prob_s:.9f} {prob_p:.9f}\")"}
{"solution": "import sys\n\ndef get_overlapping_minutes(l1, r1, l2, r2, k):\n    # Calculate the number of minutes they will be able to spend together\n    minutes_together = 0\n\n    # Check if Sonya is available during the time Filya wants to visit\n    if l2 <= k <= r2:\n        # If Sonya is available, calculate the number of minutes they can spend together\n        minutes_together = min(r2, k) - max(l2, k) + 1\n    elif l1 <= k <= r1:\n        # If Sonya is not available, calculate the number of minutes they can spend together during the overlapping time\n        minutes_together = min(r1, r2) - max(l1, l2) + 1\n\n    return minutes_together\n\nif __name__ == '__main__':\n    l1, r1, l2, r2, k = map(int, sys.stdin.readline().split())\n    print(get_overlapping_minutes(l1, r1, l2, r2, k))"}
{"solution": "import sys\n\ndef get_area(N, M, A, B, C, D, E, F):\n    # Initialize the area as 0\n    area = 0\n\n    # Iterate over each north-south line\n    for i in range(N):\n        # Get the coordinates of the line\n        x1, y1, x2, y2 = A[i], B[i], C[i], D[i]\n\n        # Check if the line intersects with the east-west lines\n        for j in range(M):\n            # Get the coordinates of the line\n            x3, y3, x4, y4 = E[j], F[j], G[j], H[j]\n\n            # Check if the line segments intersect\n            if do_segments_intersect(x1, y1, x2, y2, x3, y3, x4, y4):\n                # Add the area of the intersection to the total area\n                area += get_intersection_area(x1, y1, x2, y2, x3, y3, x4, y4)\n\n    # Return the total area\n    return area\n\ndef do_segments_intersect(x1, y1, x2, y2, x3, y3, x4, y4):\n    # Check if the segments intersect\n    return (x1 <= x3 and x2 >= x3 and y1 <= y3 and y2 >= y3) or (x1 <= x4 and x2 >= x4 and y1 <= y4 and y2 >= y4)\n\ndef get_intersection_area(x1, y1, x2, y2, x3, y3, x4, y4):\n    # Get the coordinates of the intersection\n    x, y = get_intersection_coordinates(x1, y1, x2, y2, x3, y3, x4, y4)\n\n    # Calculate the area of the intersection\n    area = (x2 - x1) * (y2 - y1)\n\n    # Return the area\n    return area\n\ndef get_intersection_coordinates(x1, y1, x2, y2, x3, y3, x4, y4):\n    # Calculate the intersection coordinates\n    x = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)\n    y = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)\n\n    # Return the intersection coordinates\n    return x, y\n\n# Get the input from the user\nN, M = map(int, input().split())\nA = [int(x) for x in input().split()]\nB = [int(x) for x in input().split()]\nC = [int(x) for x in input().split()]\nD = [int(x) for x in input().split()]\nE = [int(x) for x in input().split()]\nF = [int(x) for x in input().split()]\n\n# Calculate the area\narea = get_area(N, M, A, B, C, D, E, F)\n\n# Print the output\nprint(area)"}
{"solution": "import sys\n\nt, s, x = map(int, sys.stdin.readline().split())\n\nif (x - t) % (s + 1) == 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\nn = int(input())\nsegments = []\n\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r))\n\nfor i in range(n):\n    for j in range(i+1, n):\n        if segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            print(i, j)\n            sys.exit()\n\nprint(-1, -1)"}
{"solution": "import re\n\ndef decode_genome(genome):\n    # Initialize the number of each nucleotide type\n    a_count = 0\n    c_count = 0\n    g_count = 0\n    t_count = 0\n\n    # Iterate through the genome and count the number of each nucleotide type\n    for nucleotide in genome:\n        if nucleotide == 'A':\n            a_count += 1\n        elif nucleotide == 'C':\n            c_count += 1\n        elif nucleotide == 'G':\n            g_count += 1\n        elif nucleotide == 'T':\n            t_count += 1\n\n    # Check if the number of each nucleotide type is equal\n    if a_count == c_count and c_count == g_count and g_count == t_count:\n        return genome\n\n    # If the number of each nucleotide type is not equal, try to replace the unrecognized nucleotides\n    for i in range(len(genome)):\n        if genome[i] == '?':\n            # Try to replace the unrecognized nucleotide with each of the four types\n            for nucleotide in ['A', 'C', 'G', 'T']:\n                new_genome = genome[:i] + nucleotide + genome[i+1:]\n                if decode_genome(new_genome) is not None:\n                    return new_genome\n\n    # If it is not possible to decode the genome, return three equals signs\n    return \"===\"\n\n\n# Test the function with the given examples\nprint(decode_genome(\"AG?C??CT\"))\nprint(decode_genome(\"AGCT\"))\nprint(decode_genome(\"????G?\"))\nprint(decode_genome(\"AA??\"))"}
{"solution": "def check_winning_move(board):\n    # Check for horizontal and vertical wins\n    for row in range(4):\n        for col in range(4):\n            if board[row][col] == 'x':\n                # Check for horizontal win\n                if board[row][col+1] == 'x' and board[row][col+2] == 'x':\n                    return True\n                # Check for vertical win\n                if board[row+1][col] == 'x' and board[row+2][col] == 'x':\n                    return True\n    # Check for diagonal wins\n    for row in range(4):\n        for col in range(4):\n            if board[row][col] == 'x':\n                # Check for main diagonal win\n                if board[row+1][col+1] == 'x' and board[row+2][col+2] == 'x':\n                    return True\n                # Check for anti-diagonal win\n                if board[row-1][col-1] == 'x' and board[row-2][col-2] == 'x':\n                    return True\n    return False\n\ndef main():\n    board = [\n        ['.', '.', '.', '.'],\n        ['.', '.', '.', '.'],\n        ['.', '.', '.', '.'],\n        ['.', '.', '.', '.']\n    ]\n    print(check_winning_move(board))\n\nif __name__ == '__main__':\n    main()"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Check if the sum of the first half of the array is equal to the sum of the second half\nif sum(a[:n//2]) == sum(a[n//2:]):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Check if the number of lost elements in a is equal to the length of b\nif k!= len(b):\n    print(\"No\")\n    sys.exit()\n\n# Check if the elements in b are unique\nif len(set(b))!= len(b):\n    print(\"No\")\n    sys.exit()\n\n# Check if the elements in a are unique\nif len(set(a))!= len(a):\n    print(\"No\")\n    sys.exit()\n\n# Check if the elements in a are all non-zero\nif 0 in a:\n    print(\"No\")\n    sys.exit()\n\n# Check if the elements in b are all non-zero\nif 0 in b:\n    print(\"No\")\n    sys.exit()\n\n# Check if the elements in a can be replaced with elements in b\ncan_replace = True\nfor i in range(n):\n    if a[i]!= 0 and b[i]!= 0:\n        can_replace = False\n        break\nif not can_replace:\n    print(\"No\")\n    sys.exit()\n\n# Check if the resulting sequence is not increasing\nresult = [a[i] if a[i]!= 0 else b[i] for i in range(n)]\nif result[i] > result[i+1] for i in range(n-1):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "x, y, z = map(int, input().split())\na, b, c = map(int, input().split())\n\nif a >= x and b >= y and c >= z:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def is_accident_possible(lights):\n    # Initialize variables to keep track of the number of green lights\n    num_green_lights = 0\n    num_green_pedestrian_lights = 0\n\n    # Iterate through the lights and count the number of green lights\n    for light in lights:\n        if light == 1:\n            num_green_lights += 1\n        elif light == 4:\n            num_green_pedestrian_lights += 1\n\n    # If there are more than one green light, return \"YES\"\n    if num_green_lights > 1 or num_green_pedestrian_lights > 1:\n        return \"YES\"\n    else:\n        return \"NO\""}
{"solution": "n = int(input())\nnumber = input().strip()\n\n# Convert each digit in the input number to its corresponding coordinates\ncoordinates = [get_coordinates(digit) for digit in number]\n\n# Calculate the sequence of vectors (movements) between consecutive digits\nvectors = [coordinates[i] - coordinates[i-1] for i in range(1, len(coordinates))]\n\n# Check if any other number of the same length can produce the same sequence of vectors\nfor i in range(10**(n-1), 10**n):\n    candidate = str(i).zfill(n)\n    if candidate!= number:\n        if get_vectors(candidate) == vectors:\n            print(\"NO\")\n            break\nelse:\n    print(\"YES\")"}
{"solution": "import sys\n\nn, f = map(int, input().split())\nk = [0] * (n + 1)\nl = [0] * (n + 1)\n\nfor i in range(n):\n    k[i], l[i] = map(int, input().split())\n\n# Calculate the number of products that can be sold on each day\nproducts_sold = [0] * (n + 1)\nfor i in range(n):\n    products_sold[i] = k[i] * l[i]\n\n# Calculate the number of products that can be sold on each day with a sell-out\nproducts_sold_with_sell_out = [0] * (n + 1)\nfor i in range(n):\n    if i in f:\n        products_sold_with_sell_out[i] = 2 * k[i] * l[i]\n    else:\n        products_sold_with_sell_out[i] = k[i] * l[i]\n\n# Find the maximum number of products that can be sold\nmax_products_sold = max(products_sold_with_sell_out)\n\nprint(max_products_sold)"}
{"solution": "import sys\n\nn, k = map(int, input().split())\n\n# Initialize the array of cows with their labels\ncows = list(range(1, n + 1))\n\n# Calculate the maximum messiness by reversing segments of the array\n# and swapping elements to create the most disorder\nmax_messiness = 0\nfor i in range(k):\n    # Reverse the segment of the array from index i to index n - 1\n    cows[i:n] = reversed(cows[i:n])\n    # Swap the elements at indices i and n - 1\n    cows[i], cows[n - 1] = cows[n - 1], cows[i]\n    # Calculate the messiness of the current arrangement\n    messiness = 0\n    for j in range(n - 1):\n        if cows[j] > cows[j + 1]:\n            messiness += 1\n    # Update the maximum messiness if necessary\n    if messiness > max_messiness:\n        max_messiness = messiness\n\n# Print the maximum messiness\nprint(max_messiness)"}
{"solution": "import sys\n\ndef get_min_coins(N, M, K, L):\n    # Initialize variables\n    min_coins = 0\n    new_coins = 0\n\n    # Loop through each friend\n    for i in range(M):\n        # Calculate the number of new coins\n        new_coins = N - K\n\n        # Check if the number of new coins is greater than or equal to L\n        if new_coins >= L:\n            # Increment the minimum number of coins\n            min_coins += 1\n        else:\n            # Return -1 if it is not possible to meet all the conditions\n            return -1\n\n    # Return the minimum number of coins\n    return min_coins\n\n# Get input from stdin\nN, M, K, L = map(int, input().split())\n\n# Get the minimum number of coins\nmin_coins = get_min_coins(N, M, K, L)\n\n# Print the output\nprint(min_coins)"}
{"solution": "def min_cells_to_paint(n, m, grid):\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n    \n    # Find the bounds of the black cells\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'B':\n                min_row = min(min_row, i)\n                max_row = max(max_row, i)\n                min_col = min(min_col, j)\n                max_col = max(max_col, j)\n    \n    # If no black cells are found\n    if min_row == n:\n        return 1\n    \n    # Calculate the side length of the square\n    side_length = max(max_row - min_row + 1, max_col - min_col + 1)\n    \n    # Check if the square can fit within the grid\n    if side_length > n or side_length > m:\n        return -1\n    \n    # Count the number of white cells within the square\n    min_paint = float('inf')\n    for i in range(n - side_length + 1):\n        for j in range(m - side_length + 1):\n            paint_count = 0\n            for x in range(i, i + side_length):\n                for y in range(j, j + side_length):\n                    if grid[x][y] == 'W':\n                        paint_count += 1\n            min_paint = min(min_paint, paint_count)\n    \n    return min_paint"}
{"solution": "import sys\n\nn = int(input())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\nif len(x)!= len(y):\n    print(\"No\")\n    sys.exit()\n\nif sum(x)!= sum(y):\n    print(\"No\")\n    sys.exit()\n\nfor i in range(n):\n    if x[i]!= y[i]:\n        print(\"No\")\n        sys.exit()\n\nprint(\"Yes\")"}
{"solution": "import sys\n\nn = int(input())\nangles = list(map(int, input().split()))\n\n# Calculate the sum of all angles\ntotal_angle = sum(angles)\n\n# Initialize the minimum difference between angles\nmin_diff = 360\n\n# Iterate through all possible combinations of angles\nfor i in range(n):\n    for j in range(i+1, n):\n        # Calculate the difference between the two sectors\n        diff = abs(angles[i] + angles[j] - total_angle)\n\n        # Update the minimum difference if necessary\n        if diff < min_diff:\n            min_diff = diff\n\n# Print the minimum difference\nprint(min_diff)"}
{"solution": "import sys\n\nn, m = map(int, input().split())\n\ndef count_ways(n, m):\n    # Initialize a 2D array to store the results\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    # Base case: when there are no presents or boxes\n    for i in range(n + 1):\n        dp[i][0] = 1\n    for j in range(m + 1):\n        dp[0][j] = 1\n\n    # Fill in the table\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % (10**9 + 7)\n\n    return dp[n][m]\n\nprint(count_ways(n, m))"}
{"solution": "import math\n\ndef find_pythagorean_triple(n):\n    for m in range(1, 10**18):\n        for k in range(1, 10**18):\n            if m**2 + k**2 == n**2:\n                return m, k\n    return -1\n\nn = int(input())\nprint(find_pythagorean_triple(n))"}
{"solution": "import sys\n\nn, k = map(int, input().split())\n\nremainders = []\nfor i in range(1, k+1):\n    remainders.append(n % i)\n\nif len(remainders) == len(set(remainders)):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "a, b = input().split()\n\nif a < b:\n    print(\"<\")\nelif a > b:\n    print(\">\")\nelse:\n    print(\"=\")"}
{"solution": "import sys\n\nn, p = map(int, input().split())\ncolors = list(map(int, input().split()))\n\n# Initialize the number of valid paths to 0\nvalid_paths = 0\n\n# Iterate over all possible combinations of colors\nfor i in range(2**n):\n    # Convert the binary representation of i to a list of colors\n    color_list = [colors[j] for j in range(n) if i & (1 << j)]\n\n    # Check if the color list has the desired parity\n    if len(color_list) % 2 == p:\n        # Increment the number of valid paths\n        valid_paths += 1\n\n# Print the number of valid paths modulo 10^9 + 7\nprint(valid_paths % (10**9 + 7))"}
{"solution": "import sys\n\nn, a, b, c = map(int, sys.stdin.readline().split())\n\n# Calculate the minimum number of additional copybooks needed\nk = (4 - n % 4) % 4\n\n# Calculate the cost of the additional copybooks\ncost = k * min(a, b, c)\n\n# Print the minimum amount of rubles Alyona should pay\nprint(cost)"}
{"solution": "import sys\n\nn, m = map(int, input().split())\nedges = []\n\nfor i in range(m):\n    u, v = map(int, input().split())\n    edges.append((u, v))\n\n# Check if the graph is acyclic\nacyclic = True\nfor edge in edges:\n    if edge[0] == edge[1]:\n        acyclic = False\n        break\n\n# Check if the graph can be made acyclic by removing at most one edge\nif acyclic:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\ndef get_min_coins(n, m, x_list, s_list):\n    # Initialize variables\n    coins_spent = 0\n    antennas_covered = set()\n\n    # Sort the antennas by their position\n    sorted_x_list = sorted(x_list)\n\n    # Iterate through the sorted antennas\n    for i in range(n):\n        # Get the current antenna's position and scope\n        x = sorted_x_list[i]\n        s = s_list[i]\n\n        # Check if the antenna covers the current position\n        if x - s <= m <= x + s:\n            # If it does, add it to the set of covered antennas\n            antennas_covered.add(i)\n\n    # Iterate through the antennas again\n    for i in range(n):\n        # Get the current antenna's position and scope\n        x = sorted_x_list[i]\n        s = s_list[i]\n\n        # Check if the antenna is not already covered\n        if i not in antennas_covered:\n            # If it's not, increase its scope by 1 and add the cost to the total\n            s_list[i] += 1\n            coins_spent += 1\n\n            # Check if the antenna now covers the current position\n            if x - s <= m <= x + s:\n                # If it does, add it to the set of covered antennas\n                antennas_covered.add(i)\n\n    # Return the total cost\n    return coins_spent\n\n# Read the input\nn, m = map(int, input().split())\nx_list = []\ns_list = []\nfor i in range(n):\n    x, s = map(int, input().split())\n    x_list.append(x)\n    s_list.append(s)\n\n# Get the minimum cost\nmin_coins = get_min_coins(n, m, x_list, s_list)\n\n# Print the output\nprint(min_coins)"}
{"solution": "import sys\n\ndef get_max_weight(W, cnt):\n    # Initialize the maximum weight as 0\n    max_weight = 0\n\n    # Iterate through the input set and calculate the maximum weight\n    for i in range(len(cnt)):\n        # Calculate the current weight\n        current_weight = cnt[i] * (i + 1)\n\n        # Check if the current weight is less than or equal to the maximum weight\n        if current_weight <= W:\n            # Update the maximum weight if necessary\n            max_weight = max(max_weight, current_weight)\n\n    # Return the maximum weight\n    return max_weight\n\n# Read the input from stdin\nW, cnt = map(int, input().split())\n\n# Calculate the maximum weight\nmax_weight = get_max_weight(W, cnt)\n\n# Print the output to stdout\nprint(max_weight)"}
{"solution": "import sys\n\nn, L = map(int, input().split())\ncosts = list(map(int, input().split()))\n\n# Sort the costs in descending order\ncosts.sort(reverse=True)\n\n# Initialize the total cost and the number of bottles\ntotal_cost = 0\nnum_bottles = 0\n\n# Loop through the costs and add the bottles to the total cost\nfor i in range(n):\n    # Calculate the number of bottles that can be purchased with the current cost\n    num_bottles_i = L // (2**i - 1)\n    \n    # Add the cost of the bottles to the total cost\n    total_cost += num_bottles_i * costs[i]\n    \n    # Update the number of bottles\n    num_bottles += num_bottles_i\n    \n    # Update the remaining volume\n    L -= num_bottles_i * (2**i - 1)\n\n# Print the total cost\nprint(total_cost)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nmex = 1\nfor i in range(n):\n    if a[i] >= mex:\n        mex += 1\n\nprint(mex)"}
{"solution": "def is_lucky_ticket(n, digits):\n    total_sum = sum(int(digit) for digit in digits)\n    \n    # Try every possible segment sum from 1 to total_sum\n    for segment_sum in range(1, total_sum + 1):\n        if total_sum % segment_sum == 0:\n            current_sum = 0\n            valid_partition = True\n            for digit in digits:\n                current_sum += int(digit)\n                if current_sum > segment_sum:\n                    valid_partition = False\n                    break\n                elif current_sum == segment_sum:\n                    current_sum = 0\n            if valid_partition and current_sum == 0:\n                return \"YES\"\n    \n    return \"NO\"\n\n# Example usage:\nn = int(input())\ndigits = input().strip()\nprint(is_lucky_ticket(n, digits))"}
{"solution": "def determine_gender(username):\n    distinct_characters = set(username)\n    if len(distinct_characters) % 2 == 0:\n        return \"CHAT WITH HER!\"\n    else:\n        return \"IGNORE HIM!\""}
{"solution": "import sys\n\nn, k = map(int, input().split())\ntabs = list(map(int, input().split()))\n\n# Initialize the variables\ne = 0\ns = 0\n\n# Iterate through the tabs and count the number of test and social network tabs\nfor i in range(n):\n    if tabs[i] == 1:\n        e += 1\n    else:\n        s += 1\n\n# Calculate the absolute difference between the amounts of remaining tabs of different types\ndiff = abs(e - s)\n\n# Print the maximum absolute difference\nprint(diff)"}
{"solution": "import sys\n\nn, c0, c1 = map(int, input().split())\n\n# Initialize the cost of each letter as 0\ncost = [0] * n\n\n# Initialize the number of letters that have been used as 0\nused = 0\n\n# Loop through each letter and assign a cost based on the number of letters that have been used\nfor i in range(n):\n    # If the letter has not been used, assign the cost of 1\n    if used == 0:\n        cost[i] = 1\n    # If the letter has been used, assign the cost of 2\n    else:\n        cost[i] = 2\n\n    # Increment the number of letters that have been used\n    used += 1\n\n# Calculate the total cost of the alphabet\ntotal_cost = sum(cost)\n\n# Print the minimum possible total cost\nprint(total_cost)"}
{"solution": "def will_meet(n, a, x, b, y):\n    while a!= x and b!= y:\n        if a == b:\n            return \"YES\"\n        a = a + 1 if a < n else 1\n        b = b - 1 if b > 1 else n\n    return \"YES\" if a == b else \"NO\""}
{"solution": "import math\n\ndef get_unlucky_years(x, y, l, r):\n    unlucky_years = set()\n    for a in range(math.ceil(math.log(l, x))):\n        for b in range(math.ceil(math.log(l, y))):\n            unlucky_years.add(x**a + y**b)\n    for a in range(math.ceil(math.log(r, x))):\n        for b in range(math.ceil(math.log(r, y))):\n            unlucky_years.add(x**a + y**b)\n    return unlucky_years\n\ndef get_golden_age_intervals(x, y, l, r, unlucky_years):\n    golden_age_intervals = []\n    for year in range(l, r+1):\n        if year not in unlucky_years:\n            golden_age_intervals.append((year, year))\n    return golden_age_intervals\n\ndef get_maximum_golden_age_length(x, y, l, r, unlucky_years):\n    golden_age_intervals = get_golden_age_intervals(x, y, l, r, unlucky_years)\n    maximum_length = 0\n    for interval in golden_age_intervals:\n        length = interval[1] - interval[0] + 1\n        if length > maximum_length:\n            maximum_length = length\n    return maximum_length\n\ndef main():\n    x, y, l, r = map(int, input().split())\n    unlucky_years = get_unlucky_years(x, y, l, r)\n    maximum_golden_age_length = get_maximum_golden_age_length(x, y, l, r, unlucky_years)\n    print(maximum_golden_age_length)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n = int(input())\n\n# Calculate the maximum divisor of n\nmax_divisor = 1\nwhile n % max_divisor == 0:\n    max_divisor += 1\n\n# Calculate the minimum number of burles that Mr. Funt has to pay\nmin_burles = max_divisor - 1\n\nprint(min_burles)"}
{"solution": "def fix_typos(word):\n    vowels = set('aeiou')\n    n = len(word)\n    result = []\n    i = 0\n    \n    while i < n:\n        result.append(word[i])\n        if word[i] not in vowels:\n            start = i\n            while i < n and word[i] not in vowels:\n                i += 1\n            if i - start >= 3:\n                block = word[start:i]\n                if len(set(block)) > 1:\n                    result.append(' ')\n        i += 1\n    \n    return ''.join(result)"}
{"solution": "import sys\n\nn, m, k = map(int, input().split())\nx, s = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\nd = list(map(int, input().split()))\n\n# Use the second spell of the first type to change the preparation time of each potion\nif m > 0 and b[0] <= s:\n    x = a[0]\n    s -= b[0]\n\n# Use the second spell of the second type to instantly prepare potions\nif k > 0 and d[0] <= s:\n    n -= c[0]\n    s -= d[0]\n\n# Prepare the remaining potions\ntime = x * n\n\nprint(time)"}
{"solution": "n, k, M = map(int, input().split())\nt = list(map(int, input().split()))\n\n# Initialize the maximum number of points to 0\nmax_points = 0\n\n# Iterate over all possible combinations of subtasks\nfor i in range(1, k+1):\n    # Calculate the time required to solve the subtasks\n    time_required = sum(t[j] for j in range(i))\n    \n    # Check if the time required is less than or equal to the given time limit\n    if time_required <= M:\n        # Calculate the number of points earned by solving the subtasks\n        points = i + 1\n        \n        # Update the maximum number of points if necessary\n        max_points = max(max_points, points)\n\n# Print the maximum number of points\nprint(max_points)"}
{"solution": "import sys\n\nn = int(sys.stdin.readline().strip())\n\n# Initialize the number of perfectly balanced striped binary search trees to 0\nnum_trees = 0\n\n# Iterate over all possible keys for the root node\nfor root_key in range(1, n + 1):\n    # Check if the root node is even or odd\n    if root_key % 2 == 0:\n        # If the root node is even, the left subtree must have an odd key\n        left_key = root_key - 1\n    else:\n        # If the root node is odd, the left subtree must have an even key\n        left_key = root_key + 1\n\n    # Check if the left subtree is a valid binary search tree\n    if left_key >= 1 and left_key <= n:\n        # If the left subtree is valid, recursively find the number of perfectly balanced striped binary search trees with the remaining vertices\n        num_trees += find_num_trees(n - 1, left_key)\n\n# Return the number of perfectly balanced striped binary search trees\nprint(num_trees % 998244353)"}
{"solution": "import sys\n\nn, m, k = map(int, sys.stdin.readline().split())\n\n# Calculate the current position of Lara\ncurrent_row = 1\ncurrent_col = 1\n\n# Move down to the bottom left corner\nfor i in range(n - 1):\n    current_row += 1\n\n# Move to the right, one cell up, then to the left to the 2-nd column, one cell up\nfor i in range(m - 2):\n    current_col += 1\n    current_row -= 1\n\n# Move until she runs out of non-visited cells\nwhile current_row <= n and current_col <= m:\n    current_row += 1\n    current_col += 1\n\n# Print the current position of Lara\nprint(current_row, current_col)"}
{"solution": "  import math\n\ndef find_min_max(X):\n    # Initialize the minimum possible value of max(a, b) to infinity\n    min_max = math.inf\n    # Initialize the pair (a, b) that minimizes max(a, b) to None\n    min_pair = None\n    \n    # Iterate through all possible factors of X\n    for a in range(1, int(math.sqrt(X)) + 1):\n        if X % a == 0:\n            b = X // a\n            # Calculate the value of max(a, b)\n            max_ab = max(a, b)\n            # If the value of max(a, b) is less than the minimum possible value, update the minimum possible value and the pair (a, b) that minimizes max(a, b)\n            if max_ab < min_max:\n                min_max = max_ab\n                min_pair = (a, b)\n    \n    return min_pair\n\nX = int(input())\nprint(find_min_max(X))"}
{"solution": "def max_fruits_for_compote(a, b, c):\n    # Calculate the maximum number of complete sets for each fruit type\n    max_sets_lemons = a // 1\n    max_sets_apples = b // 2\n    max_sets_pears = c // 4\n    \n    # Find the limiting factor (minimum number of complete sets)\n    max_complete_sets = min(max_sets_lemons, max_sets_apples, max_sets_pears)\n    \n    # Calculate the total number of fruits used in the compote\n    total_fruits = max_complete_sets * (1 + 2 + 4)\n    \n    return total_fruits\n\n# Example usage:\na = int(input())\nb = int(input())\nc = int(input())\n\nprint(max_fruits_for_compote(a, b, c))"}
{"solution": "def can_divide_teams(n, ratings):\n    ratings.sort()\n    for i in range(n):\n        if ratings[i] >= ratings[i + n]:\n            return \"NO\"\n    return \"YES\""}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize the number of insertions needed\nk = 0\n\n# Iterate through the array and check if any two adjacent elements are co-prime\nfor i in range(n - 1):\n    if gcd(a[i], a[i + 1])!= 1:\n        # If not co-prime, find the least common multiple and insert it\n        lcm = a[i] * a[i + 1] // gcd(a[i], a[i + 1])\n        a.insert(i + 1, lcm)\n        k += 1\n\n# Print the number of insertions needed and the updated array\nprint(k)\nprint(*a)"}
{"solution": "import math\nfrom functools import reduce\nfrom math import gcd\n\ndef compute_gcd_of_list(lst):\n    return reduce(gcd, lst)\n\ndef max_divisor_after_operations(N, K, A):\n    if N == 1:\n        return A[0]\n    \n    # Compute the GCD of the differences between all pairs\n    diffs = [abs(A[i] - A[j]) for i in range(N) for j in range(i + 1, N)]\n    initial_gcd = compute_gcd_of_list(diffs)\n    \n    # Check all divisors of the initial GCD\n    max_divisor = 1\n    for d in range(1, initial_gcd + 1):\n        if initial_gcd % d == 0:\n            # Check if we can make all elements divisible by d\n            if all((a % d) <= K for a in A):\n                max_divisor = d\n    \n    return max_divisor\n\n# Read input\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Compute and print the result\nprint(max_divisor_after_operations(N, K, A))"}
{"solution": "import sys\n\ndef get_perfect_longcat(x):\n    t = 0\n    n = 0\n    while x < 2**30:\n        t += 1\n        n = (t-1)//2\n        x = x ^ (2**n - 1)\n        x += 1\n    return t\n\nif __name__ == \"__main__\":\n    x = int(sys.stdin.readline().strip())\n    t = get_perfect_longcat(x)\n    print(t)\n    for i in range(1, t, 2):\n        print(i//2)"}
{"solution": "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Find the minimum number of hours required to water the garden\nmin_hours = 0\nfor i in range(n):\n    if k % a[i] == 0:\n        min_hours = k // a[i]\n        break\n\nprint(min_hours)"}
{"solution": "def can_grasshopper_reach_insect(line, k):\n    # Initialize variables\n    n = len(line)\n    start_index = line.index(\"G\")\n    end_index = line.index(\"T\")\n    jump_sequence = []\n\n    # Check if the grasshopper can reach the insect\n    while start_index!= end_index:\n        # Check if the grasshopper can make a jump\n        if start_index + k <= n - 1:\n            # Make a jump and add it to the sequence\n            jump_sequence.append(start_index + k)\n            start_index += k\n        else:\n            # The grasshopper can't make a jump, so the sequence is invalid\n            return \"NO\"\n\n    # The grasshopper can reach the insect, so return the sequence\n    return \"YES\""}
{"solution": "import math\n\ndef get_point_of_aiming(y1, y2, yw, xb, yb, r):\n    # Calculate the angle of incidence\n    theta = math.atan2(yb - yw, xb - yw)\n    \n    # Calculate the angle of reflection\n    phi = math.pi - theta\n    \n    # Calculate the distance between the ball and the wall\n    d = math.sqrt((xb - yw) ** 2 + (yb - yw) ** 2)\n    \n    # Calculate the abscissa of the point of aiming\n    xw = xb + r * math.cos(phi)\n    \n    # Check if the point of aiming is within the bounds of the field\n    if xw >= 0 and xw <= y2:\n        return xw\n    else:\n        return -1\n\n# Test cases\nprint(get_point_of_aiming(4, 10, 13, 10, 3, 1))\nprint(get_point_of_aiming(1, 4, 6, 2, 2, 1))\nprint(get_point_of_aiming(3, 10, 15, 17, 9, 2))"}
{"solution": "import sys\n\ndef get_min_missed_meals(b, d, s):\n    # Initialize variables\n    missed_meals = 0\n    arrival_day = 0\n    departure_day = 0\n\n    # Check if Vasiliy arrived before breakfast\n    if b > 0:\n        arrival_day = 1\n        missed_meals += 1\n\n    # Check if Vasiliy had breakfast\n    if b > 1:\n        missed_meals += 1\n\n    # Check if Vasiliy had dinner\n    if d > 0:\n        missed_meals += 1\n\n    # Check if Vasiliy had supper\n    if s > 0:\n        missed_meals += 1\n\n    # Check if Vasiliy left after supper\n    if s > 1:\n        departure_day = 1\n        missed_meals += 1\n\n    # Return the minimum number of missed meals\n    return missed_meals\n\n# Read input from stdin\nb, d, s = map(int, sys.stdin.readline().split())\n\n# Get the minimum number of missed meals\nmissed_meals = get_min_missed_meals(b, d, s)\n\n# Print the output to stdout\nprint(missed_meals)"}
{"solution": "import sys\n\ndef solve(n, a):\n    x, y = 0, 0\n    for i in range(n):\n        if a[i] == x * y + 1:\n            x += 1\n        elif a[i] == x * (y + 1) + 1:\n            y += 1\n        else:\n            return \"NO\"\n    return \"YES\\n\" + str(x) + \" \" + str(y)\n\nif __name__ == \"__main__\":\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(solve(n, a))"}
{"solution": "import sys\n\ndef get_subsequence(a, b):\n    # Initialize variables\n    subsequence = \"\"\n    i, j = 0, 0\n\n    # Loop through both strings\n    while i < len(a) and j < len(b):\n        # If the current character in a is the same as the current character in b, add it to the subsequence\n        if a[i] == b[j]:\n            subsequence += a[i]\n            i += 1\n            j += 1\n        # If the current character in a is not the same as the current character in b, move on to the next character in a\n        else:\n            i += 1\n\n    # Return the subsequence\n    return subsequence\n\n# Get input from stdin\na = sys.stdin.readline().strip()\nb = sys.stdin.readline().strip()\n\n# Get the subsequence\nsubsequence = get_subsequence(a, b)\n\n# Print the subsequence\nprint(subsequence)"}
{"solution": "def minimal_stones(n, s):\n    current_stones = 0\n    min_stones = 0\n    \n    for char in s:\n        if char == '+':\n            current_stones += 1\n        elif char == '-':\n            current_stones -= 1\n        min_stones = min(min_stones, current_stones)\n    \n    return max(0, -min_stones)"}
{"solution": "n = int(input())\na, b, c = map(int, input().split())\n\n# Calculate the maximum number of liters of kefir that Kolya can drink\nmax_liters = n // b\n\n# If the number of liters is not a whole number, round it up\nif n % b!= 0:\n    max_liters += 1\n\n# If the number of liters is greater than the number of plastic bottles,\n# then the number of liters is equal to the number of plastic bottles\nif max_liters > a:\n    max_liters = a\n\n# If the number of liters is greater than the number of glass bottles,\n# then the number of liters is equal to the number of glass bottles\nif max_liters > b:\n    max_liters = b\n\n# If the number of liters is greater than the number of empty glass bottles,\n# then the number of liters is equal to the number of empty glass bottles\nif max_liters > c:\n    max_liters = c\n\nprint(max_liters)"}
{"solution": "n = int(input())\nk1 = int(input())\nk2 = int(input())\n\n# Initialize the cards for each player\ncards1 = [int(x) for x in input().split()]\ncards2 = [int(x) for x in input().split()]\n\n# Initialize the number of fights\nfights = 0\n\n# While both players have cards\nwhile k1 > 0 and k2 > 0:\n    # Get the top card from each player's stack\n    card1 = cards1.pop(0)\n    card2 = cards2.pop(0)\n\n    # If the cards are equal, both players lose a card\n    if card1 == card2:\n        k1 -= 1\n        k2 -= 1\n    # If the first player's card is greater, they win both cards\n    elif card1 > card2:\n        k1 -= 1\n        k2 -= 2\n    # If the second player's card is greater, they win both cards\n    else:\n        k1 -= 2\n        k2 -= 1\n\n    # Increment the number of fights\n    fights += 1\n\n# If both players have cards, the game will continue forever\nif k1 > 0 and k2 > 0:\n    print(-1)\n# If one player has no cards, they win\nelif k1 == 0:\n    print(fights, 2)\nelse:\n    print(fights, 1)"}
{"solution": "def check_password_complexity(password):\n    if len(password) < 5:\n        return \"Too weak\"\n    \n    has_upper = False\n    has_lower = False\n    has_digit = False\n    \n    for char in password:\n        if char.isupper():\n            has_upper = True\n        elif char.islower():\n            has_lower = True\n        elif char.isdigit():\n            has_digit = True\n    \n    if has_upper and has_lower and has_digit:\n        return \"Correct\"\n    else:\n        return \"Too weak\"\n\n# Example usage\npassword = input().strip()\nprint(check_password_complexity(password))"}
{"solution": "def solve(n, a, b):\n    # Initialize the number of exchanges to 0\n    exchanges = 0\n\n    # Create a dictionary to store the number of students with each academic performance\n    performance_count = {}\n    for i in range(1, 6):\n        performance_count[i] = 0\n\n    # Loop through the students in group A and increment the count for their academic performance\n    for i in range(n):\n        performance_count[a[i]] += 1\n\n    # Loop through the students in group B and increment the count for their academic performance\n    for i in range(n):\n        performance_count[b[i]] += 1\n\n    # Loop through the academic performances and find the minimum number of exchanges needed to balance the groups\n    for i in range(1, 6):\n        # If the number of students with the current academic performance is not equal in both groups, increment the number of exchanges\n        if performance_count[i]!= n / 2:\n            exchanges += abs(performance_count[i] - n / 2)\n\n    # Return the minimum number of exchanges\n    return exchanges"}
{"solution": "import sys\n\nn, m = map(int, input().split())\nhorizontal_streets = input()\nvertical_streets = input()\n\n# Check if the pattern meets the mayor's criteria\nif len(horizontal_streets)!= n or len(vertical_streets)!= m:\n    print(\"NO\")\n    sys.exit()\n\n# Check if the horizontal streets are one-way\nif not all(horizontal_streets[i] == '<' or horizontal_streets[i] == '>' for i in range(n)):\n    print(\"NO\")\n    sys.exit()\n\n# Check if the vertical streets are one-way\nif not all(vertical_streets[i] == '^' or vertical_streets[i] == 'v' for i in range(m)):\n    print(\"NO\")\n    sys.exit()\n\n# Check if the streets are connected\nif not all(horizontal_streets[i] == '<' and horizontal_streets[i+1] == '>' for i in range(n-1)):\n    print(\"NO\")\n    sys.exit()\n\nif not all(vertical_streets[i] == '^' and vertical_streets[i+1] == 'v' for i in range(m-1)):\n    print(\"NO\")\n    sys.exit()\n\n# Check if the junctions are reachable\nreachable = set()\nfor i in range(n):\n    for j in range(m):\n        if horizontal_streets[i] == '<' and vertical_streets[j] == '^':\n            reachable.add((i, j))\n\nfor i in range(n):\n    for j in range(m):\n        if horizontal_streets[i] == '>' and vertical_streets[j] == 'v':\n            reachable.add((i, j))\n\nif len(reachable)!= n*m:\n    print(\"NO\")\n    sys.exit()\n\nprint(\"YES\")"}
{"solution": "  import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize the expression with the given arguments\nexpression = ''.join(str(i) for i in a)\n\n# Check if the expression is already false\nif expression == '0':\n    print('YES')\n    print(expression)\n    sys.exit()\n\n# Check if the expression is already true\nif expression == '1':\n    print('NO')\n    sys.exit()\n\n# Check if the expression can be made false by placing brackets\nfor i in range(n):\n    # Check if the expression can be made false by placing a bracket before the ith argument\n    if a[i] == 0:\n        expression = '(' + expression[:i] + ')' + expression[i:]\n        if expression == '0':\n            print('YES')\n            print(expression)\n            sys.exit()\n\n    # Check if the expression can be made false by placing a bracket after the ith argument\n    if a[i] == 1:\n        expression = expression[:i+1] + '(' + expression[i+1:]\n        if expression == '0':\n            print('YES')\n            print(expression)\n            sys.exit()\n\n# If the expression cannot be made false by placing brackets, print NO\nprint('NO')"}
{"solution": "import sys\n\nn, m = map(int, sys.stdin.readline().split())\n\na = n\nb = m\n\nwhile a!= 0 and b!= 0:\n    if a >= 2 * b:\n        a -= 2 * b\n    elif b >= 2 * a:\n        b -= 2 * a\n    else:\n        break\n\nprint(a, b)"}
{"solution": "  import sys\n\ndef find_k_divisible_numbers(k, a, b):\n    count = 0\n    for x in range(a, b+1):\n        if x % k == 0:\n            count += 1\n    return count\n\nif __name__ == '__main__':\n    k, a, b = map(int, sys.stdin.readline().split())\n    print(find_k_divisible_numbers(k, a, b))"}
{"solution": "import sys\n\nk = int(sys.stdin.readline())\n\n# Calculate the position of the digit in the sequence\nposition = k - 1\n\n# Initialize the sequence with the first digit\nsequence = \"1\"\n\n# Iterate through the remaining digits\nfor i in range(1, position):\n    # Calculate the next digit in the sequence\n    next_digit = (sequence[i - 1] + 1) % 10\n    \n    # Add the next digit to the sequence\n    sequence += str(next_digit)\n\n# Print the k-th digit of the sequence\nprint(sequence[k - 1])"}
{"solution": "def can_vasya_win(n, s):\n    # Calculate the number of moves each player will make\n    moves_each = (n - 11) // 2\n    \n    # Count the number of '8's in the first n - 10 characters\n    count_8s = s[:n - 10].count('8')\n    \n    # Vasya wins if there are more '8's than the number of moves Petya can make\n    if count_8s > moves_each:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Determine if Vasya has a winning strategy\nresult = can_vasya_win(n, s)\nprint(result)"}
{"solution": "  import sys\n\nn, x, pos = map(int, sys.stdin.readline().split())\n\n# Initialize the number of valid permutations to 0\nvalid_permutations = 0\n\n# Iterate over all possible permutations of size n\nfor permutation in itertools.permutations(range(1, n + 1)):\n    # Check if the permutation contains x at position pos\n    if permutation[pos] == x:\n        # Increment the number of valid permutations\n        valid_permutations += 1\n\n# Print the remainder of the division of the number of valid permutations by 10^9+7\nprint(valid_permutations % (10**9 + 7))"}
{"solution": "import re\n\ndef can_encode_message(string, k):\n    # Check if the string has the correct length\n    if len(string)!= k:\n        return False\n    \n    # Check if the string contains only allowed characters\n    if not re.match(r'^[a-z\\*\\?]+$', string):\n        return False\n    \n    # Check if the string contains any invalid characters\n    if '*' in string and '?' in string:\n        return False\n    \n    # Check if the string can be decoded\n    decoded_string = decode_string(string)\n    if len(decoded_string)!= k:\n        return False\n    \n    return True\n\ndef decode_string(string):\n    decoded_string = ''\n    for i in range(len(string)):\n        if string[i] == '*':\n            decoded_string += string[i-1]\n        elif string[i] == '?':\n            decoded_string += string[i-1] * 2\n        else:\n            decoded_string += string[i]\n    return decoded_string\n\nstring = input()\nk = int(input())\n\nif can_encode_message(string, k):\n    print(decode_string(string))\nelse:\n    print(\"Impossible\")"}
{"solution": "import math\n\ndef get_min_turns(x):\n    # Convert degrees to radians\n    x = math.radians(x)\n\n    # Calculate the minimum number of 90-degree turns necessary to achieve the desired orientation\n    turns = math.ceil(x / (math.pi / 2))\n\n    return turns\n\n# Test the function with sample input\nprint(get_min_turns(60))  # Output: 1\nprint(get_min_turns(-60))  # Output: 3"}
{"solution": "def can_get_spheres(blue, violet, orange, x, y, z):\n    # Initialize the number of spheres to be transformed\n    num_spheres_to_transform = 0\n\n    # Initialize the number of spheres to be obtained\n    num_spheres_to_obtain = x + y + z\n\n    # While there are still spheres to be obtained\n    while num_spheres_to_obtain > 0:\n        # If there are still blue spheres to be obtained\n        if blue > 0 and num_spheres_to_obtain > 0:\n            # Transform as many blue spheres as possible into violet spheres\n            num_spheres_to_transform = min(blue, num_spheres_to_obtain)\n            blue -= num_spheres_to_transform\n            violet += num_spheres_to_transform\n            num_spheres_to_obtain -= num_spheres_to_transform\n\n        # If there are still violet spheres to be obtained\n        if violet > 0 and num_spheres_to_obtain > 0:\n            # Transform as many violet spheres as possible into orange spheres\n            num_spheres_to_transform = min(violet, num_spheres_to_obtain)\n            violet -= num_spheres_to_transform\n            orange += num_spheres_to_transform\n            num_spheres_to_obtain -= num_spheres_to_transform\n\n        # If there are still orange spheres to be obtained\n        if orange > 0 and num_spheres_to_obtain > 0:\n            # Transform as many orange spheres as possible into blue spheres\n            num_spheres_to_transform = min(orange, num_spheres_to_obtain)\n            orange -= num_spheres_to_transform\n            blue += num_spheres_to_transform\n            num_spheres_to_obtain -= num_spheres_to_transform\n\n    # If all the required spheres have been obtained, return \"Yes\"\n    if num_spheres_to_obtain == 0:\n        return \"Yes\"\n    # Otherwise, return \"No\"\n    else:\n        return \"No\"\n\n# Test the function with the given input\nblue, violet, orange, x, y, z = map(int, input().split())\nprint(can_get_spheres(blue, violet, orange, x, y, z))"}
{"solution": "import sys\n\nn, k, m = map(int, sys.stdin.readline().split())\n\n# Calculate the number of integer numbers x > 0 that satisfy the conditions\ncount = 0\nfor x in range(1, 10**n):\n    # Check if the decimal representation of x has exactly n digits\n    if len(str(x)) == n:\n        # Check if there exists an integer y > 0 such that y mod k = 0 and y is a suffix of x\n        for y in range(1, 10**n):\n            if y % k == 0 and str(y)[-n:] == str(x):\n                count += 1\n                break\n\n# Print the result modulo m\nprint(count % m)"}
{"solution": "def max_team_size(l, r, a):\n    if l > r:\n        l, r = r, l  # Ensure l is always the smaller or equal group\n    \n    # Use ambidexters to balance the difference\n    d = r - l\n    if a >= d:\n        l += d\n        a -= d\n        # Now l == r, distribute remaining ambidexters equally\n        l += a // 2\n        r += a // 2\n    else:\n        l += a\n        # Not enough ambidexters to balance completely, r remains larger\n    \n    # The maximum team size is twice the smaller group\n    return 2 * min(l, r)"}
{"solution": "import sys\n\nn, k = map(int, input().split())\n\n# Initialize the number of moves as 0\nmoves = 0\n\n# Initialize the number of stones on each manhole as 1\nstones = [1] * n\n\n# Initialize the number of coins on each manhole as 1\ncoins = [1] * n\n\n# Initialize the current position as the k-th manhole\ncurrent_position = k\n\n# While there are still stones on the manholes\nwhile stones.count(1) > 0:\n    # If the current position has a stone on it\n    if stones[current_position] == 1:\n        # Throw the stone to the next manhole\n        stones[current_position] = 0\n        current_position += 1\n        moves += 1\n    # If the current position has no stone on it\n    else:\n        # Open the manhole and pick the coin\n        coins[current_position] = 0\n        moves += 1\n        current_position += 1\n\n# Print the minimum number of moves\nprint(moves)"}
{"solution": "def get_tallest_tower(n, m):\n    # Initialize variables\n    two_block_heights = []\n    three_block_heights = []\n    tallest_tower = 0\n\n    # Get the heights of the towers made with two-block pieces\n    for i in range(n):\n        two_block_heights.append(i * 2 + 2)\n\n    # Get the heights of the towers made with three-block pieces\n    for i in range(m):\n        three_block_heights.append(i * 3 + 3)\n\n    # Find the tallest tower\n    for two_block_height in two_block_heights:\n        for three_block_height in three_block_heights:\n            if two_block_height + three_block_height > tallest_tower:\n                tallest_tower = two_block_height + three_block_height\n\n    return tallest_tower"}
{"solution": "n = int(input())\ncards = [int(input()) for _ in range(n)]\n\n# Check if the number of cards is even\nif n % 2!= 0:\n    print(\"NO\")\n    exit()\n\n# Check if the numbers on the cards are distinct\nif len(set(cards))!= len(cards):\n    print(\"NO\")\n    exit()\n\n# Check if the numbers can be split evenly between Petya and Vasya\nif sum(cards) % 2!= 0:\n    print(\"NO\")\n    exit()\n\n# Find the numbers that Petya and Vasya should choose to make the game fair\npetya_choice = sum(cards) // 2\nvasya_choice = sum(cards) - petya_choice\n\n# Print the output\nprint(\"YES\")\nprint(petya_choice, vasya_choice)"}
{"solution": "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Check if the total number of soldiers is less than or equal to the number of seats\nif sum(a) <= 8 * n:\n    # Initialize a list to store the number of soldiers in each group\n    soldiers = [0] * k\n\n    # Initialize a list to store the number of soldiers in each row\n    row_soldiers = [0] * n\n\n    # Loop through each group of soldiers\n    for i in range(k):\n        # Loop through each row\n        for j in range(n):\n            # If the number of soldiers in the current row is less than the number of soldiers in the current group\n            if row_soldiers[j] < a[i]:\n                # Add the current soldier to the current row\n                row_soldiers[j] += 1\n                # Add the current soldier to the total number of soldiers in the current group\n                soldiers[i] += 1\n                # Break out of the inner loop\n                break\n\n    # Check if the total number of soldiers in each group is equal to the number of soldiers in that group\n    if all(soldiers[i] == a[i] for i in range(k)):\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\nn = int(input())\nsticks = list(map(int, input().split()))\n\n# Initialize the minimum cost to infinity\nmin_cost = float('inf')\n\n# Iterate over all possible values of t\nfor t in range(1, max(sticks) + 1):\n    # Calculate the cost of changing the lengths of the sticks\n    cost = 0\n    for i in range(n):\n        cost += abs(sticks[i] - t)\n    \n    # If the cost is less than the minimum cost, update the minimum cost and the optimal value of t\n    if cost < min_cost:\n        min_cost = cost\n        optimal_t = t\n\n# Print the optimal value of t and the minimum cost\nprint(optimal_t, min_cost)"}
{"solution": "n, m = map(int, input().split())\n\n# Initialize a 2D array to store the map\nmap = [['.' for _ in range(m)] for _ in range(n)]\n\n# Read the map and store the coordinates of the stars\nstars = []\nfor i in range(n):\n    for j in range(m):\n        if map[i][j] == '*':\n            stars.append((i, j))\n\n# Find the minimum and maximum coordinates of the stars\nmin_x, min_y = min(stars, key=lambda x: x[0]), min(stars, key=lambda x: x[1])\nmax_x, max_y = max(stars, key=lambda x: x[0]), max(stars, key=lambda x: x[1])\n\n# Calculate the length and width of the rectangle that covers all the stars\nlength = max_x - min_x + 1\nwidth = max_y - min_y + 1\n\n# Find the maximum of the length and width\nmax_length_width = max(length, width)\n\n# Print the minimum possible side length of the square that covers all the stars\nprint(max_length_width)"}
{"solution": "import math\n\ndef get_probability(n, k, a):\n    # Calculate the number of possible permutations of the array\n    num_permutations = math.factorial(n)\n    \n    # Calculate the number of permutations that result in a sorted array\n    num_sorted_permutations = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] <= a[j]:\n                num_sorted_permutations += 1\n    \n    # Calculate the probability that the array is sorted after k operations\n    probability = num_sorted_permutations / num_permutations\n    \n    # Raise the probability to the k-th power\n    probability = probability ** k\n    \n    # Calculate the modular inverse of the probability\n    modular_inverse = math.inverse_mod(probability, 1000000007)\n    \n    # Return the product of the probability and its modular inverse\n    return probability * modular_inverse\n\nn = int(input())\nk = int(input())\na = list(map(int, input().split()))\n\nprint(get_probability(n, k, a))"}
{"solution": "import sys\n\ndef get_min_seconds(x, y):\n    # Initialize variables\n    current_side_length = x\n    seconds = 0\n\n    # Loop until the current side length is equal to the target side length\n    while current_side_length!= y:\n        # Calculate the new side length based on the current side length\n        new_side_length = current_side_length - 1\n\n        # Update the current side length and increment the number of seconds\n        current_side_length = new_side_length\n        seconds += 1\n\n    # Return the minimum number of seconds required to reach the target side length\n    return seconds\n\n# Get the input from stdin\nx, y = map(int, input().split())\n\n# Get the minimum number of seconds required to reach the target side length\nmin_seconds = get_min_seconds(x, y)\n\n# Print the output to stdout\nprint(min_seconds)"}
{"solution": "import math\n\ndef get_degenerate_matrix(A):\n    a, b, c, d = A[0], A[1], A[2], A[3]\n    det = a*d - b*c\n    if det == 0:\n        return A\n    else:\n        return [a, b, c, d]\n\ndef get_norm(A):\n    return math.sqrt(A[0]**2 + A[1]**2 + A[2]**2 + A[3]**2)\n\ndef get_min_norm(A):\n    degenerate_matrix = get_degenerate_matrix(A)\n    return get_norm(degenerate_matrix)\n\nif __name__ == \"__main__\":\n    a, b, c, d = map(int, input().split())\n    A = [a, b, c, d]\n    print(get_min_norm(A))"}
{"solution": "n, a, b = map(int, input().split())\ngroups = list(map(int, input().split()))\n\n# Initialize variables\none_seater_tables = a\ntwo_seater_tables = b\ndenied_service = 0\n\n# Iterate through the groups\nfor i, group in enumerate(groups):\n    # If the group consists of one person\n    if group == 1:\n        # If there is a vacant one-seater table\n        if one_seater_tables > 0:\n            # Seat the group at the vacant table\n            one_seater_tables -= 1\n        # If there are no vacant one-seater tables\n        else:\n            # If there is a vacant two-seater table\n            if two_seater_tables > 0:\n                # Seat the group at the vacant table\n                two_seater_tables -= 1\n            # If there are no vacant two-seater tables\n            else:\n                # Deny service to the group\n                denied_service += 1\n    # If the group consists of two people\n    else:\n        # If there is a vacant two-seater table\n        if two_seater_tables > 0:\n            # Seat the group at the vacant table\n            two_seater_tables -= 1\n        # If there are no vacant two-seater tables\n        else:\n            # Deny service to the group\n            denied_service += 1\n\n# Print the total number of people the restaurant denies service to\nprint(denied_service)"}
{"solution": "def solve(A, B, C, N):\n    if A + B + C!= N:\n        return -1\n    if A + B == N and C == 0:\n        return N - 1\n    if A + C == N and B == 0:\n        return N - 1\n    if B + C == N and A == 0:\n        return N - 1\n    return -1"}
{"solution": "  import sys\n\ndef solve(x, k):\n    # Calculate the expected number of dresses after one year\n    expected_dresses = x * (2 ** k)\n    \n    # Calculate the number of dresses that will be eaten by the wardrobe\n    num_eaten_dresses = expected_dresses // 2\n    \n    # Calculate the final number of dresses\n    final_dresses = expected_dresses - num_eaten_dresses\n    \n    # Return the final number of dresses modulo 10^9 + 7\n    return final_dresses % (10 ** 9 + 7)\n\nif __name__ == '__main__':\n    x, k = map(int, sys.stdin.readline().split())\n    print(solve(x, k))"}
{"solution": "import math\n\ndef calculate_probability(n, l, r):\n    # Calculate the probability of no inversions\n    probability = 1\n    for i in range(n):\n        probability *= (r[i] - l[i] + 1) / (r[i] - l[i] + 2)\n    return probability\n\ndef main():\n    # Read the input\n    n = int(input())\n    l = []\n    r = []\n    for i in range(n):\n        l.append(int(input()))\n        r.append(int(input()))\n\n    # Calculate the probability of no inversions\n    probability = calculate_probability(n, l, r)\n\n    # Print the output\n    print(probability)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\nn = int(sys.stdin.readline().strip())\n\ndef count_ways(n):\n    ways = 0\n    for i in range(1, n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                for l in range(k+1, n):\n                    if i + j + k + l == n and i * j * k * l!= n * n:\n                        ways += 1\n    return ways\n\nprint(count_ways(n))"}
{"solution": "import sys\n\nn, s = map(int, input().split())\nvolumes = list(map(int, input().split()))\n\n# Initialize the minimum volume in each keg to the maximum possible value\nmin_volumes = [sys.maxsize] * n\n\n# Iterate through each keg and calculate the minimum volume\nfor i in range(n):\n    min_volumes[i] = min(volumes[i], s // n)\n\n# Find the minimum volume in all kegs\nmin_volume = min(min_volumes)\n\n# Check if the Fair Nut can pour his glass by the desired amount\nif min_volume * n < s:\n    print(-1)\nelse:\n    print(min_volume)"}
{"solution": "def caterpillar_and_apple(h1, h2, a, b):\n    # Calculate the total distance the caterpillar needs to travel\n    total_distance = h2 - h1\n\n    # Calculate the number of days it takes for the caterpillar to travel the total distance\n    days = total_distance / (a + b)\n\n    # Check if the caterpillar can reach the apple on the same day\n    if days % 1 == 0:\n        return int(days)\n    else:\n        return -1"}
{"solution": "import sys\n\ndef get_maximum_joy_units(candies, red_candy_weight, blue_candy_weight, red_candy_joy_units, blue_candy_joy_units):\n    # Initialize variables\n    total_joy_units = 0\n    red_candy_count = 0\n    blue_candy_count = 0\n\n    # Loop through the candies and calculate the maximum number of joy units\n    for candy in candies:\n        if candy == \"red\":\n            red_candy_count += 1\n            total_joy_units += red_candy_joy_units\n        elif candy == \"blue\":\n            blue_candy_count += 1\n            total_joy_units += blue_candy_joy_units\n\n    # Calculate the maximum number of joy units that can be obtained by eating a whole candy\n    max_joy_units = total_joy_units + (red_candy_count * red_candy_joy_units) + (blue_candy_count * blue_candy_joy_units)\n\n    return max_joy_units\n\n# Read input from stdin\ncandies = sys.stdin.readline().strip().split()\nred_candy_weight = int(sys.stdin.readline().strip())\nblue_candy_weight = int(sys.stdin.readline().strip())\nred_candy_joy_units = int(sys.stdin.readline().strip())\nblue_candy_joy_units = int(sys.stdin.readline().strip())\n\n# Calculate the maximum number of joy units\nmax_joy_units = get_maximum_joy_units(candies, red_candy_weight, blue_candy_weight, red_candy_joy_units, blue_candy_joy_units)\n\n# Print the output\nprint(max_joy_units)"}
{"solution": "def get_min_steps(start_pos, finish_pos):\n    x1, y1 = start_pos\n    x2, y2 = finish_pos\n    dx = abs(x2 - x1)\n    dy = abs(y2 - y1)\n    if dx == 0 and dy == 0:\n        return 0\n    elif dx == 0:\n        return dy\n    elif dy == 0:\n        return dx\n    else:\n        return max(dx, dy)\n\nstart_pos = (0, 0)\nfinish_pos = (4, 5)\nprint(get_min_steps(start_pos, finish_pos))"}
{"solution": "import sys\n\nn = int(input())\nfractions = input()\n\n# Initialize variables\ndepublicans = 0\nremocrats = 0\ndenied_votes = 0\n\n# Iterate through each employee and their fraction\nfor i in range(n):\n    if fractions[i] == 'D':\n        depublicans += 1\n    elif fractions[i] == 'R':\n        remocrats += 1\n\n# Iterate through each employee and their statements\nfor i in range(n):\n    # If the employee has no right to vote, skip their turn\n    if denied_votes > 0:\n        denied_votes -= 1\n        continue\n\n    # If the employee is from the depublicans fraction, deny the remocrats from voting\n    if fractions[i] == 'D':\n        remocrats -= 1\n\n    # If the employee is from the remocrats fraction, deny the depublicans from voting\n    elif fractions[i] == 'R':\n        depublicans -= 1\n\n    # If the employee has denied someone from voting, add it to the denied_votes count\n    if denied_votes > 0:\n        denied_votes += 1\n\n# Print the outcome of the vote\nif depublicans > remocrats:\n    print('D')\nelse:\n    print('R')"}
{"solution": "import sys\n\ndef solve(a, b, x, y):\n    count = 0\n    for w in range(1, a+1):\n        for h in range(1, b+1):\n            if w/h == x/y and w <= a and h <= b:\n                count += 1\n    return count\n\nif __name__ == \"__main__\":\n    a, b, x, y = map(int, sys.stdin.readline().split())\n    print(solve(a, b, x, y))"}
{"solution": "import math\n\ndef trailing_zeros(n, b):\n    # Calculate the factorial of n\n    factorial = 1\n    for i in range(1, n+1):\n        factorial *= i\n    \n    # Convert the factorial to the given base\n    factorial_base = int(factorial)\n    \n    # Count the number of trailing zeros\n    count = 0\n    while factorial_base % b == 0:\n        count += 1\n        factorial_base //= b\n    \n    return count\n\nn, b = map(int, input().split())\nprint(trailing_zeros(n, b))"}
{"solution": "import sys\n\ndef frog(m, a, b):\n    # Initialize a dictionary to store the number of distinct integers the frog can reach at each position\n    f = {0: 1}\n\n    # Iterate through the positions from 1 to m\n    for i in range(1, m+1):\n        # If the frog can reach the current position, add it to the dictionary\n        if i-a >= 0 and i+b <= m:\n            f[i] = f[i-a] + f[i+b]\n        # If the frog can't reach the current position, set its value to 0\n        else:\n            f[i] = 0\n\n    # Return the sum of the values in the dictionary\n    return sum(f.values())\n\nif __name__ == '__main__':\n    m, a, b = map(int, sys.stdin.readline().split())\n    print(frog(m, a, b))"}
{"solution": "import sys\n\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Check if the length of the sequence is odd\nif n % 2 == 1:\n    # Check if the first and last elements of the sequence are odd\n    if sequence[0] % 2 == 1 and sequence[-1] % 2 == 1:\n        # Check if the sequence can be divided into an odd number of subsegments\n        subsegments = []\n        for i in range(n):\n            if sequence[i] % 2 == 1:\n                subsegments.append(sequence[i])\n        if len(subsegments) % 2 == 1:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n    else:\n        print(\"No\")\nelse:\n    print(\"No\")"}
{"solution": "def find_remaining_trees(x1, y1, x2, y2):\n    # Find the slope of the line between the two given trees\n    slope = (y2 - y1) / (x2 - x1)\n\n    # Find the coordinates of the third tree\n    x3 = x1 + (slope * (x2 - x1))\n    y3 = y1 + (slope * (y2 - y1))\n\n    # Find the coordinates of the fourth tree\n    x4 = x2 + (slope * (x2 - x1))\n    y4 = y2 + (slope * (y2 - y1))\n\n    return x3, y3, x4, y4"}
{"solution": "import sys\n\ndef calculate_f_n(x, y, n):\n    if n == 1:\n        return x\n    elif n == 2:\n        return y\n    else:\n        return (calculate_f_n(x, y, n - 1) + calculate_f_n(x, y, n + 1)) % 1000000007\n\nif __name__ == \"__main__\":\n    x, y = map(int, input().split())\n    n = int(input())\n    print(calculate_f_n(x, y, n))"}
{"solution": "n = int(input())\narr = list(map(int, input().split()))\n\n# Initialize the number of new arrays to 0\nk = 0\n\n# Iterate through the array and check if the sum of elements in each subarray is not zero\nfor i in range(n):\n    subarray_sum = 0\n    for j in range(i, n):\n        subarray_sum += arr[j]\n        if subarray_sum == 0:\n            break\n    if subarray_sum!= 0:\n        k += 1\n\n# Print \"YES\" if the number of new arrays is greater than 0\nif k > 0:\n    print(\"YES\")\n    print(k)\n    for i in range(k):\n        print(i + 1, i + 2)\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\nn, m, k = map(int, input().split())\n\n# Initialize the minimum score to 0\nmin_score = 0\n\n# Iterate through the questions\nfor i in range(n):\n    # If the question is answered correctly, add 1 point to the score\n    if i in m:\n        min_score += 1\n    # If the question is answered incorrectly, reset the score to 0\n    else:\n        min_score = 0\n    # If the counter reaches k, double the score\n    if i % k == k - 1:\n        min_score *= 2\n\n# Print the remainder of the minimum score modulo 1000000009\nprint(min_score % 1000000009)"}
{"solution": "import sys\n\nn = int(sys.stdin.readline().strip())\n\n# Check if n is divisible by 8\nif n % 8 == 0:\n    print(\"YES\")\n    print(n)\n    sys.exit()\n\n# Check if n has any digits that are divisible by 8\nfor i in range(len(str(n))):\n    if int(str(n)[i]) % 8 == 0:\n        print(\"YES\")\n        print(n - int(str(n)[i]))\n        sys.exit()\n\n# Check if n has any digits that are divisible by 4\nfor i in range(len(str(n))):\n    if int(str(n)[i]) % 4 == 0:\n        print(\"YES\")\n        print(n - int(str(n)[i]))\n        sys.exit()\n\n# Check if n has any digits that are divisible by 2\nfor i in range(len(str(n))):\n    if int(str(n)[i]) % 2 == 0:\n        print(\"YES\")\n        print(n - int(str(n)[i]))\n        sys.exit()\n\n# If none of the above conditions are met, print \"NO\"\nprint(\"NO\")"}
{"solution": "n, m = map(int, input().split())\nflats = {}\n\nfor i in range(m):\n    k, f = map(int, input().split())\n    flats[k] = f\n\nif n in flats:\n    print(flats[n])\nelse:\n    print(-1)"}
{"solution": "def max_bishwocks(board1, board2):\n    n = len(board1)\n    board = [[board1[i], board2[i]] for i in range(n)]\n    \n    # Define the four possible shapes of the bishwock\n    bishwock_shapes = [\n        [(0, 0), (0, 1), (1, 0)],  # Original L shape\n        [(0, 0), (0, 1), (1, 1)],  # Rotated 90 degrees\n        [(0, 1), (1, 0), (1, 1)],  # Rotated 180 degrees\n        [(0, 0), (1, 0), (1, 1)]   # Rotated 270 degrees\n    ]\n    \n    def can_place_bishwock(x, y, shape):\n        for dx, dy in shape:\n            nx, ny = x + dx, y + dy\n            if nx >= 2 or ny >= n or board[ny][nx] == 'X':\n                return False\n        return True\n    \n    def place_bishwock(x, y, shape):\n        for dx, dy in shape:\n            nx, ny = x + dx, y + dy\n            board[ny][nx] = 'X'\n    \n    count = 0\n    for y in range(n):\n        for x in range(2):\n            for shape in bishwock_shapes:\n                if can_place_bishwock(x, y, shape):\n                    place_bishwock(x, y, shape)\n                    count += 1\n                    break\n    \n    return count\n\n# Example usage\nboard1 = \"00X00X0XXX0\"\nboard2 = \"0XXX0X00X00\"\nprint(max_bishwocks(board1, board2))  # Output: 4"}
{"solution": "n = int(input())\ns = input().strip()\n\nmax_length = 0\ncurrent_set = set()\n\nfor char in s:\n    if char.islower():\n        current_set.add(char)\n    else:\n        max_length = max(max_length, len(current_set))\n        current_set.clear()\n\nmax_length = max(max_length, len(current_set))\n\nprint(max_length)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Initialize the maximum possible value of B - C\nmax_value = 0\n\n# Iterate through all possible partitions of the sequence\nfor i in range(n):\n    # Calculate the sum of elements in b\n    b_sum = sum(a[:i])\n    # Calculate the sum of elements in c\n    c_sum = sum(a[i:])\n    # Calculate the difference between the sums\n    diff = b_sum - c_sum\n    # Update the maximum possible value if necessary\n    if diff > max_value:\n        max_value = diff\n\n# Print the maximum possible value of B - C\nprint(max_value)"}
{"solution": "def get_min_refuels(a, b, f, k):\n    # Initialize variables\n    current_position = 0\n    current_fuel = b\n    refuels = 0\n\n    # Iterate through each journey\n    for i in range(k):\n        # Calculate the distance to the next refueling point\n        distance_to_refuel = f - current_position\n\n        # Check if the bus can make the journey without refueling\n        if current_fuel >= distance_to_refuel:\n            # Update the current position and fuel level\n            current_position = f\n            current_fuel -= distance_to_refuel\n        else:\n            # Update the current position and fuel level\n            current_position = f\n            current_fuel = b\n            refuels += 1\n\n    # Return the minimum number of refuels needed\n    return refuels"}
{"solution": "n, p, q = map(int, input().split())\ns = input()\n\nif len(s) % (p + q)!= 0:\n    print(-1)\n    exit()\n\nk = len(s) // (p + q)\nresult = []\nfor i in range(k):\n    result.append(s[i * (p + q):i * (p + q) + p])\n    result.append(s[i * (p + q) + p:i * (p + q) + p + q])\n\nprint(k)\nfor r in result:\n    print(r)"}
{"solution": "import sys\n\nn, m, s, d = map(int, input().split())\nobstacles = list(map(int, input().split()))\n\n# Initialize the starting point\nx = 0\n\n# Initialize the jump length\njump_length = 0\n\n# Initialize the run length\nrun_length = 0\n\n# Initialize the current obstacle\ncurrent_obstacle = 0\n\n# Initialize the flag to indicate if the athlete can reach the finish point\ncan_reach_finish = True\n\n# Iterate through the obstacles\nfor i in range(n):\n    # Check if the athlete can reach the current obstacle\n    if x + run_length + jump_length < obstacles[i]:\n        # The athlete cannot reach the current obstacle, so the problem is impossible\n        can_reach_finish = False\n        break\n    \n    # Check if the athlete needs to jump over the current obstacle\n    if x + run_length + jump_length == obstacles[i]:\n        # The athlete needs to jump over the current obstacle\n        jump_length = d\n        run_length = 0\n        current_obstacle += 1\n    \n    # Check if the athlete needs to run to the current obstacle\n    if x + run_length + jump_length > obstacles[i]:\n        # The athlete needs to run to the current obstacle\n        run_length = obstacles[i] - x - run_length - jump_length\n        jump_length = 0\n        current_obstacle += 1\n\n# Check if the athlete can reach the finish point\nif x + run_length + jump_length < m:\n    # The athlete can reach the finish point\n    print(\"RUN\", m - x - run_length - jump_length)\nelse:\n    # The athlete cannot reach the finish point\n    print(\"IMPOSSIBLE\")"}
{"solution": "import sys\n\ns, x = map(int, input().split())\n\n# Check if s - x is even\nif (s - x) % 2 == 0:\n    # Check if b is positive\n    b = (s - x) // 2\n    if b > 0:\n        # Check if a is positive\n        a = s - b\n        if a > 0:\n            # Print the number of solutions\n            print(2)\n        else:\n            print(0)\n    else:\n        print(0)\nelse:\n    print(0)"}
{"solution": "n, k = map(int, input().split())\n\n# Initialize the skewers as initially turned over\nskewers = [True] * n\n\n# Initialize the number of actions as 0\nactions = 0\n\n# Iterate through each skewer\nfor i in range(n):\n    # If the skewer is initially turned over, turn it over again\n    if skewers[i]:\n        skewers[i] = False\n        actions += 1\n\n    # If the skewer is initially in the initial position, turn it over\n    else:\n        skewers[i] = True\n        actions += 1\n\n# Print the number of actions\nprint(actions)\n\n# Print the skewers to be turned over\nfor i in range(n):\n    if skewers[i]:\n        print(i + 1)"}
{"solution": "import math\n\ndef min_operations_to_square(n):\n    n_str = str(n)\n    n_len = len(n_str)\n    \n    # Generate all possible squares up to the maximum possible value\n    max_square_root = int(math.sqrt(2 * 10**9)) + 1\n    squares = [str(i * i) for i in range(1, max_square_root + 1)]\n    \n    def is_subsequence(small, large):\n        it = iter(large)\n        return all(char in it for char in small)\n    \n    min_deletions = float('inf')\n    \n    for square in squares:\n        if is_subsequence(square, n_str):\n            deletions = n_len - len(square)\n            min_deletions = min(min_deletions, deletions)\n    \n    return min_deletions if min_deletions!= float('inf') else -1\n\n# Example usage:\nprint(min_operations_to_square(8314))  # Output: 2\nprint(min_operations_to_square(625))   # Output: 0\nprint(min_operations_to_square(333))   # Output: -1"}
{"solution": "import sys\n\nn = int(sys.stdin.readline().strip())\n\ndef gcd(a, b):\n    while b!= 0:\n        a, b = b, a % b\n    return a\n\ndef f(p):\n    gcds = []\n    for i in range(len(p)):\n        gcds.append(gcd(p[i], p[i+1]))\n    return len(set(gcds))\n\ndef f_max(n):\n    max_f = 0\n    for p in permutations(range(1, n+1)):\n        f_value = f(p)\n        if f_value > max_f:\n            max_f = f_value\n    return max_f\n\ndef count_permutations(n):\n    count = 0\n    for p in permutations(range(1, n+1)):\n        if f(p) == f_max(n):\n            count += 1\n    return count\n\nprint(count_permutations(n) % (10**9 + 7))"}
{"solution": "def minimum_jump_ability(s):\n    vowels = {'A', 'E', 'I', 'O', 'U', 'Y'}\n    positions = [-1]  # Start position before the first character\n    \n    # Collect positions of all vowels\n    for i, char in enumerate(s):\n        if char in vowels:\n            positions.append(i)\n    \n    positions.append(len(s))  # End position after the last character\n    \n    # Calculate maximum distance between consecutive positions\n    max_distance = 0\n    for i in range(1, len(positions)):\n        max_distance = max(max_distance, positions[i] - positions[i - 1])\n    \n    return max_distance"}
{"solution": "def is_possible(a1, a2, a3, a4):\n    # Calculate the sum of the candies in each bag\n    sum1 = a1 + a2\n    sum2 = a3 + a4\n\n    # Check if the sums are equal\n    if sum1 == sum2:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Test the function with the given input\nprint(is_possible(1, 7, 11, 5))\nprint(is_possible(7, 3, 2, 5))"}
{"solution": "def solve(N, pie_sizes):\n    # Initialize variables to keep track of the sums of the slices eaten by Alice and Bob\n    alice_sum = 0\n    bob_sum = 0\n    \n    # Iterate through the pies in the order they are to be handed out\n    for i in range(N):\n        # If the current pie is odd, Alice eats it and gives the decider token to Bob\n        if pie_sizes[i] % 2 == 1:\n            alice_sum += pie_sizes[i]\n            bob_sum += pie_sizes[i]\n        # If the current pie is even, Bob eats it and gives the decider token to Alice\n        else:\n            bob_sum += pie_sizes[i]\n            alice_sum += pie_sizes[i]\n    \n    # Return the sums of the slices eaten by Alice and Bob\n    return alice_sum, bob_sum"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Initialize the minimum number of variables to 1\nm = 1\n\n# Initialize the current sum to 0\ncurrent_sum = 0\n\n# Iterate through the sequence of operations\nfor i in range(n):\n    # Calculate the sum of the current variables\n    current_sum += sum(b_i for b_i in b)\n    \n    # If the current sum is equal to the current element in the sequence, continue\n    if current_sum == a[i]:\n        continue\n    \n    # If the current sum is greater than the current element in the sequence, decrease the sum by the current element\n    elif current_sum > a[i]:\n        current_sum -= a[i]\n    \n    # If the current sum is less than the current element in the sequence, increase the sum by the current element\n    else:\n        current_sum += a[i]\n    \n    # If the current sum is equal to the current element in the sequence, increase the number of variables\n    if current_sum == a[i]:\n        m += 1\n\n# Print the minimum number of variables\nprint(m)"}
{"solution": "n = int(input())\npiles = list(map(int, input().split()))\n\n# Count the number of piles with an odd number of stones\nodd_count = sum(1 for pile in piles if pile % 2!= 0)\n\n# Determine the winner\nif odd_count % 2 == 0:\n    print(\"Alice\")\nelse:\n    print(\"Bob\")"}
{"solution": "import sys\n\nn = int(input())\narr = list(map(int, input().split()))\n\n# Check if all elements are equal\nif len(set(arr)) == 1:\n    print(\"YES\")\n    sys.exit()\n\n# Check if the sum of all elements is divisible by n\nif sum(arr) % n == 0:\n    print(\"YES\")\n    sys.exit()\n\n# Check if the product of all elements is divisible by n\nif reduce(lambda x, y: x * y, arr) % n == 0:\n    print(\"YES\")\n    sys.exit()\n\n# Check if the sum of the squares of all elements is divisible by n\nif sum(x**2 for x in arr) % n == 0:\n    print(\"YES\")\n    sys.exit()\n\n# Check if the sum of the cubes of all elements is divisible by n\nif sum(x**3 for x in arr) % n == 0:\n    print(\"YES\")\n    sys.exit()\n\n# Check if the sum of the fourth powers of all elements is divisible by n\nif sum(x**4 for x in arr) % n == 0:\n    print(\"YES\")\n    sys.exit()\n\n# Check if the sum of the fifth powers of all elements is divisible by n\nif sum(x**5 for x in arr) % n == 0:\n    print(\"YES\")\n    sys.exit()\n\n# Check if the sum of the sixth powers of all elements is divisible by n\nif sum(x**6 for x in arr) % n == 0:\n    print(\"YES\")\n    sys.exit()\n\n# Check if the sum of the seventh powers of all elements is divisible by n\nif sum(x**7 for x in arr) % n == 0:\n    print(\"YES\")\n    sys.exit()\n\n# Check if the sum of the eighth powers of all elements is divisible by n\nif sum(x**8 for x in arr) % n == 0:\n    print(\"YES\")\n    sys.exit()\n\n# Check if the sum of the ninth powers of all elements is divisible by n\nif sum(x**9 for x in arr) % n == 0:\n    print(\"YES\")\n    sys.exit()\n\n# Check if the sum of the tenth powers of all elements is divisible by n\nif sum(x**10 for x in arr) % n == 0:\n    print(\"YES\")\n    sys.exit()\n\nprint(\"NO\")"}
{"solution": "import sys\n\nN = int(input())\nS = input()\n\n# Initialize the maximum length of a non-empty string that occurs twice or more in S as contiguous substrings without overlapping\nmax_len = 0\n\n# Iterate through each substring of length 1 to N-1\nfor i in range(1, N):\n    # Initialize the number of occurrences of the current substring\n    occurrences = 0\n    \n    # Iterate through each position in S\n    for j in range(N-i):\n        # Check if the current substring occurs at the current position\n        if S[j:j+i] == S[j+1:j+i+1]:\n            # Increment the number of occurrences\n            occurrences += 1\n            \n            # If the number of occurrences is greater than 1, update the maximum length\n            if occurrences > 1:\n                max_len = max(max_len, i)\n                \n                # Break out of the inner loop\n                break\n                \n    # If the maximum length has been updated, break out of the outer loop\n    if max_len > 0:\n        break\n        \n# Print the maximum length\nprint(max_len)"}
{"solution": "n, a = map(int, input().split())\n\nif a % 2 == 1:\n    # a is odd\n    return (a + 1) // 2\nelse:\n    # a is even\n    return (n - a + 2) // 2\n\nprint(minimum_time_to_house(n, a))"}
{"solution": "  import sys\n\nn, m = map(int, input().split())\ncolors = list(map(int, input().split()))\ncounts = list(map(int, input().split()))\n\n# Initialize the counters for each color\ncounters = [0] * m\n\n# Initialize the left and right pointers for the sliding window\nleft = 0\nright = 0\n\n# Initialize the result\nresult = \"NO\"\n\n# Expand and contract the window\nwhile right < n:\n    # Add the current color to the counters\n    counters[colors[right]] += 1\n    \n    # Check if the window meets the required counts\n    if all(counters[i] == counts[i] for i in range(m)):\n        result = \"YES\"\n        break\n    \n    # Move the right pointer to the next element\n    right += 1\n    \n    # If the window exceeds the required counts, move the left pointer to reduce the window size\n    if counters[colors[left]] > counts[colors[left]]:\n        counters[colors[left]] -= 1\n        left += 1\n\nprint(result)"}
{"solution": "n = int(input())\nrounds = []\nfor i in range(n):\n    m, c = map(int, input().split())\n    rounds.append((m, c))\n\nmishka_wins = 0\nchris_wins = 0\nfor round in rounds:\n    m, c = round\n    if m > c:\n        mishka_wins += 1\n    elif c > m:\n        chris_wins += 1\n\nif mishka_wins > chris_wins:\n    print(\"Mishka\")\nelif chris_wins > mishka_wins:\n    print(\"Chris\")\nelse:\n    print(\"Friendship is magic!^^\")"}
{"solution": "import sys\n\nn, m = map(int, input().split())\nfield = [input() for _ in range(n)]\n\n# Check if the field is valid\nfor i in range(n):\n    for j in range(m):\n        if field[i][j]!= '.':\n            # Check if the cell has a bomb\n            if field[i][j] == '*':\n                # Check if the cell has the correct number of bombs\n                if not check_bombs(i, j, field):\n                    print(\"NO\")\n                    sys.exit()\n            # Check if the cell has the correct number of neighbors\n            if not check_neighbors(i, j, field):\n                print(\"NO\")\n                sys.exit()\n\nprint(\"YES\")\n\ndef check_bombs(i, j, field):\n    # Check if the cell has the correct number of bombs\n    bombs = 0\n    for k in range(i-1, i+2):\n        for l in range(j-1, j+2):\n            if k >= 0 and k < n and l >= 0 and l < m:\n                if field[k][l] == '*':\n                    bombs += 1\n    if bombs!= int(field[i][j]):\n        return False\n    return True\n\ndef check_neighbors(i, j, field):\n    # Check if the cell has the correct number of neighbors\n    neighbors = 0\n    for k in range(i-1, i+2):\n        for l in range(j-1, j+2):\n            if k >= 0 and k < n and l >= 0 and l < m:\n                if field[k][l]!= '.':\n                    neighbors += 1\n    if neighbors!= int(field[i][j]):\n        return False\n    return True"}
{"solution": "n = int(input())\n\ndef can_vasya_eat_half(n, k):\n    total_candies = n\n    vasya_eaten = 0\n    \n    while total_candies > 0:\n        # Vasya eats k candies\n        vasya_eaten += min(k, total_candies)\n        total_candies -= min(k, total_candies)\n        \n        # Petya eats 10% of the remaining candies\n        petya_eaten = total_candies // 10\n        total_candies -= petya_eaten\n    \n    return vasya_eaten >= (n + 1) // 2\n\ndef find_min_k(n):\n    left, right = 1, n\n    while left < right:\n        mid = (left + right) // 2\n        if can_vasya_eat_half(n, mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\nprint(find_min_k(n))"}
{"solution": "def can_rearrange_necklace(s):\n    p = s.count('o')\n    l = s.count('-')\n    \n    if p == 0 or p == 1:\n        return \"YES\"\n    if l % p == 0:\n        return \"YES\"\n    return \"NO\""}
{"solution": "import sys\n\nn, m, k = map(int, sys.stdin.readline().split())\n\n# Initialize variables\nmax_pillows = 0\nhobbits = [0] * n\n\n# Loop through each hobbit and calculate the maximum number of pillows they can have\nfor i in range(n):\n    hobbits[i] = max(1, m - i)\n    max_pillows = max(max_pillows, hobbits[i])\n\n# Loop through each hobbit and calculate the maximum number of pillows Frodo can have\nfor i in range(n):\n    if i == k:\n        continue\n    max_pillows = max(max_pillows, hobbits[i] - hobbits[k])\n\nprint(max_pillows)"}
{"solution": "import sys\n\nn, m, k = map(int, input().split())\na = list(map(int, input().split()))\n\ndef get_cost(l, r):\n    return sum(a[l:r+1]) - k * ceil((r - l + 1) / m)\n\ndef solve():\n    max_cost = 0\n    for i in range(n):\n        for j in range(i, n):\n            cost = get_cost(i, j)\n            if cost > max_cost:\n                max_cost = cost\n    return max_cost\n\nprint(solve())"}
{"solution": "import sys\n\nn, m = map(int, sys.stdin.readline().split())\n\n# Initialize a 2D array to store the length of the polyline for each point\npolyline_length = [[0] * (m + 1) for _ in range(n + 1)]\n\n# Initialize a 2D array to store the previous point for each point\nprevious_point = [[(0, 0)] * (m + 1) for _ in range(n + 1)]\n\n# Initialize the maximum length of the polyline\nmax_length = 0\n\n# Initialize the starting point of the polyline\nstart_point = (0, 0)\n\n# Iterate over each point in the grid\nfor i in range(n + 1):\n    for j in range(m + 1):\n        # Calculate the length of the polyline for the current point\n        length = polyline_length[i - 1][j - 1] + 1\n\n        # If the length is greater than the maximum length, update the maximum length and the starting point\n        if length > max_length:\n            max_length = length\n            start_point = (i, j)\n\n        # Update the previous point for the current point\n        previous_point[i][j] = (i - 1, j - 1)\n\n# Initialize the end point of the polyline\nend_point = (n, m)\n\n# Initialize the points of the polyline\npoints = [start_point]\n\n# Iterate over each point in the polyline\nwhile start_point!= end_point:\n    # Get the previous point for the current point\n    previous_point = points[-1]\n\n    # Add the previous point to the list of points\n    points.append(previous_point)\n\n    # Update the start point to the previous point\n    start_point = previous_point\n\n# Print the points of the polyline in order\nfor point in points:\n    print(point[0], point[1])"}
{"solution": "def find_smallest_n(shuffled_string, remembered_substring):\n    # Convert the shuffled string to a list of digits\n    shuffled_list = [int(digit) for digit in shuffled_string]\n    \n    # Find the index of the first digit in the remembered substring\n    remembered_index = shuffled_list.index(remembered_substring[0])\n    \n    # Initialize the smallest possible integer n\n    n = 0\n    \n    # Iterate through the shuffled list and find the first digit that matches the remembered substring\n    for i in range(remembered_index, len(shuffled_list)):\n        if shuffled_list[i] == remembered_substring[0]:\n            # If a match is found, update the value of n\n            n = int(\"\".join(shuffled_list[i:i+len(remembered_substring)]))\n            break\n    \n    return n"}
{"solution": "n, m, min, max = map(int, input().split())\ntemperatures = list(map(int, input().split()))\n\n# Check if the temperatures are consistent\nif len(temperatures)!= m:\n    print(\"Incorrect\")\n    exit()\n\n# Check if the minimum and maximum temperatures are consistent\nif min not in temperatures or max not in temperatures:\n    print(\"Incorrect\")\n    exit()\n\n# Check if the temperatures are in the correct order\nif not all(temperatures[i] <= temperatures[i+1] for i in range(len(temperatures)-1)):\n    print(\"Incorrect\")\n    exit()\n\n# Check if the temperatures can be extended to meet the constraints\nif len(temperatures) < n:\n    print(\"Incorrect\")\n    exit()\n\n# Check if the minimum and maximum temperatures are equal to the given values\nif temperatures[0]!= min or temperatures[-1]!= max:\n    print(\"Incorrect\")\n    exit()\n\nprint(\"Correct\")"}
{"solution": "import sys\n\nm = int(sys.stdin.readline().strip())\n\n# Calculate the number of trailing zeroes in m!\nk = 0\nwhile m % 5 == 0:\n    m //= 5\n    k += 1\n\n# Print the number of values of n such that the factorial of n ends with m zeroes\nprint(k)\n\n# Print the values of n in increasing order\nfor i in range(1, k+1):\n    print(i)"}
{"solution": "import sys\n\nn, m, k = map(int, input().split())\nx = list(map(int, input().split()))\n\ngraph = {}\nfor _ in range(m):\n    u, v, w = map(int, input().split())\n    if u not in graph:\n        graph[u] = {}\n    if v not in graph:\n        graph[v] = {}\n    graph[u][v] = w\n    graph[v][u] = w\n\ndist = [0] * n\nfor i in range(n):\n    if i not in x:\n        continue\n    for j in range(n):\n        if j not in x:\n            continue\n        if i == j:\n            continue\n        dist[i] = max(dist[i], graph[i][j])\n\nprint(*dist)"}
{"solution": "n = int(input())\nx = int(input())\n\n# Initialize the initial position of the ball as the middle shell\ninitial_position = 1\n\n# Iterate through the number of movements made by the operator\nfor i in range(n):\n    # If the current movement is odd, swap the left shell with the middle shell\n    if i % 2 == 1:\n        initial_position = (initial_position + 1) % 3\n    # If the current movement is even, swap the middle shell with the right shell\n    else:\n        initial_position = (initial_position + 2) % 3\n\n# Print the initial position of the ball\nprint(initial_position)"}
{"solution": "import sys\n\ndef is_square(rectangles):\n    # Calculate the minimum and maximum x and y coordinates among all rectangles\n    x_min = min(rectangle[0] for rectangle in rectangles)\n    x_max = max(rectangle[2] for rectangle in rectangles)\n    y_min = min(rectangle[1] for rectangle in rectangles)\n    y_max = max(rectangle[3] for rectangle in rectangles)\n\n    # Calculate the width and height of the bounding box\n    width = x_max - x_min\n    height = y_max - y_min\n\n    # Check if the width and height are equal\n    if width!= height:\n        return False\n\n    # Check if the union of all rectangles covers the entire bounding box without any gaps or overlaps\n    for x in range(x_min, x_max + 1):\n        for y in range(y_min, y_max + 1):\n            if not any(rectangle[0] <= x <= rectangle[2] and rectangle[1] <= y <= rectangle[3] for rectangle in rectangles):\n                return False\n\n    return True\n\nif __name__ == \"__main__\":\n    n = int(input())\n    rectangles = []\n    for _ in range(n):\n        rectangles.append(list(map(int, input().split())))\n    print(\"YES\" if is_square(rectangles) else \"NO\")"}
{"solution": "import sys\n\nn, s = map(int, sys.stdin.readline().split())\n\n# Calculate the quantity of really big numbers that are not greater than n\ncount = 0\nfor i in range(1, n+1):\n    if i - sum(int(digit) for digit in str(i)) >= s:\n        count += 1\n\nprint(count)"}
{"solution": "import sys\n\nn = int(input())\npoints = []\n\nfor i in range(n):\n    x, y = map(int, input().split())\n    points.append((x, y))\n\n# Sort the points by their x-coordinate\npoints.sort(key=lambda x: x[0])\n\n# Initialize the left and right endpoints of the lines\nleft_endpoint = points[0]\nright_endpoint = points[-1]\n\n# Initialize the number of points covered by the lines\nnum_points_covered = 0\n\n# Iterate through the points and check if they are covered by the lines\nfor point in points:\n    # Check if the point is covered by the left line\n    if point[0] >= left_endpoint[0] and point[1] >= left_endpoint[1]:\n        num_points_covered += 1\n\n    # Check if the point is covered by the right line\n    if point[0] <= right_endpoint[0] and point[1] <= right_endpoint[1]:\n        num_points_covered += 1\n\n# Check if all points are covered by the lines\nif num_points_covered == n:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\ndef get_possible_games(a, b, k, t):\n    # Initialize the number of possible games to 0\n    possible_games = 0\n\n    # Iterate through all possible scores for Memory and Lexa\n    for memory_score in range(a, a + k + 1):\n        for lexa_score in range(b, b + k + 1):\n            # Check if the scores are different\n            if memory_score!= lexa_score:\n                # Increment the number of possible games\n                possible_games += 1\n\n    # Return the number of possible games modulo 10^9 + 7\n    return possible_games % (10**9 + 7)\n\n# Read the input from stdin\na, b, k, t = map(int, sys.stdin.readline().split())\n\n# Get the number of possible games\npossible_games = get_possible_games(a, b, k, t)\n\n# Print the number of possible games\nprint(possible_games)"}
{"solution": "import sys\n\nn, l, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Find the minimum number of additional marks needed\nv = 0\nfor i in range(n):\n    if marks[i] + x <= l:\n        v += 1\n    if marks[i] + y <= l:\n        v += 1\n\n# Print the minimum number of additional marks needed\nprint(v)\n\n# Print the positions of the additional marks\nfor i in range(v):\n    print(marks[i] + x, marks[i] + y)"}
{"solution": "import math\n\ndef get_max_volume(n, cakes):\n    # Sort the cakes by height in descending order\n    cakes.sort(key=lambda x: x[1], reverse=True)\n\n    # Initialize the maximum volume\n    max_volume = 0\n\n    # Iterate over the cakes\n    for i in range(n):\n        # Get the current cake\n        cake = cakes[i]\n\n        # Calculate the volume of the current cake\n        volume = math.pi * cake[0] ** 2 * cake[1]\n\n        # Check if the volume is greater than the maximum volume\n        if volume > max_volume:\n            # Update the maximum volume\n            max_volume = volume\n\n    # Return the maximum volume\n    return max_volume\n\n# Test the function\nn = 4\ncakes = [(1, 1), (9, 7), (1, 4), (10, 7)]\nprint(get_max_volume(n, cakes))"}
{"solution": "import sys\n\nn, k = map(int, input().split())\nheights = list(map(int, input().split()))\n\n# Initialize the minimum number of slices to infinity\nmin_slices = sys.maxsize\n\n# Iterate over all possible slice heights\nfor slice_height in range(1, max(heights)):\n    # Initialize the number of slices to 0\n    num_slices = 0\n\n    # Iterate over all towers\n    for tower_height in heights:\n        # If the tower height is greater than the slice height, increment the number of slices\n        if tower_height > slice_height:\n            num_slices += 1\n\n    # If the number of slices is less than or equal to k, update the minimum number of slices\n    if num_slices <= k:\n        min_slices = min(min_slices, num_slices)\n\nprint(min_slices)"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Calculate prefix sums\nprefix_sum = [0] * (n + 1)\nfor i in range(n):\n    prefix_sum[i + 1] = prefix_sum[i] + a[i]\n\nmax_score = float('-inf')\n\n# Iterate over all possible segments [l, r]\nfor l in range(n):\n    max_in_segment = float('-inf')\n    for r in range(l, n):\n        # Update the maximum value in the current segment\n        max_in_segment = max(max_in_segment, a[r])\n        # Calculate the sum of the current segment\n        segment_sum = prefix_sum[r + 1] - prefix_sum[l]\n        # Calculate the score after Bob removes the max value\n        score = segment_sum - max_in_segment\n        # Update the maximum score\n        max_score = max(max_score, score)\n\nprint(max_score)"}
{"solution": "import sys\n\ndef is_possible(k1, k2, k3):\n    # Check if k1, k2, and k3 are all positive\n    if k1 <= 0 or k2 <= 0 or k3 <= 0:\n        return False\n\n    # Check if k1, k2, and k3 are all less than or equal to 1500\n    if k1 > 1500 or k2 > 1500 or k3 > 1500:\n        return False\n\n    # Check if k1, k2, and k3 are all distinct\n    if k1 == k2 or k1 == k3 or k2 == k3:\n        return False\n\n    # Check if there is a way to choose x1, x2, and x3 such that each second after switching the garlands on at least one garland will be lit\n    x1 = 1\n    x2 = 2\n    x3 = 1\n    while x1 < 1500 and x2 < 1500 and x3 < 1500:\n        if x1 % k1 == 0 or x1 % k2 == 0 or x1 % k3 == 0:\n            x1 += 1\n            continue\n        if x2 % k1 == 0 or x2 % k2 == 0 or x2 % k3 == 0:\n            x2 += 1\n            continue\n        if x3 % k1 == 0 or x3 % k2 == 0 or x3 % k3 == 0:\n            x3 += 1\n            continue\n        return True\n    return False\n\nif __name__ == \"__main__\":\n    k1, k2, k3 = map(int, sys.stdin.readline().split())\n    if is_possible(k1, k2, k3):\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "def min_operations_to_delete_string(n, s):\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(n)]\n    \n    # Base case: single character substrings\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Fill the DP table for substrings of length greater than 1\n    for length in range(2, n + 1):  # length of the substring\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                dp[i][j] = dp[i][j-1]\n            else:\n                dp[i][j] = float('inf')\n                for k in range(i, j):\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n    \n    # The result for the entire string\n    return dp[0][n-1]\n\n# Example usage\nn = int(input())\ns = input().strip()\nprint(min_operations_to_delete_string(n, s))"}
{"solution": "def get_max_pairs(n, a, m, b):\n    pairs = []\n    for i in range(n):\n        for j in range(m):\n            if abs(a[i] - b[j]) <= 1:\n                pairs.append((i, j))\n    return len(pairs)"}
{"solution": "def determine_winner(a, b, c, d):\n    # Calculate the defence and attack skills of each team\n    team_1_defence = a + b\n    team_1_attack = c + d\n    team_2_defence = a + c\n    team_2_attack = b + d\n\n    # Check if one team is guaranteed to win\n    if team_1_defence > team_2_attack and team_1_attack > team_2_defence:\n        return \"Team 1\"\n    elif team_2_defence > team_1_attack and team_2_attack > team_1_defence:\n        return \"Team 2\"\n    else:\n        return \"Draw\""}
{"solution": "import math\n\ndef solve(N, K, x, y, c):\n    # Calculate the distance between the heat source and each piece of meat\n    distances = [(math.sqrt((x - x_i) ** 2 + (y - y_i) ** 2), c_i) for x_i, y_i, c_i in zip(x, y, c)]\n\n    # Sort the distances in ascending order\n    distances.sort(key=lambda x: x[0])\n\n    # Initialize the time required to have K or more pieces of meat ready\n    time_required = 0\n\n    # Iterate through the sorted distances\n    for distance, c_i in distances:\n        # Calculate the time required to cook the current piece of meat\n        time_required += c_i * distance\n\n        # If the time required to cook the current piece of meat is greater than the time required to have K or more pieces of meat ready, break the loop\n        if time_required > K:\n            break\n\n    # Return the time required to have K or more pieces of meat ready\n    return time_required\n\n# Test the function with the sample input\nN = 4\nK = 3\nx = [-1, 0, 1, 1]\ny = [0, 0, 0, 1]\nc = [3, 3, 2, 40]\nprint(solve(N, K, x, y, c))"}
{"solution": "import sys\n\nn = int(input())\nticket = input()\n\n# Replace erased digits with '?'\nticket = ticket.replace('?', '0')\n\n# Calculate the sum of the first half of the ticket\nfirst_half_sum = sum(int(ticket[i]) for i in range(n // 2))\n\n# Calculate the sum of the second half of the ticket\nsecond_half_sum = sum(int(ticket[i]) for i in range(n // 2, n))\n\n# Check if the ticket is happy\nif first_half_sum == second_half_sum:\n    print(\"Bicarp\")\nelse:\n    print(\"Monocarp\")"}
{"solution": "def find_bus_route(n, t, bus_routes):\n    earliest_time = float('inf')\n    chosen_route = -1\n    \n    for i in range(n):\n        s_i, d_i = bus_routes[i]\n        \n        if s_i >= t:\n            next_bus_time = s_i\n        else:\n            # Calculate the next bus time after t\n            if (t - s_i) % d_i == 0:\n                next_bus_time = t\n            else:\n                next_bus_time = s_i + ((t - s_i) // d_i + 1) * d_i\n        \n        if next_bus_time < earliest_time:\n            earliest_time = next_bus_time\n            chosen_route = i + 1\n    \n    return chosen_route"}
{"solution": "import sys\n\ndef solve(m, k):\n    # Initialize variables\n    n = 1\n    count = 0\n\n    # Iterate through numbers from n + 1 to 2n\n    for i in range(n + 1, 2 * n + 1):\n        # Count the number of digits in the binary representation of i\n        binary_repr = bin(i)[2:]\n        count += binary_repr.count('1')\n\n        # If the count is equal to m, return the current value of n\n        if count == m:\n            return n\n\n    # If no value of n was found, return -1\n    return -1\n\n# Read input from stdin\nm, k = map(int, sys.stdin.readline().split())\n\n# Solve the problem\nresult = solve(m, k)\n\n# Print the result\nprint(result)"}
{"solution": "import sys\n\nn = int(input())\nlevel = input()\n\n# Check if the level is good\nif len(level) == n and level.count('*') == n:\n    # Check if there is a sequence of four jumps of the same length\n    for i in range(n - 3):\n        if level[i] == '*' and level[i + 1] == '*' and level[i + 2] == '*' and level[i + 3] == '*':\n            print(\"yes\")\n            sys.exit()\n\nprint(\"no\")"}
{"solution": "n = int(input())\ngrid = []\nfor i in range(n):\n    grid.append(list(map(int, input().split())))\n\n# Find the empty cell\nfor i in range(n):\n    for j in range(n):\n        if grid[i][j] == 0:\n            empty_cell = (i, j)\n            break\n\n# Check if the grid is a magic square\nif not is_magic_square(grid):\n    print(-1)\n    exit()\n\n# Fill in the empty cell with a positive integer\nx = find_magic_number(grid, empty_cell)\nprint(x)\n\ndef is_magic_square(grid):\n    # Check if the grid is a square\n    if len(grid)!= len(grid[0]):\n        return False\n    \n    # Check if the grid is a magic square\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j]!= grid[(i + 1) % len(grid)][(j + 1) % len(grid[0])]:\n                return False\n    \n    return True\n\ndef find_magic_number(grid, empty_cell):\n    # Find the missing number\n    missing_number = find_missing_number(grid, empty_cell)\n    \n    # Fill in the empty cell with the missing number\n    grid[empty_cell[0]][empty_cell[1]] = missing_number\n    \n    # Check if the grid is a magic square\n    if not is_magic_square(grid):\n        return -1\n    \n    return missing_number\n\ndef find_missing_number(grid, empty_cell):\n    # Find the sum of the numbers in each row, column, and diagonal\n    row_sums = [0] * len(grid)\n    col_sums = [0] * len(grid[0])\n    diag_sums = [0] * 2\n    \n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            row_sums[i] += grid[i][j]\n            col_sums[j] += grid[i][j]\n            diag_sums[0] += grid[i][j]\n            diag_sums[1] += grid[len(grid) - i - 1][j]\n    \n    # Find the missing number\n    missing_number = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 0:\n                missing_number = row_sums[i] + col_sums[j] - diag_sums[0] - diag_sums[1]\n                break\n    \n    return missing_number"}
{"solution": "n, m = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculate the maximum possible k\nmax_k = max(a) + m\n\n# Calculate the total number of people after adding m people\ntotal_people = sum(a) + m\n\n# Calculate the minimum possible k\nmin_k = ceil(total_people / n)\n\nprint(min_k, max_k)"}
{"solution": "import sys\n\nn, m = map(int, input().split())\n\n# Initialize a 2D array to store the number of ways to assign tickets\nways = [[0] * (n + 1) for _ in range(m + 1)]\n\n# Base case: when there are no passengers or no seats\nways[0][0] = 1\n\n# Iterate over the number of passengers\nfor i in range(1, m + 1):\n    # Iterate over the number of seats\n    for j in range(1, n + 1):\n        # If the seat is empty, the number of ways to assign tickets is the same as the previous seat\n        if j == 1:\n            ways[i][j] = ways[i - 1][j]\n        # If the seat is occupied, the number of ways to assign tickets is the sum of the previous seat and the previous passenger\n        else:\n            ways[i][j] = (ways[i - 1][j - 1] + ways[i - 1][j]) % (10**9 + 7)\n\n# Print the number of ways to assign tickets modulo 10^9 + 7\nprint(ways[m][n] % (10**9 + 7))"}
{"solution": "import sys\n\nn, m = map(int, input().split())\nfriends = [list(map(int, input().split())) for _ in range(n)]\npizzas = [list(map(int, input().split())) for _ in range(m)]\n\n# Parse the input data\nfor friend in friends:\n    friend[1] = set(friend[1:])\n\nfor pizza in pizzas:\n    pizza[1] = set(pizza[1:])\n\n# Find the maximum number of friends that can be pleased\nmax_friends = 0\nfor pizza in pizzas:\n    num_friends = 0\n    for friend in friends:\n        if friend[1].issubset(pizza[1]):\n            num_friends += 1\n    if num_friends > max_friends:\n        max_friends = num_friends\n\n# Find the optimal pair of pizzas\noptimal_pair = []\nfor pizza1 in pizzas:\n    for pizza2 in pizzas:\n        if pizza1[0] + pizza2[0] == min(pizza1[0], pizza2[0]):\n            optimal_pair.append((pizza1, pizza2))\n\n# Print the output\nprint(optimal_pair[0][0][0], optimal_pair[0][1][0])"}
{"solution": "def find_smallest_largest_numbers(m, s):\n    min_num = -1\n    max_num = -1\n    for i in range(10**(m-1), 10**m):\n        if len(str(i)) == m and sum(int(j) for j in str(i)) == s:\n            min_num = i\n            break\n    for i in range(10**(m-1), 10**m):\n        if len(str(i)) == m and sum(int(j) for j in str(i)) == s:\n            max_num = i\n            break\n    return min_num, max_num\n\nm, s = map(int, input().split())\nprint(*find_smallest_largest_numbers(m, s))"}
{"solution": "import sys\n\ndef solve(l, r, k):\n    # Initialize the sum to 0\n    sum = 0\n\n    # Iterate from l to r\n    for i in range(l, r+1):\n        # Check if the number of digits in i is less than or equal to k\n        if len(str(i)) <= k:\n            # Add i to the sum\n            sum += i\n\n    # Return the sum modulo 998244353\n    return sum % 998244353\n\n# Read the input from stdin\nl, r, k = map(int, input().split())\n\n# Solve the problem\nresult = solve(l, r, k)\n\n# Print the result\nprint(result)"}
{"solution": "import sys\n\nn, k, d = map(int, input().split())\na = list(map(int, input().split()))\n\n# Check if it's possible to distribute all the pencils into boxes\nif len(a) < k:\n    print(\"NO\")\n    sys.exit()\n\n# Sort the pencils by saturation\na.sort()\n\n# Initialize the boxes\nboxes = [[] for _ in range(k)]\n\n# Distribute the pencils into the boxes\nfor i in range(len(a)):\n    # Find the box with the smallest number of pencils\n    smallest_box = 0\n    for j in range(1, k):\n        if len(boxes[j]) < len(boxes[smallest_box]):\n            smallest_box = j\n\n    # Add the pencil to the smallest box\n    boxes[smallest_box].append(a[i])\n\n# Check if the conditions are met\nfor i in range(k):\n    # Check if the box is not empty\n    if len(boxes[i]) == 0:\n        print(\"NO\")\n        sys.exit()\n\n    # Check if the box has at least k pencils\n    if len(boxes[i]) < k:\n        print(\"NO\")\n        sys.exit()\n\n    # Check if the pencils in the box have a difference in saturation <= d\n    for j in range(len(boxes[i]) - 1):\n        if abs(boxes[i][j] - boxes[i][j + 1]) > d:\n            print(\"NO\")\n            sys.exit()\n\nprint(\"YES\")"}
{"solution": "def count_dead_bulbs(s):\n    # Initialize a dictionary to store the number of dead bulbs for each color\n    dead_bulbs = {\"R\": 0, \"B\": 0, \"Y\": 0, \"G\": 0}\n\n    # Iterate through the string and count the number of dead bulbs for each color\n    for i in range(len(s)):\n        if s[i] == \"!\":\n            dead_bulbs[s[i-1]] += 1\n\n    # Return the number of dead bulbs for each color\n    return dead_bulbs[\"R\"], dead_bulbs[\"B\"], dead_bulbs[\"Y\"], dead_bulbs[\"G\"]"}
{"solution": "import sys\n\ndef solve(N, M, s_i, t_i):\n    # Initialize the expected number of passages\n    E = 0\n\n    # Loop through each passage\n    for i in range(M):\n        # Calculate the probability of taking the passage\n        probability = 1 / (N - 1)\n\n        # Calculate the expected number of passages for this passage\n        expected_passages = probability * (N - 1)\n\n        # Add the expected number of passages to the total\n        E += expected_passages\n\n    # Return the expected number of passages\n    return E\n\n# Read the input from stdin\nN, M = map(int, input().split())\ns_i, t_i = map(int, input().split())\n\n# Solve the problem\nE = solve(N, M, s_i, t_i)\n\n# Print the output to stdout\nprint(E)"}
{"solution": "n = int(input())\n\nif n % 10 == 0:\n    print(n)\nelse:\n    lower_multiple = n // 10 * 10\n    higher_multiple = (n // 10 + 1) * 10\n    if abs(n - lower_multiple) < abs(n - higher_multiple):\n        print(lower_multiple)\n    else:\n        print(higher_multiple)"}
{"solution": "def find_swaps(s, t):\n    if len(s)!= len(t):\n        return -1\n    \n    mismatches = {}\n    \n    for i in range(len(s)):\n        if s[i]!= t[i]:\n            if s[i] in mismatches and mismatches[s[i]]!= t[i]:\n                return -1\n            if t[i] in mismatches and mismatches[t[i]]!= s[i]:\n                return -1\n            mismatches[s[i]] = t[i]\n            mismatches[t[i]] = s[i]\n    \n    visited = set()\n    swaps = []\n    \n    for key in mismatches:\n        if key not in visited:\n            cycle = []\n            current = key\n            while current not in visited:\n                visited.add(current)\n                cycle.append(current)\n                current = mismatches[current]\n            if len(cycle)!= 2:\n                return -1\n            swaps.append((cycle[0], cycle[1]))\n    \n    print(len(swaps))\n    for swap in swaps:\n        print(swap[0], swap[1])"}
{"solution": "def get_alphabetically_earliest_login(first_name, last_name):\n    # Identify prefixes of first and last names\n    first_name_prefixes = [first_name[i:] for i in range(len(first_name))]\n    last_name_prefixes = [last_name[i:] for i in range(len(last_name))]\n\n    # Generate combinations of prefixes\n    combinations = []\n    for first_prefix in first_name_prefixes:\n        for last_prefix in last_name_prefixes:\n            combinations.append(first_prefix + last_prefix)\n\n    # Compare combinations alphabetically and return the earliest one\n    combinations.sort()\n    return combinations[0]"}
{"solution": "import sys\n\nn = int(input())\nsequence = input()\n\n# Initialize the output string\noutput = \"\"\n\n# Iterate through the sequence and draw the brackets\nfor i in range(n):\n    if sequence[i] == \"[\":\n        output += \"+\"\n    else:\n        output += \"-\"\n\n# Add the vertical bars\nfor i in range(n-1):\n    if sequence[i] == \"[\" and sequence[i+1] == \"]\":\n        output += \"|\"\n\n# Add the spaces between pairs of brackets\nfor i in range(n-2):\n    if sequence[i] == \"[\" and sequence[i+1] == \"]\" and sequence[i+2] == \"[\" and sequence[i+3] == \"]\":\n        output += \" \"\n\n# Add the final vertical bar\noutput += \"|\"\n\n# Print the output\nprint(output)"}
{"solution": "def compare_golden_numbers(num1, num2):\n    # Normalize both numbers\n    norm_num1 = normalize_golden_number(num1)\n    norm_num2 = normalize_golden_number(num2)\n    \n    # Compare lengths first\n    if len(norm_num1) > len(norm_num2):\n        return \">\"\n    elif len(norm_num1) < len(norm_num2):\n        return \"<\"\n    \n    # If lengths are equal, compare digit by digit\n    for digit1, digit2 in zip(norm_num1, norm_num2):\n        if digit1 > digit2:\n            return \">\"\n        elif digit1 < digit2:\n            return \"<\"\n    \n    # If all digits are equal\n    return \"=\"\n\n# Read input\nnum1 = input().strip()\nnum2 = input().strip()\n\n# Compare the numbers and print the result\nresult = compare_golden_numbers(num1, num2)\nprint(result)"}
{"solution": "n = int(input())\ncolors = []\nfor i in range(n):\n    colors.append(input().lower())\n\nabsent_gems = []\nfor gem in [\"power\", \"time\", \"space\", \"soul\", \"reality\", \"mind\"]:\n    if gem.lower() not in colors:\n        absent_gems.append(gem)\n\nprint(len(absent_gems))\nfor gem in absent_gems:\n    print(gem.title())"}
{"solution": "n, a, b = map(int, input().split())\n\nif a == b:\n    print(\"Final!\")\nelse:\n    # Calculate the number of rounds\n    num_rounds = int(n / 2)\n\n    # Calculate the round in which teams a and b can meet\n    round = 1\n    while round <= num_rounds:\n        if (a - 1) % 2 == 0 and (b - 1) % 2 == 0:\n            break\n        round += 1\n\n    # Print the output\n    if round == num_rounds + 1:\n        print(\"Final!\")\n    else:\n        print(round)"}
{"solution": "import sys\n\nn = int(input())\np = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Initialize the minimum number of changes required\nmin_changes = 0\n\n# Initialize the permutation and sequence\nperm = p\nseq = b\n\n# Iterate through each skewer\nfor i in range(n):\n    # If the skewer is not in its original position, move it to its original position\n    if perm[i]!= i + 1:\n        perm[i] = i + 1\n        min_changes += 1\n\n    # If the skewer is not in its reversed position, move it to its reversed position\n    if seq[i] == 1 and perm[i]!= n - i:\n        perm[i] = n - i\n        min_changes += 1\n\n# Print the minimum number of changes required\nprint(min_changes)"}
{"solution": "import math\n\ndef get_max_path_length(v1, v2, t, d):\n    # Calculate the total distance traveled by the car\n    total_distance = (v1 + v2) * t / 2\n\n    # Calculate the maximum possible distance traveled by the car in each second\n    max_distance_per_second = math.sqrt(v1 ** 2 + v2 ** 2)\n\n    # Calculate the maximum possible distance traveled by the car in each second,\n    # taking into account the maximum speed change between adjacent seconds\n    max_distance_per_second_with_speed_change = math.sqrt(v1 ** 2 + v2 ** 2 + 2 * d ** 2)\n\n    # Calculate the maximum possible distance traveled by the car in each second,\n    # taking into account the maximum speed change between adjacent seconds and\n    # the total distance traveled by the car\n    max_distance_per_second_with_speed_change_and_total_distance = math.sqrt(v1 ** 2 + v2 ** 2 + 2 * d ** 2 + total_distance ** 2)\n\n    # Calculate the maximum possible length of the path section\n    max_path_length = max_distance_per_second_with_speed_change_and_total_distance * t\n\n    return max_path_length\n\n\nif __name__ == \"__main__\":\n    v1, v2, t, d = map(int, input().split())\n    print(get_max_path_length(v1, v2, t, d))"}
{"solution": "import sys\n\ndef solve(N, M, w, l, v):\n    # Initialize variables\n    camels = [Camel(i, w[i-1]) for i in range(1, N+1)]\n    parts = [Part(i, l[i-1], v[i-1]) for i in range(1, M+1)]\n    min_distance = sys.maxsize\n\n    # Iterate through all possible arrangements of camels\n    for arrangement in itertools.permutations(camels):\n        # Initialize variables for this arrangement\n        current_distance = 0\n        current_weight = 0\n        current_part = 0\n\n        # Iterate through each camel in the arrangement\n        for camel in arrangement:\n            # Check if the current part can hold the current weight\n            if current_weight + camel.weight > parts[current_part].weight_capacity:\n                # If not, move to the next part\n                current_part += 1\n                current_weight = 0\n\n            # Add the weight of the current camel to the current weight\n            current_weight += camel.weight\n\n            # Check if the current distance is less than the minimum distance\n            if current_distance < min_distance:\n                # If so, update the minimum distance\n                min_distance = current_distance\n\n        # Update the current distance\n        current_distance += camel.weight\n\n    # Return the minimum distance\n    return min_distance\n\nclass Camel:\n    def __init__(self, id, weight):\n        self.id = id\n        self.weight = weight\n\nclass Part:\n    def __init__(self, id, length, weight_capacity):\n        self.id = id\n        self.length = length\n        self.weight_capacity = weight_capacity\n\n# Get input from stdin\nN, M = map(int, input().split())\nw = list(map(int, input().split()))\nl = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\n# Solve the problem\nresult = solve(N, M, w, l, v)\n\n# Print the result\nprint(result)"}
{"solution": "import math\n\ndef get_last_digit(a, b):\n    factorial_a = math.factorial(a)\n    factorial_b = math.factorial(b)\n    quotient = factorial_b // factorial_a\n    return str(quotient)[-1]\n\na, b = map(int, input().split())\nprint(get_last_digit(a, b))"}
{"solution": "def frog_jumps(n, d, s):\n    # Initialize the queue with the starting point (1) and set the number of jumps to 0\n    queue = [(1, 0)]\n\n    # Initialize the visited array to keep track of the points that have been visited\n    visited = [False] * (n + 1)\n\n    # Loop until the queue is empty\n    while queue:\n        # Dequeue the front element\n        current_position, current_jumps = queue.pop(0)\n\n        # Check if the current position is the destination point (n)\n        if current_position == n:\n            return current_jumps + 1\n\n        # Check if the current position has a lily and has not been visited\n        if s[current_position] == \"1\" and not visited[current_position]:\n            # Mark the current position as visited\n            visited[current_position] = True\n\n            # Enqueue the possible jumps from the current position\n            for jump_length in range(1, d + 1):\n                next_position = current_position + jump_length\n                if next_position <= n and s[next_position] == \"1\" and not visited[next_position]:\n                    queue.append((next_position, current_jumps + 1))\n\n    # If the queue is empty and the destination point has not been reached, return -1\n    return -1"}
{"solution": "n = int(input())\n\nfor m in range(1, 1001):\n    if not is_prime(n * m + 1):\n        print(m)\n        break\nelse:\n    print(-1)"}
{"solution": "n = int(input())\n\n# Check if n is a multiple of 1234\nif n % 1234 == 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\nn = int(input())\nx1, x2 = map(int, input().split())\nlines = []\n\nfor i in range(n):\n    k, b = map(int, input().split())\n    lines.append((k, b))\n\n# Check if there are any intersections inside the strip\nfor i in range(n):\n    for j in range(i+1, n):\n        k1, b1 = lines[i]\n        k2, b2 = lines[j]\n        if k1!= k2:\n            x = (b2 - b1) / (k1 - k2)\n            if x1 < x < x2:\n                print(\"YES\")\n                sys.exit()\n\nprint(\"NO\")"}
{"solution": "import sys\n\nn = int(sys.stdin.readline().strip())\n\n# Initialize a dictionary to store the weights of the splits\nweights = {}\n\n# Iterate through all possible splits of n\nfor i in range(1, n + 1):\n    for j in range(i, n + 1):\n        # Check if the current split is a valid split of n\n        if i + j == n:\n            # Get the weight of the current split\n            weight = 1\n            for k in range(i, j):\n                if i == k:\n                    weight += 1\n            # Add the weight to the dictionary\n            weights[weight] = weights.get(weight, 0) + 1\n\n# Print the number of different weights of splits\nprint(len(weights))"}
{"solution": "def find_good_apartments(n, k):\n    if k == 0:\n        min_good = 0\n        max_good = 0\n    else:\n        min_good = 1\n        max_good = min(n - k, 2 * k)\n    \n    return min_good, max_good\n\nn, k = map(int, input().split())\nmin_good, max_good = find_good_apartments(n, k)\nprint(min_good, max_good)"}
{"solution": "  import math\n\ndef get_max_games(n):\n    return math.floor(math.log2(n))\n\nn = int(input())\nprint(get_max_games(n))"}
{"solution": "def max_vk_occurrences(s):\n    # Initialize variables\n    vk_count = 0\n    modified_string = s\n\n    # Iterate through the string and count the number of occurrences of \"VK\"\n    for i in range(len(s) - 1):\n        if s[i] == \"V\" and s[i + 1] == \"K\":\n            vk_count += 1\n\n    # If the string is already \"VK\", return the count\n    if vk_count == 1:\n        return vk_count\n\n    # Otherwise, try changing one character to \"K\" and see if it increases the number of occurrences\n    for i in range(len(s)):\n        if s[i] == \"V\":\n            modified_string = s[:i] + \"K\" + s[i + 1:]\n            vk_count = 0\n            for j in range(len(modified_string) - 1):\n                if modified_string[j] == \"V\" and modified_string[j + 1] == \"K\":\n                    vk_count += 1\n            if vk_count > 1:\n                return vk_count\n\n    # If no changes increase the number of occurrences, return the original count\n    return vk_count"}
{"solution": "  import math\n\ndef min_segments(n):\n    a = int(math.sqrt(n))\n    b = (n + a - 1) // a  # This is equivalent to math.ceil(n / a)\n    return a + b + 2\n\n# Read input\nn = int(input().strip())\nprint(min_segments(n))"}
{"solution": "def get_years_till_limak_becomes_larger(a, b):\n    years = 0\n    while a <= b:\n        a *= 3\n        b *= 2\n        years += 1\n    return years"}
{"solution": "def solve(h, n):\n    # Initialize variables\n    visited_nodes = set()\n    current_node = 1\n    skipped_commands = 0\n\n    # Loop until the exit node is reached\n    while current_node!= n:\n        # If the current node is not a leaf node, follow the left child\n        if current_node * 2 <= n:\n            current_node = current_node * 2\n        # If the current node is a leaf node, follow the right child\n        else:\n            current_node = current_node * 2 + 1\n\n        # If the current node is already visited, skip the command\n        if current_node in visited_nodes:\n            skipped_commands += 1\n            continue\n\n        # Add the current node to the visited nodes set\n        visited_nodes.add(current_node)\n\n        # If two consecutive commands are skipped, go back to the parent node\n        if skipped_commands == 2:\n            current_node = current_node // 2\n            skipped_commands = 0\n\n    # Return the number of visited nodes (excluding the exit node)\n    return len(visited_nodes) - 1"}
{"solution": "import sys\n\ndef solve(x):\n    # Initialize variables\n    k = 0\n    pairs = []\n\n    # Iterate through possible grid sizes\n    for n in range(1, 10**18):\n        for m in range(1, 10**18):\n            # Calculate the number of distinct squares in the grid\n            num_distinct_squares = n * m\n\n            # If the number of distinct squares is equal to x, add the pair to the list\n            if num_distinct_squares == x:\n                pairs.append((n, m))\n                k += 1\n\n    # Sort the pairs in ascending order of n and m\n    pairs.sort(key=lambda x: (x[0], x[1]))\n\n    # Print the number of pairs and the pairs\n    print(k)\n    for pair in pairs:\n        print(pair[0], pair[1])\n\nif __name__ == \"__main__\":\n    x = int(sys.stdin.readline().strip())\n    solve(x)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Check if the sum of the days in the months is equal to the given number\nif sum(a) == n:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\nn = int(sys.stdin.readline().strip())\n\nif n < 2 or n > 10**9:\n    print(\"NO\")\n    sys.exit()\n\n# Initialize variables\nk = 0\na = 0\nb = 0\n\n# Iterate through all possible values of k\nfor k in range(1, 100001):\n    # Check if k is a divisor of n\n    if n % k == 0:\n        # Set a and b to the corresponding values\n        a = n // k\n        b = k\n\n        # Check if a and b are within the required range\n        if 1 < a < b < n:\n            # Print the sequence\n            print(\"YES\")\n            print(k)\n            print(f\"{a} {b}\")\n            sys.exit()\n\n# If no sequence is found, print NO\nprint(\"NO\")"}
{"solution": "import sys\n\nn, a, b = map(int, input().split())\nheights = list(map(int, input().split()))\n\n# Initialize the minimum unattractiveness value to -1\nmin_unattractiveness = -1\n\n# Iterate through each board and calculate the unattractiveness value\nfor i in range(n):\n    # Calculate the unattractiveness value for the current board\n    unattractiveness = 0\n    if i > 0:\n        # Calculate the unattractiveness value for the previous board\n        unattractiveness += abs(heights[i] - heights[i-1])\n    if i < n-1:\n        # Calculate the unattractiveness value for the next board\n        unattractiveness += abs(heights[i] - heights[i+1])\n    # Update the minimum unattractiveness value\n    if unattractiveness < min_unattractiveness or min_unattractiveness == -1:\n        min_unattractiveness = unattractiveness\n\n# Print the minimum unattractiveness value\nprint(min_unattractiveness)"}
{"solution": "import math\n\ndef find_triangle(n, m, k):\n    for x1 in range(n+1):\n        for y1 in range(m+1):\n            for x2 in range(x1+1, n+1):\n                for y2 in range(y1+1, m+1):\n                    for x3 in range(x2+1, n+1):\n                        for y3 in range(y2+1, m+1):\n                            area = abs((x1*y2 + x2*y3 + x3*y1 - x1*y3 - x2*y1 - x3*y2))/2\n                            if area == k:\n                                return \"YES\", x1, y1, x2, y2, x3, y3\n    return \"NO\"\n\nn, m, k = map(int, input().split())\nprint(find_triangle(n, m, k))"}
{"solution": "import sys\n\nn, k = map(int, input().split())\n\nif n < k:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Initialize the counts for each muscle group\nchest_count = 0\nbiceps_count = 0\nback_count = 0\n\n# Iterate through the list of exercises and increment the corresponding count\nfor i in range(n):\n    if i % 3 == 0:\n        chest_count += a[i]\n    elif i % 3 == 1:\n        biceps_count += a[i]\n    else:\n        back_count += a[i]\n\n# Determine which muscle group has the most repetitions\nif chest_count > biceps_count and chest_count > back_count:\n    print(\"chest\")\nelif biceps_count > chest_count and biceps_count > back_count:\n    print(\"biceps\")\nelse:\n    print(\"back\")"}
{"solution": "n = int(input())\ngrades = list(map(int, input().split()))\n\ncurrent_sum = sum(grades)\ntarget_sum = n * 4.5\n\nif current_sum >= target_sum:\n    print(0)\nelse:\n    grades.sort()\n    redos = 0\n    \n    for grade in grades:\n        if current_sum >= target_sum:\n            break\n        current_sum += (5 - grade)\n        redos += 1\n    \n    print(redos)"}
{"solution": "import sys\n\ndef solve(u, v):\n    # Initialize the array with the first element\n    arr = [u]\n    # Loop until the sum of the elements is equal to v\n    while sum(arr)!= v:\n        # Add the next element to the array\n        arr.append(u)\n        # XOR the elements of the array\n        xor = 0\n        for i in range(len(arr)):\n            xor ^= arr[i]\n        # If the XOR is not equal to u, then the array is not valid\n        if xor!= u:\n            return -1\n    # Return the array\n    return arr\n\nif __name__ == \"__main__\":\n    u, v = map(int, sys.stdin.readline().split())\n    print(solve(u, v))"}
{"solution": "n = int(input())\n\n# Initialize the number of digits 1 to 0\nnum_ones = 0\n\n# Loop through each digit of n\nfor digit in str(n):\n    # If the digit is 1, increment the number of digits 1\n    if digit == '1':\n        num_ones += 1\n\n# Print the expected minimal number of digits 1\nprint(num_ones)"}
{"solution": "import sys\n\ndef solve(x1, y1, x2, y2, x, y):\n    # Analyze the moves\n    moves = [(x1, y1), (x1 + x, y1 + y), (x1 + x, y1 - y), (x1 - x, y1 + y), (x1 - x, y1 - y)]\n\n    # Mathematical reasoning\n    if x1 + x == x2 and y1 + y == y2:\n        return \"YES\"\n    elif x1 + x == x2 and y1 - y == y2:\n        return \"YES\"\n    elif x1 - x == x2 and y1 + y == y2:\n        return \"YES\"\n    elif x1 - x == x2 and y1 - y == y2:\n        return \"YES\"\n    else:\n        return \"NO\"\n\nif __name__ == \"__main__\":\n    x1, y1, x2, y2 = map(int, input().split())\n    x, y = map(int, input().split())\n    print(solve(x1, y1, x2, y2, x, y))"}
{"solution": "n = int(input())\n\n# Convert the number to a string to extract digits\ndigits = list(str(n))\n\n# Generate all unique permutations of the digits\nall_permutations = set(permutations(digits))\n\n# Filter out permutations that start with '0'\nvalid_permutations = set()\nfor perm in all_permutations:\n    if perm[0]!= '0':\n        valid_permutations.add(perm)\n\n# Return the count of valid permutations\nprint(len(valid_permutations))"}
{"solution": "import sys\n\na, b, c, d, e, f = map(int, sys.stdin.readline().split())\n\n# Calculate the maximum number of suits of each type that can be made\nmax_suits_1 = a // 2\nmax_suits_2 = (b + c + d) // 3\n\n# Calculate the total cost of each type of suit\ncost_1 = e * max_suits_1\ncost_2 = f * max_suits_2\n\n# Print the maximum total cost of some set of suits that can be composed from the delivered items\nprint(max(cost_1, cost_2))"}
{"solution": "import math\n\ndef solve(a, b, p, x):\n    count = 0\n    for n in range(1, x+1):\n        if pow(a, n, p) == b:\n            count += 1\n    return count\n\na, b, p, x = map(int, input().split())\nprint(solve(a, b, p, x))"}
{"solution": "import sys\n\ndef get_max_sum(k2, k3, k5, k6):\n    # Initialize variables to store the number of digits used\n    num_2 = 0\n    num_3 = 0\n    num_5 = 0\n    num_6 = 0\n\n    # Initialize variables to store the sum of the integers\n    sum_256 = 0\n    sum_32 = 0\n\n    # Loop through the input and calculate the sum of the integers\n    for i in range(k2):\n        num_2 += 1\n        sum_256 += 256\n    for i in range(k3):\n        num_3 += 1\n        sum_32 += 32\n    for i in range(k5):\n        num_5 += 1\n        sum_256 += 256\n    for i in range(k6):\n        num_6 += 1\n        sum_32 += 32\n\n    # Return the maximum sum of the integers\n    return max(sum_256, sum_32)\n\n# Read the input from stdin\nk2, k3, k5, k6 = map(int, sys.stdin.readline().split())\n\n# Get the maximum sum of the integers\nresult = get_max_sum(k2, k3, k5, k6)\n\n# Print the result to stdout\nprint(result)"}
{"solution": "import sys\n\nn, x, y, c = map(int, sys.stdin.readline().split())\n\n# Initialize the grid with the initially switched on cell\ngrid = [[0] * n for _ in range(n)]\ngrid[x - 1][y - 1] = 1\n\n# Simulate the propagation process\nfor i in range(n):\n    for j in range(n):\n        if grid[i][j] == 0 and (grid[i - 1][j] == 1 or grid[i + 1][j] == 1 or grid[i][j - 1] == 1 or grid[i][j + 1] == 1):\n            grid[i][j] = 1\n\n# Count the number of switched on cells\ncount = 0\nfor i in range(n):\n    for j in range(n):\n        if grid[i][j] == 1:\n            count += 1\n\n# Print the answer\nprint(count)"}
{"solution": "import sys\n\ndef get_max_xor(l, r):\n    max_xor = 0\n    for a in range(l, r+1):\n        for b in range(a, r+1):\n            xor = a ^ b\n            if xor > max_xor:\n                max_xor = xor\n    return max_xor\n\nif __name__ == '__main__':\n    l, r = map(int, sys.stdin.readline().split())\n    print(get_max_xor(l, r))"}
{"solution": "def minimum_height(n, k):\n    left, right = 1, k\n    while left < right:\n        mid = (left + right) // 2\n        if n * mid >= k:\n            right = mid\n        else:\n            left = mid + 1\n    return left"}
{"solution": "def should_use_elevator(x, y, z, t1, t2, t3):\n    stairs_time = abs(x - y) * t1\n    elevator_to_masha_time = abs(z - x) * t2 + t3\n    elevator_to_egor_time = abs(x - y) * t2 + 2 * t3\n    elevator_time = elevator_to_masha_time + elevator_to_egor_time\n    if stairs_time < elevator_time:\n        return \"NO\"\n    else:\n        return \"YES\"\n\n# Example usage:\nx, y, z, t1, t2, t3 = map(int, input().split())\nprint(should_use_elevator(x, y, z, t1, t2, t3))"}
{"solution": "import random\n\ndef get_optimal_a(n, m):\n    # Initialize the optimal value of a as the minimum value\n    optimal_a = 1\n    # Initialize the maximum probability as 0\n    max_probability = 0\n\n    # Iterate through all possible values of a\n    for a in range(1, n + 1):\n        # Calculate the probability of winning for the current value of a\n        probability = abs(a - m) / n\n\n        # If the probability is greater than the maximum probability, update the optimal value of a and the maximum probability\n        if probability > max_probability:\n            optimal_a = a\n            max_probability = probability\n\n    return optimal_a\n\nn = int(input())\nm = int(input())\n\nprint(get_optimal_a(n, m))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Initialize variables\npairs_at_university = 0\npairs_at_home = 0\n\n# Iterate through the list of pairs\nfor i in range(n):\n    # If Alena has the i-th pair and it is not a break\n    if a[i] == 1 and i % 2 == 0:\n        # Increment the number of pairs at the university\n        pairs_at_university += 1\n    # If Alena has the i-th pair and it is a break\n    elif a[i] == 1 and i % 2 == 1:\n        # Increment the number of pairs at home\n        pairs_at_home += 1\n\n# Print the number of pairs at the university\nprint(pairs_at_university)"}
{"solution": "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Initialize the minimum number of days to give Bran k candies\nmin_days = -1\n\n# Iterate through each day\nfor i in range(n):\n    # If Arya has enough candies to give Bran k candies on this day\n    if a[i] >= k:\n        # Update the minimum number of days to give Bran k candies\n        min_days = i\n        break\n\n# Print the minimum number of days to give Bran k candies\nprint(min_days)"}
{"solution": "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Initialize additional walks and b array\nadditional_walks = 0\nb = a[:]\n\n# Iterate through days and adjust walks if necessary\nfor i in range(n - 1):\n    if b[i] + b[i + 1] < k:\n        needed_walks = k - (b[i] + b[i + 1])\n        b[i + 1] += needed_walks\n        additional_walks += needed_walks\n\n# Print results\nprint(additional_walks)\nprint(' '.join(map(str, b)))"}
{"solution": "n = int(input())\n\n# Initialize the number of cells to 1\ncells = 1\n\n# Iterate from 2 to n\nfor i in range(2, n+1):\n    # Calculate the number of cells in the current rhombus\n    cells += (i * (i+1)) // 2\n\nprint(cells)"}
{"solution": "import set\n\ndef is_pangram(string):\n    # Convert the string to a consistent case\n    string = string.lower()\n\n    # Create a set to track the unique letters found in the string\n    letters = set()\n\n    # Iterate through the string and add each letter to the set\n    for char in string:\n        letters.add(char)\n\n    # Check if the set contains all 26 letters of the alphabet\n    if len(letters) == 26:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Test the solution with various inputs\nprint(is_pangram(\"toosmallword\"))  # NO\nprint(is_pangram(\"TheQuickBrownFoxJumpsOverTheLazyDog\"))  # YES"}
{"solution": "import datetime\n\ndef get_time_after_minutes(current_time, minutes):\n    current_time = datetime.datetime.strptime(current_time, '%H:%M')\n    time_after_minutes = current_time + datetime.timedelta(minutes=minutes)\n    return time_after_minutes.strftime('%H:%M')\n\ncurrent_time = input()\nminutes = int(input())\nprint(get_time_after_minutes(current_time, minutes))"}
{"solution": "import sys\n\nn, m = map(int, input().split())\nmatrix = [list(map(int, input().strip())) for _ in range(n)]\n\n# Initialize a set to store the indices of the switches that are connected to each lamp\nconnected_switches = [set() for _ in range(m)]\n\n# Populate the set with the indices of the switches that are connected to each lamp\nfor i in range(n):\n    for j in range(m):\n        if matrix[i][j] == 1:\n            connected_switches[j].add(i)\n\n# Check if there is a switch that can be ignored and still turn on all lamps\nfor i in range(n):\n    # If the switch is not connected to any lamp, ignore it\n    if not connected_switches[i]:\n        continue\n\n    # If the switch is connected to all lamps, it can be ignored\n    if len(connected_switches[i]) == m:\n        print(\"YES\")\n        sys.exit()\n\nprint(\"NO\")"}
{"solution": "n = int(input())\n\n# Initialize the sums of the upper and lower halves\nupper_sum = 0\nlower_sum = 0\n\n# Iterate through each domino piece\nfor i in range(n):\n    # Get the numbers on the upper and lower halves\n    x, y = map(int, input().split())\n    \n    # Add the numbers to the sums\n    upper_sum += x\n    lower_sum += y\n\n# Check if the sums are even\nif upper_sum % 2 == 0 and lower_sum % 2 == 0:\n    # If the sums are even, no rotation is required\n    print(0)\nelse:\n    # If the sums are not even, find the minimum number of rotations required to make them even\n    rotations = 0\n    while upper_sum % 2!= 0 or lower_sum % 2!= 0:\n        rotations += 1\n        upper_sum, lower_sum = lower_sum, upper_sum\n    \n    # Print the minimum number of rotations required\n    print(rotations)"}
{"solution": "import math\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef solve(a, b):\n    area = (a - b) * (a + b)\n    return \"YES\" if is_prime(area) else \"NO\"\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        a, b = map(int, input().split())\n        print(solve(a, b))"}
{"solution": "n = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\npositive_count = 0\nnegative_count = 0\n\nfor x, y in points:\n    if x > 0:\n        positive_count += 1\n    else:\n        negative_count += 1\n\nif positive_count <= 1 or negative_count <= 1:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "import math\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\ndef factorial(n):\n    result = 1\n    for i in range(1, n+1):\n        result *= i\n    return result\n\ndef main():\n    a, b = map(int, input().split())\n    a_factorial = factorial(a)\n    b_factorial = factorial(b)\n    gcd_value = gcd(a_factorial, b_factorial)\n    print(gcd_value)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef find_composite_integers(n):\n    # Find the prime factors of n\n    prime_factors = []\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            prime_factors.append(i)\n    if n > 1:\n        prime_factors.append(n)\n\n    # Find the two composite integers a and b such that a - b = n\n    a = 1\n    b = 1\n    for prime in prime_factors:\n        a *= prime\n        b *= prime - 1\n    return a, b\n\nn = int(input())\na, b = find_composite_integers(n)\nprint(a, b)"}
{"solution": "import sys\n\ndef solve(N, M, P, edges):\n    # Initialize the graph with N vertices and M edges\n    graph = [[] for _ in range(N)]\n    for edge in edges:\n        graph[edge[0] - 1].append((edge[1] - 1, edge[2]))\n\n    # Initialize the maximum score to 0\n    max_score = 0\n\n    # Traverse the graph from Vertex 1 to Vertex N\n    for vertex in range(N):\n        # If the current vertex is Vertex N, break the loop\n        if vertex == N - 1:\n            break\n\n        # Get the edges connected to the current vertex\n        edges = graph[vertex]\n\n        # Initialize the current score to 0\n        current_score = 0\n\n        # Traverse the edges and collect coins\n        for edge in edges:\n            # Get the next vertex and the number of coins on the edge\n            next_vertex, coins = edge\n\n            # Add the number of coins to the current score\n            current_score += coins\n\n            # If the next vertex is Vertex N, break the loop\n            if next_vertex == N - 1:\n                break\n\n        # If the current score is greater than the maximum score, update the maximum score\n        if current_score > max_score:\n            max_score = current_score\n\n    # Return the maximum score\n    return max_score\n\nif __name__ == \"__main__\":\n    # Read the input from Standard Input\n    N, M, P = map(int, input().split())\n    edges = []\n    for _ in range(M):\n        edges.append(list(map(int, input().split())))\n\n    # Solve the problem\n    result = solve(N, M, P, edges)\n\n    # Print the result\n    print(result)"}
{"solution": "import sys\n\ndef get_min_cost(strings, costs):\n    # Initialize the minimum cost to -1\n    min_cost = -1\n\n    # Loop through each string and its corresponding cost\n    for string, cost in zip(strings, costs):\n        # If the string is a palindrome, update the minimum cost\n        if is_palindrome(string):\n            min_cost = cost\n            break\n\n    # If no palindrome was found, return -1\n    if min_cost == -1:\n        return -1\n\n    # Otherwise, return the minimum cost\n    return min_cost\n\ndef is_palindrome(string):\n    # Check if the string is a palindrome by comparing it to its reverse\n    return string == string[::-1]\n\n# Get the number of strings and their corresponding costs from the input\nN = int(input())\nstrings = []\ncosts = []\nfor i in range(N):\n    string, cost = input().split()\n    strings.append(string)\n    costs.append(int(cost))\n\n# Get the minimum cost to make a palindrome\nmin_cost = get_min_cost(strings, costs)\n\n# Print the minimum cost\nprint(min_cost)"}
{"solution": "def largest_xor_sum(n, k):\n    # Find the number of bits in n\n    num_bits = n.bit_length()\n    # The largest possible xor-sum\n    max_xor_sum = (1 << num_bits) - 1\n    return max_xor_sum\n\n# Example usage:\nn, k = map(int, input().split())\nprint(largest_xor_sum(n, k))"}
{"solution": "import math\n\ndef solve(n, points):\n    # Sort the points by their x-coordinate\n    sorted_points = sorted(points, key=lambda x: x[0])\n\n    # Initialize the minimum length of the shorter side of the triangle\n    min_length = math.inf\n\n    # Iterate through the points and find the optimal placement of the triangle\n    for i in range(n):\n        # Calculate the length of the side of the triangle that is parallel to the x-axis\n        side_length = sorted_points[i][0] - sorted_points[i - 1][0]\n\n        # Calculate the length of the side of the triangle that is parallel to the y-axis\n        side_length_y = sorted_points[i][1] - sorted_points[i - 1][1]\n\n        # Calculate the length of the shorter side of the triangle\n        shorter_side_length = min(side_length, side_length_y)\n\n        # Update the minimum length of the shorter side of the triangle\n        min_length = min(min_length, shorter_side_length)\n\n    # Return the minimum length of the shorter side of the triangle\n    return min_length\n\n# Test the function with the given examples\nassert solve(3, [(1, 1), (1, 2), (2, 1)]) == 3\nassert solve(4, [(1, 1), (1, 2), (2, 1), (2, 2)]) == 4"}
{"solution": "def max_nineteens(s):\n    from collections import Counter\n    \n    # Count the frequency of each character in the string\n    char_count = Counter(s)\n    \n    # Define the required frequency of each character in the word \"nineteen\"\n    required_counts = {'n': 3, 'i': 1, 'e': 3, 't': 1}\n    \n    # Calculate the maximum number of \"nineteen\" words that can be formed\n    max_nineteens = float('inf')\n    for char, required in required_counts.items():\n        if char in char_count:\n            max_nineteens = min(max_nineteens, char_count[char] // required)\n        else:\n            return 0  # If any required character is missing, we can't form \"nineteen\"\n    \n    return max_nineteens"}
{"solution": "import sys\n\ndef main():\n    p, y = map(int, sys.stdin.readline().split())\n    if p > y:\n        print(-1)\n        return\n\n    # Find the highest branch that is not a multiple of any number from 2 to p\n    for i in range(p, y + 1):\n        if i % p!= 0:\n            print(i)\n            return\n\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\nn, m, k = map(int, input().split())\nprices = list(map(int, input().split()))\n\n# Initialize the minimum distance to a large value\nmin_distance = sys.maxsize\n\n# Iterate through the houses\nfor i in range(n):\n    # If the house is occupied or the price is greater than the budget, skip it\n    if prices[i] == 0 or prices[i] > k:\n        continue\n    \n    # Calculate the distance from the girl's house to the current house\n    distance = abs(m - i) * 10\n    \n    # If the distance is less than the minimum distance, update the minimum distance\n    if distance < min_distance:\n        min_distance = distance\n\n# Print the minimum distance\nprint(min_distance)"}
{"solution": "import sys\n\nn, m = map(int, input().split())\nA = [[int(x) for x in input().split()] for _ in range(n)]\nB = [[int(x) for x in input().split()] for _ in range(n)]\n\n# Initialize a matrix C to store the result of the transpositions\nC = [[0] * m for _ in range(n)]\n\n# Perform the transpositions\nfor i in range(n):\n    for j in range(m):\n        C[i][j] = A[j][i]\n\n# Check if the result is equal to B\nif C == B:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\na = sys.stdin.readline().strip()\nb = sys.stdin.readline().strip()\n\n# Initialize variables\nlongest_uncommon_subsequence = -1\n\n# Iterate through each character in a\nfor i in range(len(a)):\n    # Check if the character is not in b\n    if a[i] not in b:\n        # If it's not in b, it's an uncommon subsequence\n        longest_uncommon_subsequence = max(longest_uncommon_subsequence, len(a[i:]))\n\n# Iterate through each character in b\nfor i in range(len(b)):\n    # Check if the character is not in a\n    if b[i] not in a:\n        # If it's not in a, it's an uncommon subsequence\n        longest_uncommon_subsequence = max(longest_uncommon_subsequence, len(b[i:]))\n\n# Print the longest uncommon subsequence\nprint(longest_uncommon_subsequence)"}
{"solution": "import sys\n\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Calculate the least common multiple (LCM) of a and c\nlcm = a * c // gcd(a, c)\n\n# Calculate the first time Rick and Morty will scream at the same time\ntime = lcm // a\n\n# Check if the time is a multiple of b and d\nif time % b == 0 and time % d == 0:\n    print(time)\nelse:\n    print(-1)"}
{"solution": "n = int(input())\n\n# Initialize variables\na = 0\nb = 0\nc = 0\n\n# Find a solution\nwhile a + b + c!= n:\n    a += 1\n    b += 1\n    c += 1\n\n# Check if a, b, or c is a multiple of 3\nif a % 3 == 0 or b % 3 == 0 or c % 3 == 0:\n    a -= 1\n    b -= 1\n    c -= 1\n\n# Print the solution\nprint(a, b, c)"}
{"solution": "import sys\n\nn, a, b, c, d = map(int, input().split())\n\n# Initialize a 3x3 matrix to store the painting\npainting = [[0] * 3 for _ in range(3)]\n\n# Fill in the known values\npainting[0][0] = a\npainting[0][1] = b\npainting[1][0] = c\npainting[1][1] = d\n\n# Initialize a set to store the distinct squares\ndistinct_squares = set()\n\n# Iterate over each possible square\nfor i in range(n):\n    for j in range(n):\n        # Check if the current square is distinct\n        if (i, j) not in distinct_squares:\n            # Add the current square to the set of distinct squares\n            distinct_squares.add((i, j))\n\n            # Check if the current square satisfies the constraints\n            if satisfies_constraints(painting, i, j):\n                # Add the current square to the list of valid squares\n                valid_squares.append((i, j))\n\n# Print the number of valid squares\nprint(len(valid_squares))\n\ndef satisfies_constraints(painting, i, j):\n    # Check if the current square satisfies the constraints\n    if painting[i][j]!= painting[i][j + 1] + painting[i + 1][j] + painting[i + 1][j + 1]:\n        return False\n\n    # Check if the current square satisfies the constraints\n    if painting[i][j]!= painting[i][j + 1] + painting[i + 1][j] + painting[i + 1][j + 1]:\n        return False\n\n    # Check if the current square satisfies the constraints\n    if painting[i][j]!= painting[i][j + 1] + painting[i + 1][j] + painting[i + 1][j + 1]:\n        return False\n\n    # Check if the current square satisfies the constraints\n    if painting[i][j]!= painting[i][j + 1] + painting[i + 1][j] + painting[i + 1][j + 1]:\n        return False\n\n    # If all constraints are satisfied, return True\n    return True"}
{"solution": "import sys\n\ndef main():\n    w, h = map(int, input().split())\n    u1, d1 = map(int, input().split())\n    u2, d2 = map(int, input().split())\n\n    # Initialize the snowball's weight and height\n    weight = w\n    height = h\n\n    # Loop through the sequence of events\n    while height > 0:\n        # Increase the snowball's weight by its current height\n        weight += height\n\n        # Check if the snowball has hit a stone\n        if height in [d1, d2]:\n            # If so, decrease the snowball's weight by the weight of the stone\n            weight -= u1 if height == d1 else u2\n\n        # Move the snowball one meter down\n        height -= 1\n\n    # Print the final weight of the snowball\n    print(weight)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef get_passing_rate(scores, x, y):\n    # Sort the scores in descending order\n    sorted_scores = sorted(scores, reverse=True)\n\n    # Initialize the passing rate to the highest score\n    passing_rate = sorted_scores[0]\n\n    # Initialize the number of students in each group\n    beginner_group = 0\n    intermediate_group = 0\n\n    # Iterate through the scores and add them to the appropriate group\n    for score in sorted_scores:\n        if score >= passing_rate:\n            intermediate_group += 1\n        else:\n            beginner_group += 1\n\n        # If the size of either group exceeds the specified range, return 0\n        if beginner_group > y or intermediate_group > y:\n            return 0\n\n    # If the size of either group is less than the specified range, return 0\n    if beginner_group < x or intermediate_group < x:\n        return 0\n\n    # Return the passing rate\n    return passing_rate\n\nif __name__ == \"__main__\":\n    m = int(input())\n    scores = list(map(int, input().split()))\n    x, y = map(int, input().split())\n    print(get_passing_rate(scores, x, y))"}
{"solution": "n, k, A, B = map(int, input().split())\n\n# Initialize x to n\nx = n\n\n# Initialize the cost to 0\ncost = 0\n\n# While x is not equal to 1\nwhile x!= 1:\n    # If x is divisible by k\n    if x % k == 0:\n        # Divide x by k and add the cost of the operation to the total cost\n        x //= k\n        cost += B\n    # Otherwise, subtract 1 from x and add the cost of the operation to the total cost\n    else:\n        x -= 1\n        cost += A\n\n# Print the minimum amount of coins needed to make x equal to 1\nprint(cost)"}
{"solution": "  import math\n\ndef solve(n):\n    # Initialize variables\n    min_value = n\n    min_operations = 0\n\n    # Iterate through all possible values of x\n    for x in range(1, int(math.sqrt(n)) + 1):\n        # Calculate the new value of n after applying the mul operation\n        new_value = n * x\n\n        # If the new value is less than the minimum value, update the minimum value and the number of operations\n        if new_value < min_value:\n            min_value = new_value\n            min_operations = 1\n\n        # If the new value is equal to the minimum value, update the number of operations\n        elif new_value == min_value:\n            min_operations += 1\n\n    # Return the minimum value and the number of operations\n    return min_value, min_operations\n\n# Test the function with the given input\nn = 20\nprint(solve(n))\n\n# Test the function with a random input\nn = 5184\nprint(solve(n))"}
{"solution": "import sys\n\ndef get_max_score(N, K, R, S, P, T):\n    # Initialize variables\n    max_score = 0\n    hand_history = []\n    current_hand = None\n\n    # Iterate through each round\n    for i in range(N):\n        # Get the machine's hand for this round\n        machine_hand = T[i]\n\n        # If this is the first K rounds, play any hand\n        if i < K:\n            current_hand = \"r\" if machine_hand == \"s\" else \"s\" if machine_hand == \"p\" else \"p\"\n\n        # Otherwise, play the hand that maximizes the score\n        else:\n            # Get the previous K hands played\n            previous_hands = hand_history[-K:]\n\n            # If the machine played the same hand as the previous K rounds, play the opposite hand\n            if machine_hand in previous_hands:\n                current_hand = \"r\" if machine_hand == \"s\" else \"s\" if machine_hand == \"p\" else \"p\"\n\n            # Otherwise, play the hand that wins against the machine's hand\n            else:\n                if machine_hand == \"r\":\n                    current_hand = \"s\"\n                elif machine_hand == \"s\":\n                    current_hand = \"p\"\n                else:\n                    current_hand = \"r\"\n\n        # Add the current hand to the hand history\n        hand_history.append(current_hand)\n\n        # Calculate the score for this round\n        if current_hand == \"r\":\n            score = R\n        elif current_hand == \"s\":\n            score = S\n        else:\n            score = P\n\n        # Update the maximum score\n        max_score += score\n\n    return max_score\n\n# Read input from stdin\nN, K, R, S, P = map(int, input().split())\nT = input()\n\n# Get the maximum score\nmax_score = get_max_score(N, K, R, S, P, T)\n\n# Print the maximum score\nprint(max_score)"}
{"solution": "import sys\n\ndef get_longest_good_string(a, b, c):\n    # Initialize variables\n    longest_good_string = \"\"\n    current_string = \"\"\n    current_length = 0\n\n    # Iterate through the strings\n    for i in range(a):\n        current_string += \"a\"\n        current_length += 1\n        if current_length > len(longest_good_string):\n            longest_good_string = current_string\n\n    for i in range(b):\n        current_string += \"b\"\n        current_length += 1\n        if current_length > len(longest_good_string):\n            longest_good_string = current_string\n\n    for i in range(c):\n        current_string += \"ab\"\n        current_length += 2\n        if current_length > len(longest_good_string):\n            longest_good_string = current_string\n\n    return longest_good_string\n\n# Read input from stdin\na, b, c = map(int, input().split())\n\n# Get the longest good string\nlongest_good_string = get_longest_good_string(a, b, c)\n\n# Print the output\nprint(len(longest_good_string))"}
{"solution": "import math\n\ndef get_marks(n, k, p, x, y, a):\n    # Calculate the sum of marks for the remaining tests\n    sum_marks = x - sum(a)\n\n    # Calculate the median point of the remaining marks\n    median_point = math.floor(sum_marks / 2)\n\n    # Check if the median point is less than or equal to y\n    if median_point <= y:\n        # If the median point is less than or equal to y, return the marks that will achieve the desired result\n        return [sum_marks - median_point] * (n - k)\n    else:\n        # If the median point is greater than y, return -1\n        return -1\n\n# Test case 1\nn = 5\nk = 3\np = 5\nx = 18\ny = 4\na = [3, 5, 4]\nprint(get_marks(n, k, p, x, y, a))\n\n# Test case 2\nn = 5\nk = 3\np = 5\nx = 16\ny = 4\na = [5, 5, 5]\nprint(get_marks(n, k, p, x, y, a))"}
{"solution": "def is_berlanese(s):\n    vowels = [\"a\", \"o\", \"u\", \"i\", \"e\"]\n    consonants = [\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    for i in range(len(s)):\n        if s[i] in consonants:\n            if i == len(s) - 1 or s[i + 1] not in vowels:\n                return \"NO\"\n        elif s[i] in vowels:\n            if i == len(s) - 1 or s[i + 1] in consonants:\n                return \"NO\"\n    return \"YES\""}
{"solution": "import sys\n\nn, m = map(int, input().split())\n\nedges = []\nfor i in range(m):\n    a, b = map(int, input().split())\n    edges.append((a, b))\n\n# Initialize the number of dominoes to 0\nnum_dominoes = 0\n\n# Iterate over each edge\nfor edge in edges:\n    # Get the vertices of the edge\n    a, b = edge\n    \n    # Check if the vertices are adjacent\n    if a == b - 1 or a == b + 1:\n        # Increment the number of dominoes\n        num_dominoes += 1\n\n# Print the maximum number of dominoes\nprint(num_dominoes)"}
{"solution": "import sys\n\nn, m = map(int, input().split())\nprices = list(map(int, input().split()))\nauction_questions = set(map(int, input().split()))\n\ndef calculate_points(prices, auction_questions):\n    points = 0\n    for i, price in enumerate(prices):\n        if i in auction_questions:\n            points += price\n        else:\n            points += price\n    return points\n\nprint(calculate_points(prices, auction_questions))"}
{"solution": "import math\n\ndef compute_score(submission_times, wrong_submissions, successful_hacks, unsuccessful_hacks):\n    problem_scores = []\n    for i in range(len(submission_times)):\n        problem_score = max(0.3 * (i + 1) * 500, (1 - submission_times[i] / 250) * (i + 1) * 500 - 50 * wrong_submissions[i])\n        problem_scores.append(problem_score)\n    total_score = sum(problem_scores)\n    total_score += successful_hacks * 100\n    total_score -= unsuccessful_hacks * 50\n    return total_score\n\nsubmission_times = [20, 40, 60, 80, 100]\nwrong_submissions = [0, 1, 2, 3, 4]\nsuccessful_hacks = 1\nunsuccessful_hacks = 0\n\nprint(compute_score(submission_times, wrong_submissions, successful_hacks, unsuccessful_hacks))"}
{"solution": "import sys\n\nn, m, L, R = map(int, input().split())\n\n# Initialize a 2D array to store the number of cubes in each cell\ngrid = [[0] * m for _ in range(n)]\n\n# Initialize a set to store the visited states\nvisited = set()\n\n# Initialize a queue to store the states to be processed\nqueue = [(0, 0)]\n\n# Initialize a variable to store the number of states that can be reached\ncount = 0\n\n# Loop until the queue is empty\nwhile queue:\n    # Dequeue a state from the queue\n    state = queue.pop(0)\n\n    # If the state is not visited, mark it as visited and increment the count\n    if state not in visited:\n        visited.add(state)\n        count += 1\n\n        # If the state is a goal state, add it to the queue\n        if is_goal_state(state):\n            queue.append(state)\n\n# Print the number of states that can be reached modulo 998,244,353\nprint(count % 998244353)\n\ndef is_goal_state(state):\n    # Check if all cells have the same number of cubes\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j]!= grid[0][0]:\n                return False\n\n    # Check if all cells are within the given range\n    for i in range(n):\n        for j in range(m):\n            if not L <= grid[i][j] <= R:\n                return False\n\n    return True"}
{"solution": "def is_possible_to_make_increasing(n, m, matrix_a, matrix_b):\n    for i in range(n):\n        for j in range(m):\n            # Ensure that matrix_a[i][j] is the smaller or equal element\n            if matrix_a[i][j] > matrix_b[i][j]:\n                matrix_a[i][j], matrix_b[i][j] = matrix_b[i][j], matrix_a[i][j]\n    \n    # Check rows for strictly increasing property\n    for i in range(n):\n        for j in range(1, m):\n            if matrix_a[i][j] <= matrix_a[i][j-1] or matrix_b[i][j] <= matrix_b[i][j-1]:\n                return \"Impossible\"\n    \n    # Check columns for strictly increasing property\n    for j in range(m):\n        for i in range(1, n):\n            if matrix_a[i][j] <= matrix_a[i-1][j] or matrix_b[i][j] <= matrix_b[i-1][j]:\n                return \"Impossible\"\n    \n    return \"Possible\""}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize the maximum length of the string\nmax_length = 0\n\n# Iterate over each letter in the alphabet\nfor i in range(n):\n    # Calculate the maximum number of occurrences of the current letter\n    max_occurrences = a[i]\n\n    # If the current letter has already been used, decrease the maximum number of occurrences\n    if i in used_letters:\n        max_occurrences -= 1\n\n    # Add the current letter to the string\n    string += chr(i)\n\n    # If the current letter has already been used, decrease the maximum number of occurrences\n    if i in used_letters:\n        max_occurrences -= 1\n\n    # Update the maximum length of the string\n    max_length = max(max_length, len(string))\n\n# Print the maximum length of the string\nprint(max_length)"}
{"solution": "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Sort the list of difficulties in descending order\na.sort(reverse=True)\n\n# Initialize the minimum number of problems to solve on other judges\nmin_problems = 0\n\n# Iterate through the list of difficulties\nfor i in range(n):\n    # If the current difficulty is greater than the maximum difficulty Makes has already solved,\n    # we need to solve at least one more problem on other judges\n    if a[i] > k:\n        min_problems += 1\n\nprint(min_problems)"}
{"solution": "  import sys\n\nn = int(input())\nmin_1, max_1 = map(int, input().split())\nmin_2, max_2 = map(int, input().split())\nmin_3, max_3 = map(int, input().split())\n\n# Initialize variables to store the number of diplomas of each degree\nfirst_degree = 0\nsecond_degree = 0\nthird_degree = 0\n\n# Initialize a list to store the number of participants for each degree\nparticipants = [0] * (n + 1)\n\n# Loop through each participant and assign a degree based on the constraints\nfor i in range(n):\n    # Check if the first degree is available\n    if first_degree < min_1:\n        first_degree += 1\n        participants[i] = 1\n    # Check if the second degree is available\n    elif second_degree < min_2:\n        second_degree += 1\n        participants[i] = 2\n    # Check if the third degree is available\n    elif third_degree < min_3:\n        third_degree += 1\n        participants[i] = 3\n    # If all degrees are full, assign the participant to the degree with the least number of participants\n    else:\n        participants[i] = min(participants)\n\n# Print the number of participants for each degree\nprint(first_degree, second_degree, third_degree)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Check if the moon's size is increasing or decreasing\nif a[n-1] < a[n-2]:\n    print(\"DOWN\")\nelif a[n-1] > a[n-2]:\n    print(\"UP\")\nelse:\n    print(-1)"}
{"solution": "s = input().strip()\nt = input().strip()\n\nvowels = {'a', 'e', 'i', 'o', 'u'}\n\nif len(s)!= len(t):\n    print(\"No\")\n    exit()\n\nfor char_s, char_t in zip(s, t):\n    if (char_s in vowels)!= (char_t in vowels):\n        print(\"No\")\n        exit()\n\nprint(\"Yes\")"}
{"solution": "def pawn_chess(board):\n    # Initialize variables\n    player_a_moves = []\n    player_b_moves = []\n    winner = None\n\n    # Parse the board\n    for row in board:\n        for cell in row:\n            if cell == 'B':\n                player_b_moves.append((row, cell))\n            elif cell == 'W':\n                player_a_moves.append((row, cell))\n\n    # Determine the winner\n    if len(player_a_moves) == 0:\n        winner = 'B'\n    elif len(player_b_moves) == 0:\n        winner = 'A'\n    else:\n        # Both players have moves available, so we need to determine the optimal strategy\n        # We will use a depth-first search to explore all possible moves and determine the winner\n        visited = set()\n        queue = [(player_a_moves, player_b_moves)]\n\n        while queue:\n            player_a_moves, player_b_moves = queue.pop(0)\n            visited.add((player_a_moves, player_b_moves))\n\n            # Check if either player has won\n            if len(player_a_moves) == 0:\n                winner = 'B'\n                break\n            elif len(player_b_moves) == 0:\n                winner = 'A'\n                break\n\n            # Generate all possible moves for both players\n            for move in player_a_moves:\n                new_player_a_moves = []\n                new_player_b_moves = []\n\n                for pawn in player_a_moves:\n                    if pawn!= move:\n                        new_player_a_moves.append(pawn)\n\n                for pawn in player_b_moves:\n                    if pawn!= move:\n                        new_player_b_moves.append(pawn)\n\n                # Add the new moves to the queue\n                queue.append((new_player_a_moves, new_player_b_moves))\n\n        # If we reach this point, then neither player has won, so the game is a draw\n        if winner is None:\n            winner = 'D'\n\n    return winner"}
{"solution": "n = int(input())\nA = list(map(int, input().split()))\nm = int(input())\nB = list(map(int, input().split()))\n\nif sum(A)!= sum(B):\n    print(-1)\nelse:\n    i, j = 0, 0\n    sumA, sumB = 0, 0\n    count = 0\n    \n    while i < n and j < m:\n        sumA += A[i]\n        sumB += B[j]\n        \n        if sumA == sumB:\n            count += 1\n            sumA = 0\n            sumB = 0\n            i += 1\n            j += 1\n        elif sumA < sumB:\n            i += 1\n        else:\n            j += 1\n    \n    print(count)"}
{"solution": "def is_from_contest(problem_name):\n    friends = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\n    for friend in friends:\n        if friend in problem_name:\n            return \"YES\"\n    return \"NO\""}
{"solution": "def min_length_with_k_primes(a, b, k):\n    is_prime = sieve(b)\n    prime_count = count_primes_in_range(is_prime, a, b)\n    \n    def has_k_primes_in_length(l):\n        for x in range(a, b - l + 2):\n            if prime_count[x + l - 1] - prime_count[x - 1] >= k:\n                return True\n        return False\n    \n    left, right = 1, b - a + 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if has_k_primes_in_length(mid):\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return result"}
{"solution": "import math\n\ndef solve(a, h, w):\n    # Calculate the minimum value of x\n    x = math.sqrt(a * h * w) / (a + h + w)\n    \n    # Check if the value of x is valid\n    if x >= 0 and x <= 1:\n        return x\n    else:\n        return -1\n\na = int(input())\nh = int(input())\nw = int(input())\nprint(solve(a, h, w))"}
{"solution": "n = int(input())\nchapters = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    chapters.append((l, r))\nk = int(input())\n\n# Find the chapter that Nastya finished reading in\nfinished_chapter = None\nfor i in range(n):\n    if chapters[i][0] <= k <= chapters[i][1]:\n        finished_chapter = i\n        break\n\n# Count the number of chapters that have not been read\nnum_chapters_left = 0\nfor i in range(n):\n    if i < finished_chapter:\n        num_chapters_left += 1\n    elif i > finished_chapter:\n        num_chapters_left += 1\n\nprint(num_chapters_left)"}
{"solution": "def can_form_codeforces(word):\n    target = \"CODEFORCES\"\n    n = len(word)\n    m = len(target)\n    \n    if n < m:\n        return \"NO\"\n    \n    for i in range(m + 1):\n        if word[:i] == target[:i] and word[n - (m - i):] == target[i:]:\n            return \"YES\"\n    \n    return \"NO\"\n\nprint(can_form_codeforces(input()))"}
{"solution": "import sys\n\nn = int(sys.stdin.readline().strip())\n\n# Calculate the minimum weight among all triangulations of the polygon\nmin_weight = 0\n\n# Iterate over all possible triangulations of the polygon\nfor i in range(1, n):\n    for j in range(i + 1, n):\n        for k in range(j + 1, n):\n            # Calculate the weight of the current triangulation\n            weight = i * j * k\n\n            # Update the minimum weight if necessary\n            if weight < min_weight or min_weight == 0:\n                min_weight = weight\n\n# Print the minimum weight\nprint(min_weight)"}
{"solution": "n = int(input())\n\n# Calculate the number of digits needed to number all the books\ndigits = 1\nwhile n > 0:\n    n //= 10\n    digits += 1\n\nprint(digits)"}
{"solution": "import sys\n\nn, A = map(int, input().split())\ncolors = list(map(int, input().split()))\n\n# Initialize the counts for Alice and Bob\ncnt_A = [0] * (n + 1)\ncnt_B = [0] * (n + 1)\n\n# Set the initial count for Alice's color\ncnt_A[0] = 1\n\n# Iterate through the colors and update the counts\nfor i in range(1, n + 1):\n    cnt_A[i] = cnt_A[i - 1] + 1 if colors[i - 1] == A else cnt_A[i - 1]\n    cnt_B[i] = cnt_B[i - 1] + 1 if colors[i - 1]!= A else cnt_B[i - 1]\n\n# Find the color that gives Bob the advantage\nfor i in range(1, n + 1):\n    if cnt_B[i] > cnt_A[i]:\n        print(colors[i - 1])\n        break\nelse:\n    print(-1)"}
{"solution": "  import sys\n\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Check if the encoding is valid\nif len(a)!= n or any(a_i > x for a_i in a):\n    print(\"NO\")\n    sys.exit()\n\n# Check if the encoding forms a crossword of the correct length\nif sum(a)!= x:\n    print(\"NO\")\n    sys.exit()\n\n# Check if the encoding forms a crossword with no intersecting segments\nif any(a_i > 1 for a_i in a):\n    print(\"NO\")\n    sys.exit()\n\nprint(\"YES\")"}
{"solution": "import sys\n\nn, S = map(int, sys.stdin.readline().split())\n\ncoins = [i for i in range(1, n+1)]\n\ndef get_min_coins(coins, S):\n    if not coins:\n        return 0\n    if coins[0] == S:\n        return 1\n    if coins[0] > S:\n        return get_min_coins(coins[1:], S)\n    return 1 + get_min_coins(coins[1:], S-coins[0])\n\nprint(get_min_coins(coins, S))"}
{"solution": "import sys\n\ndef get_lexicographically_smallest_palindrome(s):\n    # Initialize variables\n    changes = 0\n    palindrome = \"\"\n\n    # Iterate through the string\n    for i in range(len(s)):\n        # If the character is not already a palindrome, change it\n        if s[i]!= s[-i-1]:\n            changes += 1\n            palindrome += s[-i-1]\n        else:\n            palindrome += s[i]\n\n    # Return the lexicographically smallest palindrome\n    return palindrome\n\n# Get the input string\ns = sys.stdin.readline().strip()\n\n# Get the lexicographically smallest palindrome\npalindrome = get_lexicographically_smallest_palindrome(s)\n\n# Print the output\nprint(palindrome)"}
{"solution": "def calculate_weight(board):\n    piece_weights = {\n        'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'P': 1,\n        'q': 9, 'r': 5, 'b': 3, 'n': 3, 'p': 1\n    }\n    \n    white_weight = 0\n    black_weight = 0\n    \n    for row in board:\n        for piece in row:\n            if piece in piece_weights:\n                if piece.isupper():\n                    white_weight += piece_weights[piece]\n                else:\n                    black_weight += piece_weights[piece]\n    \n    if white_weight > black_weight:\n        return \"White\"\n    elif black_weight > white_weight:\n        return \"Black\"\n    else:\n        return \"Draw\""}
{"solution": "import sys\n\ndef solve(N, M, S):\n    # Initialize the sequence of numbers coming up in the roulette\n    sequence = []\n\n    # Initialize the current square\n    current_square = 0\n\n    # Initialize the number of turns\n    turns = 0\n\n    # While the current square is not Square N\n    while current_square!= N:\n        # Spin the roulette\n        number = roulette(M)\n\n        # Add the number to the sequence\n        sequence.append(number)\n\n        # Move to the next square\n        current_square += number\n\n        # If the current square is a Game Over Square, break\n        if S[current_square] == 1:\n            break\n\n        # Increment the number of turns\n        turns += 1\n\n    # If the current square is Square N, return the sequence\n    if current_square == N:\n        return sequence\n\n    # Otherwise, return -1\n    return -1\n\ndef roulette(M):\n    # Return a random number between 1 and M\n    return random.randint(1, M)\n\nif __name__ == \"__main__\":\n    # Read the input\n    N, M = map(int, input().split())\n    S = input()\n\n    # Solve the problem\n    sequence = solve(N, M, S)\n\n    # Print the output\n    if sequence == -1:\n        print(-1)\n    else:\n        print(\" \".join(map(str, sequence)))"}
{"solution": "import math\n\ndef manhattan_distance(x1, y1, x2, y2):\n    return abs(x1 - x2) + abs(y1 - y2)\n\ndef find_lowest_score(k, x, y):\n    # Initialize the score to infinity\n    score = math.inf\n    # Initialize the position of the ball to the origin\n    position = (0, 0)\n    # Initialize the list of moves to be empty\n    moves = []\n    # Loop until the ball reaches the goal\n    while position!= (x, y):\n        # Find the next move that minimizes the Manhattan distance\n        next_move = find_next_move(k, position, (x, y))\n        # Add the move to the list of moves\n        moves.append(next_move)\n        # Update the position of the ball\n        position = next_move\n        # Update the score\n        score += manhattan_distance(position[0], position[1], x, y)\n    # Return the lowest score and the list of moves\n    return score, moves\n\ndef find_next_move(k, position, goal):\n    # Find the Manhattan distance between the current position and the goal\n    distance = manhattan_distance(position[0], position[1], goal[0], goal[1])\n    # If the distance is less than or equal to k, return the goal\n    if distance <= k:\n        return goal\n    # Otherwise, find the next move that minimizes the Manhattan distance\n    next_move = find_next_move_helper(k, position, goal)\n    # Return the next move\n    return next_move\n\ndef find_next_move_helper(k, position, goal):\n    # Initialize the minimum Manhattan distance to infinity\n    min_distance = math.inf\n    # Initialize the next move to be the goal\n    next_move = goal\n    # Loop through all possible moves\n    for move in possible_moves(k, position, goal):\n        # Calculate the Manhattan distance for the current move\n        distance = manhattan_distance(move[0], move[1], goal[0], goal[1])\n        # If the distance is less than the minimum distance, update the minimum distance and the next move\n        if distance < min_distance:\n            min_distance = distance\n            next_move = move\n    # Return the next move\n    return next_move\n\ndef possible_moves(k, position, goal):\n    # Initialize the list of possible moves to be empty\n    moves = []\n    # Loop through all possible x-coordinates\n    for x in range(position[0] - k, position[0] + k + 1):\n        # Loop through all possible y-coordinates\n        for y in range(position[1] - k, position[1] + k + 1):\n            # If the current position is not the goal, and the Manhattan distance between the current position and the goal is less than or equal to k, add the current position to the list of possible moves\n            if (x, y)!= goal and manhattan_distance(x, y, goal[0], goal[1]) <= k:\n                moves.append((x, y))\n    # Return the list of possible moves\n    return moves\n\n# Read the input\nk, x, y = map(int, input().split())\n\n# Find the lowest score and the list of moves\nscore, moves = find_lowest_score(k, x, y)\n\n# Print the lowest score and the list of moves\nprint(score)\nfor move in moves:\n    print(move[0], move[1])"}
{"solution": "import sys\n\ndef get_n(m):\n    # Initialize n to 1\n    n = 1\n    # Loop until we find the smallest n that leads to m ways of stealing chocolates\n    while True:\n        # Calculate the number of ways the chocolates can be stolen with n chocolates per thief\n        num_ways = (n * (n + 1)) // 2\n        # If the number of ways is equal to m, we have found the smallest n\n        if num_ways == m:\n            return n\n        # If the number of ways is greater than m, we need to decrease n\n        elif num_ways > m:\n            n -= 1\n        # If the number of ways is less than m, we need to increase n\n        else:\n            n += 1\n\n# Read the input from stdin\nm = int(sys.stdin.readline())\n\n# Get the smallest n that leads to m ways of stealing chocolates\nn = get_n(m)\n\n# Print the output to stdout\nif n == -1:\n    print(-1)\nelse:\n    print(n)"}
{"solution": "import math\n\ndef get_intersection_area(circle1, circle2):\n    x1, y1, r1 = circle1\n    x2, y2, r2 = circle2\n    d = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    if d > r1 + r2:\n        return 0\n    if d < abs(r1 - r2):\n        return math.pi * min(r1, r2) ** 2\n    h = (r1 ** 2 - r2 ** 2 + d ** 2) / (2 * d)\n    return math.acos(h / r1) * r1 ** 2\n\nif __name__ == \"__main__\":\n    circle1 = tuple(map(int, input().split()))\n    circle2 = tuple(map(int, input().split()))\n    print(get_intersection_area(circle1, circle2))"}
{"solution": "import sys\n\nn = int(sys.stdin.readline().strip())\n\n# Initialize the minimum value of n to n itself\nmin_n = n\n\n# Iterate through all possible values of x\nfor x in range(1, n):\n    # If x is not a divisor of n, subtract it from n\n    if n % x!= 0:\n        min_n = min(min_n, n - x)\n\nprint(min_n)"}
{"solution": "import sys\n\nn = int(input())\np = list(map(int, input().split()))\na = list(map(int, input().split()))\n\n# Initialize the number of citizens caught to 0\ncaught = 0\n\n# Loop through each square\nfor i in range(n):\n    # If the square has no outgoing roads, the bandit can't move from it\n    if p[i] == 0:\n        continue\n    \n    # If the square has outgoing roads, the bandit can move from it\n    # Increment the number of citizens caught by the bandit\n    caught += a[i]\n    \n    # Update the number of citizens on the square\n    a[i] = 0\n    \n    # Update the number of citizens on the next square\n    a[p[i]] += a[i]\n    \n# Print the number of citizens caught by the bandit\nprint(caught)"}
{"solution": "n = int(input())\nS = input().strip()\nT = input().strip()\n\ncount = 0\nfor i in range(n + 1):\n    # Construct W by inserting a character at position i in both S and T\n    if i == 0:\n        W1 = S[0] + S\n        W2 = T[0] + T\n    elif i == n:\n        W1 = S + S[-1]\n        W2 = T + T[-1]\n    else:\n        W1 = S[:i] + S[i] + S[i:]\n        W2 = T[:i] + T[i] + T[i:]\n    \n    # Check if the constructed words are the same\n    if W1 == W2:\n        count += 1\n\nprint(count)"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\nwires = [list(map(int, input().split())) for _ in range(n - 1)]\n\n# Initialize the computer strength to 0\ncomputer_strength = 0\n\n# Initialize the list of banks to hack\nbanks_to_hack = list(range(1, n + 1))\n\n# While there are still banks to hack\nwhile banks_to_hack:\n    # Find the bank with the lowest strength that is still online\n    bank_to_hack = min(banks_to_hack, key=lambda x: a[x - 1])\n\n    # Hack the bank\n    a[bank_to_hack - 1] = -1\n\n    # Update the computer strength\n    computer_strength += 1\n\n    # Update the list of banks to hack\n    banks_to_hack = [x for x in banks_to_hack if x!= bank_to_hack]\n\n# Print the minimum computer strength needed to hack all the banks\nprint(computer_strength)"}
{"solution": "n, m = map(int, input().split())\nprint(min(m, n - m))"}
{"solution": "import sys\n\ndef main():\n    k, r = map(int, sys.stdin.readline().split())\n    shovels = 0\n    while k * shovels < 10 * r:\n        shovels += 1\n    print(shovels)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def can_form_rectangle(n, m, grid):\n    # Find the bounding box of the 'X' characters\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'X':\n                min_row = min(min_row, i)\n                max_row = max(max_row, i)\n                min_col = min(min_col, j)\n                max_col = max(max_col, j)\n    \n    # Dimensions of the bounding box\n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n    \n    # Extract the bounding box\n    piece = []\n    for i in range(min_row, max_row + 1):\n        piece.append(grid[i][min_col:max_col + 1])\n    \n    # Check horizontal placement\n    if width * 2 == m:\n        valid = True\n        for i in range(height):\n            for j in range(width):\n                if piece[i][j]!= piece[i][j + width]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return \"YES\"\n    \n    # Check vertical placement\n    if height * 2 == n:\n        valid = True\n        for i in range(height):\n            for j in range(width):\n                if piece[i][j]!= piece[i + height][j]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(can_form_rectangle(n, m, grid))"}
{"solution": "def get_min_segments(points):\n    x1, y1 = points[0]\n    x2, y2 = points[1]\n    x3, y3 = points[2]\n\n    # Check for collinearity on the same axis\n    if x1 == x2 == x3 or y1 == y2 == y3:\n        return 1\n\n    # Check for two points sharing the same coordinate\n    if (x1 == x2 and x3!= x2) or (y1 == y2 and y3!= y2):\n        return 2\n\n    # General case\n    return 3\n\n\nif __name__ == \"__main__\":\n    points = [(1, -1), (1, 1), (1, 2)]\n    print(get_min_segments(points))"}
{"solution": "import sys\n\ndef construct_k_regular_graph(k):\n    # Initialize the graph with one vertex\n    graph = [[]]\n\n    # Add vertices to the graph\n    for i in range(k):\n        graph.append([])\n\n    # Add edges to the graph\n    for i in range(k):\n        for j in range(i + 1, k):\n            graph[i].append(j)\n            graph[j].append(i)\n\n    # Check if the graph is connected\n    if not is_connected(graph):\n        return \"NO\"\n\n    # Check if the graph is k-regular\n    if not is_k_regular(graph, k):\n        return \"NO\"\n\n    # Check if the graph contains at least one bridge\n    if not contains_bridge(graph):\n        return \"NO\"\n\n    # Print the graph\n    print(\"YES\")\n    print(len(graph), len(graph[0]))\n    for i in range(len(graph)):\n        for j in range(len(graph[i])):\n            print(i + 1, graph[i][j] + 1)\n\n    return \"YES\"\n\ndef is_connected(graph):\n    # Check if the graph is connected by performing a BFS\n    queue = [0]\n    visited = set()\n    while queue:\n        vertex = queue.pop(0)\n        if vertex not in visited:\n            visited.add(vertex)\n            queue.extend(graph[vertex])\n    return len(visited) == len(graph)\n\ndef is_k_regular(graph, k):\n    # Check if the graph is k-regular by checking the degree of each vertex\n    for vertex in graph:\n        if len(vertex)!= k:\n            return False\n    return True\n\ndef contains_bridge(graph):\n    # Check if the graph contains at least one bridge by checking if there is an edge that connects two disconnected components\n    for i in range(len(graph)):\n        for j in range(i + 1, len(graph)):\n            if graph[i][j] and not is_connected(graph[i:j]):\n                return True\n    return False\n\nif __name__ == \"__main__\":\n    k = int(sys.stdin.readline().strip())\n    print(construct_k_regular_graph(k))"}
{"solution": "import sys\n\nn, m, q = map(int, input().split())\ns = input()\nt = input()\n\n# Initialize a dictionary to store the occurrences of t in s\noccurrences = {}\n\n# Iterate through each substring of s and count the occurrences of t\nfor i in range(n - m + 1):\n    substring = s[i:i+m]\n    if substring not in occurrences:\n        occurrences[substring] = 0\n    if t in substring:\n        occurrences[substring] += 1\n\n# Print the number of occurrences of t in each substring\nfor i in range(q):\n    l, r = map(int, input().split())\n    print(occurrences[s[l:r+1]])"}
{"solution": "  import sys\n\nn, k, d = map(int, sys.stdin.readline().split())\n\n# Initialize the dp array with 0\ndp = [0] * (n + 1)\n\n# Base case: dp[0] = 1\ndp[0] = 1\n\n# Fill the dp array\nfor i in range(1, n + 1):\n    for j in range(1, k + 1):\n        if i - j >= 0:\n            dp[i] = (dp[i] + dp[i - j]) % 1000000007\n\n# Print the answer\nprint(dp[n])"}
{"solution": "def encrypt_japanese_crossword(n, row):\n    groups = []\n    count = 0\n    \n    for char in row:\n        if char == 'B':\n            count += 1\n        else:\n            if count > 0:\n                groups.append(count)\n                count = 0\n    \n    if count > 0:\n        groups.append(count)\n    \n    print(len(groups))\n    if groups:\n        print(\" \".join(map(str, groups)))\n\n# Example usage:\nn = int(input())\nrow = input().strip()\nencrypt_japanese_crossword(n, row)"}
{"solution": "import sys\n\nn, m, p = map(int, input().split())\nsequence = input()\noperations = input()\n\n# Initialize the cursor position\ncursor = p\n\n# Iterate through the operations\nfor operation in operations:\n    if operation == \"L\":\n        # Move the cursor to the left\n        cursor -= 1\n    elif operation == \"R\":\n        # Move the cursor to the right\n        cursor += 1\n    elif operation == \"D\":\n        # Delete the bracket at the cursor position\n        sequence = sequence[:cursor] + sequence[cursor+1:]\n        # Update the cursor position\n        cursor = cursor - 1\n\n# Print the final sequence\nprint(sequence)"}
{"solution": "def guess_a_number(questions):\n    # Initialize y to a random integer between -2000000000 and 2000000000\n    y = random.randint(-2000000000, 2000000000)\n\n    # Iterate through the questions and answers\n    for question, answer in questions:\n        # If the question is \"Is it true that y is strictly larger than number x?\", check if y is strictly larger than x\n        if question == \">\":\n            if y <= x:\n                return \"Impossible\"\n        # If the question is \"Is it true that y is strictly smaller than number x?\", check if y is strictly smaller than x\n        elif question == \"<\":\n            if y >= x:\n                return \"Impossible\"\n        # If the question is \"Is it true that y is larger than or equal to number x?\", check if y is larger than or equal to x\n        elif question == \">=\":\n            if y < x:\n                return \"Impossible\"\n        # If the question is \"Is it true that y is smaller than or equal to number x?\", check if y is smaller than or equal to x\n        elif question == \"<=\":\n            if y > x:\n                return \"Impossible\"\n\n    # If all questions are answered correctly, return y\n    return y"}
{"solution": "import sys\n\ndef get_periods(a, b):\n    periods = set()\n    for i in range(1, a + b + 1):\n        if i % 2 == 0:\n            periods.add(i)\n        else:\n            periods.add(i * 2)\n    return periods\n\na, b = map(int, sys.stdin.readline().split())\nperiods = get_periods(a, b)\nprint(len(periods))"}
{"solution": "def generate_names(n, k, conditions):\n    # Predefined list of unique names\n    names = [\"Adam\", \"Bob\", \"Charlie\", \"David\", \"Edward\", \"Frank\", \"George\", \"Henry\", \"Isaac\", \"Jack\"]\n    \n    # Initialize the result list with the first k names\n    result = names[:k]\n    \n    for i in range(1, n - k + 1):\n        if conditions[i - 1] == \"YES\":\n            # If the group should be effective, add a new unique name\n            result.append(names[k + i - 1])\n        else:\n            # If the group should not be effective, repeat the last name\n            result.append(result[-1])\n    \n    return result\n\n# Example input\nn = 8\nk = 3\nconditions = [\"NO\", \"NO\", \"YES\", \"YES\", \"YES\", \"NO\"]\n\n# Generate and print the names\nnames = generate_names(n, k, conditions)\nprint(\" \".join(names))"}
{"solution": "def min_operations_to_equal(a, b):\n    # Prime factorization of a and b\n    a_factors = prime_factors(a)\n    b_factors = prime_factors(b)\n\n    # Count the number of times each factor appears in a and b\n    a_counts = Counter(a_factors)\n    b_counts = Counter(b_factors)\n\n    # Calculate the minimum number of operations needed to make the pieces equal\n    operations = 0\n    for factor in a_counts:\n        if factor in b_counts:\n            operations += abs(a_counts[factor] - b_counts[factor])\n        else:\n            operations += a_counts[factor]\n\n    return operations\n\ndef prime_factors(n):\n    factors = []\n    while n % 2 == 0:\n        factors.append(2)\n        n //= 2\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        while n % i == 0:\n            factors.append(i)\n            n //= i\n    if n > 1:\n        factors.append(n)\n    return factors"}
{"solution": "def solve(n, a, b, c):\n    # Initialize variables\n    cost = 0\n    palindrome = True\n    leftmost_color = c[0]\n    rightmost_color = c[-1]\n\n    # Check if the colors form a palindrome\n    for i in range(n):\n        if c[i]!= c[n-i-1]:\n            palindrome = False\n            break\n\n    # If the colors do not form a palindrome, check if it is possible to buy new suits\n    if not palindrome:\n        # Check if the leftmost dancer's suit is already bought\n        if c[0] == 2:\n            cost += a\n            c[0] = 0\n\n        # Check if the rightmost dancer's suit is already bought\n        if c[-1] == 2:\n            cost += b\n            c[-1] = 1\n\n        # Check if the colors form a palindrome after buying new suits\n        for i in range(n):\n            if c[i]!= c[n-i-1]:\n                palindrome = False\n                break\n\n    # If the colors still do not form a palindrome, it is not possible to obtain the desired visual effect\n    if not palindrome:\n        return -1\n\n    # Return the minimal cost to obtain the desired visual effect\n    return cost"}
{"solution": "import sys\n\ndef paint_cube(k):\n    # Initialize the cube with all unit cubes white\n    cube = [[0] * k for _ in range(k)]\n\n    # Iterate through each layer of the cube\n    for layer in range(k):\n        # Iterate through each unit cube in the layer\n        for i in range(k):\n            for j in range(k):\n                # If the unit cube is white, check if it has exactly 2 white neighbors\n                if cube[layer][i][j] == 0:\n                    # Count the number of white neighbors\n                    num_white_neighbors = 0\n                    for neighbor in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                        if 0 <= neighbor[0] < k and 0 <= neighbor[1] < k and cube[layer][neighbor[0]][neighbor[1]] == 0:\n                            num_white_neighbors += 1\n\n                    # If the unit cube has exactly 2 white neighbors, paint it black\n                    if num_white_neighbors == 2:\n                        cube[layer][i][j] = 1\n\n    # Print the painted cube\n    for layer in cube:\n        for row in layer:\n            print(\"\".join([\"w\" if x == 0 else \"b\" for x in row]))\n        print()\n\nif __name__ == \"__main__\":\n    k = int(input())\n    paint_cube(k)"}
{"solution": "import math\n\ndef largest_lovely_number(n):\n    prime_factors = []\n    while n > 1:\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                prime_factors.append(i)\n                n //= i\n                break\n        else:\n            prime_factors.append(n)\n            n = 1\n    lovely_number = 1\n    for prime in prime_factors:\n        lovely_number *= prime\n    return lovely_number\n\nn = int(input())\nprint(largest_lovely_number(n))"}
{"solution": "def is_maximal_seating(n, seating):\n    # Check for adjacent occupied seats\n    for i in range(n - 1):\n        if seating[i] == '1' and seating[i + 1] == '1':\n            return \"No\"\n    \n    # Check for possible additional seating\n    for i in range(n):\n        if seating[i] == '0':\n            if (i == 0 or seating[i - 1] == '0') and (i == n - 1 or seating[i + 1] == '0'):\n                return \"No\"\n    \n    return \"Yes\""}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize the possible values of k\nk_values = set(range(1, n + 1))\n\n# Iterate through each value of k\nfor k in k_values:\n    # Check if the length of the array is correct\n    if len(a)!= k:\n        # If the length is not correct, remove the value of k from the set\n        k_values.remove(k)\n        continue\n\n    # Check if the array is an arithmetic progression\n    if not is_arithmetic_progression(a):\n        # If the array is not an arithmetic progression, remove the value of k from the set\n        k_values.remove(k)\n        continue\n\n# Print the number of possible values of k\nprint(len(k_values))\n\n# Print the possible values of k in increasing order\nprint(*sorted(k_values))\n\ndef is_arithmetic_progression(a):\n    # Check if the array is an arithmetic progression\n    for i in range(1, len(a)):\n        if a[i] - a[i - 1]!= a[1] - a[0]:\n            return False\n    return True"}
{"solution": "import sys\n\ndef main():\n    scores = list(map(int, sys.stdin.readline().split()))\n    teams = []\n    for i in range(len(scores)):\n        for j in range(i+1, len(scores)):\n            for k in range(j+1, len(scores)):\n                teams.append([scores[i], scores[j], scores[k]])\n    team_scores = [sum(team) for team in teams]\n    if len(set(team_scores)) == 1:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef count_23_integers(l, r):\n    count = 0\n    for i in range(l, r+1):\n        if is_23_integer(i):\n            count += 1\n    return count\n\ndef is_23_integer(n):\n    if n == 1:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    for i in range(2, int(math.sqrt(n))+1):\n        if n % i == 0:\n            return False\n    return True\n\nl, r = map(int, input().split())\nprint(count_23_integers(l, r))"}
{"solution": "n, k = map(int, input().split())\n\n# Initialize variables\nactions = 0\ncandies = 0\n\n# Iterate through each action\nfor i in range(n):\n    # If the box is empty, put one candy in the box\n    if candies == 0:\n        candies += 1\n    # If the box is not empty, take one candy out and eat it\n    else:\n        candies -= 1\n        actions += 1\n\n# Print the number of candies eaten\nprint(actions)"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Check if the sum of any three lengths is greater than the sum of the remaining lengths\nsum_of_three = 0\nfor i in range(n):\n    for j in range(i+1, n):\n        for k in range(j+1, n):\n            sum_of_three = a[i] + a[j] + a[k]\n            if sum_of_three > sum(a[i+1:]) and sum_of_three > sum(a[:i]) and sum_of_three > sum(a[j+1:]) and sum_of_three > sum(a[k+1:]):\n                print(\"YES\")\n                sys.exit()\nprint(\"NO\")"}
{"solution": "import sys\n\ndef is_possible(x, y):\n    if x == 0 and y == 0:\n        return \"Yes\"\n    if x < 0 or y < 0:\n        return \"No\"\n    if x == 1 and y == 1:\n        return \"Yes\"\n    if x == 1 and y > 1:\n        return \"No\"\n    if x > 1 and y == 1:\n        return \"No\"\n    if x > 1 and y > 1:\n        return \"Yes\"\n    return \"No\"\n\nx, y = map(int, sys.stdin.readline().split())\nprint(is_possible(x, y))"}
{"solution": "import math\n\ndef get_max_total_rating(n, k, a):\n    # Calculate the initial total rating\n    total_rating = sum(math.floor(ai / 10) for ai in a)\n\n    # Identify improvement opportunities\n    improvement_opportunities = [(ai, math.ceil(ai / 10) * 10 - ai) for ai in a]\n\n    # Prioritize improvements\n    improvement_opportunities.sort(key=lambda x: x[1], reverse=True)\n\n    # Allocate units\n    for ai, improvement in improvement_opportunities:\n        if k == 0:\n            break\n        ai += improvement\n        k -= 1\n\n    # Recalculate total rating\n    total_rating = sum(math.floor(ai / 10) for ai in a)\n\n    return total_rating\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nprint(get_max_total_rating(n, k, a))"}
{"solution": "def find_smallest_pretty_integer(n, m, list1, list2):\n    # Convert lists to sets for faster lookup\n    set1 = set(list1)\n    set2 = set(list2)\n    \n    # Check for common digits\n    common_digits = set1.intersection(set2)\n    if common_digits:\n        return min(common_digits)\n    \n    # If no common digits, find the smallest combination\n    min1 = min(list1)\n    min2 = min(list2)\n    \n    # Form the smallest two-digit number\n    smallest_pretty = min(int(str(min1) + str(min2)), int(str(min2) + str(min1)))\n    return smallest_pretty"}
{"solution": "n, k = map(int, input().split())\n\n# Calculate the total time needed to solve each problem\ntotal_time = [5 * i for i in range(1, n + 1)]\n\n# Calculate the maximum number of problems that can be solved within the time limit\nmax_problems = 0\nfor i in range(n):\n    if total_time[i] + k <= 240:\n        max_problems += 1\n\nprint(max_problems)"}
{"solution": "import sys\n\nn, x, y = map(int, input().split())\na = list(map(int, input().split()))\n\n# Sort the list of pages in ascending order\na.sort()\n\n# Initialize variables to track the number of double-sided and single-sided sheets\ndouble_sided = x\nsingle_sided = y\ncount = 0\n\nfor pages in a:\n    # Try to print the current set of pages using double-sided sheets first\n    double_needed = pages // 2\n    single_needed = pages % 2\n\n    if double_needed <= double_sided:\n        double_sided -= double_needed\n        if single_needed <= single_sided:\n            single_sided -= single_needed\n            count += 1\n        else:\n            # If there are not enough single-sided sheets, return the used double-sided sheets and break\n            double_sided += double_needed\n            break\n    else:\n        # If there are not enough double-sided sheets, try to print the remaining pages using single-sided sheets\n        remaining_pages = pages - 2 * double_sided\n        if remaining_pages <= single_sided:\n            single_sided -= remaining_pages\n            double_sided = 0\n            count += 1\n        else:\n            break\n\nprint(count)"}
{"solution": "b = int(input())\n\ndef count_distinct_values(b):\n    divisors = set()\n    for i in range(1, int(b**0.5) + 1):\n        if b % i == 0:\n            divisors.add(i)\n            divisors.add(b // i)\n    return len(divisors)\n\nprint(count_distinct_values(b))"}
{"solution": "import sys\n\nn = int(input())\nbumpers = input()\n\n# Initialize a list to store the positions where the ball will fall from the field\nfalling_positions = []\n\n# Iterate through the bumpers and check if the ball will fall from the field\nfor i in range(n):\n    # If the bumper is '<', the ball will move to the left\n    if bumpers[i] == '<':\n        # If the ball is at position 1, it will fall from the field\n        if i == 1:\n            falling_positions.append(1)\n        # If the ball is at position 2 or more, it will move to the left\n        else:\n            falling_positions.append(i - 1)\n    # If the bumper is '>', the ball will move to the right\n    else:\n        # If the ball is at position n, it will fall from the field\n        if i == n:\n            falling_positions.append(n)\n        # If the ball is at position n - 1 or less, it will move to the right\n        else:\n            falling_positions.append(i + 1)\n\n# Print the number of positions where the ball will fall from the field\nprint(len(falling_positions))"}
{"solution": "import sys\n\nn = int(input())\nsticks = [int(x) for x in input().split()]\n\n# Sort the sticks in descending order\nsticks.sort(reverse=True)\n\n# Initialize the maximum area\nmax_area = 0\n\n# Iterate through the sticks and form rectangles\nfor i in range(n):\n    for j in range(i+1, n):\n        # Check if the rectangle can be formed\n        if sticks[i] <= sticks[j]:\n            # Calculate the area of the rectangle\n            area = sticks[i] * sticks[j]\n            # Update the maximum area\n            max_area = max(max_area, area)\n\n# Print the maximum area\nprint(max_area)"}
{"solution": "n = int(input())\n\n# Dictionary to map letters to digits\nletter_to_digit = {\n    'a': 1,\n    'b': 0,\n    'c': 2,\n    'd': 3,\n    'e': 4,\n    'f': 5,\n    'g': 6,\n    'h': 7,\n    'i': 8,\n    'j': 9\n}\n\n# List to store the restored numbers\nrestored_numbers = []\n\n# Loop through each string and restore the numbers\nfor i in range(n):\n    s = input()\n    restored_number = 0\n    for j in range(len(s)):\n        restored_number += letter_to_digit[s[j]] * (10 ** (len(s) - j - 1))\n    restored_numbers.append(restored_number)\n\n# Calculate the sum of the restored numbers\nsum_of_restored_numbers = sum(restored_numbers)\n\n# Print the minimum possible sum of the restored numbers\nprint(sum_of_restored_numbers)"}
{"solution": "n, m = map(int, input().split())\n\n# Calculate the maximum number of teams that can be formed\nmax_teams = min(n, m, (n + m) // 3)\n\n# Print the result\nprint(max_teams)"}
{"solution": "def check_substrings(s):\n    n = len(s)\n    found_AB = False\n    found_BA = False\n    for i in range(n - 1):\n        if s[i:i+2] == \"AB\":\n            found_AB = True\n            for j in range(i + 2, n - 1):\n                if s[j:j+2] == \"BA\":\n                    print(\"YES\")\n                    return\n            break\n        elif s[i:i+2] == \"BA\":\n            found_BA = True\n            for j in range(i + 2, n - 1):\n                if s[j:j+2] == \"AB\":\n                    print(\"YES\")\n                    return\n            break\n    if not found_AB and not found_BA:\n        print(\"NO\")"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\nk = int(input())\nb = list(map(int, input().split()))\n\n# Check if the input is valid\nif n < 1 or n > 500:\n    print(\"NO\")\n    sys.exit()\nif k < 1 or k > n:\n    print(\"NO\")\n    sys.exit()\nif len(a)!= n:\n    print(\"NO\")\n    sys.exit()\nif len(b)!= k:\n    print(\"NO\")\n    sys.exit()\n\n# Initialize the queue with the initial weights\nqueue = a\n\n# Loop through the queue and check if the monsters can eat each other\nwhile len(queue) > k:\n    # Check if the first monster can eat the second monster\n    if queue[0] > queue[1]:\n        # Eat the second monster and update the queue\n        queue.pop(1)\n        queue[0] += queue[1]\n    # Check if the second monster can eat the third monster\n    elif queue[1] > queue[2]:\n        # Eat the third monster and update the queue\n        queue.pop(2)\n        queue[1] += queue[2]\n    # Check if the third monster can eat the fourth monster\n    elif queue[2] > queue[3]:\n        # Eat the fourth monster and update the queue\n        queue.pop(3)\n        queue[2] += queue[3]\n    # Check if the fourth monster can eat the fifth monster\n    elif queue[3] > queue[4]:\n        # Eat the fifth monster and update the queue\n        queue.pop(4)\n        queue[3] += queue[4]\n    # If no monster can eat another, break the loop\n    else:\n        break\n\n# Check if the final queue is the same as the input\nif queue == b:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\ndef is_perfect_matching(R, B, x, y):\n    # Initialize a graph with R nodes and B nodes\n    graph = {}\n    for i in range(R):\n        graph[i] = set()\n    for j in range(B):\n        graph[j + R] = set()\n\n    # Add edges between nodes based on the coordinates\n    for i in range(R):\n        for j in range(B):\n            if x[i] == x[j + R] and y[i] == y[j + R]:\n                graph[i].add(j + R)\n                graph[j + R].add(i)\n\n    # Check if the graph has a perfect matching\n    matching = []\n    for i in range(R):\n        if len(graph[i]) == 1:\n            matching.append(i)\n            graph[i].clear()\n            graph[i + R].clear()\n\n    return len(matching) == R\n\n\nif __name__ == \"__main__\":\n    R, B = map(int, input().split())\n    x = [int(x) for x in input().split()]\n    y = [int(y) for y in input().split()]\n    print(\"Yes\" if is_perfect_matching(R, B, x, y) else \"No\")"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Find the maximum power of 2 that divides at least one number in the sequence\nmax_power = 0\nfor i in range(n):\n    power = 0\n    while a[i] % 2 == 0:\n        power += 1\n        a[i] //= 2\n    if power > max_power:\n        max_power = power\n\n# Count the number of elements in the sequence that divide by the maximum power\ncount = 0\nfor i in range(n):\n    if a[i] % (2 ** max_power) == 0:\n        count += 1\n\nprint(max_power, count)"}
{"solution": "n, m = map(int, input().split())\n\n# Initialize the number of clicks to 0\nclicks = 0\n\n# While the number is not equal to m\nwhile n!= m:\n    # If the number is even\n    if n % 2 == 0:\n        # Double the number\n        n *= 2\n        # Increment the number of clicks\n        clicks += 1\n    # If the number is odd\n    else:\n        # Subtract 1 from the number\n        n -= 1\n        # Increment the number of clicks\n        clicks += 1\n\n# Print the minimum number of clicks required to get the number m\nprint(clicks)"}
{"solution": "import sys\n\nn = int(input())\nsegments = []\n\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append([l, r])\n\n# Check if the graph is connected\ndef is_connected(graph):\n    visited = set()\n    queue = [0]\n    while queue:\n        node = queue.pop(0)\n        if node not in visited:\n            visited.add(node)\n            queue.extend(graph[node])\n    return len(visited) == n\n\n# Check if there are exactly n-1 edges\ndef has_exactly_n_edges(graph):\n    return len(graph) == n - 1\n\n# Check if there are no cycles using DFS\ndef has_no_cycles(graph):\n    visited = set()\n    def dfs(node):\n        if node in visited:\n            return False\n        visited.add(node)\n        for neighbor in graph[node]:\n            if not dfs(neighbor):\n                return False\n        return True\n    for node in range(n):\n        if not dfs(node):\n            return False\n    return True\n\n# Check if the graph is a tree\ndef is_tree(graph):\n    return is_connected(graph) and has_exactly_n_edges(graph) and has_no_cycles(graph)\n\n# Build the graph\ngraph = {}\nfor i in range(n):\n    for j in range(i+1, n):\n        if segments[i][1] >= segments[j][0] and segments[i][0] <= segments[j][1]:\n            if i not in graph:\n                graph[i] = []\n            graph[i].append(j)\n            if j not in graph:\n                graph[j] = []\n            graph[j].append(i)\n\n# Check if the graph is a tree\nif is_tree(graph):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\nn = int(input())\nrequests = list(map(int, input().split()))\n\n# Calculate the total number of requests in the given time segment\ntotal_requests = sum(requests)\n\n# Check if the total number of requests exceeds the threshold\nif total_requests > 100 * n:\n    # Find the longest continuous period of time with at least one request\n    longest_period = 0\n    current_period = 0\n    for i in range(n):\n        if requests[i] > 0:\n            current_period += 1\n            if current_period > longest_period:\n                longest_period = current_period\n        else:\n            current_period = 0\n\n    print(longest_period)\nelse:\n    print(0)"}
{"solution": "n, k = map(int, input().split())\nsequence = input()\n\n# Initialize variables\nmax_consecutive_n = 0\ncurrent_consecutive_n = 0\n\n# Iterate through the sequence\nfor i in range(n):\n    if sequence[i] == \"N\":\n        current_consecutive_n += 1\n    else:\n        current_consecutive_n = 0\n    max_consecutive_n = max(max_consecutive_n, current_consecutive_n)\n\n# Check if the maximum consecutive 'N's is equal to k\nif max_consecutive_n == k:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\ndef solve(N, X, D):\n    # Initialize the sequence with the first element\n    A = [X]\n\n    # Generate the remaining elements of the sequence\n    for i in range(1, N):\n        A.append(A[i-1] + D)\n\n    # Initialize the sum of the elements taken by Takahashi and Aoki\n    S = 0\n    T = 0\n\n    # Iterate over the elements of the sequence and calculate the sum\n    for i in range(N):\n        if i % 2 == 0:\n            S += A[i]\n        else:\n            T += A[i]\n\n    # Return the number of possible values of S - T\n    return S - T\n\nif __name__ == \"__main__\":\n    N, X, D = map(int, input().split())\n    print(solve(N, X, D))"}
{"solution": "n = int(input())\nparticipants = [input().split() for _ in range(n)]\nparticipants = [(handle, int(before), int(after)) for handle, before, after in participants]\n\nfor participant in participants:\n    handle, before, after = participant\n    if before >= 2400 and after > before:\n        print(\"YES\")\n        break\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\ndef main():\n    s = int(sys.stdin.readline(), 2)\n    count = 0\n    for i in range(s):\n        if (s >> i) & 1:\n            count += 1\n    print(count)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\nn, m = map(int, input().split())\na = [[int(x) for x in input().split()] for _ in range(n)]\n\n# Initialize the minimum number of rows to 1\nmin_rows = 1\n\n# Iterate over each row of matrix a\nfor i in range(n):\n    # Check if the row is symmetric\n    if a[i] == a[n-i-1]:\n        # If the row is symmetric, increment the minimum number of rows\n        min_rows += 1\n    else:\n        # If the row is not symmetric, break the loop\n        break\n\n# Print the minimum number of rows\nprint(min_rows)"}
{"solution": "import sys\n\nn = int(input())\norders = []\n\nfor i in range(n):\n    l, r = map(int, input().split())\n    orders.append((l, r))\n\norders.sort(key=lambda x: x[1])\n\nmax_orders = 0\ncurrent_time = 0\n\nfor order in orders:\n    if order[0] >= current_time:\n        max_orders += 1\n        current_time = order[1]\n\nprint(max_orders)"}
{"solution": "import sys\n\nn, k = map(int, input().split())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\n# Initialize the number of tables and formulas in each page\nnum_tables = [0] * n\nnum_formulas = [0] * n\n\n# Iterate through each page\nfor i in range(n):\n    # Add the number of tables and formulas in the current page\n    num_tables[i] += x[i]\n    num_formulas[i] += y[i]\n\n    # Check if the number of tables or formulas in the current page is greater than k\n    if num_tables[i] > k or num_formulas[i] > k:\n        print(\"NO\")\n        sys.exit()\n\n# Check if the number of tables or formulas in each page is less than or equal to k\nif all(num_tables[i] <= k for i in range(n)) and all(num_formulas[i] <= k for i in range(n)):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\nn, k = map(int, input().split())\ncoefficients = [int(input()) for _ in range(n + 1)]\n\n# Check if the human has a winning strategy\nif coefficients[0] == -1:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "import math\n\ndef get_smallest_starting_number(x_2):\n    # Find the prime factors of x_2\n    prime_factors = []\n    current_number = x_2\n    while current_number > 1:\n        for i in range(2, int(math.sqrt(current_number)) + 1):\n            if current_number % i == 0:\n                prime_factors.append(i)\n                current_number //= i\n                break\n    \n    # Find the smallest number that is a multiple of all prime factors\n    smallest_number = 1\n    for prime_factor in prime_factors:\n        smallest_number *= prime_factor\n    \n    return smallest_number\n\n\nif __name__ == \"__main__\":\n    x_2 = int(input())\n    print(get_smallest_starting_number(x_2))"}
{"solution": "import sys\n\nn, p = map(int, input().split())\n\nif p == 0:\n    print(2)\nelif p == 1:\n    print(3)\nelif p == -1:\n    print(4)\nelse:\n    print(-1)"}
{"solution": "def solve(n, k, S):\n    # Initialize the minimum value of S\n    min_S = 0\n    # Initialize the number of changes made\n    changes_made = 0\n    # Iterate through the digits of S\n    for i in range(n):\n        # If the current digit is not 0, change it to 0\n        if S[i]!= 0:\n            S[i] = 0\n            changes_made += 1\n        # If the current digit is 0 and the number of changes made is less than k, change it to 1\n        elif changes_made < k:\n            S[i] = 1\n            changes_made += 1\n    # If the number of changes made is greater than k, return -1\n    if changes_made > k:\n        return -1\n    # Return the resulting number\n    return int(\"\".join(map(str, S)))"}
{"solution": "import sys\n\ndef solve(cnt_1, cnt_2, x, y):\n    # Initialize the minimum number of presents as 1\n    v = 1\n\n    # Loop through the numbers from 2 to v\n    for i in range(2, v+1):\n        # If the number is not divisible by x or y, add it to the set of presents\n        if i % x!= 0 and i % y!= 0:\n            presents.add(i)\n\n    # If the number of presents is greater than or equal to cnt_1, return the minimum number of presents\n    if len(presents) >= cnt_1:\n        return v\n\n    # Otherwise, increment the minimum number of presents and repeat the loop\n    v += 1\n\n# Get the input from stdin\ncnt_1, cnt_2, x, y = map(int, input().split())\n\n# Solve the problem\nresult = solve(cnt_1, cnt_2, x, y)\n\n# Print the result to stdout\nprint(result)"}
{"solution": "import sys\n\nn, sx, sy, dx, dy, t = map(int, sys.stdin.readline().split())\n\n# Initialize the bear's position and speed\nx = sx\ny = sy\nspeed_x = dx\nspeed_y = dy\n\n# Loop for t seconds\nfor i in range(t):\n    # Eat the raspberry bushes in the current cell\n    x += speed_x\n    y += speed_y\n    \n    # Increase the speed by the number of raspberry bushes eaten\n    speed_x += x\n    speed_y += y\n    \n    # Move to the next cell\n    x = (x + speed_x - 1) % n + 1\n    y = (y + speed_y - 1) % n + 1\n    \n    # Increase the number of raspberry bushes by 1\n    x += 1\n    y += 1\n\n# Print the final position of the bear\nprint(x, y)"}
{"solution": "import re\n\ndef is_nice(word):\n    # Check if the word has length less than 26\n    if len(word) < 26:\n        return False\n    \n    # Check if the word contains all the letters of the English alphabet\n    if not re.search(r'^[A-Za-z]{26}$', word):\n        return False\n    \n    # Check if the word contains all unique letters\n    if len(set(word))!= 26:\n        return False\n    \n    return True\n\ndef fill_missing_letters(word):\n    # Replace the question marks with uppercase letters\n    word = re.sub(r'\\?', lambda x: chr(ord('A') + x.start()), word)\n    \n    # Check if the resulting word is nice\n    if is_nice(word):\n        return word\n    else:\n        return -1\n\nword = input()\nprint(fill_missing_letters(word))"}
{"solution": "n = int(input())\nweights = [int(input()) for _ in range(n)]\n\n# Check if all weights are either 100 or 200\nif not all(weight in [100, 200] for weight in weights):\n    print(\"NO\")\n    exit()\n\n# Check if the total weight is divisible by 2\nif sum(weights) % 2!= 0:\n    print(\"NO\")\n    exit()\n\n# Check if the weights can be divided equally\nif len(set(weights))!= 1:\n    print(\"NO\")\n    exit()\n\n# Check if the weights can be divided into two equal groups\nif len(weights) % 2!= 0:\n    print(\"NO\")\n    exit()\n\n# If all conditions are met, print \"YES\"\nprint(\"YES\")"}
{"solution": "n, m = map(int, input().split())\n\n# Initialize the building description\nbuilding = []\nfor i in range(n):\n    building.append(input())\n\n# Initialize the total time\ntotal_time = 0\n\n# Iterate through each floor\nfor floor in range(n):\n    # Get the number of rooms in the current floor\n    num_rooms = len(building[floor]) - 2\n    \n    # Iterate through each room in the current floor\n    for room in range(num_rooms):\n        # Check if the light is on\n        if building[floor][room + 1] == '1':\n            # Calculate the time to turn off the light\n            time = (floor + 1) * 2 + room + 1\n            \n            # Add the time to the total time\n            total_time += time\n            \n            # Update the building description\n            building[floor] = building[floor][:room + 1] + '0' + building[floor][room + 2:]\n\n# Print the total time\nprint(total_time)"}
{"solution": "def find_min_trap_cost(n, costs, transitions):\n    visited = [False] * n\n    in_stack = [False] * n\n    min_cost = 0\n\n    def dfs(node):\n        stack = []\n        while True:\n            if visited[node]:\n                if in_stack[node]:\n                    # Found a cycle, calculate the minimum cost in this cycle\n                    cycle_min_cost = float('inf')\n                    while stack:\n                        cycle_node = stack.pop()\n                        in_stack[cycle_node] = False\n                        cycle_min_cost = min(cycle_min_cost, costs[cycle_node])\n                        if cycle_node == node:\n                            break\n                    return cycle_min_cost\n                else:\n                    return 0\n            visited[node] = True\n            in_stack[node] = True\n            stack.append(node)\n            node = transitions[node] - 1\n\n    for i in range(n):\n        if not visited[i]:\n            min_cost += dfs(i)\n\n    return min_cost\n\n# Input reading\nn = int(input())\ncosts = list(map(int, input().split()))\ntransitions = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(find_min_trap_cost(n, costs, transitions))"}
{"solution": "import sys\n\nn, a, b = map(int, sys.stdin.readline().split())\n\nif b == 0:\n    print(a)\nelif b > 0:\n    print((a + b) % n + 1)\nelse:\n    print((a - b) % n + 1)"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize the minimum number of progressions to 0\nmin_progressions = 0\n\n# Initialize the current progression to the first element of the sequence\ncurrent_progression = [a[0]]\n\n# Iterate through the remaining elements of the sequence\nfor i in range(1, n):\n    # If the current element is -1, we need to start a new progression\n    if a[i] == -1:\n        # Increment the minimum number of progressions\n        min_progressions += 1\n        # Start a new progression with the current element\n        current_progression = [a[i]]\n    # If the current element is not -1, we can add it to the current progression\n    else:\n        current_progression.append(a[i])\n\n# Print the minimum number of progressions\nprint(min_progressions)"}
{"solution": "import sys\n\nn, k = map(int, input().split())\ns = input()\n\n# Initialize the maximum beauty as 0\nmax_beauty = 0\n\n# Iterate through the string\nfor i in range(n - k):\n    # Check if the substring is equal to the first character\n    if s[i] == s[i + 1]:\n        # Update the maximum beauty\n        max_beauty = max(max_beauty, len(s[i:i + k]))\n\n# Print the maximum beauty\nprint(max_beauty)"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Find the maximum number of seats among all parties\nmax_seats = max(a)\n\n# Find the party with the maximum number of seats\nmax_seats_party = a.index(max_seats) + 1\n\n# Find the parties that have at least twice the seats of the maximum number of seats party\ncoalition_parties = [i for i in range(1, n + 1) if a[i - 1] >= 2 * max_seats]\n\n# Check if the coalition satisfies the conditions\nif len(coalition_parties) > 0 and sum(a[i - 1] for i in coalition_parties) > n / 2:\n    print(len(coalition_parties))\n    print(\" \".join(str(i) for i in coalition_parties))\nelse:\n    print(0)"}
{"solution": "import math\n\ndef max_reward(n):\n    harmonic_sum = 0.0\n    for i in range(1, n + 1):\n        harmonic_sum += 1.0 / i\n    return harmonic_sum\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the maximum reward\nprint(f\"{max_reward(n):.12f}\")"}
{"solution": "import sys\n\nn = int(sys.stdin.readline().strip())\n\n# Calculate the sum of the first k integers\ndef sum_of_first_k_integers(k):\n    return k * (k + 1) // 2\n\n# Find the largest k such that S_k <= n\nk = 1\nwhile sum_of_first_k_integers(k) <= n:\n    k += 1\n\n# Distribute the remaining candies\nremaining_candies = n - sum_of_first_k_integers(k - 1)\ndistribution = [1] * (k - 1) + [remaining_candies]\n\n# Print the output\nprint(k)\nprint(*distribution)"}
{"solution": "n, m = map(int, input().split())\n\n# Calculate 2^n\npower = 1\nfor i in range(n):\n    power *= 2\n\n# Calculate m mod 2^n\nresult = m % power\n\nprint(result)"}
{"solution": "n = int(input())\ns = input()\n\n# Initialize a variable to store the corrected word\ncorrected_word = \"\"\n\n# Iterate through each letter in the word\nfor i in range(n):\n    # If the letter is a vowel, check if it is consecutive with another vowel\n    if s[i] in \"aeiouy\":\n        # If it is consecutive with another vowel, skip it\n        if i < n-1 and s[i+1] in \"aeiouy\":\n            continue\n        # Otherwise, add it to the corrected word\n        corrected_word += s[i]\n    # If the letter is not a vowel, add it to the corrected word\n    else:\n        corrected_word += s[i]\n\n# Print the corrected word\nprint(corrected_word)"}
{"solution": "def max_students(n, a, b, seats):\n    segments = []\n    i = 0\n    \n    # Identify segments of empty seats\n    while i < n:\n        if seats[i] == '.':\n            start = i\n            while i < n and seats[i] == '.':\n                i += 1\n            segments.append(i - start)\n        else:\n            i += 1\n    \n    total_students = 0\n    \n    # Place students in each segment\n    for length in segments:\n        # Calculate the number of students that can be placed in this segment\n        # We will place students in an alternating fashion\n        if a > b:\n            # Start with a student-programmer if more student-programmers are available\n            programmers = (length + 1) // 2\n            athletes = length // 2\n        else:\n            # Start with a student-athlete if more student-athletes are available\n            athletes = (length + 1) // 2\n            programmers = length // 2\n        \n        # Place the students\n        placed_programmers = min(programmers, a)\n        placed_athletes = min(athletes, b)\n        \n        total_students += placed_programmers + placed_athletes\n        a -= placed_programmers\n        b -= placed_athletes\n    \n    return total_students"}
{"solution": "import math\n\ndef is_reversible(r):\n    for x in range(1, math.ceil(math.sqrt(r))):\n        y = (r - x**2) // (2*x + 1)\n        if y.is_integer():\n            return (x, y)\n    return \"NO\"\n\nr = int(input())\nprint(is_reversible(r))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Check if it's possible to divide the balloons\nif sum(a) % 2 == 1:\n    print(-1)\n    exit()\n\n# Divide the balloons\nk = sum(a) // 2\nb = [0] * n\nfor i in range(n):\n    b[i] = a[i] // 2\n    a[i] -= b[i]\n\n# Check if the conditions are met\nif sum(b)!= k or any(a[i] == 0 for i in range(n)):\n    print(-1)\n    exit()\n\n# Print the result\nprint(k)\nprint(*[i + 1 for i in range(n) if b[i] > 0], sep=' ')"}
{"solution": "n = int(input())\n\n# Initialize the minimum number of different digits as 10\nmin_diff_digits = 10\n\n# Initialize the partition with the minimum number of different digits\npartition = [1]\n\n# Iterate through all possible partitions of the number n\nfor i in range(1, n):\n    # Check if the current partition has the minimum number of different digits\n    if len(set(partition)) < min_diff_digits:\n        # Update the minimum number of different digits\n        min_diff_digits = len(set(partition))\n        # Update the partition with the minimum number of different digits\n        partition = partition[:]\n\n    # Add the current digit to the partition\n    partition.append(i)\n\n# Print the number of digits in the partition\nprint(len(partition))\n\n# Print the partition\nprint(*partition)"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize a dictionary to store the prime numbers and their counts\nprime_dict = {}\n\n# Iterate through the array and check if each element is a prime number\nfor i in range(n):\n    if is_prime(a[i]):\n        prime_dict[a[i]] = prime_dict.get(a[i], 0) + 1\n\n# Initialize a list to store the maximum size subset\nmax_subset = []\n\n# Iterate through the prime numbers and their counts and check if they form a simple subset\nfor prime, count in prime_dict.items():\n    if is_simple_subset(prime, count):\n        max_subset.append(prime)\n\n# Print the maximum size subset\nprint(len(max_subset))\nprint(\" \".join(map(str, max_subset)))\n\n# Function to check if a number is prime\ndef is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\n# Function to check if a number and its count form a simple subset\ndef is_simple_subset(prime, count):\n    for i in range(1, count):\n        if prime + i not in prime_dict or prime_dict[prime + i] < count:\n            return False\n    return True"}
{"solution": "n = int(input())\n\n# Find the greatest beautiful divisor of n\ndivisor = 1\nwhile divisor <= n:\n    if n % divisor == 0 and is_beautiful_number(divisor):\n        break\n    divisor += 1\n\nprint(divisor)\n\ndef is_beautiful_number(n):\n    # Check if n is a power of 2\n    if n & (n - 1) == 0:\n        return True\n    \n    # Check if n is a beautiful number\n    k = 1\n    while k <= n:\n        if n % k == 0 and is_beautiful_number(n // k):\n            return True\n        k += 1\n    \n    return False"}
{"solution": "import math\n\ndef is_d_magic(n, d):\n    n_str = str(n)\n    count = 0\n    for i in range(len(n_str)):\n        if n_str[i] == d and i % 2 == 0:\n            count += 1\n    return count\n\ndef count_d_magic_numbers(a, b, d, m):\n    count = 0\n    for i in range(a, b+1):\n        if i % m == 0 and is_d_magic(i, d):\n            count += 1\n    return count\n\ndef solve(a, b, d, m):\n    return count_d_magic_numbers(a, b, d, m) % (10**9 + 7)\n\na, b, d, m = map(int, input().split())\nprint(solve(a, b, d, m))"}
{"solution": "import sys\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\n# Implement the algorithm to distribute candies and manage the queue\nqueue = [i for i in range(1, n + 1)]\nwhile queue:\n    child = queue.pop(0)\n    if a[child - 1] <= m:\n        a[child - 1] -= m\n        if a[child - 1] == 0:\n            print(child)\n            break\n        else:\n            queue.append(child)\n    else:\n        a[child - 1] -= m\n        queue.append(child)\n        m = 0\n\n# Print the number of the last child\nprint(child)"}
{"solution": "n = int(input())\n\n# Initialize the minimum number of bills to 0\nmin_bills = 0\n\n# Loop through the denominations\nfor denomination in [1, 5, 10, 20, 100]:\n    # Calculate the number of bills for this denomination\n    num_bills = n // denomination\n\n    # If the number of bills is greater than the current minimum, update the minimum\n    if num_bills > min_bills:\n        min_bills = num_bills\n\n    # Update the remaining amount\n    n = n % denomination\n\n# Print the minimum number of bills\nprint(min_bills)"}
{"solution": "import sys\n\nn, k = map(int, sys.stdin.readline().split())\n\n# Initialize a list to store the permutations\npermutations = []\n\n# Iterate through all possible permutations\nfor i in range(1, n + 1):\n    for j in range(1, n + 1):\n        for k in range(1, n + 1):\n            # Check if the current permutation has exactly k good positions\n            if abs(i - j) == 1 and abs(j - k) == 1 and abs(k - i) == 1:\n                permutations.append((i, j, k))\n\n# Print the number of permutations with exactly k good positions\nprint(len(permutations))"}
{"solution": "import sys\n\nn, k = map(int, input().split())\nbeauty = list(map(int, input().split()))\ncolors = input()\n\n# Initialize the maximum total beauty to -1\nmax_beauty = -1\n\n# Iterate through all possible combinations of k roses\nfor i in range(n - k + 1):\n    # Check if the combination of roses satisfies the constraints\n    if colors[i] == colors[i + 1] or colors[i + 1] == colors[i + 2]:\n        continue\n    \n    # Calculate the total beauty of the current combination\n    total_beauty = sum(beauty[i:i+k])\n    \n    # Update the maximum total beauty if necessary\n    if total_beauty > max_beauty:\n        max_beauty = total_beauty\n\n# Print the maximum total beauty\nprint(max_beauty)"}
{"solution": "  #include <iostream>\nusing namespace std;\n\nint main() {\n    long long p, q, n;\n    cin >> p >> q >> n;\n\n    long long a[n];\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n\n    long long numerator = p * a[0];\n    long long denominator = q;\n\n    for (int i = 1; i < n; i++) {\n        numerator *= a[i];\n        denominator *= a[i];\n    }\n\n    if (numerator == denominator) {\n        cout << \"YES\" << endl;\n    } else {\n        cout << \"NO\" << endl;\n    }\n\n    return 0;\n}"}
{"solution": "def solve(expression):\n    # Split the expression into its components\n    A, B, C = expression.split(\"+\")\n    A = int(A)\n    B = int(B)\n    C = int(C)\n\n    # Check if the expression is already arithmetically correct\n    if A + B == C:\n        return expression\n\n    # Check if we can shift a stick from the third group to the first group\n    if A + B + 1 == C:\n        return f\"{A + 1}+{B}-1={C}\"\n\n    # Check if we can shift a stick from the second group to the third group\n    if A + B - 1 == C:\n        return f\"{A}-1+{B + 1}={C}\"\n\n    # If no shift is possible, return \"Impossible\"\n    return \"Impossible\""}
{"solution": "import sys\n\nn, k = map(int, sys.stdin.readline().split())\n\ndef count_permutations(n, k):\n    # Initialize a 2D array to store the results\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n\n    # Base case: only one permutation of length 1\n    for i in range(1, n + 1):\n        dp[i][0] = 1\n\n    # Iterate over the length of the permutation\n    for len in range(1, n + 1):\n        # Iterate over the value of the permutation\n        for val in range(1, n + 1):\n            # Calculate the number of permutations with the current value and length\n            dp[len][val] = (dp[len - 1][val - 1] + dp[len - 1][val + 1]) % (10**9 + 7)\n\n    # Return the number of permutations with the given oddness\n    return dp[n][k]\n\nprint(count_permutations(n, k))"}
{"solution": "import sys\n\ndef solve(N, X, Y):\n    # Initialize the robot arm with 1 section and 2 joints\n    sections = [1]\n    joints = [0, 1]\n    positions = [(0, 0), (0, 0)]\n\n    # Loop through each point (X_j, Y_j)\n    for i in range(N):\n        # Calculate the distance between the current position and the target position\n        distance = ((X[i] - positions[1][0]) ** 2 + (Y[i] - positions[1][1]) ** 2) ** 0.5\n\n        # If the distance is less than the length of the current section, move the joint to the target position\n        if distance <= sections[1]:\n            positions[1] = (X[i], Y[i])\n\n        # Otherwise, move the joint to the end of the current section and add a new section\n        else:\n            positions.append((positions[1][0] + sections[1] * (X[i] - positions[1][0]) / distance, positions[1][1] + sections[1] * (Y[i] - positions[1][1]) / distance))\n            sections.append(distance - sections[1])\n            joints.append(len(positions) - 1)\n\n    # Print the solution\n    print(len(sections) - 1)\n    for i in range(len(sections)):\n        print(sections[i], end=\" \")\n    print()\n    for i in range(len(joints)):\n        print(joints[i], end=\" \")\n    print()\n    for i in range(len(positions)):\n        print(positions[i][0], positions[i][1], end=\" \")\n    print()\n\nif __name__ == \"__main__\":\n    N = int(input())\n    X = [int(x) for x in input().split()]\n    Y = [int(y) for y in input().split()]\n    solve(N, X, Y)"}
{"solution": "import re\n\ndef replace_filler_words(s):\n    # find all filler words in the string\n    filler_words = re.findall(r'ogo+', s)\n\n    # replace each filler word with three asterisks\n    for filler_word in filler_words:\n        s = s.replace(filler_word, '***')\n\n    return s\n\n\ns = input()\nprint(replace_filler_words(s))"}
{"solution": "import math\n\ndef f(x, y):\n    prime_factors = prime_divisors(x)\n    result = 1\n    for p in prime_factors:\n        result *= g(y, p)\n    return result\n\ndef prime_divisors(x):\n    prime_factors = []\n    for i in range(2, int(math.sqrt(x)) + 1):\n        if x % i == 0:\n            prime_factors.append(i)\n            if x // i!= i:\n                prime_factors.append(x // i)\n    return prime_factors\n\ndef g(x, p):\n    k = 0\n    while x % p == 0:\n        k += 1\n        x //= p\n    return p ** k\n\ndef calculate_product(x, n):\n    result = 1\n    for i in range(1, n + 1):\n        result *= f(x, i)\n    return result % (10 ** 9 + 7)\n\nx, n = map(int, input().split())\nprint(calculate_product(x, n))"}
{"solution": "def sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_solutions(a, b, c):\n    solutions = []\n    for s in range(1, 82):  # s(x) can be at most 81\n        x = b * (s ** a) + c\n        if 0 < x < 10**9 and sum_of_digits(x) == s:\n            solutions.append(x)\n    solutions.sort()\n    return solutions\n\n# Read input\na, b, c = map(int, input().split())\n\n# Find solutions\nsolutions = find_solutions(a, b, c)\n\n# Print results\nprint(len(solutions))\nif solutions:\n    print(\" \".join(map(str, solutions)))"}
{"solution": "import sys\n\ndef is_solvable(cube):\n    # Check if the cube is solved\n    if all(cube[i] == cube[i+1] for i in range(24)):\n        return \"YES\"\n    \n    # Check if the cube can be solved with one rotation\n    for i in range(24):\n        if cube[i]!= cube[i+1]:\n            break\n    else:\n        return \"NO\"\n    \n    # Check if the cube can be solved with two rotations\n    for i in range(24):\n        if cube[i]!= cube[i+2]:\n            break\n    else:\n        return \"NO\"\n    \n    # Check if the cube can be solved with three rotations\n    for i in range(24):\n        if cube[i]!= cube[i+3]:\n            break\n    else:\n        return \"NO\"\n    \n    # Check if the cube can be solved with four rotations\n    for i in range(24):\n        if cube[i]!= cube[i+4]:\n            break\n    else:\n        return \"NO\"\n    \n    # Check if the cube can be solved with five rotations\n    for i in range(24):\n        if cube[i]!= cube[i+5]:\n            break\n    else:\n        return \"NO\"\n    \n    # Check if the cube can be solved with six rotations\n    for i in range(24):\n        if cube[i]!= cube[i+6]:\n            break\n    else:\n        return \"NO\"\n    \n    # Check if the cube can be solved with seven rotations\n    for i in range(24):\n        if cube[i]!= cube[i+7]:\n            break\n    else:\n        return \"NO\"\n    \n    # Check if the cube can be solved with eight rotations\n    for i in range(24):\n        if cube[i]!= cube[i+8]:\n            break\n    else:\n        return \"NO\"\n    \n    # Check if the cube can be solved with nine rotations\n    for i in range(24):\n        if cube[i]!= cube[i+9]:\n            break\n    else:\n        return \"NO\"\n    \n    # Check if the cube can be solved with ten rotations\n    for i in range(24):\n        if cube[i]!= cube[i+10]:\n            break\n    else:\n        return \"NO\"\n    \n    # Check if the cube can be solved with eleven rotations\n    for i in range(24):\n        if cube[i]!= cube[i+11]:\n            break\n    else:\n        return \"NO\"\n    \n    # Check if the cube can be solved with twelve rotations\n    for i in range(24):\n        if cube[i]!= cube[i+12]:\n            break\n    else:\n        return \"NO\"\n    \n    # Check if the cube can be solved with thirteen rotations\n    for i in range(24):\n        if cube[i]!= cube[i+13]:\n            break\n    else:\n        return \"NO\"\n    \n    # Check if the cube can be solved with fourteen rotations\n    for i in range(24):\n        if cube[i]!= cube[i+14]:\n            break\n    else:\n        return \"NO\"\n    \n    # Check if the cube can be solved with fifteen rotations\n    for i in range(24):\n        if cube[i]!= cube[i+15]:\n            break\n    else:\n        return \"NO\"\n    \n    # Check if the cube can be solved with sixteen rotations\n    for i in range(24):\n        if cube[i]!= cube[i+16]:\n            break\n    else:\n        return \"NO\"\n    \n    # Check if the cube can be solved with seventeen rotations\n    for i in range(24):\n        if cube[i]!= cube[i+17]:\n            break\n    else:\n        return \"NO\"\n    \n    # Check if the cube can be solved with eighteen rotations\n    for i in range(24):\n        if cube[i]!= cube[i+18]:\n            break\n    else:\n        return \"NO\"\n    \n    # Check if the cube can be solved with nineteen rotations\n    for i in range(24):\n        if cube[i]!= cube[i+19]:\n            break\n    else:\n        return \"NO\"\n    \n    # Check if the cube can be solved with twenty rotations\n    for i in range(24):\n        if cube[i]!= cube[i+20]:\n            break\n    else:\n        return \"NO\"\n    \n    # Check if the cube can be solved with twenty-one rotations\n    for i in range(24):\n        if cube[i]!= cube[i+21]:\n            break\n    else:\n        return \"NO\"\n    \n    # Check if the cube can be solved with twenty-two rotations\n    for i in range(24):\n        if cube[i]!= cube[i+22]:\n            break\n    else:\n        return \"NO\"\n    \n    # Check if the cube can be solved with twenty-three rotations\n    for i in range(24):\n        if cube[i]!= cube[i+23]:\n            break\n    else:\n        return \"NO\"\n    \n    # Check if the cube can be solved with twenty-four rotations\n    for i in range(24):\n        if cube[i]!= cube[i+24]:\n            break\n    else:\n        return \"NO\"\n    \n    return \"YES\"\n\nif __name__ == \"__main__\":\n    cube = list(map(int, sys.stdin.readline().split()))\n    print(is_solvable(cube))"}
{"solution": "import sys\n\ndef get_min_hacks(p, x, y):\n    # Calculate the number of successful hacks needed to win the round\n    num_hacks = (y - x) // 100\n    \n    # Calculate the number of places where the T-shirts will be given\n    num_places = 25\n    \n    # Calculate the number of successful hacks needed to get a T-shirt\n    num_tshirt_hacks = (p - 26) // 25\n    \n    # Return the minimum number of successful hacks needed to win the round and get a T-shirt\n    return min(num_hacks, num_tshirt_hacks)\n\nif __name__ == \"__main__\":\n    p, x, y = map(int, sys.stdin.readline().split())\n    print(get_min_hacks(p, x, y))"}
{"solution": "n = int(input())\na, b, c = map(int, input().split())\n\n# Initialize the distance matrix\ndist = [[0] * (n + 1) for _ in range(n + 1)]\n\n# Fill in the distance matrix\nfor i in range(1, n + 1):\n    for j in range(1, n + 1):\n        if i == j:\n            dist[i][j] = 0\n        elif i == 1:\n            dist[i][j] = a\n        elif j == n:\n            dist[i][j] = c\n        else:\n            dist[i][j] = min(dist[i - 1][j - 1], dist[i - 1][j] + a, dist[i][j - 1] + b)\n\n# Find the minimum distance\nmin_dist = dist[n][n]\n\n# Print the output\nprint(min_dist)"}
{"solution": "def solve(x1, x2, x3):\n    # Calculate the distance between each pair of friends\n    d1 = abs(x1 - x2)\n    d2 = abs(x2 - x3)\n    d3 = abs(x3 - x1)\n\n    # Find the minimum distance\n    min_dist = min(d1, d2, d3)\n\n    # Return the minimum distance\n    return min_dist"}
{"solution": "import sys\n\nn, x = map(int, input().split())\narr = list(map(int, input().split()))\n\n# Initialize the number of operations to 0\noperations = 0\n\n# Iterate through the array and check if there are any equal elements\nfor i in range(n):\n    for j in range(i+1, n):\n        if arr[i] == arr[j]:\n            # If there are any equal elements, return the number of operations\n            return operations\n\n# If there are no equal elements, apply the operation to the last element\narr[n-1] &= x\noperations += 1\n\n# Check if there are any equal elements after applying the operation\nfor i in range(n-1):\n    for j in range(i+1, n-1):\n        if arr[i] == arr[j]:\n            # If there are any equal elements, return the number of operations\n            return operations\n\n# If there are no equal elements after applying the operation, return -1\nreturn -1"}
{"solution": "import sys\n\ndef has_single_plus_shape(picture):\n    w, h = picture.shape\n    for i in range(w):\n        for j in range(h):\n            if picture[i, j] == '*':\n                # Check if there are consecutive non-empty cells in all four directions\n                if not (picture[i-1, j] == '*' and picture[i+1, j] == '*' and picture[i, j-1] == '*' and picture[i, j+1] == '*'):\n                    return False\n                # Check if there is only one center and no other cells outside the \"+\" shape are non-empty\n                if picture[i-1, j-1] == '*' or picture[i-1, j+1] == '*' or picture[i+1, j-1] == '*' or picture[i+1, j+1] == '*':\n                    return False\n    return True\n\nif __name__ == '__main__':\n    w, h = map(int, input().split())\n    picture = []\n    for i in range(h):\n        picture.append(input())\n    picture = np.array(picture)\n    if has_single_plus_shape(picture):\n        print('YES')\n    else:\n        print('NO')"}
{"solution": "import sys\n\nn, a, b = map(int, input().split())\n\n# Initialize the adjacency matrix\nmatrix = [[0] * n for _ in range(n)]\n\n# Fill in the matrix with the required number of components\nfor i in range(a):\n    for j in range(i, n):\n        matrix[i][j] = 1\n        matrix[j][i] = 1\n\n# Fill in the matrix with the required number of components in the complement\nfor i in range(b):\n    for j in range(i, n):\n        matrix[i][j] = 1\n        matrix[j][i] = 1\n\n# Print the matrix\nprint(\"YES\")\nfor row in matrix:\n    print(\"\".join(str(x) for x in row))"}
{"solution": "import sys\n\ndef get_min_problems(c, d, n, m, k):\n    # Calculate the total number of finalists\n    total_finalists = n * m + k\n    \n    # Calculate the number of problems needed in each round\n    main_problems = c * m\n    additional_problems = d * (total_finalists - n * m)\n    \n    # Calculate the minimum number of problems needed\n    min_problems = main_problems + additional_problems\n    \n    return min_problems\n\nif __name__ == \"__main__\":\n    c, d, n, m, k = map(int, sys.stdin.readline().split())\n    print(get_min_problems(c, d, n, m, k))"}
{"solution": "import re\n\ndef find_grid(s):\n    # Initialize the grid with 2 rows and 13 columns\n    grid = [[''for _ in range(13)] for _ in range(2)]\n\n    # Iterate through the string and place each letter in the grid\n    for i, letter in enumerate(s):\n        row = i // 13\n        col = i % 13\n        grid[row][col] = letter\n\n    # Check if the grid contains a path that forms the string\n    for row in grid:\n        for i in range(len(row) - 1):\n            if row[i]!= row[i + 1]:\n                break\n        else:\n            # If we reach this point, the grid contains a path that forms the string\n            return grid\n    else:\n        # If we don't find a path, return \"Impossible\"\n        return \"Impossible\"\n\ns = \"ABCDEFGHIJKLMNOPQRSGTUVWXYZ\"\nprint(find_grid(s))"}
{"solution": "import math\n\ndef compare_powers(x, y):\n    if x == y:\n        return '='\n    elif x == 1:\n        return '<' if y > 1 else '='\n    elif y == 1:\n        return '>' if x > 1 else '='\n    else:\n        # Compute y * log(x) and x * log(y)\n        lhs = y * math.log(x)\n        rhs = x * math.log(y)\n        \n        if lhs < rhs:\n            return '<'\n        elif lhs > rhs:\n            return '>'\n        else:\n            return '='\n\n# Read input\nx, y = map(int, input().split())\n\n# Output the result of the comparison\nprint(compare_powers(x, y))"}
{"solution": "import math\n\ndef get_max_balloons(r, h):\n    # Calculate the volume of the cupboard\n    cupboard_volume = math.pi * r ** 2 * (h + r)\n\n    # Calculate the volume of a single balloon\n    balloon_volume = (4 / 3) * math.pi * (r / 2) ** 3\n\n    # Calculate the maximum number of balloons that can fit in the cupboard\n    max_balloons = int(cupboard_volume / balloon_volume)\n\n    return max_balloons\n\n# Test the function with some examples\nprint(get_max_balloons(1, 1))  # 3\nprint(get_max_balloons(1, 2))  # 5\nprint(get_max_balloons(2, 1))  # 2"}
{"solution": "def solve(numbers):\n    # sort the numbers in descending order\n    numbers.sort(reverse=True)\n\n    # initialize the sum of remaining numbers\n    sum = 0\n\n    # loop through the numbers and discard two or three cards with the same number\n    for i in range(len(numbers)):\n        if numbers[i] == numbers[i-1] or numbers[i] == numbers[i-2]:\n            numbers.pop(i)\n            numbers.pop(i-1)\n            if len(numbers) > 2:\n                numbers.pop(i-2)\n            break\n\n    # calculate the sum of remaining numbers\n    for num in numbers:\n        sum += num\n\n    return sum"}
{"solution": "import sys\n\nn, a = map(int, input().split())\ncheckpoints = list(map(int, input().split()))\n\n# Calculate the distance between each checkpoint and the starting point\ndistances = [abs(checkpoint - a) for checkpoint in checkpoints]\n\n# Sort the distances in ascending order\ndistances.sort()\n\n# Calculate the minimum distance Vasya has to travel\nmin_distance = sum(distances)\n\nprint(min_distance)"}
{"solution": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    long long n;\n    cin >> n;\n\n    long long x = 1;\n    while (x * x + s(x) * x - n!= 0) {\n        x++;\n    }\n\n    if (x * x + s(x) * x - n == 0) {\n        cout << x << endl;\n    } else {\n        cout << -1 << endl;\n    }\n\n    return 0;\n}\n\nlong long s(long long x) {\n    long long sum = 0;\n    while (x > 0) {\n        sum += x % 10;\n        x /= 10;\n    }\n    return sum;\n}"}
{"solution": "import datetime\n\ndef get_bedtime(current_time, sleep_duration):\n    current_time = datetime.datetime.strptime(current_time, \"%H:%M\")\n    sleep_duration = datetime.timedelta(hours=int(sleep_duration[:2]), minutes=int(sleep_duration[3:]))\n    bedtime = current_time - sleep_duration\n    return bedtime.strftime(\"%H:%M\")\n\nprint(get_bedtime(\"05:50\", \"05:44\"))"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Find the maximum arithmetic mean of all subsegments\nmax_mean = 0\nmax_subsegment = []\nfor l in range(n):\n    for r in range(l, n):\n        mean = sum(a[l:r+1]) / (r - l + 1)\n        if mean > max_mean:\n            max_mean = mean\n            max_subsegment = a[l:r+1]\n\n# Find the longest subsegment with maximum arithmetic mean\nlongest_subsegment = []\nfor l in range(n):\n    for r in range(l, n):\n        if a[l:r+1] == max_subsegment:\n            longest_subsegment = a[l:r+1]\n            break\n\nprint(len(longest_subsegment))"}
{"solution": "import sys\n\nn, m, k = map(int, sys.stdin.readline().split())\n\n# Initialize a 2D array to store the number of ways to color each brick\nways = [[0] * (n + 1) for _ in range(m + 1)]\n\n# Base case: if there are no bricks, there is only one way to color them\nways[0][0] = 1\n\n# Iterate over the number of bricks\nfor i in range(1, n + 1):\n    # Iterate over the number of colors\n    for j in range(1, m + 1):\n        # If the current brick is the same color as the previous brick,\n        # the number of ways to color it is the same as the previous brick\n        if i == 1 or j == 1:\n            ways[i][j] = ways[i - 1][j - 1]\n        # If the current brick is different from the previous brick,\n        # the number of ways to color it is the sum of the number of ways\n        # to color the previous brick with the current color,\n        # and the number of ways to color the previous brick with the previous color\n        else:\n            ways[i][j] = (ways[i - 1][j - 1] + ways[i - 1][j]) % 998244353\n\n# Print the number of ways to color the bricks modulo 998244353\nprint(ways[n][m] % 998244353)"}
{"solution": "  import re\n\ndef is_magic_number(n):\n    pattern = re.compile(r'^(1|14|144)+$')\n    if pattern.match(str(n)):\n        return \"YES\"\n    else:\n        return \"NO\"\n\nn = int(input())\nprint(is_magic_number(n))"}
{"solution": "import sys\n\nn, m, i, j, a, b = map(int, sys.stdin.readline().split())\n\n# Initialize the chessboard with the candy in position (i, j)\nchessboard = [[0] * m for _ in range(n)]\nchessboard[i - 1][j - 1] = 1\n\n# Initialize the number of moves to 0\nmoves = 0\n\n# Initialize the current position of the candy\ncurrent_position = (i, j)\n\n# Loop until the candy reaches one of the corner cells\nwhile current_position not in [(1, m), (n, 1), (n, m), (1, 1)]:\n    # Check if the candy can move to any of the four possible positions\n    possible_positions = [(current_position[0] - a, current_position[1] - b),\n                          (current_position[0] + a, current_position[1] - b),\n                          (current_position[0] - a, current_position[1] + b),\n                          (current_position[0] + a, current_position[1] + b)]\n\n    # Check if any of the possible positions are within the chessboard borders\n    for position in possible_positions:\n        if position[0] >= 1 and position[0] <= n and position[1] >= 1 and position[1] <= m:\n            # Move the candy to the first possible position within the chessboard borders\n            current_position = position\n            moves += 1\n            break\n\n# Print the minimum number of moves needed to get the candy to a corner cell\nprint(moves)"}
{"solution": "import sys\n\ndef get_previous_letter(letter):\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    index = alphabet.index(letter)\n    if index == 0:\n        return \"\"\n    else:\n        return alphabet[index - 1]\n\ndef get_next_letter(letter):\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    index = alphabet.index(letter)\n    if index == 25:\n        return \"\"\n    else:\n        return alphabet[index + 1]\n\ndef get_adjacent_letters(string, index):\n    if index == 0:\n        return [get_next_letter(string[index])]\n    elif index == len(string) - 1:\n        return [get_previous_letter(string[index - 1])]\n    else:\n        return [get_previous_letter(string[index - 1]), get_next_letter(string[index])]\n\ndef remove_character(string, index):\n    return string[:index] + string[index + 1:]\n\ndef get_maximum_removable_characters(string):\n    maximum = 0\n    for i in range(len(string)):\n        adjacent_letters = get_adjacent_letters(string, i)\n        if adjacent_letters[0]!= \"\" and adjacent_letters[1]!= \"\":\n            maximum += 1\n            string = remove_character(string, i)\n    return maximum\n\nif __name__ == \"__main__\":\n    string = sys.stdin.readline().strip()\n    print(get_maximum_removable_characters(string))"}
{"solution": "n, k = map(int, input().split())\ndenominations = list(map(int, input().split()))\nq = int(input())\n\n# Create a dictionary to store the number of bills for each denomination\nbills = {denomination: 0 for denomination in denominations}\n\n# Loop through each request for cash withdrawal\nfor i in range(q):\n    # Get the current request\n    x = int(input())\n    \n    # Initialize the minimum number of bills to -1\n    min_bills = -1\n    \n    # Loop through each denomination and check if it can be used to get the current request\n    for denomination in denominations:\n        # If the denomination is greater than the current request, skip it\n        if denomination > x:\n            continue\n        \n        # If the denomination is less than or equal to the current request, check if it can be used to get the current request\n        if x % denomination == 0:\n            # If it can be used, update the minimum number of bills\n            min_bills = x // denomination\n            break\n    \n    # Print the minimum number of bills or -1 if it is impossible to get the current request\n    print(min_bills)"}
{"solution": "import math\n\ndef get_min_time(s, x1, x2, t1, t2, p, d):\n    # Calculate the distance between x1 and x2\n    distance = abs(x2 - x1)\n    \n    # Calculate the time it takes for Igor to walk the distance\n    walk_time = distance / t2\n    \n    # Calculate the time it takes for the tram to pass the distance\n    tram_time = distance / t1\n    \n    # Calculate the time it takes for Igor to wait for the tram\n    wait_time = abs(p - x1) / t1\n    \n    # Calculate the minimum time it takes for Igor to get to x2\n    min_time = min(walk_time, tram_time, wait_time)\n    \n    return min_time\n\n# Test the function with the given input\ns = 4\nx1 = 2\nx2 = 4\nt1 = 3\nt2 = 4\np = 1\nd = 1\nprint(get_min_time(s, x1, x2, t1, t2, p, d))"}
{"solution": "import sys\n\nn, x = map(int, input().split())\n\ncount = 0\nfor i in range(1, n+1):\n    for j in range(1, n+1):\n        if i*j == x:\n            count += 1\n\nprint(count)"}
{"solution": "  import random\n\ndef generate_password(n, k):\n    password = \"\"\n    while len(password) < n:\n        symbol = chr(random.randint(97, 122))\n        if symbol not in password:\n            password += symbol\n    return password\n\nn, k = map(int, input().split())\npassword = generate_password(n, k)\nprint(password)"}
{"solution": "def first_collision_time(n, directions, positions):\n    min_time = float('inf')\n    collision_found = False\n    \n    for i in range(n - 1):\n        if directions[i] == 'R' and directions[i + 1] == 'L':\n            collision_time = (positions[i + 1] - positions[i]) // 2\n            min_time = min(min_time, collision_time)\n            collision_found = True\n    \n    if collision_found:\n        return min_time\n    else:\n        return -1"}
{"solution": "import sys\n\nn, a, b = map(int, input().split())\nseals = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    seals.append((x, y))\n\n# Sort seals by area in descending order\nseals.sort(key=lambda x: x[0] * x[1], reverse=True)\n\n# Initialize the maximum area as 0\nmax_area = 0\n\n# Iterate through all possible combinations of seals\nfor i in range(n):\n    for j in range(i+1, n):\n        # Calculate the area of the current combination\n        area = seals[i][0] * seals[i][1] + seals[j][0] * seals[j][1]\n\n        # Check if the current combination fits on the paper\n        if area <= a * b:\n            # Update the maximum area if necessary\n            max_area = max(max_area, area)\n\nprint(max_area)"}
{"solution": "import sys\n\nn = int(input())\npoints = []\n\nfor i in range(4*n+1):\n    x, y = map(int, input().split())\n    points.append((x, y))\n\n# Find the point that is not on the boundary of the square\nfor point in points:\n    if point not in [(0, 0), (0, 2), (2, 0), (2, 2)]:\n        print(point[0], point[1])\n        break\nelse:\n    print(\"No point found\")"}
{"solution": "import math\n\ndef get_max_product(n):\n    max_product = 0\n    for i in range(1, n+1):\n        product = 1\n        for digit in str(i):\n            product *= int(digit)\n        max_product = max(max_product, product)\n    return max_product\n\nn = int(input())\nprint(get_max_product(n))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Calculate the total number of votes for Elodreip\ntotal_votes = sum(a)\n\n# Determine the minimum value of k that ensures a win\nk = max(a)\nwhile total_votes > 0:\n    total_votes -= k\n    k += 1\n\nprint(k)"}
{"solution": "def solve(colors):\n    # Initialize variables\n    num_operations = 0\n    points_to_delete = []\n\n    # Iterate through the colors\n    for i in range(len(colors)):\n        # Check if the current point has a neighbor of a different color\n        if i > 0 and i < len(colors) - 1 and colors[i]!= colors[i - 1] and colors[i]!= colors[i + 1]:\n            # Add the current point to the list of points to delete\n            points_to_delete.append(i)\n\n    # Iterate through the list of points to delete\n    for point in points_to_delete:\n        # Delete the point and its neighbors\n        del colors[point - 1:point + 2]\n        num_operations += 1\n\n    return num_operations"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Sort the array in non-decreasing order\na.sort()\n\n# Initialize the minimum product to infinity\nmin_product = float('inf')\n\n# Initialize the count of triples to 0\ncount = 0\n\n# Iterate over the array\nfor i in range(n - 2):\n    # Find the minimum product of the current element and the next two elements\n    product = a[i] * a[i + 1] * a[i + 2]\n    \n    # If the minimum product is less than the current product, update the minimum product and increment the count\n    if product < min_product:\n        min_product = product\n        count += 1\n\nprint(count)"}
{"solution": "  import math\n\ndef solve(n):\n    return int(math.ceil(n / 2))\n\nn = int(input())\nprint(solve(n))"}
{"solution": "n = int(input())\n\n# Initialize the maximum state of the bank account\nmax_state = n\n\n# Check if the last digit can be removed\nif n % 10!= 0:\n    max_state = n - (n % 10)\n\n# Check if the digit before last can be removed\nif n % 100!= 0:\n    max_state = max(max_state, n - (n % 100))\n\nprint(max_state)"}
{"solution": "def get_direction(start_position, end_position, duration):\n    # Convert the starting and ending positions to integers\n    start_position = ord(start_position) - ord('v')\n    end_position = ord(end_position) - ord('v')\n\n    # Calculate the direction of rotation\n    direction = (end_position - start_position) % 4\n\n    # Check if the direction is clockwise or counter-clockwise\n    if direction == 1 or direction == 3:\n        return \"cw\"\n    elif direction == 2 or direction == 0:\n        return \"ccw\"\n    else:\n        return \"undefined\"\n\n# Test the function with some examples\nprint(get_direction(\"^\", \">\", 1))  # Should print \"cw\"\nprint(get_direction(\"<\", \"^\", 3))  # Should print \"ccw\"\nprint(get_direction(\"^\", \"v\", 6))  # Should print \"undefined\""}
{"solution": "def domino_show(n, s):\n    # Initialize a list to store the number of dominoes standing vertically\n    standing_vertically = [0] * n\n\n    # Iterate through the string s and check if the domino has been pushed to the left or right\n    for i in range(n):\n        if s[i] == \"L\":\n            # If the domino has been pushed to the left, check if the adjacent domino on the left is standing vertically\n            if standing_vertically[i-1] == 1:\n                # If the adjacent domino is standing vertically, the current domino falls down\n                standing_vertically[i] = 0\n            else:\n                # If the adjacent domino is not standing vertically, the current domino stands vertically\n                standing_vertically[i] = 1\n        elif s[i] == \"R\":\n            # If the domino has been pushed to the right, check if the adjacent domino on the right is standing vertically\n            if standing_vertically[i+1] == 1:\n                # If the adjacent domino is standing vertically, the current domino falls down\n                standing_vertically[i] = 0\n            else:\n                # If the adjacent domino is not standing vertically, the current domino stands vertically\n                standing_vertically[i] = 1\n\n    # Return the number of dominoes standing vertically at the end of the process\n    return sum(standing_vertically)"}
{"solution": "import sys\n\nn, m = map(int, input().split())\nleaders = list(map(int, input().split()))\n\n# Initialize the permutation with the first leader\npermutation = [leaders[0]]\n\n# Iterate through the remaining leaders\nfor i in range(1, m):\n    # Find the index of the current leader in the permutation\n    leader_index = permutation.index(leaders[i])\n    \n    # Add the next leader to the permutation\n    permutation.insert(leader_index + 1, leaders[i + 1])\n\n# Print the permutation\nprint(\" \".join(map(str, permutation)))"}
{"solution": "import sys\n\ndef get_max_number(a, k):\n    # Convert the number to a list of digits\n    digits = [int(d) for d in str(a)]\n\n    # Iterate through the digits\n    for i in range(len(digits)):\n        # Determine the best possible digit to swap with within the allowed range of k swaps\n        best_swap = None\n        for j in range(i+1, min(i+k+1, len(digits))):\n            if digits[j] > digits[i]:\n                best_swap = j\n                break\n\n        # Perform the swap\n        if best_swap is not None:\n            digits[i], digits[best_swap] = digits[best_swap], digits[i]\n            k -= 1\n\n    # Repeat until k swaps are used or no more beneficial swaps are possible\n    while k > 0 and any(digits[i] < digits[i+1] for i in range(len(digits)-1)):\n        for i in range(len(digits)-1):\n            if digits[i] < digits[i+1]:\n                digits[i], digits[i+1] = digits[i+1], digits[i]\n                k -= 1\n                break\n\n    # Convert the list of digits back to a number\n    return int(\"\".join(str(d) for d in digits))\n\nif __name__ == \"__main__\":\n    a, k = map(int, input().split())\n    print(get_max_number(a, k))"}
{"solution": "import math\n\ndef is_arithmetic_progression(seq):\n    # Check if the sequence is arithmetic\n    for i in range(1, len(seq)):\n        if seq[i] - seq[i-1]!= seq[1] - seq[0]:\n            return False\n    return True\n\ndef is_geometric_progression(seq):\n    # Check if the sequence is geometric\n    for i in range(1, len(seq)):\n        if seq[i] / seq[i-1]!= seq[1] / seq[0]:\n            return False\n    return True\n\ndef find_next_number(seq):\n    # Find the next number in the sequence\n    if is_arithmetic_progression(seq):\n        return seq[-1] + (seq[1] - seq[0])\n    elif is_geometric_progression(seq):\n        return seq[-1] * (seq[1] / seq[0])\n    else:\n        return 42\n\nseq = [int(x) for x in input().split()]\nprint(find_next_number(seq))"}
{"solution": "n = int(input())\ncolors = list(map(int, input().split()))\n\n# Find the first and last occurrences of each color\nfirst_occurrence = {}\nlast_occurrence = {}\n\nfor i in range(n):\n    color = colors[i]\n    if color not in first_occurrence:\n        first_occurrence[color] = i\n    last_occurrence[color] = i\n\n# Get the list of unique colors\nunique_colors = list(first_occurrence.keys())\n\n# Calculate the maximum distance\nmax_dist = 0\n\n# Compare distances from the first house to the last house of a different color\nfor color in unique_colors:\n    if colors[0]!= color:\n        max_dist = max(max_dist, last_occurrence[color])\n    if colors[-1]!= color:\n        max_dist = max(max_dist, n - 1 - first_occurrence[color])\n\nprint(max_dist)"}
{"solution": "n, m, k = map(int, input().split())\n\nlane = k // (m * 2) + 1\ndesk = (k - 1) % m + 1\nside = \"L\" if k % 2 == 0 else \"R\"\n\nprint(lane, desk, side)"}
{"solution": "import sys\n\nn = int(input())\ns = input()\n\n# Count the number of each color\nb_count = s.count('B')\ng_count = s.count('G')\nr_count = s.count('R')\n\n# Determine the parity of each color\nb_parity = 'even' if b_count % 2 == 0 else 'odd'\ng_parity = 'even' if g_count % 2 == 0 else 'odd'\nr_parity = 'even' if r_count % 2 == 0 else 'odd'\n\n# Determine the possible final colors\nif b_parity == 'even' and g_parity == 'even' and r_parity == 'even':\n    final_colors = ['B', 'G', 'R']\nelif b_parity == 'odd' and g_parity == 'even' and r_parity == 'even':\n    final_colors = ['B']\nelif b_parity == 'even' and g_parity == 'odd' and r_parity == 'even':\n    final_colors = ['G']\nelif b_parity == 'even' and g_parity == 'even' and r_parity == 'odd':\n    final_colors = ['R']\nelse:\n    final_colors = []\n\n# Print the possible final colors\nprint(' '.join(final_colors))"}
