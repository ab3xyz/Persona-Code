{"solution": "import sys\n\ndef is_accordion(s):\n    if len(s) < 4:\n        return False\n    if s[0]!= '[' or s[-1]!= ']':\n        return False\n    if s[1]!= ':' or s[-2]!= ':':\n        return False\n    if s.count('|') > 1:\n        return False\n    return True\n\ndef get_max_accordion_length(s):\n    if not is_accordion(s):\n        return -1\n    return len(s)\n\nif __name__ == '__main__':\n    s = sys.stdin.readline().strip()\n    print(get_max_accordion_length(s))"}
{"solution": "import math\n\ndef get_max_sum_of_digits(x):\n    # Initialize the maximum sum of digits as 0\n    max_sum = 0\n    # Initialize the maximum number with the maximum sum of digits as 0\n    max_num = 0\n\n    # Iterate from 1 to x\n    for i in range(1, x + 1):\n        # Get the sum of the digits of i\n        sum_of_digits = sum(int(digit) for digit in str(i))\n\n        # If the sum of digits is greater than the maximum sum of digits, update the maximum sum of digits and the maximum number with the maximum sum of digits\n        if sum_of_digits > max_sum:\n            max_sum = sum_of_digits\n            max_num = i\n\n    # Return the maximum number with the maximum sum of digits\n    return max_num\n\n# Test the function with the given input\nx = 100\nprint(get_max_sum_of_digits(x))"}
{"solution": "def find_next_lucky_year(current_year):\n    # Initialize a variable to store the number of years until the next lucky year\n    years_until_lucky_year = 0\n\n    # Loop through each year from the current year to the next 10^9 years\n    for year in range(current_year, 10**9):\n        # Check if the current year is a lucky year\n        if is_lucky_year(year):\n            # If it is, break out of the loop and return the number of years until the lucky year\n            break\n        else:\n            # If it's not, increment the number of years until the lucky year\n            years_until_lucky_year += 1\n\n    # Return the number of years until the next lucky year\n    return years_until_lucky_year\n\ndef is_lucky_year(year):\n    # Initialize a variable to store the number of non-zero digits in the year\n    non_zero_digits = 0\n\n    # Loop through each digit in the year\n    for digit in str(year):\n        # Check if the digit is not zero\n        if digit!= '0':\n            # If it's not, increment the number of non-zero digits\n            non_zero_digits += 1\n\n    # Return True if the number of non-zero digits is less than or equal to 1, False otherwise\n    return non_zero_digits <= 1\n\n# Test the function with the given examples\nprint(find_next_lucky_year(4))  # Output: 1\nprint(find_next_lucky_year(201))  # Output: 99\nprint(find_next_lucky_year(4000))  # Output: 1000"}
{"solution": "import sys\n\nn, q = map(int, input().split())\npainters = []\nfor i in range(q):\n    l, r = map(int, input().split())\n    painters.append((l, r))\n\n# Sort painters by their left endpoint\npainters.sort(key=lambda x: x[0])\n\n# Initialize the number of painted sections to 0\npainted_sections = 0\n\n# Iterate through the painters and check if they overlap\nfor i in range(q - 2):\n    # Check if the current painter overlaps with the previous painter\n    if painters[i][1] >= painters[i + 1][0]:\n        # If they overlap, merge them into a single painter\n        painters[i] = (painters[i][0], max(painters[i][1], painters[i + 1][1]))\n        # Remove the second painter from the list\n        del painters[i + 1]\n        # Increment the number of painted sections\n        painted_sections += 1\n\n# Print the maximum number of painted sections\nprint(painted_sections)"}
{"solution": "import datetime\n\ndef get_lucky_time(hh, mm, x):\n    # Convert the input time to a datetime object\n    time = datetime.time(hh, mm)\n\n    # Calculate the time difference between the input time and the current time\n    time_diff = time - datetime.datetime.now().time()\n\n    # Calculate the number of minutes between the input time and the current time\n    minutes = time_diff.total_seconds() // 60\n\n    # Calculate the number of snooze intervals needed\n    snooze_intervals = minutes // x\n\n    # Calculate the time of the first snooze interval\n    first_snooze_time = time - datetime.timedelta(minutes=snooze_intervals * x)\n\n    # Check if the first snooze time contains the digit '7'\n    if str(first_snooze_time).find('7')!= -1:\n        return snooze_intervals\n\n    # If the first snooze time does not contain the digit '7', calculate the time of the next snooze interval\n    next_snooze_time = first_snooze_time - datetime.timedelta(minutes=x)\n\n    # Check if the next snooze time contains the digit '7'\n    if str(next_snooze_time).find('7')!= -1:\n        return snooze_intervals + 1\n\n    # If the next snooze time does not contain the digit '7', calculate the time of the next snooze interval\n    next_snooze_time = next_snooze_time - datetime.timedelta(minutes=x)\n\n    # Repeat the process until a lucky time is found\n    while True:\n        if str(next_snooze_time).find('7')!= -1:\n            return snooze_intervals + 2\n        next_snooze_time = next_snooze_time - datetime.timedelta(minutes=x)\n\n# Test the function with some examples\nprint(get_lucky_time(11, 23, 3))  # Output: 2\nprint(get_lucky_time(01, 07, 5))  # Output: 0"}
{"solution": "n, pos, l, r = map(int, input().split())\n\n# Check if the segment [l, r] covers the entire range of tabs\nif l == 1 and r == n:\n    print(0)\n    exit()\n\n# Check if the left boundary (l) is greater than 1\nif l > 1:\n    # Move the cursor to the left boundary\n    pos = l\n    # Close the tabs to the left\n    for i in range(l, pos):\n        print(abs(pos - i) + 1)\n\n# Check if the right boundary (r) is less than n\nif r < n:\n    # Move the cursor to the right boundary\n    pos = r\n    # Close the tabs to the right\n    for i in range(pos, r):\n        print(abs(pos - i) + 1)\n\n# Print the total time required\nprint(sum(range(l, r + 1)))"}
{"solution": "import sys\n\ndef get_min_blows(n, x, d, h):\n    # Initialize variables\n    cur_x = x\n    num_blows = 0\n    \n    # Loop through each blow\n    for i in range(n):\n        # Calculate the number of heads after the blow\n        new_x = cur_x - min(d[i], cur_x) + h[i]\n        \n        # If the number of heads is still positive, deal another blow\n        if new_x > 0:\n            cur_x = new_x\n            num_blows += 1\n        # If the number of heads is zero or less, break the loop\n        else:\n            break\n    \n    # Return the minimum number of blows\n    return num_blows\n\n# Read the input\nt = int(input())\nfor _ in range(t):\n    n, x = map(int, input().split())\n    d = [int(x) for x in input().split()]\n    h = [int(x) for x in input().split()]\n    \n    # Calculate the minimum number of blows\n    min_blows = get_min_blows(n, x, d, h)\n    \n    # Print the output\n    print(min_blows)"}
{"solution": "import sys\n\nn, m = map(int, input().split())\n\n# Initialize the number of grains in the barn\ngrains = n\n\n# Initialize the number of sparrows that have eaten grain\nsparrows = 0\n\n# Initialize the number of days\ndays = 0\n\n# Loop until the barn is empty\nwhile grains > 0:\n    # Bring m grains to the barn\n    grains += m\n\n    # If the barn becomes full, remove one grain\n    if grains > n:\n        grains -= 1\n\n    # Increment the number of sparrows that have eaten grain\n    sparrows += 1\n\n    # Increment the number of days\n    days += 1\n\n    # If the barn is empty, break the loop\n    if grains == 0:\n        break\n\n# Print the number of the day when the barn becomes empty\nprint(days)"}
{"solution": "def min_draws_to_win(tiles):\n    # Parse the input tiles\n    tile1, tile2, tile3 = tiles.split()\n    \n    # Extract numbers and suits\n    num1, suit1 = int(tile1[0]), tile1[1]\n    num2, suit2 = int(tile2[0]), tile2[1]\n    num3, suit3 = int(tile3[0]), tile3[1]\n    \n    # Check for koutsu (triplet)\n    if tile1 == tile2 == tile3:\n        return 0\n    \n    # Check for shuntsu (sequence)\n    def is_shuntsu(n1, n2, n3):\n        return sorted([n1, n2, n3]) in [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7], [6, 7, 8], [7, 8, 9]]\n    \n    if suit1 == suit2 == suit3 and is_shuntsu(num1, num2, num3):\n        return 0\n    \n    # Check for possible koutsu with one more draw\n    if tile1 == tile2 or tile1 == tile3 or tile2 == tile3:\n        return 1\n    \n    # Check for possible shuntsu with one more draw\n    def needs_one_for_shuntsu(n1, n2):\n        return abs(n1 - n2) == 1 or abs(n1 - n2) == 2\n    \n    if suit1 == suit2 and needs_one_for_shuntsu(num1, num2):\n        return 1\n    if suit1 == suit3 and needs_one_for_shuntsu(num1, num3):\n        return 1\n    if suit2 == suit3 and needs_one_for_shuntsu(num2, num3):\n        return 1\n    \n    # If no koutsu or shuntsu can be formed with one more draw, return 2\n    return 2"}
{"solution": "import sys\n\ndef find_sofa(n, m, d, x, y, cnt_l, cnt_r, cnt_t, cnt_b):\n    # Initialize a matrix to store the positions of the sofas\n    sofa_matrix = [[0 for _ in range(m)] for _ in range(n)]\n\n    # Fill the matrix with the positions of the sofas\n    for i in range(d):\n        sofa_matrix[x[i]][y[i]] = i + 1\n\n    # Initialize a variable to store the number of the sofa that matches the conditions\n    matching_sofa = -1\n\n    # Iterate through the matrix and find the sofa that matches the conditions\n    for i in range(n):\n        for j in range(m):\n            if sofa_matrix[i][j]!= 0:\n                # Check if the sofa is to the left of the grandpa's sofa\n                if i < cnt_l:\n                    continue\n                # Check if the sofa is to the right of the grandpa's sofa\n                if i > cnt_r:\n                    continue\n                # Check if the sofa is to the top of the grandpa's sofa\n                if j < cnt_t:\n                    continue\n                # Check if the sofa is to the bottom of the grandpa's sofa\n                if j > cnt_b:\n                    continue\n                # If all the conditions are met, set the matching sofa to the current sofa\n                matching_sofa = sofa_matrix[i][j]\n                break\n\n    return matching_sofa\n\n# Read the input from stdin\nn, m, d = map(int, input().split())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\ncnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\n# Find the matching sofa\nmatching_sofa = find_sofa(n, m, d, x, y, cnt_l, cnt_r, cnt_t, cnt_b)\n\n# Print the output to stdout\nprint(matching_sofa)"}
{"solution": "def mars_days_off(n):\n    full_weeks = n // 7\n    remaining_days = n % 7\n    \n    min_days_off = full_weeks * 2\n    max_days_off = full_weeks * 2 + min(remaining_days, 2)\n    \n    return min_days_off, max_days_off\n\nn = int(input())\nmin_days_off, max_days_off = mars_days_off(n)\nprint(min_days_off, max_days_off)"}
{"solution": "import sys\n\nn, a, b, p, q = map(int, sys.stdin.readline().split())\n\n# Calculate the number of tiles that can be painted Red\nred_tiles = n // a\n\n# Calculate the number of tiles that can be painted Blue\nblue_tiles = n // b\n\n# Calculate the number of tiles that can be painted either Red or Blue\neither_tiles = red_tiles + blue_tiles - (red_tiles * blue_tiles)\n\n# Calculate the total number of chocolates Joty can get\ntotal_chocolates = red_tiles * p + blue_tiles * q + either_tiles * (p + q)\n\nprint(total_chocolates)"}
{"solution": "  import sys\n\nn = int(input().strip())\ntrophies = input().strip()\n\n# Initialize the maximum length of the longest subsegment of golden trophies to 0\nmax_length = 0\n\n# Iterate through the trophies and check if the current trophy is golden\nfor i in range(n):\n    if trophies[i] == \"G\":\n        # If the current trophy is golden, check if the length of the longest subsegment of golden trophies is greater than the current maximum length\n        if i - max_length > 0:\n            # If the length of the longest subsegment of golden trophies is greater than the current maximum length, update the maximum length\n            max_length = i\n\n# Print the maximum possible length of the longest subsegment of golden trophies\nprint(max_length)"}
{"solution": "import sys\n\nn, k = map(int, input().split())\nmain_courses = set(map(int, input().split()))\n\ncourses = []\nfor i in range(n):\n    t = int(input())\n    courses.append(set(map(int, input().split())))\n\ndef get_order(courses, main_courses):\n    order = []\n    for i in range(n):\n        if i in main_courses:\n            order.append(i)\n        else:\n            for j in range(n):\n                if i in courses[j]:\n                    order.append(j)\n                    break\n    return order\n\norder = get_order(courses, main_courses)\n\nif len(order) == k:\n    print(len(order))\n    print(*order)\nelse:\n    print(-1)"}
{"solution": "import sys\n\nn, k = map(int, input().split())\np = list(map(int, input().split()))\n\n# Check if the first k elements of p are pairwise distinct\nif len(set(p[:k]))!= k:\n    print(-1)\n    sys.exit()\n\n# Initialize the stack and the remaining elements of the permutation\nstack = []\nremaining = [i for i in range(1, n + 1) if i not in p[:k]]\n\n# Perform the operations until both a and s are empty\nwhile stack or remaining:\n    # Take the first element of a, push it into s and remove it from a (if a is not empty)\n    if p:\n        stack.append(p.pop(0))\n    # Take the top element from s, append it to the end of array b and remove it from s (if s is not empty)\n    if stack:\n        remaining.append(stack.pop())\n\n# Check if the remaining elements of the permutation are sorted in non-descending order\nif sorted(remaining) == remaining:\n    print(remaining)\nelse:\n    print(-1)"}
{"solution": "def does_b_appear_in_sequence(a, b, c):\n    if c == 0:\n        return \"YES\" if a == b else \"NO\"\n    else:\n        if (b - a) % c == 0 and (b - a) // c >= 0:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n# Example usage:\na, b, c = map(int, input().split())\nprint(does_b_appear_in_sequence(a, b, c))"}
{"solution": "def can_form_regular_sequence(cnt_1, cnt_2, cnt_3, cnt_4):\n    if cnt_1 == cnt_4:\n        return 1\n    else:\n        return 0"}
{"solution": "import sys\n\nn, k, t = map(int, sys.stdin.readline().split())\n\n# Initialize the number of standing spectators to 0\nstanding_spectators = 0\n\n# Iterate through the time steps\nfor i in range(t):\n    # If the current time step is a multiple of k, increase the number of standing spectators\n    if i % k == 0:\n        standing_spectators += 1\n\n# Print the number of standing spectators at time t\nprint(standing_spectators)"}
{"solution": "def lexicographically_minimal_string(s):\n    t = []\n    u = []\n    min_char = min(s)\n    s = list(s)\n    \n    while s or t:\n        if t and (not s or t[-1] <= min_char):\n            u.append(t.pop())\n        else:\n            char = s.pop(0)\n            t.append(char)\n            if s:\n                min_char = min(s)\n    \n    return ''.join(u)\n\n# Example usage:\ns = input().strip()\nprint(lexicographically_minimal_string(s))"}
{"solution": "import sys\n\ndef check_records(stats):\n    n = len(stats)\n    for i in range(n-1):\n        p1, c1 = stats[i]\n        p2, c2 = stats[i+1]\n        if p2 < p1 or c2 < c1:\n            return \"NO\"\n    return \"YES\"\n\nfor case in range(int(input())):\n    n = int(input())\n    stats = []\n    for i in range(n):\n        p, c = map(int, input().split())\n        stats.append((p, c))\n    print(check_records(stats))"}
{"solution": "import re\n\ndef is_palindrome(time):\n    return time == time[::-1]\n\ndef get_next_palindrome(time):\n    h, m = map(int, time.split(':'))\n    for i in range(m, 60):\n        if is_palindrome(str(i)):\n            return f'{h:02d}:{i:02d}'\n    for i in range(h+1, 24):\n        if is_palindrome(str(i)):\n            return f'{i:02d}:00'\n    return '00:00'\n\ndef get_minutes_to_sleep(time):\n    next_palindrome = get_next_palindrome(time)\n    h, m = map(int, time.split(':'))\n    next_h, next_m = map(int, next_palindrome.split(':'))\n    return (next_h - h) * 60 + (next_m - m)\n\ntime = input()\nprint(get_minutes_to_sleep(time))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Find the minimum and maximum elements\nmin_idx = a.index(min(a))\nmax_idx = a.index(max(a))\n\n# Find the optimal swap\nswap_idx = min_idx\nfor i in range(n):\n    if a[i] > a[swap_idx]:\n        swap_idx = i\n\n# Perform the swap\na[min_idx], a[swap_idx] = a[swap_idx], a[min_idx]\n\n# Calculate the distance\ndistance = abs(min_idx - max_idx)\n\nprint(distance)"}
{"solution": "def is_s_palindrome(s):\n    n = len(s)\n    mid = n // 2\n    if n % 2 == 0:\n        first_half = s[:mid]\n        second_half = s[mid:]\n    else:\n        first_half = s[:mid]\n        second_half = s[mid+1:]\n    \n    if first_half == second_half[::-1]:\n        return \"TAK\"\n    else:\n        return \"NIE\"\n\n# Example usage:\ns = input().strip()\nprint(is_s_palindrome(s))"}
{"solution": "import sys\n\na, b = map(int, sys.stdin.readline().split())\n\n# Convert a to a list of digits\na_digits = [int(x) for x in str(a)]\n\n# Sort the digits in descending order\na_digits.sort(reverse=True)\n\n# Create a new list to store the permutations\npermutations = []\n\n# Iterate through the digits of a and create all possible permutations\nfor i in range(len(a_digits)):\n    for j in range(i+1, len(a_digits)):\n        permutations.append(a_digits[i] * 10 + a_digits[j])\n\n# Filter out permutations that exceed b\npermutations = [x for x in permutations if x <= b]\n\n# Sort the permutations in descending order\npermutations.sort(reverse=True)\n\n# Print the first permutation that is not greater than b\nprint(permutations[0])"}
{"solution": "def check_win(matrix):\n    # Check if there is a horizontal line of length 5 or more\n    for i in range(10):\n        for j in range(8):\n            if matrix[i][j] == 'X' and matrix[i][j+1] == 'X' and matrix[i][j+2] == 'X' and matrix[i][j+3] == 'X' and matrix[i][j+4] == 'X':\n                return 'YES'\n    \n    # Check if there is a vertical line of length 5 or more\n    for i in range(10):\n        for j in range(8):\n            if matrix[j][i] == 'X' and matrix[j+1][i] == 'X' and matrix[j+2][i] == 'X' and matrix[j+3][i] == 'X' and matrix[j+4][i] == 'X':\n                return 'YES'\n    \n    # Check if there is a diagonal line of length 5 or more\n    for i in range(10):\n        for j in range(8):\n            if matrix[i-j][j] == 'X' and matrix[i-j+1][j+1] == 'X' and matrix[i-j+2][j+2] == 'X' and matrix[i-j+3][j+3] == 'X' and matrix[i-j+4][j+4] == 'X':\n                return 'YES'\n    \n    # Check if there is a diagonal line of length 5 or more\n    for i in range(10):\n        for j in range(8):\n            if matrix[i+j][j] == 'X' and matrix[i+j+1][j+1] == 'X' and matrix[i+j+2][j+2] == 'X' and matrix[i+j+3][j+3] == 'X' and matrix[i+j+4][j+4] == 'X':\n                return 'YES'\n    \n    return 'NO'"}
{"solution": "def solve(n, k):\n    # Initialize the matrix with zeroes\n    matrix = [[0] * n for _ in range(n)]\n\n    # Place the k ones in the matrix symmetrically and lexicographically maximally\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] = 1\n            elif i + j == n - 1:\n                matrix[i][j] = 1\n            else:\n                matrix[i][j] = 0\n\n    # Check if the resulting matrix is symmetrical with respect to the main diagonal\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j]!= matrix[j][i]:\n                return -1\n\n    # Check if the resulting matrix is lexicographically maximal\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] > matrix[j][i]:\n                return -1\n\n    return matrix"}
{"solution": "import math\n\ndef get_maximum_expression(x, y, z):\n    expressions = [\n        x**y**z,\n        x**z**y,\n        (x**y)**z,\n        (x**z)**y,\n        y**x**z,\n        y**z**x,\n        (y**x)**z,\n        (y**z)**x,\n        z**x**y,\n        z**y**x,\n        (z**x)**y,\n        (z**y)**x\n    ]\n    return max(expressions)\n\ndef get_expression_string(expression):\n    if expression == x**y**z:\n        return \"x^y^z\"\n    elif expression == x**z**y:\n        return \"x^z^y\"\n    elif expression == (x**y)**z:\n        return \"(x^y)^z\"\n    elif expression == (x**z)**y:\n        return \"(x^z)^y\"\n    elif expression == y**x**z:\n        return \"y^x^z\"\n    elif expression == y**z**x:\n        return \"y^z^x\"\n    elif expression == (y**x)**z:\n        return \"(y^x)^z\"\n    elif expression == (y**z)**x:\n        return \"(y^z)^x\"\n    elif expression == z**x**y:\n        return \"z^x^y\"\n    elif expression == z**y**x:\n        return \"z^y^x\"\n    elif expression == (z**x)**y:\n        return \"(z^x)^y\"\n    elif expression == (z**y)**x:\n        return \"(z^y)^x\"\n\nx, y, z = map(float, input().split())\nexpression = get_maximum_expression(x, y, z)\nexpression_string = get_expression_string(expression)\nprint(expression_string)"}
{"solution": "n = int(input())\ns = input()\n\n# Initialize variables\noperations = 0\n\n# Iterate through the string\nfor i in range(n):\n    # If the current character is the same as the previous character, skip it\n    if i > 0 and s[i] == s[i-1]:\n        continue\n    # If the current character is different from the previous character, add it to the string\n    else:\n        operations += 1\n\n# Print the minimum number of operations\nprint(operations)"}
{"solution": "import sys\n\nn = int(input())\nfiles = []\n\nfor i in range(n):\n    name, type = input().split()\n    files.append((name, int(type)))\n\n# Sort the files by type (0 for regular, 1 for example)\nfiles.sort(key=lambda x: x[1])\n\n# Initialize the output script\nscript = []\n\n# Iterate through the files and generate the script\nfor i, (name, type) in enumerate(files):\n    if type == 0:\n        # Regular test, rename to \"e + 1\", \"e + 2\",..., \"n\"\n        new_name = str(i + 1)\n    else:\n        # Example test, rename to \"1\", \"2\",..., \"e\"\n        new_name = str(i + 1)\n\n    script.append(f\"move {name} {new_name}\")\n\nprint(len(script))\nprint(\"\\n\".join(script))"}
{"solution": "def is_lucky(ticket):\n    # Split the ticket into two parts\n    first_three = ticket[:3]\n    last_three = ticket[3:]\n\n    # Calculate the sum of the first three digits\n    first_sum = sum(map(int, first_three))\n\n    # Calculate the sum of the last three digits\n    last_sum = sum(map(int, last_three))\n\n    # Return the minimum number of replacements needed to make the ticket lucky\n    return min(first_sum, last_sum)\n\n\n# Test the function\nticket = \"123456\"\nprint(is_lucky(ticket))  # Output: 2\n\nticket = \"111000\"\nprint(is_lucky(ticket))  # Output: 1\n\nticket = \"000000\"\nprint(is_lucky(ticket))  # Output: 0"}
{"solution": "def minimum_traps(m, x):\n    return m - 1"}
{"solution": "  import math\n\ndef birthday_paradox(n, k):\n    # Calculate the probability of at least two people having the same birthday\n    probability = 1 - math.factorial(2**n) / (math.factorial(2**n - k) * math.factorial(k))\n\n    # Calculate the values of A and B\n    A = int(probability * (10**6 + 3))\n    B = int(10**6 + 3)\n\n    # Return the values of A and B\n    return A, B\n\n# Test the function with the given examples\nassert birthday_paradox(3, 2) == (1, 8)\nassert birthday_paradox(1, 3) == (1, 1)\nassert birthday_paradox(4, 3) == (23, 128)\n\n# Test the function with random inputs\nimport random\n\nfor i in range(100):\n    n = random.randint(1, 10**18)\n    k = random.randint(2, 10**18)\n    A, B = birthday_paradox(n, k)\n    assert A >= 0 and B >= 1 and math.gcd(A, B) == 1\n    assert A % (10**6 + 3) == B % (10**6 + 3)\n    print(f\"{A} {B}\")"}
{"solution": "n = int(input())\n\n# Initialize the position of Limak as the North Pole\nposition = \"North\"\n\n# Iterate through the n parts of the journey\nfor i in range(n):\n    # Get the length and direction of the i-th part of the journey\n    t, direction = map(int, input().split())\n    \n    # Check if Limak is on the North or South Pole\n    if position == \"North\":\n        # Limak is on the North Pole, so he can only move South\n        if direction == \"South\":\n            # Update the position and move the required distance\n            position = \"South\"\n            t -= 20000\n        else:\n            # Limak cannot move North, so the description is invalid\n            print(\"NO\")\n            break\n    elif position == \"South\":\n        # Limak is on the South Pole, so he can only move North\n        if direction == \"North\":\n            # Update the position and move the required distance\n            position = \"North\"\n            t -= 20000\n        else:\n            # Limak cannot move South, so the description is invalid\n            print(\"NO\")\n            break\n    \n    # Check if the journey ends on the North Pole\n    if t == 0 and position == \"North\":\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "import sys\n\ndef solve(a1, b1, a2, b2, L, R):\n    x = 0\n    for k in range(L, R+1):\n        for l in range(L, R+1):\n            if a1*k + b1 == a2*l + b2:\n                x += 1\n    return x\n\nif __name__ == \"__main__\":\n    a1, b1, a2, b2, L, R = map(int, sys.stdin.readline().split())\n    print(solve(a1, b1, a2, b2, L, R))"}
{"solution": "n, a, b = map(int, input().split())\n\n# Initialize the number of pieces on each plate to 0\nplates = [0] * n\n\n# Initialize the number of pieces of each cake to 0\ncake1 = 0\ncake2 = 0\n\n# Loop through each plate\nfor i in range(n):\n    # If the current plate is not full, add a piece of cake to it\n    if plates[i] < a:\n        plates[i] += 1\n        cake1 += 1\n    # If the current plate is full, add a piece of cake to the next plate\n    else:\n        plates[i + 1] += 1\n        cake2 += 1\n\n# Print the maximum number of pieces on each plate\nprint(max(plates))"}
{"solution": "n, m = map(int, input().split())\nfield = [input() for _ in range(n)]\n\n# Check if the field is rectangular\nif len(set(map(len, field)))!= 1:\n    print(\"NO\")\n    exit()\n\n# Check if the field has three colors\nif len(set(field[0]))!= 3:\n    print(\"NO\")\n    exit()\n\n# Check if the field has three equal-width stripes\nif len(set(map(lambda x: x[0], field)))!= 3:\n    print(\"NO\")\n    exit()\n\n# Check if each color is used exactly once\nif len(set(field[0]))!= len(set(field[1])) or len(set(field[1]))!= len(set(field[2])):\n    print(\"NO\")\n    exit()\n\n# Check if each stripe has the same height\nif len(set(map(len, field)))!= 1:\n    print(\"NO\")\n    exit()\n\nprint(\"YES\")"}
{"solution": "import math\n\ndef spiral_moves(n):\n    # Calculate the number of moves in each direction\n    num_moves_right = int(math.ceil(n / 2))\n    num_moves_left = int(math.floor(n / 2))\n    num_moves_up = int(math.ceil((n - num_moves_right) / 2))\n    num_moves_down = int(math.floor((n - num_moves_right) / 2))\n\n    # Calculate the current position\n    x = num_moves_right - num_moves_left\n    y = num_moves_up - num_moves_down\n\n    return x, y\n\nn = int(input())\nx, y = spiral_moves(n)\nprint(x, y)"}
{"solution": "import math\n\ndef can_break_shield(a, b, c):\n    # Calculate the greatest common divisor of a and b\n    gcd_ab = math.gcd(a, b)\n    \n    # Check if c is divisible by the gcd of a and b\n    if c % gcd_ab == 0:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read input values\na, b, c = map(int, input().split())\n\n# Output the result\nprint(can_break_shield(a, b, c))"}
{"solution": "n, L = map(int, input().split())\nkefa_barriers = list(map(int, input().split()))\nsasha_barriers = list(map(int, input().split()))\n\n# Calculate distances between consecutive barriers for Kefa\nkefa_distances = [(kefa_barriers[(i + 1) % n] - kefa_barriers[i]) % L for i in range(n)]\n# Calculate distances between consecutive barriers for Sasha\nsasha_distances = [(sasha_barriers[(i + 1) % n] - sasha_barriers[i]) % L for i in range(n)]\n\n# Double the kefa_distances to handle circular rotation\ndoubled_kefa_distances = kefa_distances + kefa_distances\n\n# Check if sasha_distances is a sublist of doubled_kefa_distances\nfor i in range(n):\n    if doubled_kefa_distances[i:i + n] == sasha_distances:\n        print(\"YES\")\n        break\nelse:\n    print(\"NO\")"}
{"solution": "def longest_non_palindromic_substring(s):\n    # Initialize variables\n    max_length = 0\n    current_length = 0\n    is_palindrome = True\n\n    # Iterate over the string\n    for i in range(len(s)):\n        # Check if the substring is a palindrome\n        if s[i] == s[len(s) - i - 1]:\n            current_length += 1\n        else:\n            # If the substring is not a palindrome, check if it's longer than the current maximum\n            if current_length > max_length:\n                max_length = current_length\n                is_palindrome = False\n            current_length = 0\n\n    # If the entire string is a palindrome, return 0\n    if is_palindrome:\n        return 0\n\n    # Return the maximum length of the non-palindromic substring\n    return max_length"}
{"solution": "n = int(input())\na = [int(input()) for _ in range(n)]\nb = [int(input()) for _ in range(n)]\n\nif any(a[i]!= b[i] for i in range(n)):\n    print(\"rated\")\nelif all(a[i] == b[i] for i in range(n)):\n    print(\"unrated\")\nelse:\n    print(\"maybe\")"}
{"solution": "def find_nearest_zero(arr):\n    n = len(arr)\n    d = [0] * n\n    for i in range(n):\n        if arr[i] == 0:\n            d[i] = 0\n        else:\n            for j in range(i+1, n):\n                if arr[j] == 0:\n                    d[i] = j - i\n                    break\n    return d\n\narr = [2, 1, 0, 3, 0, 0, 3, 2, 4]\nprint(find_nearest_zero(arr))"}
{"solution": "def count_distinct_cyclical_strings(n, s):\n    from itertools import product\n    \n    def is_substring_in_cyclical_shifts(t, s):\n        t_extended = t + t\n        return any(s in t_extended[i:i+len(t)] for i in range(len(t)))\n    \n    distinct_cyclical_strings = set()\n    \n    for bits in product('01', repeat=n):\n        t = ''.join(bits)\n        if is_substring_in_cyclical_shifts(t, s):\n            distinct_cyclical_strings.add(t)\n    \n    return len(distinct_cyclical_strings)\n\n# Example usage\nn = int(input())\ns = input().strip()\nprint(count_distinct_cyclical_strings(n, s))"}
{"solution": "import sys\n\nn = int(input())\nvectors = []\n\nfor i in range(n):\n    x, y = map(int, input().split())\n    vectors.append((x, y))\n\n# Calculate the angle between each pair of vectors\nangles = []\nfor i in range(n):\n    for j in range(i+1, n):\n        angle = calculate_angle(vectors[i], vectors[j])\n        angles.append((i, j, angle))\n\n# Find the pair with the minimal non-oriented angle\nmin_angle = float('inf')\nmin_pair = None\nfor pair in angles:\n    if pair[2] < min_angle:\n        min_angle = pair[2]\n        min_pair = pair\n\n# Print the indices of the vectors with the minimal non-oriented angle\nprint(min_pair[0], min_pair[1])\n\ndef calculate_angle(v1, v2):\n    # Calculate the dot product of the two vectors\n    dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n\n    # Calculate the magnitude of the two vectors\n    mag1 = (v1[0] ** 2 + v1[1] ** 2) ** 0.5\n    mag2 = (v2[0] ** 2 + v2[1] ** 2) ** 0.5\n\n    # Calculate the cosine of the angle between the two vectors\n    cos_angle = dot_product / (mag1 * mag2)\n\n    # Calculate the angle between the two vectors\n    angle = math.acos(cos_angle)\n\n    return angle"}
{"solution": "def minimal_time(d, k, a, b, t):\n    if d <= k:\n        return d * a\n    \n    # Full segments\n    full_segments = d // k\n    remaining_distance = d % k\n    \n    # Time for full segments\n    time_for_full_segments = full_segments * k * a + (full_segments - 1) * t\n    \n    # Time for remaining distance\n    if remaining_distance == 0:\n        return time_for_full_segments\n    else:\n        # Option 1: Drive the remaining distance\n        time_drive_remaining = remaining_distance * a + t\n        # Option 2: Walk the remaining distance\n        time_walk_remaining = remaining_distance * b\n        \n        return time_for_full_segments + min(time_drive_remaining, time_walk_remaining)"}
{"solution": "import sys\n\nn, k = map(int, input().split())\n\n# Initialize the sequence with the first element\nsequence = [1]\n\n# Loop through the remaining elements\nfor i in range(1, k):\n    # Find the next element in the sequence\n    next_element = find_next_element(sequence, n)\n\n    # Add the next element to the sequence\n    sequence.append(next_element)\n\n# Print the sequence\nprint(sequence)\n\ndef find_next_element(sequence, n):\n    # Find the greatest common divisor of the sequence\n    gcd = find_gcd(sequence)\n\n    # Find the next element in the sequence\n    next_element = find_next_element_helper(sequence, n, gcd)\n\n    return next_element\n\ndef find_gcd(sequence):\n    # Initialize the greatest common divisor to 1\n    gcd = 1\n\n    # Loop through the sequence\n    for element in sequence:\n        # Find the greatest common divisor of the element and the current gcd\n        gcd = find_gcd_helper(element, gcd)\n\n    return gcd\n\ndef find_gcd_helper(element, gcd):\n    # Find the greatest common divisor of the element and the current gcd\n    gcd = gcd if gcd > element else element\n\n    return gcd\n\ndef find_next_element_helper(sequence, n, gcd):\n    # Initialize the next element to 1\n    next_element = 1\n\n    # Loop through the sequence\n    for element in sequence:\n        # Find the next element in the sequence\n        next_element = find_next_element_helper_helper(element, next_element, n, gcd)\n\n    return next_element\n\ndef find_next_element_helper_helper(element, next_element, n, gcd):\n    # Find the next element in the sequence\n    next_element = (element + next_element) // gcd\n\n    # Check if the next element is less than or equal to n\n    if next_element <= n:\n        return next_element\n    else:\n        return -1"}
{"solution": "import sys\n\nn, m = map(int, input().split())\n\ncount = 0\nfor x in range(1, n+1):\n    for y in range(1, m+1):\n        if (x + y) % 5 == 0:\n            count += 1\n\nprint(count)"}
{"solution": "import sys\n\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Initialize the maximum beauty of the array to 0\nmax_beauty = 0\n\n# Iterate over all possible subarrays\nfor i in range(n):\n    for j in range(i, n):\n        # Calculate the sum of the subarray\n        subarray_sum = sum(a[i:j+1])\n        # Multiply the subarray by x\n        subarray_sum *= x\n        # Calculate the beauty of the subarray\n        subarray_beauty = max(subarray_sum, 0)\n        # Update the maximum beauty of the array\n        max_beauty = max(max_beauty, subarray_beauty)\n\n# Print the maximum beauty of the array\nprint(max_beauty)"}
{"solution": "def find_kth_largest(n, m, k):\n    def count_less_equal(x):\n        count = 0\n        for i in range(1, n + 1):\n            count += min(m, x // i)\n        return count\n\n    low, high = 1, n * m\n    while low < high:\n        mid = (low + high) // 2\n        if count_less_equal(mid) < k:\n            low = mid + 1\n        else:\n            high = mid\n    return low"}
{"solution": "import sys\n\nk = int(sys.stdin.readline())\n\n# Initialize the sequence with the first 1000 numbers\nsequence = [str(i) for i in range(1, 1001)]\n\n# Append the next 1000 numbers to the sequence\nfor i in range(1001, 2001):\n    sequence.append(str(i))\n\n# Print the k-th digit of the sequence\nprint(sequence[k-1])"}
{"solution": "import sys\n\nn, m, r = map(int, input().split())\ns = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Initialize the maximum number of bourles to 0\nmax_bourles = 0\n\n# Iterate over the opportunities to buy shares\nfor i in range(n):\n    # Calculate the number of shares that can be bought with the current opportunity\n    num_shares = r // s[i]\n    \n    # Update the maximum number of bourles\n    max_bourles += num_shares * s[i]\n    \n    # Update the number of bourles remaining\n    r -= num_shares * s[i]\n\n# Iterate over the opportunities to sell shares\nfor i in range(m):\n    # Calculate the number of shares that can be sold with the current opportunity\n    num_shares = min(r // b[i], num_shares)\n    \n    # Update the maximum number of bourles\n    max_bourles += num_shares * b[i]\n    \n    # Update the number of bourles remaining\n    r -= num_shares * b[i]\n\n# Print the maximum number of bourles\nprint(max_bourles)"}
{"solution": "def find_original_message(t):\n    n = len(t)\n    \n    # \u041f\u0435\u0440\u0435\u0431\u0438\u0440\u0430\u0435\u043c \u0432\u0441\u0435 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u0434\u043b\u0438\u043d\u044b \u043d\u0430\u043b\u043e\u0436\u0435\u043d\u0438\u044f\n    for overlap in range(1, n // 2 + 1):\n        # \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u0441\u043e\u0432\u043f\u0430\u0434\u0430\u044e\u0442 \u043b\u0438 \u043d\u0430\u0447\u0430\u043b\u043e \u0441\u0442\u0440\u043e\u043a\u0438 t \u0434\u043b\u0438\u043d\u043e\u0439 overlap \u0438 \u043a\u043e\u043d\u0435\u0446 \u0441\u0442\u0440\u043e\u043a\u0438 t \u0434\u043b\u0438\u043d\u043e\u0439 overlap\n        if t[:overlap] == t[-overlap:]:\n            s = t[:-overlap]\n            if s + t[-overlap:] == t:\n                return \"YES\", s\n    \n    return \"NO\", None\n\n# \u0427\u0442\u0435\u043d\u0438\u0435 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\nt = input().strip()\n\n# \u041f\u043e\u0438\u0441\u043a \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0433\u043e \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f s\nresult, s = find_original_message(t)\n\n# \u0412\u044b\u0432\u043e\u0434 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430\nprint(result)\nif result == \"YES\":\n    print(s)"}
{"solution": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    int teams = 1;\n    while (true) {\n        int games = 0;\n        for (int i = 0; i < teams; i++) {\n            if (i % 2 == 0) {\n                games += 1;\n            } else {\n                games += 2;\n            }\n        }\n\n        if (games == n) {\n            cout << teams << endl;\n            break;\n        } else if (games > n) {\n            cout << -1 << endl;\n            break;\n        }\n\n        teams++;\n    }\n\n    return 0;\n}"}
{"solution": "import sys\n\nn = int(input())\ns = input()\nb = list(map(int, input().split()))\n\n# Initialize the maximum beauty as 0\nmax_beauty = 0\n\n# Iterate through each permutation of the string\nfor i in range(len(s)):\n    # Check if the permutation is antipalindromic\n    if is_antipalindromic(s[i:]):\n        # Calculate the beauty of the permutation\n        beauty = calculate_beauty(s[i:], b)\n        # Update the maximum beauty if necessary\n        if beauty > max_beauty:\n            max_beauty = beauty\n\n# Print the maximum beauty\nprint(max_beauty)\n\n# Function to check if a string is antipalindromic\ndef is_antipalindromic(s):\n    # Check if the length of the string is even\n    if len(s) % 2 == 0:\n        # Iterate through each character in the string\n        for i in range(len(s)):\n            # Check if the character is not equal to the character at the opposite index\n            if s[i]!= s[len(s) - i - 1]:\n                # If any character is not equal, return False\n                return False\n        # If all characters are equal, return True\n        return True\n    # If the length of the string is odd, return False\n    return False\n\n# Function to calculate the beauty of a string\ndef calculate_beauty(s, b):\n    # Initialize the beauty as 0\n    beauty = 0\n    # Iterate through each character in the string\n    for i in range(len(s)):\n        # Add the beauty of the character to the total beauty\n        beauty += b[i]\n    # Return the total beauty\n    return beauty"}
{"solution": "import sys\n\ndef can_weight(weights, item_mass):\n    # sort the weights in descending order\n    sorted_weights = sorted(weights, reverse=True)\n\n    # initialize the left and right pans of the scales\n    left_pan = 0\n    right_pan = 0\n\n    # iterate through the weights and add them to the appropriate pan\n    for weight in sorted_weights:\n        if left_pan + weight <= item_mass:\n            left_pan += weight\n        else:\n            right_pan += weight\n\n    # check if the pans are in balance\n    if left_pan == right_pan:\n        return \"YES\"\n    else:\n        return \"NO\"\n\nif __name__ == \"__main__\":\n    weights = list(map(int, sys.stdin.readline().split()))\n    item_mass = int(sys.stdin.readline())\n    print(can_weight(weights, item_mass))"}
{"solution": "  import sys\n\nn, k = map(int, input().split())\n\ndef find_sequence(n, k):\n    # Initialize the sequence with the largest possible value\n    sequence = [10**18] * k\n    \n    # Start from the largest power of 2 and work backwards\n    for i in range(k-1, -1, -1):\n        # Calculate the current power of 2\n        power = 2**i\n        \n        # If the current power is less than or equal to the required sum, use it\n        if power <= n:\n            sequence[i] = i\n            n -= power\n    \n    # If the required sum is not exhausted, there is no solution\n    if n > 0:\n        return \"No\"\n    \n    # Sort the sequence in lexicographical order\n    sequence.sort(reverse=True)\n    \n    # Print the solution\n    return \"Yes\\n\" + \" \".join(str(x) for x in sequence)\n\nprint(find_sequence(n, k))"}
{"solution": "import sys\n\nn, t = map(int, sys.stdin.readline().split())\n\n# Initialize the pyramid with n levels and 1 glass on the top level\npyramid = [[1]]\nfor i in range(n-1):\n    pyramid.append([0] * (i+2))\n\n# Pour champagne into the pyramid\nfor i in range(t):\n    # Pour champagne into the top glass\n    pyramid[0][0] += 1\n    # Check if the top glass is full\n    if pyramid[0][0] == 1:\n        # Pour champagne over the edge of the top glass and distribute it evenly among the glasses below\n        for j in range(1, len(pyramid[0])):\n            pyramid[0][j] += 1\n            pyramid[0][j-1] -= 1\n        # Check if any of the glasses below are full\n        for j in range(1, len(pyramid)):\n            if pyramid[j][0] == 1:\n                # Pour champagne over the edge of the glass and distribute it evenly among the glasses below\n                for k in range(1, len(pyramid[j])):\n                    pyramid[j][k] += 1\n                    pyramid[j][k-1] -= 1\n\n# Count the number of completely full glasses\ncompletely_full_glasses = 0\nfor i in range(n):\n    for j in range(i+1):\n        if pyramid[i][j] == 1:\n            completely_full_glasses += 1\n\nprint(completely_full_glasses)"}
{"solution": "n = int(input())\nvertices = [tuple(map(int, input().split())) for _ in range(n)]\n\nif n == 1:\n    return -1\nelif n == 2:\n    x1, y1 = vertices[0]\n    x2, y2 = vertices[1]\n    if x1!= x2 and y1!= y2:\n        return abs(x1 - x2) * abs(y1 - y2)\n    else:\n        return -1\nelif n == 3:\n    x_coords = set()\n    y_coords = set()\n    for x, y in vertices:\n        x_coords.add(x)\n        y_coords.add(y)\n    if len(x_coords) == 2 and len(y_coords) == 2:\n        x1, x2 = x_coords\n        y1, y2 = y_coords\n        return abs(x1 - x2) * abs(y1 - y2)\n    else:\n        return -1\nelif n == 4:\n    x_coords = set()\n    y_coords = set()\n    for x, y in vertices:\n        x_coords.add(x)\n        y_coords.add(y)\n    if len(x_coords) == 2 and len(y_coords) == 2:\n        x1, x2 = x_coords\n        y1, y2 = y_coords\n        return abs(x1 - x2) * abs(y1 - y2)\n    else:\n        return -1"}
{"solution": "n = int(input())\na = int(input())\nb = int(input())\n\n# Calculate the total length of the sides of the frames\ntotal_length = 2 * a + 2 * b\n\n# Calculate the number of wooden bars needed\nnum_bars = total_length // n\n\n# Print the output\nprint(num_bars)"}
{"solution": "import sys\n\nn = int(input())\narr = list(map(int, input().split()))\nswaps = input()\n\n# Check if the array is already sorted\nif arr == sorted(arr):\n    print(\"YES\")\n    sys.exit()\n\n# Check if the swaps are valid\nif len(swaps)!= n - 1:\n    print(\"NO\")\n    sys.exit()\n\n# Check if the swaps are allowed\nfor i in range(n - 1):\n    if swaps[i] == \"1\" and arr[i] > arr[i + 1]:\n        print(\"NO\")\n        sys.exit()\n\n# Perform the swaps\nfor i in range(n - 1):\n    if swaps[i] == \"1\":\n        arr[i], arr[i + 1] = arr[i + 1], arr[i]\n\n# Check if the array is sorted\nif arr == sorted(arr):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\ndef get_time_to_wait(seat):\n    row, col = seat\n    row = int(row)\n    col = ord(col) - ord('a') + 1\n    if col == 1 or col == 3:\n        return row\n    elif col == 2 or col == 4:\n        return row + 1\n    else:\n        return row + 2\n\nseat = sys.stdin.readline().strip()\nprint(get_time_to_wait(seat))"}
{"solution": "def compare_numbers(x, y):\n    x_base = x[1]\n    y_base = y[1]\n    x_digits = x[0]\n    y_digits = y[0]\n\n    if x_base == y_base:\n        if x_digits == y_digits:\n            return '='\n        elif x_digits < y_digits:\n            return '<'\n        else:\n            return '>'\n    else:\n        x_value = int(x_digits, x_base)\n        y_value = int(y_digits, y_base)\n        if x_value < y_value:\n            return '<'\n        elif x_value > y_value:\n            return '>'\n        else:\n            return '='\n\nx = [101111, 2]\ny = [47, 10]\nprint(compare_numbers(x, y))"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize the game state\ngame_state = {\n    \"a\": a,\n    \"x\": 0,\n    \"y\": 0\n}\n\n# Determine the winner\nwhile True:\n    # Check if the game is over\n    if len(game_state[\"a\"]) == 0:\n        break\n    \n    # Determine the next move\n    if game_state[\"x\"] == 0:\n        # Choose the minimum value in the array\n        game_state[\"x\"] = min(game_state[\"a\"])\n    else:\n        # Choose the maximum value in the array\n        game_state[\"x\"] = max(game_state[\"a\"])\n    \n    # Decrease all values by the chosen value\n    for i in range(len(game_state[\"a\"])):\n        game_state[\"a\"][i] -= game_state[\"x\"]\n    \n    # Update the game state\n    game_state[\"y\"] += 1\n\n# Print the winner\nif game_state[\"y\"] % 2 == 0:\n    print(\"BitLGM\")\nelse:\n    print(\"BitAryo\")"}
{"solution": "import sys\n\nn, k = map(int, input().split())\ncards = list(map(int, input().split()))\n\n# Initialize the number of ways to choose x and y\nways = 0\n\n# Iterate over all possible values of x and y\nfor x in range(n):\n    for y in range(n):\n        # Check if the resulting deck is valid\n        if is_valid_deck(cards, x, y, k):\n            ways += 1\n\nprint(ways)\n\ndef is_valid_deck(cards, x, y, k):\n    # Remove the top x cards and bottom y cards from the deck\n    deck = cards[x:n-y]\n\n    # Calculate the product of all numbers written on the cards in the deck\n    product = 1\n    for card in deck:\n        product *= card\n\n    # Check if the product is divisible by k\n    return product % k == 0"}
{"solution": "n, k = map(int, input().split())\ns = input()\n\n# Initialize a dictionary to keep track of the colors and their counts\ncolors = {}\nfor c in s:\n    if c not in colors:\n        colors[c] = 1\n    else:\n        colors[c] += 1\n\n# Check if the number of balloons is divisible by the number of friends\nif n % k == 0:\n    # If the number of balloons is divisible, check if the colors are divisible\n    for c, count in colors.items():\n        if count % k!= 0:\n            print(\"NO\")\n            exit()\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\nn = int(input())\narr = list(map(int, input().split()))\n\n# find the positions of the minimum values in the array\nmin_positions = []\nfor i in range(n):\n    if arr[i] == min(arr[i:n]):\n        min_positions.append(i)\n\n# calculate the distance between the two closest minimums\nmin_distance = sys.maxsize\nfor i in range(len(min_positions)):\n    for j in range(i+1, len(min_positions)):\n        distance = abs(min_positions[i] - min_positions[j])\n        if distance < min_distance:\n            min_distance = distance\n\nprint(min_distance)"}
{"solution": "import random\n\ndef get_probability(t, w, b):\n    total_steps = t // min(w, b)\n    tie_cases = 0\n    for i in range(total_steps):\n        if i % w == 0 and i % b == 0:\n            tie_cases += 1\n    return tie_cases / total_steps\n\nt = int(input())\nw = int(input())\nb = int(input())\n\nprobability = get_probability(t, w, b)\n\nprint(f\"{probability:.6f}\")"}
{"solution": "import sys\n\ndef main():\n    x, y, z = map(int, sys.stdin.readline().split())\n    if x > y:\n        print(\"+\")\n    elif y > x:\n        print(\"-\")\n    else:\n        print(\"0\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\nn = int(input())\nsequence = input()\nx, y = map(int, input().split())\n\n# Initialize the minimum length of the changed subsegment to -1\nmin_length = -1\n\n# Iterate through the sequence and check if the robot can reach the target coordinates\nfor i in range(n):\n    # If the current operation is U, move up by 1\n    if sequence[i] == 'U':\n        y += 1\n    # If the current operation is D, move down by 1\n    elif sequence[i] == 'D':\n        y -= 1\n    # If the current operation is L, move left by 1\n    elif sequence[i] == 'L':\n        x -= 1\n    # If the current operation is R, move right by 1\n    elif sequence[i] == 'R':\n        x += 1\n\n# If the robot has reached the target coordinates, set the minimum length to 0\nif x == x and y == y:\n    min_length = 0\n\nprint(min_length)"}
{"solution": "import sys\n\ndef solve():\n    T = int(input())\n    results = []\n\n    for _ in range(T):\n        n, x = map(int, input().split())\n        s = input()\n\n        balance_s = s.count('0') - s.count('1')\n        prefix_balances = [0] * (n + 1)\n\n        for i in range(n):\n            prefix_balances[i + 1] = prefix_balances[i] + (1 if s[i] == '0' else -1)\n\n        if balance_s == 0:\n            if x in prefix_balances:\n                results.append(-1)\n            else:\n                results.append(0)\n        else:\n            count = 0\n            for b in prefix_balances:\n                if (x - b) % balance_s == 0 and (x - b) // balance_s >= 0:\n                    count += 1\n            results.append(count)\n\n    for result in results:\n        print(result)\n\nsolve()"}
{"solution": "import math\n\ndef get_min_digits_to_delete(n, k):\n    # Convert the number to a string\n    n_str = str(n)\n    \n    # Find the length of the number\n    n_len = len(n_str)\n    \n    # Initialize the minimum number of digits to delete\n    min_digits = 0\n    \n    # Iterate through the digits of the number\n    for i in range(n_len):\n        # Get the current digit\n        digit = int(n_str[i])\n        \n        # Check if the digit is divisible by 10^k\n        if digit % (10 ** k) == 0:\n            # If it is, increment the minimum number of digits to delete\n            min_digits += 1\n    \n    # Return the minimum number of digits to delete\n    return min_digits\n\n# Test the function\nn = 30020\nk = 3\nprint(get_min_digits_to_delete(n, k))"}
{"solution": "import sys\n\nn, m, k, x, y = map(int, sys.stdin.readline().split())\n\n# Calculate the maximum number of questions a particular pupil is asked\nmax_questions = 0\nfor i in range(n):\n    for j in range(m):\n        if i == x and j == y:\n            continue\n        max_questions = max(max_questions, k // (n * m - 1))\n\n# Calculate the minimum number of questions a particular pupil is asked\nmin_questions = k // (n * m - 1)\n\n# Calculate how many times the teacher asked Sergei\nsergei_questions = k % (n * m - 1)\n\nprint(max_questions, min_questions, sergei_questions)"}
{"solution": "n = int(input())\n\nribbon_kuro = input()\nribbon_shiro = input()\nribbon_katie = input()\n\ndef get_beauty(ribbon):\n    beauty = 0\n    for i in range(len(ribbon)):\n        if ribbon[i] == ribbon[i-1]:\n            beauty += 1\n    return beauty\n\nbeauty_kuro = get_beauty(ribbon_kuro)\nbeauty_shiro = get_beauty(ribbon_shiro)\nbeauty_katie = get_beauty(ribbon_katie)\n\nif beauty_kuro > beauty_shiro and beauty_kuro > beauty_katie:\n    print(\"Kuro\")\nelif beauty_shiro > beauty_kuro and beauty_shiro > beauty_katie:\n    print(\"Shiro\")\nelif beauty_katie > beauty_kuro and beauty_katie > beauty_shiro:\n    print(\"Katie\")\nelse:\n    print(\"Draw\")"}
{"solution": "  import sys\n\ndef calculate_days(c, v_0, v_1, a, l):\n    days = 0\n    pages_read = 0\n    while pages_read < c:\n        pages_read += v_0\n        v_0 += a\n        if v_0 > v_1:\n            v_0 = v_1\n        days += 1\n        if pages_read - l >= 0:\n            pages_read -= l\n    return days\n\nif __name__ == '__main__':\n    c, v_0, v_1, a, l = map(int, sys.stdin.readline().split())\n    print(calculate_days(c, v_0, v_1, a, l))"}
{"solution": "import math\n\ndef find_prime_representation(n):\n    # Initialize the list of prime numbers\n    prime_list = []\n\n    # Iterate from 2 to the square root of n\n    for i in range(2, int(math.sqrt(n)) + 1):\n        # Check if i is a prime number\n        if is_prime(i):\n            # Add i to the list of prime numbers\n            prime_list.append(i)\n\n            # Check if the sum of the prime numbers is equal to n\n            if sum(prime_list) == n:\n                # Return the list of prime numbers\n                return prime_list\n\n    # If no prime number was found, return an empty list\n    return []\n\ndef is_prime(n):\n    # Check if n is a prime number\n    if n == 1 or n == 0:\n        return False\n\n    # Iterate from 2 to the square root of n\n    for i in range(2, int(math.sqrt(n)) + 1):\n        # Check if i divides n\n        if n % i == 0:\n            return False\n\n    # If no divisor was found, n is a prime number\n    return True\n\n# Test the function\nn = 27\nprime_list = find_prime_representation(n)\nprint(len(prime_list))\nprint(*prime_list)"}
{"solution": "import sys\n\nn, m = map(int, input().split())\nfield = [list(input()) for _ in range(n)]\n\n# Count the number of walls in each row and column\nrow_walls = [0] * n\ncol_walls = [0] * m\nfor i in range(n):\n    for j in range(m):\n        if field[i][j] == '*':\n            row_walls[i] += 1\n            col_walls[j] += 1\n\n# Check if there exists a cell (x, y) such that the sum of walls in row x and column y equals the total number of walls\nfor i in range(n):\n    for j in range(m):\n        if row_walls[i] + col_walls[j] == sum(row_walls) + sum(col_walls):\n            print(\"YES\")\n            print(i, j)\n            sys.exit()\n\nprint(\"NO\")"}
{"solution": "import sys\n\nn, m, a, b = map(int, sys.stdin.readline().split())\n\n# Initialize the number of boxes to be divisible by m\nnum_boxes = n // m * m\n\n# Initialize the number of burles to be paid\nburles = 0\n\n# While the number of boxes is not divisible by m\nwhile num_boxes % m!= 0:\n    # If the number of boxes is less than m\n    if num_boxes < m:\n        # Build m - num_boxes boxes\n        burles += (m - num_boxes) * a\n        num_boxes += m - num_boxes\n    # If the number of boxes is greater than m\n    else:\n        # Demolish num_boxes - m boxes\n        burles += (num_boxes - m) * b\n        num_boxes -= num_boxes - m\n\nprint(burles)"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Find the maximum odd sum subsequence\nmax_sum = 0\nfor i in range(n):\n    for j in range(i, n):\n        sum = 0\n        for k in range(i, j+1):\n            sum += a[k]\n        if sum % 2 == 1 and sum > max_sum:\n            max_sum = sum\n\nprint(max_sum)"}
{"solution": "import sys\n\ndef count_valid_playlists(n, T, songs):\n    # Initialize a dictionary to store the number of valid playlists for each song\n    valid_playlists = {}\n\n    # Iterate over each song\n    for i in range(n):\n        # Get the duration and genre of the current song\n        duration, genre = songs[i]\n\n        # If the current song is the first song in the playlist, it is a valid playlist\n        if i == 0:\n            valid_playlists[i] = 1\n\n        # If the current song is not the first song in the playlist, check if it is a valid playlist\n        else:\n            # Get the previous song in the playlist\n            previous_song = songs[i - 1]\n\n            # If the previous song has the same genre as the current song, it is not a valid playlist\n            if previous_song[1] == genre:\n                valid_playlists[i] = 0\n\n            # If the previous song has a different genre than the current song, it is a valid playlist\n            else:\n                valid_playlists[i] = 1\n\n    # Return the number of valid playlists\n    return sum(valid_playlists.values())\n\nif __name__ == '__main__':\n    # Read the input from stdin\n    n, T = map(int, input().split())\n    songs = []\n    for _ in range(n):\n        duration, genre = map(int, input().split())\n        songs.append((duration, genre))\n\n    # Call the count_valid_playlists function and print the result\n    result = count_valid_playlists(n, T, songs)\n    print(result)"}
{"solution": "import math\n\ndef solve(m):\n    # Initialize variables\n    a = []\n    x = 0\n    gcd = 0\n    P = 0\n    Q = 0\n\n    # Perform the algorithm\n    while True:\n        # Select a random integer x uniformly in range from 1 to m\n        x = random.randint(1, m)\n\n        # Append x to the end of a\n        a.append(x)\n\n        # Compute the greatest common divisor of integers in a\n        gcd = math.gcd(a)\n\n        # If gcd equals to 1, break\n        if gcd == 1:\n            break\n\n    # Compute the expected length of a\n    expected_length = 0\n    for i in range(1, len(a)):\n        expected_length += (len(a) - i) / math.factorial(i)\n\n    # Compute P and Q\n    P = math.floor(expected_length)\n    Q = math.ceil(expected_length)\n\n    # Print the value of P * Q^-1 mod 10^9 + 7\n    print(P * pow(Q, -1, 1000000007))\n\n# Test the function\nsolve(1)\nsolve(2)\nsolve(4)"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b!= 0:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_good_pairs(l, r, x, y):\n    count = 0\n    for a in range(l, r + 1):\n        for b in range(a, r + 1):\n            if gcd(a, b) == x and lcm(a, b) == y:\n                count += 1\n    return count\n\nl, r, x, y = map(int, input().split())\nprint(count_good_pairs(l, r, x, y))"}
{"solution": "  import sys\n\ndef get_lcm(a, b):\n    if a == 0 or b == 0:\n        return 0\n    else:\n        lcm = 1\n        for i in range(1, max(a, b) + 1):\n            if i % a == 0 and i % b == 0:\n                lcm = i\n                break\n        return lcm\n\ndef get_smallest_k(a, b):\n    k = 0\n    lcm = get_lcm(a, b)\n    while True:\n        if get_lcm(a + k, b + k) == lcm:\n            break\n        k += 1\n    return k\n\nif __name__ == \"__main__\":\n    a, b = map(int, sys.stdin.readline().split())\n    print(get_smallest_k(a, b))"}
{"solution": "n, k = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Calculate the current average mark\ncurrent_average = sum(marks) / len(marks)\n\n# Calculate the number of marks needed to reach the desired average\nneeded_marks = k - current_average\n\n# Round up the number of marks needed to the nearest integer\nneeded_marks = int(needed_marks) + 1\n\n# Print the output\nprint(needed_marks)"}
{"solution": "import sys\n\nn = int(input())\narr = list(map(int, input().split()))\n\n# Initialize the number of positive numbers to 0\npositive_count = 0\n\n# Iterate through the array and count the number of positive numbers\nfor i in range(n):\n    if arr[i] > 0:\n        positive_count += 1\n\n# Find the value of d that satisfies the condition\nd = 0\nwhile positive_count < n / 2:\n    d += 1\n    for i in range(n):\n        arr[i] /= d\n        if arr[i] > 0:\n            positive_count += 1\n\n# Print the value of d\nprint(d)"}
{"solution": "import sys\n\nn = int(input())\n\n# Initialize a list to store the pairs of shovels\npairs = []\n\n# Iterate through the shovels\nfor i in range(n):\n    # Find the cost of the current shovel\n    cost = i + 1\n    \n    # Check if the cost ends with a 9\n    if cost % 10 == 9:\n        # Add the current shovel to the list of pairs\n        pairs.append(i)\n\n# Print the number of pairs of shovels\nprint(len(pairs))"}
{"solution": "import math\n\ndef solve(a1, b1, a2, b2):\n    # Calculate the total number of squares in both bars\n    total_squares_1 = a1 * b1\n    total_squares_2 = a2 * b2\n\n    # Calculate the difference between the total number of squares in both bars\n    diff = abs(total_squares_1 - total_squares_2)\n\n    # Initialize the minimum number of minutes required to make the bars have the same number of squares\n    m = 0\n\n    # Loop through all possible combinations of breaking the bars in half or in thirds\n    for i in range(1, math.ceil(diff / 2) + 1):\n        # Calculate the number of squares that can be removed from each bar in i minutes\n        squares_removed_1 = i * (a1 + b1)\n        squares_removed_2 = i * (a2 + b2)\n\n        # Calculate the new total number of squares in each bar after i minutes\n        new_total_squares_1 = total_squares_1 - squares_removed_1\n        new_total_squares_2 = total_squares_2 - squares_removed_2\n\n        # Check if the new total number of squares in each bar is equal\n        if new_total_squares_1 == new_total_squares_2:\n            # If the new total number of squares is equal, return the minimum number of minutes required to make the bars have the same number of squares\n            return m\n        else:\n            # If the new total number of squares is not equal, increment the minimum number of minutes required to make the bars have the same number of squares\n            m += 1\n\n    # If no solution is found, return -1\n    return -1\n\n# Test cases\nprint(solve(2, 6, 2, 3)) # Output: 1\nprint(solve(36, 5, 10, 16)) # Output: 3\nprint(solve(3, 5, 2, 1)) # Output: -1"}
{"solution": "import sys\n\ndef get_winner(x_p, y_p, x_v, y_v):\n    if x_p == 0 and y_p == 0:\n        return \"Polycarp\"\n    elif x_v == 0 and y_v == 0:\n        return \"Vasiliy\"\n    else:\n        return \"Vasiliy\" if x_p < x_v else \"Polycarp\"\n\nif __name__ == \"__main__\":\n    x_p, y_p, x_v, y_v = map(int, sys.stdin.readline().split())\n    print(get_winner(x_p, y_p, x_v, y_v))"}
{"solution": "import sys\n\ndef get_number_of_columns(month, weekday):\n    # Calculate the number of days in the month\n    days_in_month = 31\n    if month in [4, 6, 9, 11]:\n        days_in_month = 30\n    elif month == 2:\n        days_in_month = 28\n\n    # Calculate the number of weeks in the month\n    weeks_in_month = days_in_month // 7\n    if days_in_month % 7!= 0:\n        weeks_in_month += 1\n\n    # Calculate the number of columns needed\n    columns = weeks_in_month\n    if weekday!= 1:\n        columns += 1\n\n    return columns\n\nif __name__ == \"__main__\":\n    month, weekday = map(int, sys.stdin.readline().split())\n    print(get_number_of_columns(month, weekday))"}
{"solution": "import sys\n\ndef count_years(a, b):\n    count = 0\n    for year in range(a, b+1):\n        binary = bin(year)[2:]\n        if binary.count('0') == 1:\n            count += 1\n    return count\n\na, b = map(int, sys.stdin.readline().split())\nprint(count_years(a, b))"}
{"solution": "def minimal_layers(N):\n    return (N * (N + 1)) // 2\n\nN = int(input())\nprint(minimal_layers(N))"}
{"solution": "import itertools\n\ndef solve(n, k, S, a):\n    # Calculate the factorial of each number\n    factorials = [1] * (n + 1)\n    for i in range(2, n + 1):\n        factorials[i] = factorials[i - 1] * i\n\n    # Initialize the number of ways to choose cubes and stick exclamation marks\n    ways = 0\n\n    # Iterate over all possible combinations of cubes and stickers\n    for combination in itertools.combinations(range(n), k):\n        # Calculate the sum of the numbers on the chosen cubes\n        sum = 0\n        for i in combination:\n            sum += a[i]\n\n        # If the sum is equal to S, increment the number of ways\n        if sum == S:\n            ways += 1\n\n    return ways\n\n# Test the function with the given input\nn = 2\nk = 2\nS = 30\na = [4, 3]\nprint(solve(n, k, S, a))"}
{"solution": "import sys\n\ndef can_make_array(v, a, k):\n    # Initialize the array with zeroes\n    v = [0] * len(v)\n    # Loop through each element in a\n    for i, element in enumerate(a):\n        # If the element is not zero, add k^i to the corresponding position in v\n        if element!= 0:\n            v[i] += k**i\n    # Return True if v is equal to a, False otherwise\n    return v == a\n\n# Read the input from stdin\nfor line in sys.stdin:\n    # Split the line into tokens\n    tokens = line.split()\n    # Get the size of the arrays and the value of k\n    n, k = map(int, tokens[:2])\n    # Get the array a\n    a = list(map(int, tokens[2:]))\n    # Call the can_make_array function and print the result\n    print(\"YES\" if can_make_array(v, a, k) else \"NO\")"}
{"solution": "import sys\n\ndef calculate_sum(a, b, c):\n    sum = 0\n    for i in range(1, a+1):\n        for j in range(1, b+1):\n            for k in range(1, c+1):\n                sum += d(i*j*k)\n    return sum % (2**30)\n\ndef d(n):\n    count = 0\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            count += 2\n    if n**0.5 == int(n**0.5):\n        count -= 1\n    return count\n\na, b, c = map(int, input().split())\nprint(calculate_sum(a, b, c))"}
{"solution": "from collections import deque\n\ndef get_neighbors(state):\n    neighbors = []\n    idx = state.index('X')\n    if idx == 0:\n        neighbors.append(swap(state, 0, 1))\n        neighbors.append(swap(state, 0, 2))\n    elif idx == 1:\n        neighbors.append(swap(state, 1, 0))\n        neighbors.append(swap(state, 1, 3))\n    elif idx == 2:\n        neighbors.append(swap(state, 2, 0))\n        neighbors.append(swap(state, 2, 3))\n    elif idx == 3:\n        neighbors.append(swap(state, 3, 1))\n        neighbors.append(swap(state, 3, 2))\n    return neighbors\n\ndef swap(state, i, j):\n    state = list(state)\n    state[i], state[j] = state[j], state[i]\n    return ''.join(state)\n\ndef bfs(start):\n    queue = deque([start])\n    visited = set([start])\n    while queue:\n        current = queue.popleft()\n        for neighbor in get_neighbors(current):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    return visited\n\ndef can_be_same_configuration(bessie, elsie):\n    bessie_start = ''.join(bessie)\n    elsie_start = ''.join(elsie)\n    \n    bessie_reachable = bfs(bessie_start)\n    elsie_reachable = bfs(elsie_start)\n    \n    return not bessie_reachable.isdisjoint(elsie_reachable)\n\n# Input reading\nbessie = [input().strip() for _ in range(2)]\nelsie = [input().strip() for _ in range(2)]\n\nif can_be_same_configuration(bessie, elsie):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\nn = int(sys.stdin.readline().strip())\nk = int(sys.stdin.readline().strip())\n\n# Convert k to a list of digits in the base n system\nk_list = []\nwhile k > 0:\n    k_list.append(k % n)\n    k //= n\nk_list.reverse()\n\n# Find the minimum decimal number that converts to k in the base n system\nx = 0\nfor i in range(len(k_list)):\n    x += k_list[i] * n**i\n\nprint(x)"}
{"solution": "n = int(input())\narr = list(map(int, input().split()))\n\n# Check if the array is unimodal\nif len(arr) < 3:\n    print(\"NO\")\nelse:\n    # Check if the first block is strictly increasing\n    if arr[0] < arr[1]:\n        increasing = True\n        for i in range(1, len(arr) - 1):\n            if arr[i] < arr[i + 1]:\n                increasing = True\n            else:\n                increasing = False\n                break\n        if increasing:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n    # Check if the last block is strictly decreasing\n    else:\n        decreasing = True\n        for i in range(len(arr) - 2, 0, -1):\n            if arr[i] > arr[i + 1]:\n                decreasing = True\n            else:\n                decreasing = False\n                break\n        if decreasing:\n            print(\"YES\")\n        else:\n            print(\"NO\")"}
{"solution": "import sys\n\nn, k = map(int, sys.stdin.readline().split())\n\ndef f(x):\n    if x % 2 == 0:\n        return x // 2\n    else:\n        return x - 1\n\ndef path(x):\n    y = x\n    while y!= 1:\n        y = f(y)\n        yield y\n\npaths = [list(path(x)) for x in range(1, n + 1)]\n\nmax_value = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        if len(set(paths[i]).intersection(paths[j])) >= k:\n            max_value = max(max_value, max(paths[i]) + max(paths[j]))\n\nprint(max_value)"}
{"solution": "import sys\n\nn, m, x, y, vx, vy = map(int, sys.stdin.readline().split())\n\n# Check if the ball is initially in a pocket\nif x in range(n) and y in range(m):\n    print(x, y)\n    sys.exit()\n\n# Check if the ball will move indefinitely\nif vx == 0 and vy == 0:\n    print(-1)\n    sys.exit()\n\n# Check if the ball will fall into a pocket\npocket_x = [0, n, 0, n]\npocket_y = [0, 0, m, m]\n\nfor i in range(4):\n    if x == pocket_x[i] and y == pocket_y[i]:\n        print(x, y)\n        sys.exit()\n\n# Check if the ball will move along a side\nif vx == 0 or vy == 0:\n    print(-1)\n    sys.exit()\n\n# Check if the ball will move diagonally\nif vx!= 0 and vy!= 0:\n    print(-1)\n    sys.exit()\n\n# Check if the ball will move horizontally\nif vx!= 0:\n    if x + vx < 0 or x + vx > n:\n        print(-1)\n        sys.exit()\n    else:\n        print(x + vx, y)\n        sys.exit()\n\n# Check if the ball will move vertically\nif vy!= 0:\n    if y + vy < 0 or y + vy > m:\n        print(-1)\n        sys.exit()\n    else:\n        print(x, y + vy)\n        sys.exit()"}
{"solution": "def can_place_paintings(a1, b1, a2, b2, a3, b3):\n    # Check if two rectangles (a2, b2) and (a3, b3) can fit in (a1, b1)\n    def fits(w1, h1, w2, h2, W, H):\n        return (w1 + w2 <= W and max(h1, h2) <= H) or (h1 + h2 <= H and max(w1, w2) <= W)\n    \n    # Check all combinations of orientations\n    if (fits(a2, b2, a3, b3, a1, b1) or fits(b2, a2, a3, b3, a1, b1) or\n        fits(a2, b2, b3, a3, a1, b1) or fits(b2, a2, b3, a3, a1, b1) or\n        fits(a3, b3, a2, b2, a1, b1) or fits(b3, a3, a2, b2, a1, b1) or\n        fits(a3, b3, b2, a2, a1, b1) or fits(b3, a3, b2, a2, a1, b1)):\n        return \"YES\"\n    else:\n        return \"NO\""}
{"solution": "import sys\n\ndef solve(b_1, q, l, m, a):\n    # Initialize variables\n    count = 0\n    current = b_1\n    while abs(current) <= l:\n        # Check if current term is not a \"bad\" integer\n        if current not in a:\n            count += 1\n        # Update current term\n        current = current - q\n    # Return result\n    if count == 0:\n        return \"inf\"\n    else:\n        return count\n\n# Read input\nb_1, q, l, m = map(int, input().split())\na = set(map(int, input().split()))\n\n# Solve the problem\nresult = solve(b_1, q, l, m, a)\n\n# Print output\nprint(result)"}
{"solution": "import sys\n\ndef find_frame(n, m, pixels):\n    # Initialize the frame size to 1\n    frame_size = 1\n    # Initialize the frame position to (0, 0)\n    frame_position = (0, 0)\n    # Initialize the minimum frame size to infinity\n    min_frame_size = float('inf')\n    # Iterate over all possible frame positions\n    for i in range(n - frame_size + 1):\n        for j in range(m - frame_size + 1):\n            # Check if the frame is within the borders of the screen\n            if i + frame_size <= n and j + frame_size <= m:\n                # Check if all white pixels are located on the frame\n                if all(pixels[i + k][j + l] == 'w' for k in range(frame_size) for l in range(frame_size)):\n                    # Check if the frame size is smaller than the minimum frame size\n                    if frame_size < min_frame_size:\n                        # Update the minimum frame size and position\n                        min_frame_size = frame_size\n                        frame_position = (i, j)\n    # If the required frame doesn't exist, return -1\n    if min_frame_size == float('inf'):\n        return -1\n    # Otherwise, return the frame position and size\n    return (frame_position, min_frame_size)\n\n# Read the input\nn, m = map(int, input().split())\npixels = [input() for _ in range(n)]\n\n# Find the frame\nframe_position, frame_size = find_frame(n, m, pixels)\n\n# Print the output\nif frame_position == -1:\n    print(-1)\nelse:\n    for i in range(n):\n        for j in range(m):\n            if pixels[i][j] == 'w':\n                print('w', end='')\n            elif i >= frame_position[0] and i < frame_position[0] + frame_size and j >= frame_position[1] and j < frame_position[1] + frame_size:\n                print('+', end='')\n            else:\n                print('.', end='')\n        print()"}
{"solution": "import sys\n\nn, a, b = map(int, sys.stdin.readline().split())\n\n# Check if n is divisible by a or b\nif n % a == 0 or n % b == 0:\n    print(\"YES\")\n    print(n // a, n // b)\nelse:\n    print(\"NO\")"}
{"solution": "  def number_to_words(s):\n    ones = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n\n    if 0 <= s <= 9:\n        return ones[s]\n    elif 10 <= s <= 19:\n        return teens[s - 10]\n    elif 20 <= s <= 99:\n        if s % 10 == 0:\n            return tens[s // 10]\n        else:\n            return tens[s // 10] + \"-\" + ones[s % 10]\n\n# Example usage:\ns = int(input())\nprint(number_to_words(s))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Find the longest consecutive sequence of elements that can be erased\nmax_length = 0\ncurrent_length = 0\nfor i in range(n - 1):\n    if a[i] + 1 == a[i + 1]:\n        current_length += 1\n    else:\n        max_length = max(max_length, current_length)\n        current_length = 0\n\n# Print the maximum number of consecutive elements that can be erased\nprint(max_length)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Calculate the cumulative sum of problems solved each day\ncumulative_sum = [0]\nfor i in range(n):\n    cumulative_sum.append(cumulative_sum[i] + a[i])\n\n# Find the day when Polycarp will celebrate the equator\nfor i in range(n):\n    if cumulative_sum[i] >= (n + 1) / 2:\n        print(i + 1)\n        break\nelse:\n    print(-1)"}
{"solution": "import sys\n\ndef solve(N, A):\n    # Initialize the board with the given numbers\n    board = [[0] * N for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            board[i][j] = A[i][j]\n\n    # Initialize the number of steps and replacements\n    steps = 0\n    replacements = 0\n\n    # Initialize the current piece and its position\n    current_piece = \"knight\"\n    current_position = (0, 0)\n\n    # While we haven't reached the final square\n    while current_position!= (N - 1, N - 1):\n        # Get the possible moves for the current piece\n        moves = get_moves(current_piece, current_position, board)\n\n        # If there are no possible moves, we need to replace the piece\n        if not moves:\n            replacements += 1\n            current_piece = get_next_piece(current_piece)\n            continue\n\n        # Choose the move with the lowest number of steps\n        move = min(moves, key=lambda x: x[1])\n        current_position = move[0]\n        steps += move[1]\n\n    return steps, replacements\n\ndef get_moves(piece, position, board):\n    # Get the possible moves for the current piece\n    if piece == \"knight\":\n        moves = get_knight_moves(position, board)\n    elif piece == \"bishop\":\n        moves = get_bishop_moves(position, board)\n    elif piece == \"rook\":\n        moves = get_rook_moves(position, board)\n    else:\n        raise ValueError(\"Invalid piece\")\n\n    return moves\n\ndef get_knight_moves(position, board):\n    # Get the possible knight moves from the current position\n    moves = []\n    for i in range(-2, 3):\n        for j in range(-2, 3):\n            if abs(i) + abs(j) == 3 and 0 <= position[0] + i < len(board) and 0 <= position[1] + j < len(board[0]):\n                moves.append(((position[0] + i, position[1] + j), 1))\n    return moves\n\ndef get_bishop_moves(position, board):\n    # Get the possible bishop moves from the current position\n    moves = []\n    for i in range(-1, 2):\n        for j in range(-1, 2):\n            if i!= 0 and j!= 0 and 0 <= position[0] + i < len(board) and 0 <= position[1] + j < len(board[0]):\n                moves.append(((position[0] + i, position[1] + j), 1))\n    return moves\n\ndef get_rook_moves(position, board):\n    # Get the possible rook moves from the current position\n    moves = []\n    for i in range(-1, 2):\n        for j in range(-1, 2):\n            if i!= 0 or j!= 0 and 0 <= position[0] + i < len(board) and 0 <= position[1] + j < len(board[0]):\n                moves.append(((position[0] + i, position[1] + j), 1))\n    return moves\n\ndef get_next_piece(piece):\n    # Get the next piece in the sequence\n    if piece == \"knight\":\n        return \"bishop\"\n    elif piece == \"bishop\":\n        return \"rook\"\n    elif piece == \"rook\":\n        return \"knight\"\n    else:\n        raise ValueError(\"Invalid piece\")\n\nif __name__ == \"__main__\":\n    N = int(input())\n    A = []\n    for i in range(N):\n        A.append(list(map(int, input().split())))\n    steps, replacements = solve(N, A)\n    print(steps, replacements)"}
{"solution": ""}
{"solution": "import sys\n\ndef is_divisible_by_64(binary_string):\n    # Check if the string is empty\n    if not binary_string:\n        return \"no\"\n\n    # Check if the string is divisible by 64\n    if len(binary_string) % 64 == 0:\n        return \"yes\"\n\n    # Check if the string can be manipulated to be divisible by 64\n    for i in range(len(binary_string)):\n        if binary_string[i] == \"1\":\n            # Remove the digit and check if the remaining string is divisible by 64\n            remaining_string = binary_string[:i] + binary_string[i+1:]\n            if is_divisible_by_64(remaining_string):\n                return \"yes\"\n\n    # If the string cannot be manipulated to be divisible by 64, return \"no\"\n    return \"no\"\n\nif __name__ == \"__main__\":\n    binary_string = sys.stdin.readline().strip()\n    print(is_divisible_by_64(binary_string))"}
{"solution": "def get_subsequence(s):\n    # Initialize a list to store the characters of the string\n    chars = list(s)\n    # Initialize a set to store the characters of the alphabet\n    alphabet = set(\"abcdefghijklmnopqrstuvwxyz\")\n    # Initialize a list to store the characters of the subsequence\n    subsequence = []\n\n    # Iterate through the characters of the string\n    for char in chars:\n        # If the character is not 'z', replace it with the next character in the alphabet\n        if char!= \"z\":\n            char = chr(ord(char) + 1)\n        # If the character is 'z', replace it with 'a'\n        else:\n            char = \"a\"\n        # Add the character to the subsequence\n        subsequence.append(char)\n\n    # Check if the subsequence contains all the characters of the alphabet\n    if set(subsequence).issuperset(alphabet):\n        return \"\".join(subsequence)\n    else:\n        return \"-1\"\n\ns = \"aacceeggiikkmmooqqssuuwwyy\"\nprint(get_subsequence(s))"}
{"solution": "import math\n\ndef solve(n, m, r, k):\n    # Calculate the total number of cells in the pond\n    total_cells = n * m\n    \n    # Calculate the number of possible positions for the scoop-net\n    possible_positions = (n - r + 1) * (m - r + 1)\n    \n    # Calculate the expected value for each position\n    expected_values = []\n    for i in range(possible_positions):\n        # Calculate the number of fishes in each cell for this position\n        fishes_in_cells = [0] * total_cells\n        for j in range(k):\n            # Calculate the cell index for this fish\n            cell_index = (i // possible_positions) * total_cells + j\n            fishes_in_cells[cell_index] += 1\n        \n        # Calculate the expected value for this position\n        expected_value = 0\n        for fishes in fishes_in_cells:\n            expected_value += fishes / total_cells\n        \n        expected_values.append(expected_value)\n    \n    # Return the maximum expected value\n    return max(expected_values)\n\nn = 3\nm = 3\nr = 2\nk = 3\nprint(solve(n, m, r, k))"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize the maximum product to 0\nmax_product = 0\n\n# Iterate through all possible indices\nfor i in range(n):\n    # Calculate the product of the array elements after applying the operation to the current index\n    product = 1\n    for j in range(n):\n        if j == i:\n            product *= -a[j] - 1\n        else:\n            product *= a[j]\n    \n    # If the current product is greater than the maximum product, update the maximum product and the corresponding array elements\n    if product > max_product:\n        max_product = product\n        max_array = a.copy()\n        max_array[i] = -a[i] - 1\n\n# Print the array with the maximum product of elements\nprint(*max_array)"}
{"solution": "n, k = map(int, input().split())\n\n# Find the divisors of n\ndivisors = []\nfor i in range(1, int(n**0.5) + 1):\n    if n % i == 0:\n        divisors.append(i)\n        if n // i!= i:\n            divisors.append(n // i)\n\n# Sort the divisors in ascending order\ndivisors.sort()\n\n# Check if k is within the range of the divisors\nif k > len(divisors):\n    print(-1)\nelse:\n    print(divisors[k - 1])"}
{"solution": "n = int(input())\ncubes = []\nfor i in range(n):\n    cube = []\n    for j in range(6):\n        cube.append(int(input()))\n    cubes.append(cube)\n\n# Initialize the maximum number x to 0\nx = 0\n\n# Iterate through all possible combinations of digits on the cubes\nfor i in range(10):\n    for j in range(10):\n        for k in range(10):\n            for l in range(10):\n                for m in range(10):\n                    for n in range(10):\n                        # Check if the current combination forms a consecutive number\n                        if i + j + k + l + m + n == x:\n                            # If it does, check if the current combination is the largest\n                            if x < i * 100000 + j * 10000 + k * 1000 + l * 100 + m * 10 + n:\n                                x = i * 100000 + j * 10000 + k * 1000 + l * 100 + m * 10 + n\n\n# Print the maximum number x\nprint(x)"}
{"solution": "import math\n\ndef k_rounding(n, k):\n    if n == 0:\n        return 0\n    if k == 0:\n        return n\n    x = int(math.log10(n))\n    y = int(math.log10(n))\n    while x % k!= 0:\n        x += 1\n    while y % k!= 0:\n        y -= 1\n    return x * 10 ** k\n\nn, k = map(int, input().split())\nprint(k_rounding(n, k))"}
{"solution": "def transform_matrix(n, m, A):\n    operations = []\n    B = [[0] * m for _ in range(n)]\n    \n    for i in range(n - 1):\n        for j in range(m - 1):\n            if A[i][j] == 1 and A[i][j + 1] == 1 and A[i + 1][j] == 1 and A[i + 1][j + 1] == 1:\n                operations.append((i + 1, j + 1))\n                B[i][j] = B[i][j + 1] = B[i + 1][j] = B[i + 1][j + 1] = 1\n    \n    for i in range(n):\n        for j in range(m):\n            if A[i][j]!= B[i][j]:\n                return -1\n    \n    return operations"}
{"solution": "import math\n\ndef get_probabilities(r, s, p):\n    # Calculate the total number of individuals\n    total = r + s + p\n\n    # Calculate the probability of each species being the sole survivor\n    prob_r = r / total\n    prob_s = s / total\n    prob_p = p / total\n\n    # Calculate the probability of each species being killed by another species\n    prob_r_killed = (s + p) / total\n    prob_s_killed = (r + p) / total\n    prob_p_killed = (r + s) / total\n\n    # Calculate the probability of each species being the only survivor\n    prob_r_alone = prob_r * (1 - prob_r_killed)\n    prob_s_alone = prob_s * (1 - prob_s_killed)\n    prob_p_alone = prob_p * (1 - prob_p_killed)\n\n    return prob_r_alone, prob_s_alone, prob_p_alone\n\n\nif __name__ == \"__main__\":\n    r, s, p = map(int, input().split())\n    prob_r, prob_s, prob_p = get_probabilities(r, s, p)\n    print(f\"{prob_r:.9f} {prob_s:.9f} {prob_p:.9f}\")"}
{"solution": "import sys\n\ndef get_overlapping_minutes(l1, r1, l2, r2, k):\n    # Calculate the number of minutes they will be able to spend together\n    minutes_together = 0\n\n    # Check if Sonya is available during Filya's visit\n    if l2 <= k <= r2:\n        # If Sonya is available, calculate the number of minutes they can spend together\n        minutes_together = r2 - l2 + 1\n    elif l1 <= k <= r1:\n        # If Sonya is not available, calculate the number of minutes they can spend together\n        minutes_together = r1 - l1 + 1\n    else:\n        # If Sonya is not available and Filya's visit does not overlap with her sleeping time, they can spend the entire visit together\n        minutes_together = r2 - l2 + 1\n\n    return minutes_together\n\nif __name__ == \"__main__\":\n    l1, r1, l2, r2, k = map(int, sys.stdin.readline().split())\n    print(get_overlapping_minutes(l1, r1, l2, r2, k))"}
{"solution": "import sys\n\ndef get_area(N, M, A, B, C, D, E, F):\n    # Initialize the area as 0\n    area = 0\n\n    # Iterate over each north-south line\n    for i in range(N):\n        # Calculate the length of the line\n        length = abs(A[i] - B[i])\n\n        # Add the length to the area\n        area += length\n\n    # Iterate over each east-west line\n    for j in range(M):\n        # Calculate the length of the line\n        length = abs(D[j] - E[j])\n\n        # Add the length to the area\n        area += length\n\n    # Return the area\n    return area\n\n# Read the input from stdin\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nC = list(map(int, input().split()))\nD = list(map(int, input().split()))\nE = list(map(int, input().split()))\nF = list(map(int, input().split()))\n\n# Calculate the area\narea = get_area(N, M, A, B, C, D, E, F)\n\n# Print the output\nprint(area)"}
{"solution": "import sys\n\nt, s, x = map(int, sys.stdin.readline().split())\n\nif (x - t) % (s + 1) == 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\nn = int(input())\nsegments = []\n\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r))\n\nfor i in range(n):\n    for j in range(i+1, n):\n        if segments[i][0] >= segments[j][0] and segments[i][1] <= segments[j][1]:\n            print(i, j)\n            sys.exit()\n\nprint(-1, -1)"}
{"solution": "import re\n\ndef decode_genome(genome):\n    # Initialize the number of each nucleotide type\n    a_count = 0\n    c_count = 0\n    g_count = 0\n    t_count = 0\n\n    # Iterate through the genome and count the number of each nucleotide type\n    for nucleotide in genome:\n        if nucleotide == 'A':\n            a_count += 1\n        elif nucleotide == 'C':\n            c_count += 1\n        elif nucleotide == 'G':\n            g_count += 1\n        elif nucleotide == 'T':\n            t_count += 1\n\n    # Check if the number of each nucleotide type is equal\n    if a_count == c_count and c_count == g_count and g_count == t_count:\n        return genome\n\n    # If the number of each nucleotide type is not equal, try to replace the unrecognized nucleotides\n    for i in range(len(genome)):\n        if genome[i] == '?':\n            # Try to replace the unrecognized nucleotide with each of the four types\n            for nucleotide in ['A', 'C', 'G', 'T']:\n                new_genome = genome[:i] + nucleotide + genome[i+1:]\n                if decode_genome(new_genome) is not None:\n                    return new_genome\n\n    # If it is not possible to decode the genome, return three equals signs\n    return \"===\"\n\n\n# Test the function with the given examples\nprint(decode_genome(\"AG?C??CT\"))\nprint(decode_genome(\"AGCT\"))\nprint(decode_genome(\"????G?\"))\nprint(decode_genome(\"AA??\"))"}
{"solution": "def check_winning_move(board):\n    # Check for horizontal and vertical winning moves\n    for row in range(4):\n        for col in range(4):\n            if board[row][col] == 'x' and board[row][col+1] == 'x' and board[row][col+2] == 'x':\n                return True\n            if board[col][row] == 'x' and board[col+1][row] == 'x' and board[col+2][row] == 'x':\n                return True\n    \n    # Check for diagonal winning moves\n    for row in range(4):\n        for col in range(4):\n            if board[row][col] == 'x' and board[row+1][col+1] == 'x' and board[row+2][col+2] == 'x':\n                return True\n            if board[row][col] == 'x' and board[row+1][col-1] == 'x' and board[row+2][col-2] == 'x':\n                return True\n    \n    return False\n\ndef main():\n    board = [\n        ['.', '.', '.', '.'],\n        ['.', '.', '.', '.'],\n        ['.', '.', '.', '.'],\n        ['.', '.', '.', '.']\n    ]\n    \n    # Read the board configuration\n    for row in range(4):\n        for col in range(4):\n            board[row][col] = input()\n    \n    # Check for winning moves\n    if check_winning_move(board):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Check if the sum of the first half of the array is equal to the sum of the second half\nif sum(a[:n//2]) == sum(a[n//2:]):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Check if the number of lost elements in a is equal to the length of b\nif k!= len(b):\n    print(\"No\")\n    sys.exit()\n\n# Check if the elements in b are unique\nif len(set(b))!= len(b):\n    print(\"No\")\n    sys.exit()\n\n# Check if the elements in a are unique\nif len(set(a))!= len(a):\n    print(\"No\")\n    sys.exit()\n\n# Check if the elements in a are all non-zero\nif 0 in a:\n    print(\"No\")\n    sys.exit()\n\n# Check if the elements in b are all non-zero\nif 0 in b:\n    print(\"No\")\n    sys.exit()\n\n# Check if the elements in a can be replaced with elements in b\ncan_replace = True\nfor i in range(n):\n    if a[i]!= 0 and b[i] == 0:\n        can_replace = False\n        break\n\nif not can_replace:\n    print(\"No\")\n    sys.exit()\n\n# Check if the resulting sequence is not increasing\nis_increasing = False\nfor i in range(n - 1):\n    if a[i] > a[i + 1]:\n        is_increasing = True\n        break\n\nif is_increasing:\n    print(\"No\")\n    sys.exit()\n\n# If all the checks pass, the answer is \"Yes\"\nprint(\"Yes\")"}
{"solution": "x, y, z = map(int, input().split())\na, b, c = map(int, input().split())\n\nif a >= x and b >= y and c >= z:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def is_accident_possible(lights):\n    # Initialize variables to keep track of the number of green lights\n    num_green_lights = 0\n    num_green_pedestrian_lights = 0\n\n    # Iterate through the lights and count the number of green lights\n    for light in lights:\n        if light == 1:\n            num_green_lights += 1\n        elif light == 0:\n            num_green_pedestrian_lights += 1\n\n    # If there are more than one green light, an accident is possible\n    if num_green_lights > 1:\n        return \"YES\"\n    # If there are no green lights, an accident is not possible\n    elif num_green_lights == 0:\n        return \"NO\"\n    # If there is only one green light, check if it is a pedestrian light\n    else:\n        if num_green_pedestrian_lights == 1:\n            return \"NO\"\n        else:\n            return \"YES\"\n\n# Test the function with different inputs\nprint(is_accident_possible([1, 0, 0, 1]))  # YES\nprint(is_accident_possible([0, 1, 1, 0]))  # NO\nprint(is_accident_possible([1, 0, 0, 0]))  # NO\nprint(is_accident_possible([0, 0, 0, 1]))  # YES"}
{"solution": "def is_unique_finger_movement(n, number):\n    original_vectors = get_vectors(number)\n    for i in range(10**(n-1), 10**n):\n        candidate = str(i).zfill(n)\n        if candidate!= number:\n            if get_vectors(candidate) == original_vectors:\n                return \"NO\"\n    return \"YES\""}
{"solution": "import sys\n\nn, f = map(int, input().split())\nk = [0] * n\nl = [0] * n\n\nfor i in range(n):\n    k[i], l[i] = map(int, input().split())\n\n# Calculate the number of products that can be sold on each day\nproducts_sold = [0] * n\nfor i in range(n):\n    products_sold[i] = k[i] * l[i]\n\n# Choose the f days with the highest number of products sold\nchosen_days = sorted(range(n), key=lambda i: products_sold[i], reverse=True)[:f]\n\n# Calculate the total number of products that can be sold\ntotal_products_sold = sum(products_sold[i] for i in chosen_days)\n\nprint(total_products_sold)"}
{"solution": "import sys\n\nn, k = map(int, input().split())\n\n# Initialize the array of cows\ncows = [i for i in range(1, n+1)]\n\n# Initialize the maximum messiness\nmax_messiness = 0\n\n# Loop through each minute\nfor i in range(k):\n    # Choose two distinct stalls\n    stall1, stall2 = random.sample(range(n), 2)\n\n    # Swap the cows in the stalls\n    cows[stall1], cows[stall2] = cows[stall2], cows[stall1]\n\n    # Calculate the messiness\n    messiness = 0\n    for j in range(n-1):\n        if cows[j] > cows[j+1]:\n            messiness += 1\n\n    # Update the maximum messiness\n    if messiness > max_messiness:\n        max_messiness = messiness\n\n# Print the maximum messiness\nprint(max_messiness)"}
{"solution": "import sys\n\ndef get_min_coins(N, M, K, L):\n    # Initialize variables\n    min_coins = 0\n    new_coins = 0\n\n    # Iterate through each friend\n    for i in range(M):\n        # Calculate the number of new coins\n        new_coins = N - K\n\n        # Check if the number of new coins is greater than or equal to L\n        if new_coins >= L:\n            # Increment the minimum number of coins\n            min_coins += 1\n        else:\n            # Return -1 if it is not possible to meet all the conditions\n            return -1\n\n    # Return the minimum number of coins\n    return min_coins\n\n# Get input from stdin\nN, M, K, L = map(int, input().split())\n\n# Get the minimum number of coins\nmin_coins = get_min_coins(N, M, K, L)\n\n# Print the output\nprint(min_coins)"}
{"solution": "n, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\n\n# Find the bounds of the black cells\nmin_row, max_row = n, -1\nmin_col, max_col = m, -1\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 'B':\n            min_row = min(min_row, i)\n            max_row = max(max_row, i)\n            min_col = min(min_col, j)\n            max_col = max(max_col, j)\n\n# If no black cells are found\nif min_row == n:\n    print(1)\n    exit()\n\n# Calculate the side length of the square\nside_length = max(max_row - min_row + 1, max_col - min_col + 1)\n\n# Check if the square can fit within the grid\nif side_length > n or side_length > m:\n    print(-1)\n    exit()\n\n# Count the number of white cells within the square\nmin_paint = float('inf')\nfor i in range(n - side_length + 1):\n    for j in range(m - side_length + 1):\n        paint_count = 0\n        for x in range(i, i + side_length):\n            for y in range(j, j + side_length):\n                if grid[x][y] == 'W':\n                    paint_count += 1\n        min_paint = min(min_paint, paint_count)\n\nprint(min_paint)"}
{"solution": "import sys\n\nn = int(input())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\nif len(x)!= len(y):\n    print(\"No\")\n    sys.exit()\n\nfor i in range(len(x)):\n    if x[i]!= y[i]:\n        print(\"No\")\n        sys.exit()\n\nprint(\"Yes\")"}
{"solution": "import sys\n\nn = int(input())\nangles = [int(x) for x in input().split()]\n\n# Calculate the sum of angles\nsum_angles = sum(angles)\n\n# Calculate the difference between the sum of angles and 360\ndiff = abs(sum_angles - 360)\n\n# Print the minimal difference between angles of sectors\nprint(diff)"}
{"solution": "import sys\n\nn, m = map(int, input().split())\n\ndef count_ways(n, m):\n    # Initialize a 2D array to store the results\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    # Base case: when there are no presents or boxes\n    for i in range(n + 1):\n        dp[i][0] = 1\n    for j in range(m + 1):\n        dp[0][j] = 1\n\n    # Fill in the table\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % (10**9 + 7)\n\n    return dp[n][m]\n\nprint(count_ways(n, m))"}
{"solution": "import math\n\ndef find_pythagorean_triple(n):\n    for m in range(1, 10**18):\n        for k in range(1, 10**18):\n            if m**2 + k**2 == n**2:\n                return m, k\n    return -1\n\nn = int(input())\nprint(find_pythagorean_triple(n))"}
{"solution": "import sys\n\nn, k = map(int, input().split())\n\nremainders = set()\nfor i in range(1, k+1):\n    remainders.add(n % i)\n\nif len(remainders) == k:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "a = input()\nb = input()\n\nif a < b:\n    print(\"<\")\nelif a > b:\n    print(\">\")\nelse:\n    print(\"=\")"}
{"solution": "import sys\n\nn, p = map(int, input().split())\ncolors = list(map(int, input().split()))\n\n# Initialize the number of valid paths to 0\nvalid_paths = 0\n\n# Iterate over all possible combinations of colors\nfor i in range(2**n):\n    # Convert the binary representation of i to a list of colors\n    color_list = [colors[j] for j in range(n) if i & (1 << j)]\n\n    # Check if the color list has the desired parity\n    if len(color_list) % 2 == p:\n        # Increment the number of valid paths\n        valid_paths += 1\n\n# Print the number of valid paths modulo 10^9 + 7\nprint(valid_paths % (10**9 + 7))"}
{"solution": "import sys\n\nn, a, b, c = map(int, sys.stdin.readline().split())\n\n# Calculate the minimum number of additional copybooks needed\nk = 4 - (n % 4)\n\n# Calculate the cost of the additional copybooks\ncost = k * min(a, b, c)\n\n# Print the minimum amount of rubles Alyona should pay\nprint(cost)"}
{"solution": "import sys\n\nn, m = map(int, input().split())\nedges = []\n\nfor i in range(m):\n    u, v = map(int, input().split())\n    edges.append((u, v))\n\n# Check if the graph is acyclic\nacyclic = True\nfor edge in edges:\n    if edge[0] == edge[1]:\n        acyclic = False\n        break\n\n# Check if the graph can be made acyclic by removing at most one edge\nif acyclic:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\ndef solve(n, m, x, s):\n    # Initialize variables\n    coins_spent = 0\n    antennas = []\n\n    # Loop through each antenna\n    for i in range(n):\n        # Check if the antenna covers the required positions\n        if x[i] - s[i] <= m and x[i] + s[i] >= m:\n            # If it does, add it to the list of antennas\n            antennas.append(i)\n        else:\n            # If it doesn't, calculate the cost of increasing its scope\n            cost = abs(m - x[i])\n\n            # Check if the cost is less than the current minimum cost\n            if cost < coins_spent:\n                # If it is, update the minimum cost and add the antenna to the list of antennas\n                coins_spent = cost\n                antennas.append(i)\n\n    # Return the minimum cost required to make all positions from 1 to m inclusive covered by at least one antenna\n    return coins_spent\n\n# Read input from stdin\nn, m = map(int, input().split())\nx = list(map(int, input().split()))\ns = list(map(int, input().split()))\n\n# Solve the problem\nresult = solve(n, m, x, s)\n\n# Output the result to stdout\nprint(result)"}
{"solution": "import sys\n\ndef get_max_weight(W, cnt):\n    # Initialize variables\n    max_weight = 0\n    current_weight = 0\n    current_subset = []\n\n    # Sort the counts in descending order\n    sorted_cnt = sorted(cnt, reverse=True)\n\n    # Iterate through the counts\n    for i in range(len(sorted_cnt)):\n        # If the current weight plus the current count is less than or equal to W,\n        # add the count to the current subset and update the current weight\n        if current_weight + sorted_cnt[i] <= W:\n            current_subset.append(sorted_cnt[i])\n            current_weight += sorted_cnt[i]\n        # If the current weight plus the current count is greater than W,\n        # update the maximum weight and break the loop\n        else:\n            max_weight = current_weight\n            break\n\n    # Return the maximum weight\n    return max_weight\n\n# Read input from stdin\nW = int(input())\ncnt = list(map(int, input().split()))\n\n# Get the maximum weight\nmax_weight = get_max_weight(W, cnt)\n\n# Print the output\nprint(max_weight)"}
{"solution": "import sys\n\nn, L = map(int, input().split())\ncosts = list(map(int, input().split()))\n\n# Sort the costs in descending order\ncosts.sort(reverse=True)\n\n# Initialize the total cost and the number of bottles bought\ntotal_cost = 0\nnum_bottles = 0\n\n# Loop through the costs and buy bottles until the required amount of lemonade is reached\nfor i in range(n):\n    # Calculate the number of bottles that can be bought with the current cost\n    num_bottles_i = L // (costs[i] - 1)\n    \n    # Update the total cost and the number of bottles bought\n    total_cost += num_bottles_i * costs[i]\n    num_bottles += num_bottles_i\n    \n    # Update the required amount of lemonade\n    L -= num_bottles_i * (costs[i] - 1)\n    \n    # If the required amount of lemonade is reached, break the loop\n    if L == 0:\n        break\n\n# Print the total cost\nprint(total_cost)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nmex = 1\nfor i in range(n):\n    if a[i] >= mex:\n        mex += 1\n\nprint(mex)"}
{"solution": "def is_lucky_ticket(n, digits):\n    total_sum = sum(int(digit) for digit in digits)\n    \n    # Try every possible segment sum from 1 to total_sum\n    for segment_sum in range(1, total_sum + 1):\n        if total_sum % segment_sum == 0:\n            current_sum = 0\n            valid_partition = True\n            for digit in digits:\n                current_sum += int(digit)\n                if current_sum > segment_sum:\n                    valid_partition = False\n                    break\n                elif current_sum == segment_sum:\n                    current_sum = 0\n            if valid_partition and current_sum == 0:\n                return \"YES\"\n    \n    return \"NO\"\n\n# Example usage:\nn = int(input())\ndigits = input().strip()\nprint(is_lucky_ticket(n, digits))"}
{"solution": "def determine_gender(username):\n    distinct_characters = set(username)\n    if len(distinct_characters) % 2 == 0:\n        return \"CHAT WITH HER!\"\n    else:\n        return \"IGNORE HIM!\""}
{"solution": "import sys\n\nn, k = map(int, input().split())\ntabs = list(map(int, input().split()))\n\n# Initialize the variables\ne = 0\ns = 0\n\n# Iterate through the tabs and count the number of test and social network tabs\nfor i in range(n):\n    if tabs[i] == 1:\n        e += 1\n    else:\n        s += 1\n\n# Calculate the absolute difference between the amounts of remaining tabs of different types\ndiff = abs(e - s)\n\n# Print the maximum absolute difference\nprint(diff)"}
{"solution": "import sys\n\nn, c0, c1 = map(int, input().split())\n\n# Initialize the cost array with the given costs\ncosts = [c0, c1]\n\n# Initialize the optimal encoding with the first letter\noptimal_encoding = [0]\n\n# Iterate over the remaining letters\nfor i in range(1, n):\n    # Find the letter with the minimum cost\n    min_cost = sys.maxsize\n    min_index = -1\n    for j in range(len(costs)):\n        if costs[j] < min_cost:\n            min_cost = costs[j]\n            min_index = j\n    \n    # Add the letter to the optimal encoding\n    optimal_encoding.append(min_index)\n    \n    # Update the costs\n    costs[min_index] += 1\n\n# Calculate the total cost\ntotal_cost = sum(costs)\n\n# Print the optimal encoding and total cost\nprint(optimal_encoding)\nprint(total_cost)"}
{"solution": "def will_meet(n, a, x, b, y):\n    while a!= x and b!= y:\n        if a == b:\n            return \"YES\"\n        a = a + 1 if a < n else 1\n        b = b - 1 if b > 1 else n\n    return \"YES\" if a == b else \"NO\""}
{"solution": "import math\n\ndef is_unlucky(n, x, y):\n    a = int(math.log(n, x))\n    b = int(math.log(n, y))\n    return a + b == n\n\ndef find_golden_age(x, y, l, r):\n    unlucky_years = set()\n    for i in range(l, r+1):\n        if is_unlucky(i, x, y):\n            unlucky_years.add(i)\n\n    golden_age_length = 0\n    for i in range(l, r+1):\n        if i not in unlucky_years:\n            golden_age_length = max(golden_age_length, i - l + 1)\n\n    return golden_age_length\n\nx, y, l, r = map(int, input().split())\nprint(find_golden_age(x, y, l, r))"}
{"solution": "n = int(input())\n\n# Calculate the maximum divisor of n\nmax_divisor = 1\nwhile n % max_divisor == 0:\n    max_divisor += 1\n\n# Calculate the minimum number of burles that Mr. Funt has to pay\nmin_burles = max_divisor - 1\n\nprint(min_burles)"}
{"solution": "def fix_typos(word):\n    vowels = set('aeiou')\n    n = len(word)\n    result = []\n    i = 0\n    \n    while i < n:\n        result.append(word[i])\n        if word[i] not in vowels:\n            start = i\n            while i < n and word[i] not in vowels:\n                i += 1\n            if i - start >= 3:\n                block = word[start:i]\n                if len(set(block)) > 1:\n                    result.append(' ')\n        i += 1\n    \n    return ''.join(result)"}
{"solution": "import sys\n\nn, m, k = map(int, input().split())\nx, s = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\nd = list(map(int, input().split()))\n\n# Use the second spell of the first type to speed up the preparation time\nif m > 0 and b[0] <= s:\n    x = a[0]\n    s -= b[0]\n\n# Use the second spell of the second type to prepare potions instantly\nif k > 0 and d[0] <= s:\n    n -= c[0]\n    s -= d[0]\n\n# Prepare the remaining potions\ntime = x * n\n\nprint(time)"}
{"solution": "n, k, M = map(int, input().split())\nt = list(map(int, input().split()))\n\n# Initialize the maximum number of points to 0\nmax_points = 0\n\n# Iterate over all possible combinations of tasks\nfor i in range(1, n+1):\n    for j in range(1, k+1):\n        # Calculate the time required to solve the subtask\n        time_required = t[j-1]\n        \n        # Check if the time required is less than or equal to the available time\n        if time_required <= M:\n            # Add the points earned for the subtask\n            max_points += 1\n            \n            # Subtract the time required from the available time\n            M -= time_required\n            \n            # Check if the maximum number of points has been reached\n            if max_points == n*k:\n                break\n                \n        # If the time required is greater than the available time, break the loop\n        else:\n            break\n            \n# Print the maximum number of points\nprint(max_points)"}
{"solution": "import sys\n\nn = int(sys.stdin.readline().strip())\n\n# Initialize the number of perfectly balanced striped binary search trees to 0\nnum_trees = 0\n\n# Iterate over all possible keys for the root node\nfor root_key in range(1, n + 1):\n    # Check if the root node is even or odd\n    if root_key % 2 == 0:\n        # If the root node is even, the left subtree must have an odd key\n        left_key = root_key - 1\n    else:\n        # If the root node is odd, the left subtree must have an even key\n        left_key = root_key + 1\n\n    # Check if the left subtree is a perfectly balanced striped binary search tree\n    if is_perfectly_balanced_striped_bst(left_key, n):\n        # If the left subtree is a perfectly balanced striped binary search tree,\n        # check if the right subtree is a perfectly balanced striped binary search tree\n        right_key = root_key + 2\n        if is_perfectly_balanced_striped_bst(right_key, n):\n            # If both subtrees are perfectly balanced striped binary search trees,\n            # increment the number of perfectly balanced striped binary search trees\n            num_trees += 1\n\n# Print the number of perfectly balanced striped binary search trees modulo 998244353\nprint(num_trees % 998244353)\n\ndef is_perfectly_balanced_striped_bst(key, n):\n    # Check if the key is within the range of the tree\n    if key < 1 or key > n:\n        return False\n\n    # Check if the key is even or odd\n    if key % 2 == 0:\n        # If the key is even, the left subtree must have an odd key\n        left_key = key - 1\n    else:\n        # If the key is odd, the left subtree must have an even key\n        left_key = key + 1\n\n    # Check if the left subtree is a perfectly balanced striped binary search tree\n    if not is_perfectly_balanced_striped_bst(left_key, n):\n        return False\n\n    # Check if the right subtree is a perfectly balanced striped binary search tree\n    right_key = key + 2\n    if not is_perfectly_balanced_striped_bst(right_key, n):\n        return False\n\n    # If both subtrees are perfectly balanced striped binary search trees,\n    # return True\n    return True"}
{"solution": "import sys\n\nn, m, k = map(int, sys.stdin.readline().split())\n\n# Calculate the current position of Lara\ncurrent_row = 1\ncurrent_col = 1\n\n# Move down to the bottom left corner\nfor i in range(n - 1):\n    current_row += 1\n\n# Move to the right, one cell up, then to the left to the cell in 2-nd column, one cell up\nfor i in range(m - 2):\n    current_col += 1\n    current_row -= 1\n\n# Move until she runs out of non-visited cells\nwhile current_row > 1 and current_col > 1:\n    current_row -= 1\n    current_col -= 1\n\n# Print the current position of Lara\nprint(current_row, current_col)"}
{"solution": "import math\n\ndef find_min_max(X):\n    # Initialize variables\n    a = 1\n    b = 1\n    min_max = math.inf\n    \n    # Iterate through all possible pairs of factors of X\n    for i in range(1, int(math.sqrt(X)) + 1):\n        if X % i == 0:\n            j = X // i\n            # Calculate the LCM of the current pair\n            lcm = i * j\n            # If the LCM is equal to X and the current pair has a smaller max(a, b) than the previous pairs, update the variables\n            if lcm == X and (a * b) > (i * j):\n                a = i\n                b = j\n                min_max = math.inf\n    \n    # Return the minimum possible value of max(a, b) and the corresponding pair (a, b)\n    return min_max, (a, b)\n\n# Test the function with the given input\nX = 2\nmin_max, pair = find_min_max(X)\nprint(pair)"}
{"solution": "a = int(input())\nb = int(input())\nc = int(input())\n\n# Calculate the maximum number of complete sets for each fruit type\nmax_sets_lemons = a // 1\nmax_sets_apples = b // 2\nmax_sets_pears = c // 4\n\n# Find the limiting factor (minimum number of complete sets)\nmax_complete_sets = min(max_sets_lemons, max_sets_apples, max_sets_pears)\n\n# Calculate the total number of fruits used in the compote\ntotal_fruits = max_complete_sets * (1 + 2 + 4)\n\nprint(total_fruits)"}
{"solution": "def can_divide_teams(n, ratings):\n    ratings.sort()\n    for i in range(n):\n        if ratings[i] >= ratings[i + n]:\n            return \"NO\"\n    return \"YES\""}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize the number of insertions needed\nk = 0\n\n# Iterate through the array and check if any two adjacent numbers are co-prime\nfor i in range(n - 1):\n    if gcd(a[i], a[i + 1])!= 1:\n        # If not co-prime, increment the number of insertions needed\n        k += 1\n\n# Print the number of insertions needed\nprint(k)\n\n# Print the updated array with the insertions\nprint(*a, sep=' ')"}
{"solution": "import math\nfrom functools import reduce\nfrom math import gcd\n\ndef compute_gcd_of_list(lst):\n    return reduce(gcd, lst)\n\ndef max_divisor_after_operations(N, K, A):\n    if N == 1:\n        return A[0]\n    \n    # Compute the GCD of the differences between all pairs\n    diffs = [abs(A[i] - A[j]) for i in range(N) for j in range(i + 1, N)]\n    initial_gcd = compute_gcd_of_list(diffs)\n    \n    # Check all divisors of the initial GCD\n    max_divisor = 1\n    for d in range(1, initial_gcd + 1):\n        if initial_gcd % d == 0:\n            # Check if we can make all elements divisible by d\n            if all((a % d) <= K for a in A):\n                max_divisor = d\n    \n    return max_divisor\n\n# Read input\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Compute and print the result\nprint(max_divisor_after_operations(N, K, A))"}
{"solution": "import sys\n\ndef main():\n    x = int(sys.stdin.readline().strip())\n    t = 0\n    n = 0\n    while x < 2**30:\n        t += 1\n        n = (t-1)//2\n        x = x ^ (2**n - 1)\n        x += 1\n    print(t)\n    for i in range(t//2):\n        print(n)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Find the minimum number of hours required to water the garden\nmin_hours = 1000000000\nfor i in range(n):\n    if k % a[i] == 0:\n        min_hours = min(min_hours, k // a[i])\n\nprint(min_hours)"}
{"solution": "def can_grasshopper_reach_insect(line, k):\n    # Initialize variables\n    n = len(line)\n    start_index = line.index(\"G\")\n    end_index = line.index(\"T\")\n    jumps = 0\n\n    # Check if the grasshopper can reach the insect\n    while start_index!= end_index:\n        # Check if the grasshopper can make a jump\n        if start_index + k <= n - 1 and line[start_index + k] == \".\":\n            start_index += k\n            jumps += 1\n        else:\n            break\n\n    # Return the result\n    if jumps == 0:\n        return \"NO\"\n    else:\n        return \"YES\""}
{"solution": "import math\n\ndef get_point_of_aiming(y1, y2, yw, xb, yb, r):\n    # Calculate the angle of incidence\n    theta = math.atan2(yb - yw, xb - yw)\n\n    # Calculate the angle of reflection\n    phi = math.pi - theta\n\n    # Calculate the distance between the ball and the wall\n    d = math.sqrt((yb - yw) ** 2 + (xb - yw) ** 2)\n\n    # Calculate the abscissa of the point of aiming\n    xw = xb + r * math.cos(phi)\n\n    # Check if the point of aiming is within the bounds of the field\n    if xw < 0 or xw > y2:\n        return -1\n\n    # Check if the ball will bounce off the wall and go straight to the goal\n    if math.sqrt((yb - yw) ** 2 + (xb - yw) ** 2) == r:\n        return xw\n\n    # If the ball will not bounce off the wall, return -1\n    return -1\n\n\n# Test the function with the given examples\nprint(get_point_of_aiming(4, 10, 13, 10, 3, 1))  # Output: 4.3750000000\nprint(get_point_of_aiming(1, 4, 6, 2, 2, 1))  # Output: -1\nprint(get_point_of_aiming(3, 10, 15, 17, 9, 2))  # Output: 11.3333333333"}
{"solution": "import sys\n\ndef get_min_missed_meals(b, d, s):\n    # Initialize variables\n    missed_meals = 0\n    arrival_day = 0\n    departure_day = 0\n\n    # Check if Vasiliy arrived before breakfast\n    if b > 0:\n        arrival_day = 1\n        missed_meals += 1\n\n    # Check if Vasiliy had breakfast\n    if b > 1:\n        missed_meals += 1\n\n    # Check if Vasiliy had dinner\n    if d > 0:\n        missed_meals += 1\n\n    # Check if Vasiliy had supper\n    if s > 0:\n        missed_meals += 1\n\n    # Check if Vasiliy left after supper\n    if s > 1:\n        departure_day = 1\n        missed_meals += 1\n\n    # Return the minimum number of missed meals\n    return missed_meals\n\n# Read input from stdin\nb, d, s = map(int, sys.stdin.readline().split())\n\n# Get the minimum number of missed meals\nmissed_meals = get_min_missed_meals(b, d, s)\n\n# Print the output to stdout\nprint(missed_meals)"}
{"solution": "import sys\n\ndef solve(n, a):\n    # Initialize x and y to 1\n    x = 1\n    y = 1\n\n    # Iterate through the sequence of visited cells\n    for i in range(n):\n        # If the current cell is not in the top row, move down\n        if i > 0 and a[i] - a[i-1] == y:\n            y += 1\n        # If the current cell is not in the leftmost column, move right\n        elif i > 0 and a[i] - a[i-1] == x:\n            x += 1\n        # If the current cell is not in the top row or the leftmost column, the path is invalid\n        else:\n            return \"NO\"\n\n    # If the path is valid, return the values of x and y\n    return \"YES\\n\" + str(x) + \" \" + str(y)\n\nif __name__ == \"__main__\":\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(solve(n, a))"}
{"solution": "import sys\n\ndef get_subsequence(a, b):\n    # Initialize variables\n    subsequence = \"\"\n    i, j = 0, 0\n\n    # Loop through both strings\n    while i < len(a) and j < len(b):\n        # If the current character in a is the same as the current character in b, add it to the subsequence\n        if a[i] == b[j]:\n            subsequence += a[i]\n            i += 1\n            j += 1\n        # If the current character in a is not the same as the current character in b, move on to the next character in a\n        else:\n            i += 1\n\n    # Return the subsequence\n    return subsequence\n\n# Get input from stdin\na = sys.stdin.readline().strip()\nb = sys.stdin.readline().strip()\n\n# Get the subsequence\nsubsequence = get_subsequence(a, b)\n\n# Print the subsequence\nprint(subsequence)"}
{"solution": "def minimal_stones(n, s):\n    current_stones = 0\n    min_stones = 0\n    \n    for char in s:\n        if char == '+':\n            current_stones += 1\n        elif char == '-':\n            current_stones -= 1\n        min_stones = min(min_stones, current_stones)\n    \n    return max(0, -min_stones)\n\n# Example usage:\nn = int(input())\ns = input().strip()\nprint(minimal_stones(n, s))"}
{"solution": "n = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# Calculate the maximum number of liters of kefir that Kolya can drink\nmax_liters = n // b\n\n# If the number of liters is greater than the number of liters that can be returned,\n# then the number of liters that can be returned is the maximum number of liters\nif max_liters > c:\n    max_liters = c\n\n# If the number of liters is greater than the number of plastic bottles that can be bought,\n# then the number of plastic bottles that can be bought is the maximum number of liters\nif max_liters > a:\n    max_liters = a\n\n# Print the maximum number of liters of kefir that Kolya can drink\nprint(max_liters)"}
{"solution": "n = int(input())\nk1 = int(input())\nk2 = int(input())\n\n# Initialize the cards for each player\ncards1 = [int(x) for x in input().split()]\ncards2 = [int(x) for x in input().split()]\n\n# Initialize the number of fights and the winner\nfights = 0\nwinner = -1\n\n# While both players have cards\nwhile k1 > 0 and k2 > 0:\n    # If the top card of player 1 is greater than the top card of player 2\n    if cards1[0] > cards2[0]:\n        # Player 1 wins the fight\n        fights += 1\n        # Add the top card of player 2 to the bottom of player 1's stack\n        cards1.append(cards2.pop(0))\n    # If the top card of player 2 is greater than the top card of player 1\n    elif cards2[0] > cards1[0]:\n        # Player 2 wins the fight\n        fights += 1\n        # Add the top card of player 1 to the bottom of player 2's stack\n        cards2.append(cards1.pop(0))\n    # If the top cards are equal\n    else:\n        # Both players lose the fight\n        fights += 1\n        # Remove the top cards from both players' stacks\n        cards1.pop(0)\n        cards2.pop(0)\n\n# If both players have cards, the game will continue forever\nif k1 > 0 and k2 > 0:\n    winner = -1\n# If one player has no cards, they win the game\nelif k1 == 0:\n    winner = 2\nelse:\n    winner = 1\n\n# Print the number of fights and the winner\nprint(fights, winner)"}
{"solution": "def check_password_complexity(password):\n    if len(password) < 5:\n        return \"Too weak\"\n    \n    has_upper = False\n    has_lower = False\n    has_digit = False\n    \n    for char in password:\n        if char.isupper():\n            has_upper = True\n        elif char.islower():\n            has_lower = True\n        elif char.isdigit():\n            has_digit = True\n    \n    if has_upper and has_lower and has_digit:\n        return \"Correct\"\n    else:\n        return \"Too weak\"\n\n# Example usage\npassword = input().strip()\nprint(check_password_complexity(password))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Initialize the number of exchanges to 0\nexchanges = 0\n\n# Loop through each student in both groups\nfor i in range(n):\n    # If the academic performance of the student in group A is not equal to the academic performance of the student in group B\n    if a[i]!= b[i]:\n        # Increment the number of exchanges by 1\n        exchanges += 1\n\n# Print the minimum number of exchanges required to achieve the desired distribution of students\nprint(exchanges)"}
{"solution": "import sys\n\nn, m = map(int, input().split())\nhorizontal_streets = input()\nvertical_streets = input()\n\n# Check if the pattern meets the mayor's criteria\nif len(horizontal_streets)!= n or len(vertical_streets)!= m:\n    print(\"NO\")\n    sys.exit()\n\n# Check if the horizontal streets are one-way\nif not all(horizontal_streets[i] in [\"<\", \">\"] for i in range(n)):\n    print(\"NO\")\n    sys.exit()\n\n# Check if the vertical streets are one-way\nif not all(vertical_streets[i] in [\"^\", \"v\"] for i in range(m)):\n    print(\"NO\")\n    sys.exit()\n\n# Check if it is possible to reach any junction from any other junction\nreachable = set()\nfor i in range(n):\n    for j in range(m):\n        if horizontal_streets[i] == \"<\":\n            reachable.add((i, j))\n        elif horizontal_streets[i] == \">\":\n            reachable.add((i, j))\n        elif vertical_streets[j] == \"^\":\n            reachable.add((i, j))\n        elif vertical_streets[j] == \"v\":\n            reachable.add((i, j))\n\nif len(reachable) == n * m:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Check if the expression is possible to make false\nif a[0] == 0 and a[1] == 1 and a[2] == 1 and a[3] == 0:\n    print(\"YES\")\n    print(\"(((0)->1)->(1->0))\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\nn, m = map(int, sys.stdin.readline().split())\n\na = n\nb = m\n\nwhile a!= 0 and b!= 0:\n    if a >= 2 * b:\n        a -= 2 * b\n    elif b >= 2 * a:\n        b -= 2 * a\n    else:\n        break\n\nprint(a, b)"}
{"solution": "  import sys\n\ndef find_k_divisible_numbers(k, a, b):\n    count = 0\n    for x in range(a, b+1):\n        if x % k == 0:\n            count += 1\n    return count\n\nif __name__ == '__main__':\n    k, a, b = map(int, sys.stdin.readline().split())\n    print(find_k_divisible_numbers(k, a, b))"}
{"solution": "import sys\n\nk = int(sys.stdin.readline())\n\n# Calculate the position of the digit in the sequence\nposition = k - 1\n\n# Initialize the sequence with the first digit\nsequence = \"1\"\n\n# Iterate through the remaining digits\nfor i in range(1, position):\n    # Calculate the next digit in the sequence\n    next_digit = (sequence[i - 1] + 1) % 10\n    \n    # Add the next digit to the sequence\n    sequence += str(next_digit)\n\n# Print the k-th digit of the sequence\nprint(sequence[position])"}
{"solution": "def can_vasya_win(n, s):\n    # Calculate the number of moves each player will make\n    moves_each = (n - 11) // 2\n    \n    # Count the number of '8's in the first n - 10 characters\n    count_8s = s[:n - 10].count('8')\n    \n    # Vasya wins if there are more '8's than the number of moves Petya can make\n    if count_8s > moves_each:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Determine if Vasya has a winning strategy\nresult = can_vasya_win(n, s)\nprint(result)"}
{"solution": "import sys\n\nn, x, pos = map(int, sys.stdin.readline().split())\n\n# Initialize the number of valid permutations to 0\nvalid_permutations = 0\n\n# Iterate over all possible permutations of size n\nfor permutation in itertools.permutations(range(1, n + 1)):\n    # Check if the permutation contains x at position pos\n    if permutation[pos] == x:\n        # Increment the number of valid permutations\n        valid_permutations += 1\n\n# Print the remainder of the division of the number of valid permutations by 10^9 + 7\nprint(valid_permutations % (10**9 + 7))"}
{"solution": "import re\n\ndef can_encode_message(string, k):\n    # Check if the string has the correct length\n    if len(string)!= k:\n        return False\n    \n    # Check if the string contains only allowed characters\n    if not re.match(r'^[a-z*?]+$', string):\n        return False\n    \n    # Check if the string contains any invalid characters\n    if '*' in string and '?' in string:\n        return False\n    \n    # Check if the string can be decoded\n    decoded_string = decode_string(string)\n    if len(decoded_string)!= k:\n        return False\n    \n    # Check if the decoded string is a valid message\n    if not re.match(r'^[a-z]+$', decoded_string):\n        return False\n    \n    return True\n\ndef decode_string(string):\n    decoded_string = ''\n    for i in range(len(string)):\n        if string[i] == '*':\n            decoded_string += string[i-1]\n        elif string[i] == '?':\n            decoded_string += string[i-1] + string[i-1]\n        else:\n            decoded_string += string[i]\n    return decoded_string\n\nstring = input()\nk = int(input())\n\nif can_encode_message(string, k):\n    print(decode_string(string))\nelse:\n    print(\"Impossible\")"}
{"solution": "import math\n\ndef get_min_turns(x):\n    # Convert the angle to radians\n    angle = math.radians(x)\n\n    # Calculate the deviation from \"true up\"\n    deviation = abs(angle - math.pi / 2)\n\n    # Calculate the minimum number of turns required\n    turns = int(deviation / (math.pi / 2))\n\n    return turns\n\n# Test the function\nprint(get_min_turns(60))  # Should print 1\nprint(get_min_turns(-60))  # Should print 3"}
{"solution": "def can_get_spheres(blue, violet, orange, x, y, z):\n    # Initialize the number of spheres of each color\n    blue_spheres = blue\n    violet_spheres = violet\n    orange_spheres = orange\n\n    # Initialize the number of spheres needed of each color\n    blue_needed = x\n    violet_needed = y\n    orange_needed = z\n\n    # Initialize the number of transformations made\n    transformations = 0\n\n    # While there are still spheres needed and there are still spheres to transform\n    while blue_needed > 0 and violet_needed > 0 and orange_needed > 0 and blue_spheres > 0 and violet_spheres > 0 and orange_spheres > 0:\n        # If there are more blue spheres than violet spheres, transform all blue spheres into violet spheres\n        if blue_spheres > violet_spheres:\n            blue_spheres -= violet_spheres\n            violet_spheres += violet_spheres\n            transformations += 1\n        # If there are more violet spheres than orange spheres, transform all violet spheres into orange spheres\n        elif violet_spheres > orange_spheres:\n            violet_spheres -= orange_spheres\n            orange_spheres += orange_spheres\n            transformations += 1\n        # If there are more orange spheres than blue spheres, transform all orange spheres into blue spheres\n        elif orange_spheres > blue_spheres:\n            orange_spheres -= blue_spheres\n            blue_spheres += blue_spheres\n            transformations += 1\n        # If there are an equal number of spheres of each color, transform all blue spheres into violet spheres\n        else:\n            blue_spheres -= violet_spheres\n            violet_spheres += violet_spheres\n            transformations += 1\n\n    # If all the spheres needed have been obtained, return \"Yes\"\n    if blue_needed == 0 and violet_needed == 0 and orange_needed == 0:\n        return \"Yes\"\n    # Otherwise, return \"No\"\n    else:\n        return \"No\"\n\n# Test the function with the given input\nprint(can_get_spheres(4, 4, 0, 2, 1, 2))"}
{"solution": "import math\n\ndef solve(n, k, m):\n    # Calculate the number of integer numbers x > 0 that satisfy the conditions\n    count = 0\n    for x in range(1, 10**n):\n        # Check if the decimal representation of x has exactly n digits\n        if len(str(x)) == n:\n            # Check if there exists an integer y > 0 such that y mod k = 0 and the decimal representation of y is a suffix of the decimal representation of x\n            for y in range(1, 10**k):\n                if y % k == 0 and str(y)[-n:] == str(x):\n                    count += 1\n                    break\n    \n    # Return the remainder of the count modulo m\n    return count % m\n\n# Test the function with the given input\nn = 1\nk = 2\nm = 1000\nprint(solve(n, k, m))"}
{"solution": "def max_team_size(l, r, a):\n    if l > r:\n        l, r = r, l  # Ensure l is always the smaller or equal group\n    \n    # Use ambidexters to balance the difference\n    d = r - l\n    if a >= d:\n        l += d\n        a -= d\n        # Now l == r, distribute remaining ambidexters equally\n        l += a // 2\n        r += a // 2\n    else:\n        l += a\n        # Not enough ambidexters to balance completely, r remains larger\n    \n    # The maximum team size is twice the smaller group\n    return 2 * min(l, r)\n\n# Example usage\nprint(max_team_size(1, 4, 2))  # Output: 6\nprint(max_team_size(5, 5, 5))  # Output: 14\nprint(max_team_size(0, 2, 0))  # Output: 0"}
{"solution": "import sys\n\nn, k = map(int, input().split())\n\n# Initialize the number of moves as 0\nmoves = 0\n\n# Initialize the number of stones as n\nstones = n\n\n# Initialize the number of coins as n\ncoins = n\n\n# Initialize the current position as k\ncurrent_position = k\n\n# Initialize the previous position as k\nprevious_position = k\n\n# Initialize the number of moves required to pick all the coins as 0\nrequired_moves = 0\n\n# While there are still stones in the room\nwhile stones > 0:\n    # If the current position is not the leftmost manhole\n    if current_position!= 1:\n        # If there is at least one stone on the current manhole\n        if stones[current_position] > 0:\n            # Throw exactly one stone from the current manhole to any other manhole\n            stones[current_position] -= 1\n            moves += 1\n        # If there are no stones on the current manhole\n        else:\n            # Open the current manhole and pick the coin from it\n            coins[current_position] -= 1\n            moves += 1\n            # If the current manhole is not the leftmost manhole\n            if current_position!= 1:\n                # Go to the previous manhole\n                current_position -= 1\n                moves += 1\n            # If the current manhole is the leftmost manhole\n            else:\n                # Open the current manhole and pick the coin from it\n                coins[current_position] -= 1\n                moves += 1\n                # Go to the next manhole\n                current_position += 1\n                moves += 1\n    # If the current position is the leftmost manhole\n    else:\n        # If there are no stones on the current manhole\n        if stones[current_position] == 0:\n            # Open the current manhole and pick the coin from it\n            coins[current_position] -= 1\n            moves += 1\n            # Go to the next manhole\n            current_position += 1\n            moves += 1\n        # If there are stones on the current manhole\n        else:\n            # Throw exactly one stone from the current manhole to any other manhole\n            stones[current_position] -= 1\n            moves += 1\n            # If the current manhole is not the leftmost manhole\n            if current_position!= 1:\n                # Go to the previous manhole\n                current_position -= 1\n                moves += 1\n            # If the current manhole is the leftmost manhole\n            else:\n                # Open the current manhole and pick the coin from it\n                coins[current_position] -= 1\n                moves += 1\n                # Go to the next manhole\n                current_position += 1\n                moves += 1\n\n# Print the minimum number of moves required to pick all the coins\nprint(moves)"}
{"solution": "def get_tallest_tower(n, m):\n    # Initialize variables\n    two_block_heights = []\n    three_block_heights = []\n    tallest_tower = 0\n\n    # Get the heights of the towers made with two-block pieces\n    for i in range(n):\n        two_block_heights.append(i * 2 + 2)\n\n    # Get the heights of the towers made with three-block pieces\n    for i in range(m):\n        three_block_heights.append(i * 3 + 3)\n\n    # Find the tallest tower\n    for two_block_height in two_block_heights:\n        for three_block_height in three_block_heights:\n            if two_block_height + three_block_height > tallest_tower:\n                tallest_tower = two_block_height + three_block_height\n\n    return tallest_tower"}
{"solution": "n = int(input())\ncards = [int(input()) for _ in range(n)]\n\n# Check if the number of cards is even\nif n % 2!= 0:\n    print(\"NO\")\n    exit()\n\n# Check if all cards have the same number\nif len(set(cards)) == 1:\n    print(\"NO\")\n    exit()\n\n# Check if the numbers are distinct\nif len(set(cards))!= len(cards):\n    print(\"NO\")\n    exit()\n\n# Check if the numbers are in ascending order\nif not all(cards[i] < cards[i+1] for i in range(len(cards)-1)):\n    print(\"NO\")\n    exit()\n\n# Check if the numbers are in descending order\nif not all(cards[i] > cards[i+1] for i in range(len(cards)-1)):\n    print(\"NO\")\n    exit()\n\n# Check if the numbers are in ascending order with a step of 2\nif not all(cards[i] < cards[i+2] for i in range(len(cards)-2)):\n    print(\"NO\")\n    exit()\n\n# Check if the numbers are in descending order with a step of 2\nif not all(cards[i] > cards[i+2] for i in range(len(cards)-2)):\n    print(\"NO\")\n    exit()\n\n# If all checks pass, the game is fair\nprint(\"YES\")"}
{"solution": "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Check if the number of soldiers is less than or equal to the number of seats\nif sum(a) <= n * 8:\n    # Initialize a matrix to represent the seating arrangement\n    matrix = [[0] * 8 for _ in range(n)]\n\n    # Place the soldiers in the matrix\n    for i in range(k):\n        for j in range(a[i]):\n            matrix[i][j] = 1\n\n    # Check if there are any neighboring seats\n    for i in range(n):\n        for j in range(7):\n            if matrix[i][j] == 1 and matrix[i][j + 1] == 1:\n                print(\"NO\")\n                exit()\n\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import math\n\ndef solve(n, a):\n    # Calculate the cost of changing each stick's length\n    costs = [abs(a[i] - a[i-1]) for i in range(1, n)]\n\n    # Find the minimum cost\n    min_cost = min(costs)\n\n    # Find the index of the minimum cost\n    min_index = costs.index(min_cost)\n\n    # Calculate the new length of the stick\n    new_length = a[min_index] + min_cost\n\n    # Calculate the new cost\n    new_cost = abs(new_length - a[min_index])\n\n    # Return the new length and cost\n    return new_length, new_cost\n\n# Test the function\nn = 3\na = [10, 1, 4]\nprint(solve(n, a))"}
{"solution": "n, m = map(int, input().split())\n\n# Initialize a 2D array to store the map\nmap = [['.' for _ in range(m)] for _ in range(n)]\n\n# Read the map and store the coordinates of the stars\nstars = []\nfor i in range(n):\n    for j in range(m):\n        if map[i][j] == '*':\n            stars.append((i, j))\n\n# Find the minimum and maximum coordinates of the stars\nmin_x, min_y = min(stars, key=lambda x: x[0]), min(stars, key=lambda x: x[1])\nmax_x, max_y = max(stars, key=lambda x: x[0]), max(stars, key=lambda x: x[1])\n\n# Calculate the length and width of the rectangle that covers all the stars\nlength = max_x - min_x + 1\nwidth = max_y - min_y + 1\n\n# Find the maximum of the length and width\nmax_length_width = max(length, width)\n\n# Print the minimum possible side length of the square that covers all the stars\nprint(max_length_width)"}
{"solution": "import math\n\ndef get_probability(a, k):\n    n = len(a)\n    p = 1\n    q = 1\n    for i in range(k):\n        p *= math.factorial(n - 1)\n        q *= math.factorial(n - 2)\n    return p * q % (10**9 + 7)\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nprint(get_probability(a, k))"}
{"solution": "import sys\n\ndef get_min_seconds(x, y):\n    # Initialize variables\n    current_side_length = x\n    seconds = 0\n\n    # Loop until the current side length is equal to the target side length\n    while current_side_length!= y:\n        # Calculate the new side length based on the current side length\n        new_side_length = calculate_new_side_length(current_side_length)\n\n        # Update the current side length and increment the number of seconds\n        current_side_length = new_side_length\n        seconds += 1\n\n    # Return the minimum number of seconds required to reach the target side length\n    return seconds\n\ndef calculate_new_side_length(current_side_length):\n    # Calculate the new side length based on the current side length\n    new_side_length = current_side_length - 1\n\n    # If the new side length is less than 3, set it to 3\n    if new_side_length < 3:\n        new_side_length = 3\n\n    return new_side_length\n\n# Read the input from stdin\nx, y = map(int, input().split())\n\n# Calculate the minimum number of seconds required to reach the target side length\nresult = get_min_seconds(x, y)\n\n# Print the result to stdout\nprint(result)"}
{"solution": "import math\n\ndef get_degenerate_matrix(A):\n    # Initialize the degenerate matrix B\n    B = [[0, 0], [0, 0]]\n    \n    # Calculate the determinant of A\n    det_A = A[0][0] * A[1][1] - A[0][1] * A[1][0]\n    \n    # Calculate the norm of A\n    norm_A = math.sqrt(A[0][0] ** 2 + A[0][1] ** 2 + A[1][0] ** 2 + A[1][1] ** 2)\n    \n    # Calculate the minimum possible value of ||A - B||\n    min_norm = math.sqrt((A[0][0] - B[0][0]) ** 2 + (A[0][1] - B[0][1]) ** 2 + (A[1][0] - B[1][0]) ** 2 + (A[1][1] - B[1][1]) ** 2)\n    \n    # Return the minimum possible value of ||A - B||\n    return min_norm\n\n# Test the function\nA = [[1, 2], [3, 4]]\nprint(get_degenerate_matrix(A))\n\nA = [[1, 0], [0, 1]]\nprint(get_degenerate_matrix(A))"}
{"solution": "n, a, b = map(int, input().split())\ngroups = list(map(int, input().split()))\n\n# Initialize variables\none_seater_tables = a\ntwo_seater_tables = b\ndenied_service = 0\n\n# Iterate through the groups\nfor i in range(n):\n    # If the group consists of one person\n    if groups[i] == 1:\n        # If there is a vacant one-seater table\n        if one_seater_tables > 0:\n            # Seat the group at the vacant table\n            one_seater_tables -= 1\n        # If there are no vacant one-seater tables\n        else:\n            # If there is a vacant two-seater table\n            if two_seater_tables > 0:\n                # Seat the group at the vacant table\n                two_seater_tables -= 1\n            # If there are no vacant two-seater tables\n            else:\n                # Deny service to the group\n                denied_service += 1\n    # If the group consists of two people\n    else:\n        # If there is a vacant two-seater table\n        if two_seater_tables > 0:\n            # Seat the group at the vacant table\n            two_seater_tables -= 1\n        # If there are no vacant two-seater tables\n        else:\n            # Deny service to the group\n            denied_service += 1\n\n# Print the total number of people the restaurant denies service to\nprint(denied_service)"}
{"solution": "import sys\n\ndef main():\n    a, b, c, n = map(int, input().split())\n    if a + b + c!= n:\n        print(-1)\n        return\n    if a + b + c == 0:\n        print(n)\n        return\n    if a + b + c == n:\n        print(0)\n        return\n    if a + b + c < n:\n        print(n - a - b - c)\n        return\n    if a + b + c > n:\n        print(-1)\n        return\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "  import sys\n\ndef solve(x, k):\n    # Calculate the number of dresses after k months\n    num_dresses = x * 2 ** k\n    \n    # Calculate the number of dresses that will be eaten by the wardrobe\n    num_eaten = num_dresses // 2\n    \n    # Calculate the expected number of dresses after k months\n    expected_num_dresses = num_dresses - num_eaten\n    \n    # Return the expected number of dresses modulo 10^9 + 7\n    return expected_num_dresses % (10 ** 9 + 7)\n\nif __name__ == \"__main__\":\n    x, k = map(int, sys.stdin.read().split())\n    print(solve(x, k))"}
{"solution": "import math\n\ndef calculate_probability(n, l, r):\n    # Calculate the probability of no inversions\n    probability = 1\n    for i in range(n):\n        probability *= (r[i] - l[i] + 1) / (r[i] - l[i] + 2)\n    return probability\n\ndef main():\n    # Read the input\n    n = int(input())\n    l = [int(x) for x in input().split()]\n    r = [int(x) for x in input().split()]\n\n    # Calculate the probability of no inversions\n    probability = calculate_probability(n, l, r)\n\n    # Print the output\n    print(probability)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\nn = int(sys.stdin.readline().strip())\n\ndef count_ways(n):\n    # Initialize a dictionary to store the number of ways to cut the stick\n    ways = {1: 1}\n\n    # Iterate from 2 to n\n    for i in range(2, n + 1):\n        # Initialize a variable to store the number of ways to cut the stick with length i\n        num_ways = 0\n\n        # Iterate over the keys in the dictionary\n        for j in ways:\n            # If the key is less than i, add the number of ways to cut the stick with length j to the number of ways to cut the stick with length i\n            if j < i:\n                num_ways += ways[j]\n\n        # Add the number of ways to cut the stick with length i to the dictionary\n        ways[i] = num_ways\n\n    # Return the number of ways to cut the stick with length n\n    return ways[n]\n\nprint(count_ways(n))"}
{"solution": "import sys\n\nn, s = map(int, input().split())\nvolumes = list(map(int, input().split()))\n\n# Initialize the minimum volume in each keg to the maximum possible value\nmin_volume = [sys.maxsize] * n\n\n# Iterate through each keg and calculate the minimum volume\nfor i in range(n):\n    min_volume[i] = min(volumes[i], s // n)\n\n# Find the minimum volume in all kegs\nmin_volume = min(min_volume)\n\n# Check if the Fair Nut can pour his glass by the desired amount\nif min_volume == 0:\n    print(-1)\nelse:\n    print(min_volume)"}
{"solution": "import math\n\ndef solve(h1, h2, a, b):\n    # Calculate the total distance the caterpillar needs to travel\n    total_distance = h2 - h1\n\n    # Calculate the number of days it takes for the caterpillar to travel the total distance\n    days = total_distance / (a + b)\n\n    # Calculate the number of hours the caterpillar spends on the tree each day\n    hours_per_day = 10\n\n    # Calculate the number of hours the caterpillar spends climbing up and down each day\n    climbing_hours = a + b\n\n    # Calculate the number of hours the caterpillar spends on the tree each night\n    night_hours = hours_per_day - climbing_hours\n\n    # Calculate the number of hours the caterpillar spends on the tree each day, excluding nights\n    day_hours = hours_per_day - night_hours\n\n    # Calculate the number of hours the caterpillar spends climbing up each day\n    climbing_up_hours = a * day_hours\n\n    # Calculate the number of hours the caterpillar spends slipping down each day\n    slipping_down_hours = b * day_hours\n\n    # Calculate the total number of hours the caterpillar spends on the tree each day\n    total_hours = climbing_up_hours + slipping_down_hours\n\n    # Calculate the number of days it takes for the caterpillar to reach the apple\n    days_to_apple = total_distance / total_hours\n\n    # Return the number of days it takes for the caterpillar to reach the apple\n    return days_to_apple\n\n\n# Test the function with different inputs\nprint(solve(10, 30, 2, 1))  # Output: 1\nprint(solve(10, 13, 1, 1))  # Output: 0\nprint(solve(10, 19, 1, 2))  # Output: -1\nprint(solve(1, 50, 5, 4))  # Output: 1"}
{"solution": "import sys\n\ndef get_maximum_joy_units(candies, red_candy_weight, blue_candy_weight, red_candy_joy_units, blue_candy_joy_units):\n    # Initialize variables\n    total_joy_units = 0\n    red_candy_count = 0\n    blue_candy_count = 0\n\n    # Loop through the candies and calculate the maximum number of joy units\n    for candy in candies:\n        if candy == \"red\":\n            red_candy_count += 1\n            total_joy_units += red_candy_joy_units\n        elif candy == \"blue\":\n            blue_candy_count += 1\n            total_joy_units += blue_candy_joy_units\n\n    # Calculate the maximum number of joy units that can be obtained by eating a whole candy\n    max_joy_units = total_joy_units + (red_candy_count * red_candy_weight + blue_candy_count * blue_candy_weight)\n\n    return max_joy_units\n\n# Read input from stdin\ncandies, red_candy_weight, blue_candy_weight, red_candy_joy_units, blue_candy_joy_units = map(int, input().split())\n\n# Calculate the maximum number of joy units\nmax_joy_units = get_maximum_joy_units(candies, red_candy_weight, blue_candy_weight, red_candy_joy_units, blue_candy_joy_units)\n\n# Print the output\nprint(max_joy_units)"}
{"solution": "import sys\n\ndef get_min_steps(start_pos, finish_pos):\n    x1, y1 = start_pos\n    x2, y2 = finish_pos\n    dx = abs(x2 - x1)\n    dy = abs(y2 - y1)\n    if dx > dy:\n        return dx\n    else:\n        return dy\n\nif __name__ == \"__main__\":\n    x1, y1 = map(int, input().split())\n    x2, y2 = map(int, input().split())\n    print(get_min_steps((x1, y1), (x2, y2)))"}
{"solution": "import sys\n\nn = int(input())\nfractions = input()\n\n# Initialize the voting outcome\noutcome = 'D' if fractions[0] == 'D' else 'R'\n\n# Iterate through each employee's statement\nfor i in range(1, n):\n    # Get the current employee's fraction\n    current_fraction = fractions[i]\n    \n    # Check if the current employee has the right to vote\n    if current_fraction == outcome:\n        # The current employee has the right to vote, so skip their turn\n        continue\n    \n    # The current employee does not have the right to vote, so deny their vote\n    outcome = 'D' if outcome == 'R' else 'R'\n\n# Print the final outcome of the vote\nprint(outcome)"}
{"solution": "import sys\n\ndef solve(a, b, x, y):\n    count = 0\n    for w in range(1, a+1):\n        for h in range(1, b+1):\n            if w/h == x/y and w <= a and h <= b:\n                count += 1\n    return count\n\nif __name__ == \"__main__\":\n    a, b, x, y = map(int, sys.stdin.readline().split())\n    print(solve(a, b, x, y))"}
{"solution": "import math\n\ndef trailing_zeros(n, b):\n    # Calculate the factorial of n\n    factorial = math.factorial(n)\n    \n    # Convert the factorial to the given base\n    factorial_base = int(factorial, b)\n    \n    # Count the number of trailing zeros in the base representation\n    trailing_zeros = 0\n    while factorial_base % b == 0:\n        trailing_zeros += 1\n        factorial_base //= b\n    \n    return trailing_zeros\n\nn, b = map(int, input().split())\nprint(trailing_zeros(n, b))"}
{"solution": "import sys\n\ndef frog_jumps(m, a, b):\n    # Initialize a dictionary to store the number of distinct integers the frog can reach at each position\n    f = {0: 1}\n\n    # Iterate through the positions from 1 to m\n    for i in range(1, m+1):\n        # If the frog can jump to position i+a, add it to the dictionary\n        if i+a <= m:\n            f[i+a] = f.get(i+a, 0) + 1\n        # If the frog can jump to position i-b, add it to the dictionary\n        if i-b >= 0:\n            f[i-b] = f.get(i-b, 0) + 1\n\n    # Return the sum of the values in the dictionary\n    return sum(f.values())\n\nif __name__ == \"__main__\":\n    m, a, b = map(int, input().split())\n    print(frog_jumps(m, a, b))"}
{"solution": "import sys\n\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Check if the length of the sequence is odd\nif n % 2 == 0:\n    print(\"No\")\n    sys.exit()\n\n# Check if the sequence starts and ends with odd numbers\nif sequence[0] % 2 == 0 or sequence[-1] % 2 == 0:\n    print(\"No\")\n    sys.exit()\n\n# Check if the sequence can be divided into an odd number of subsegments\nsubsegments = []\nfor i in range(n):\n    if sequence[i] % 2 == 0:\n        subsegments.append(sequence[i])\n\nif len(subsegments) % 2 == 0:\n    print(\"No\")\n    sys.exit()\n\n# Check if each subsegment has an odd length\nfor subsegment in subsegments:\n    if len(subsegment) % 2 == 0:\n        print(\"No\")\n        sys.exit()\n\n# Check if each subsegment starts and ends with odd numbers\nfor subsegment in subsegments:\n    if subsegment[0] % 2 == 0 or subsegment[-1] % 2 == 0:\n        print(\"No\")\n        sys.exit()\n\nprint(\"Yes\")"}
{"solution": "import sys\n\ndef find_remaining_trees(x1, y1, x2, y2):\n    # Find the slope of the line between the two given trees\n    slope = (y2 - y1) / (x2 - x1)\n\n    # Find the x-coordinate of the third tree\n    x3 = (slope * (slope * x1 - y1) + x2) / (slope * slope + 1)\n\n    # Find the y-coordinate of the third tree\n    y3 = slope * x3 + y1\n\n    # Find the x-coordinate of the fourth tree\n    x4 = (slope * (slope * x2 - y2) + x1) / (slope * slope + 1)\n\n    # Find the y-coordinate of the fourth tree\n    y4 = slope * x4 + y2\n\n    return x3, y3, x4, y4\n\nif __name__ == \"__main__\":\n    x1, y1, x2, y2 = map(int, input().split())\n    x3, y3, x4, y4 = find_remaining_trees(x1, y1, x2, y2)\n    print(x3, y3, x4, y4)"}
{"solution": "import sys\n\ndef calculate_f_n(x, y, n):\n    if n == 1:\n        return x\n    elif n == 2:\n        return y\n    else:\n        return (calculate_f_n(x, y, n - 1) + calculate_f_n(x, y, n + 1)) % 1000000007\n\nif __name__ == \"__main__\":\n    x, y = map(int, input().split())\n    n = int(input())\n    print(calculate_f_n(x, y, n))"}
{"solution": "n = int(input())\narr = list(map(int, input().split()))\n\n# Initialize the number of new arrays to 0\nk = 0\n\n# Iterate through the array and check if the sum of elements in each subarray is not zero\nfor i in range(n):\n    subarray_sum = 0\n    for j in range(i, n):\n        subarray_sum += arr[j]\n        if subarray_sum == 0:\n            break\n    if subarray_sum!= 0:\n        k += 1\n\n# Print \"YES\" if there is at least one subarray with non-zero sum\nif k > 0:\n    print(\"YES\")\n    print(k)\n\n    # Print the indices of the subarrays\n    for i in range(k):\n        print(i + 1, i + 2)\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\nn, m, k = map(int, input().split())\n\n# Initialize the minimum score to 0\nmin_score = 0\n\n# Iterate through the questions\nfor i in range(n):\n    # If the question is answered correctly, add 1 point to the score\n    if i in m:\n        min_score += 1\n    # If the counter reaches k, double the score\n    if i % k == 0:\n        min_score *= 2\n\n# Print the remainder of the minimum score modulo 1000000009\nprint(min_score % 1000000009)"}
{"solution": ""}
{"solution": "n, m = map(int, input().split())\nfloors = {}\n\nfor i in range(m):\n    k, f = map(int, input().split())\n    if f not in floors:\n        floors[f] = [k]\n    else:\n        floors[f].append(k)\n\nif len(floors) == 1:\n    print(floors[1][0])\nelse:\n    print(-1)"}
{"solution": "def max_bishwocks(board1, board2):\n    n = len(board1)\n    board = [[board1[i], board2[i]] for i in range(n)]\n    \n    # Define the four possible shapes of the bishwock\n    bishwock_shapes = [\n        [(0, 0), (0, 1), (1, 0)],  # Original L shape\n        [(0, 0), (0, 1), (1, 1)],  # Rotated 90 degrees\n        [(0, 1), (1, 0), (1, 1)],  # Rotated 180 degrees\n        [(0, 0), (1, 0), (1, 1)]   # Rotated 270 degrees\n    ]\n    \n    def can_place_bishwock(x, y, shape):\n        for dx, dy in shape:\n            nx, ny = x + dx, y + dy\n            if nx >= 2 or ny >= n or board[ny][nx] == 'X':\n                return False\n        return True\n    \n    def place_bishwock(x, y, shape):\n        for dx, dy in shape:\n            nx, ny = x + dx, y + dy\n            board[ny][nx] = 'X'\n    \n    count = 0\n    for y in range(n):\n        for x in range(2):\n            for shape in bishwock_shapes:\n                if can_place_bishwock(x, y, shape):\n                    place_bishwock(x, y, shape)\n                    count += 1\n                    break\n    \n    return count\n\n# Example usage\nboard1 = \"00X00X0XXX0\"\nboard2 = \"0XXX0X00X00\"\nprint(max_bishwocks(board1, board2))  # Output: 4"}
{"solution": "n = int(input())\ns = input().strip()\n\nmax_length = 0\ncurrent_set = set()\n\nfor char in s:\n    if char.islower():\n        current_set.add(char)\n    else:\n        max_length = max(max_length, len(current_set))\n        current_set.clear()\n\nmax_length = max(max_length, len(current_set))\n\nprint(max_length)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Initialize the maximum possible value of B - C\nmax_value = 0\n\n# Iterate over all possible partitions of the sequence\nfor i in range(n):\n    # Calculate the sum of elements in b\n    b_sum = sum(a[:i])\n    # Calculate the sum of elements in c\n    c_sum = sum(a[i:])\n    # Calculate the difference between the sums\n    value = b_sum - c_sum\n    # Update the maximum possible value if necessary\n    if value > max_value:\n        max_value = value\n\n# Print the maximum possible value of B - C\nprint(max_value)"}
{"solution": "def get_min_refuels(a, b, f, k):\n    # Initialize variables\n    current_position = 0\n    current_fuel = b\n    refuels = 0\n\n    # Iterate through each journey\n    for i in range(k):\n        # Calculate the distance to the next refueling point\n        distance_to_refuel = f - current_position\n\n        # Check if the bus can make the journey without refueling\n        if current_fuel >= distance_to_refuel:\n            # Update the current position and fuel level\n            current_position = f\n            current_fuel -= distance_to_refuel\n        else:\n            # Update the current position and fuel level\n            current_position = f\n            current_fuel = b\n            refuels += 1\n\n    return refuels"}
{"solution": "n, p, q = map(int, input().split())\ns = input()\n\nif len(s) % (p + q)!= 0:\n    print(-1)\n    exit()\n\nk = len(s) // (p + q)\nresult = []\nfor i in range(k):\n    if i % 2 == 0:\n        result.append(s[i * (p + q) : i * (p + q) + p])\n    else:\n        result.append(s[i * (p + q) + p : i * (p + q) + p + q])\n\nprint(k)\nfor r in result:\n    print(r)"}
{"solution": "import sys\n\nn, m, s, d = map(int, input().split())\nobstacles = list(map(int, input().split()))\n\n# Initialize the starting point\nx = 0\n\n# Initialize the jump length\njump_length = 0\n\n# Initialize the run length\nrun_length = 0\n\n# Initialize the jump count\njump_count = 0\n\n# Initialize the run count\nrun_count = 0\n\n# Initialize the finish flag\nfinish = False\n\n# Iterate through the obstacles\nfor i in range(n):\n    # Check if the obstacle is within the jump length\n    if obstacles[i] - x <= d:\n        # Increment the jump length\n        jump_length += obstacles[i] - x\n\n        # Print the jump command\n        print(f\"JUMP {jump_length}\")\n\n        # Increment the jump count\n        jump_count += 1\n\n        # Set the new starting point\n        x = obstacles[i]\n\n    # Check if the obstacle is within the run length\n    elif obstacles[i] - x <= s:\n        # Increment the run length\n        run_length += obstacles[i] - x\n\n        # Print the run command\n        print(f\"RUN {run_length}\")\n\n        # Increment the run count\n        run_count += 1\n\n        # Set the new starting point\n        x = obstacles[i]\n\n    # Check if the obstacle is beyond the jump length\n    elif obstacles[i] - x > d:\n        # Print the impossible message\n        print(\"IMPOSSIBLE\")\n\n        # Break the loop\n        break\n\n# Check if the finish flag is set\nif finish:\n    # Print the finish message\n    print(\"FINISH\")\n\n# Print the jump and run counts\nprint(f\"JUMP COUNT: {jump_count}\")\nprint(f\"RUN COUNT: {run_count}\")"}
{"solution": "import sys\n\ns, x = map(int, input().split())\n\n# Check if s - x is even\nif (s - x) % 2 == 0:\n    # Check if b is positive\n    b = (s - x) // 2\n    if b > 0:\n        # Check if a is positive\n        a = s - b\n        if a > 0:\n            # Print the number of solutions\n            print(2)\n        else:\n            print(0)\n    else:\n        print(0)\nelse:\n    print(0)"}
{"solution": "n, k = map(int, input().split())\n\n# Initialize the skewers as initially turned over\nskewers = [True] * n\n\n# Initialize the number of actions as 0\nactions = 0\n\n# Iterate through each skewer\nfor i in range(n):\n    # If the skewer is initially turned over, turn it over again\n    if skewers[i]:\n        skewers[i] = False\n        actions += 1\n\n    # If the skewer is initially in the initial state, turn it over\n    else:\n        skewers[i] = True\n        actions += 1\n\n# Print the number of actions\nprint(actions)\n\n# Print the skewers to be turned over\nfor i in range(n):\n    if skewers[i]:\n        print(i + 1)"}
{"solution": "def min_operations_to_square(n):\n    # Generate all possible squares up to the maximum possible value\n    max_square_root = int(math.sqrt(2 * 10**9)) + 1\n    squares = [str(i * i) for i in range(1, max_square_root + 1)]\n    \n    # Check if n is a subsequence of any square\n    for square in squares:\n        if is_subsequence(square, str(n)):\n            return len(square) - len(str(n))\n    \n    # If no valid transformation exists, return -1\n    return -1\n\n# Example usage:\nprint(min_operations_to_square(8314))  # Output: 2\nprint(min_operations_to_square(625))   # Output: 0\nprint(min_operations_to_square(333))   # Output: -1"}
{"solution": "import sys\n\nn = int(sys.stdin.readline().strip())\n\ndef f(p):\n    gcds = []\n    for i in range(len(p)):\n        gcds.append(gcd(p[i], p[i+1]))\n    return len(set(gcds))\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\ndef count_permutations(n):\n    permutations = []\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                permutations.append([i, j, k])\n    return len([p for p in permutations if f(p) == f_max(n)])\n\ndef f_max(n):\n    max_value = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                value = f([i, j, k])\n                if value > max_value:\n                    max_value = value\n    return max_value\n\nprint(count_permutations(n) % (10**9 + 7))"}
{"solution": "def minimum_jump_ability(s):\n    vowels = {'A', 'E', 'I', 'O', 'U', 'Y'}\n    positions = [-1]  # Start position before the first character\n    \n    # Collect positions of all vowels\n    for i, char in enumerate(s):\n        if char in vowels:\n            positions.append(i)\n    \n    positions.append(len(s))  # End position after the last character\n    \n    # Calculate maximum distance between consecutive positions\n    max_distance = 0\n    for i in range(1, len(positions)):\n        max_distance = max(max_distance, positions[i] - positions[i - 1])\n    \n    return max_distance"}
{"solution": "def is_possible(a1, a2, a3, a4):\n    # Calculate the sum of the candies in each bag\n    sum1 = a1 + a2\n    sum2 = a3 + a4\n\n    # Check if the sums are equal\n    if sum1 == sum2:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Test the function with the given input\nprint(is_possible(1, 7, 11, 5))\nprint(is_possible(7, 3, 2, 5))"}
{"solution": "import sys\n\nN = int(input())\nsizes = [int(x) for x in input().split()]\n\n# Initialize the sums of the slices eaten by Alice and Bob\nalice_sum = 0\nbob_sum = 0\n\n# Initialize the decider token\ndecider = 0\n\n# Iterate through the slices\nfor i in range(N):\n    # If the decider token is held by Alice, give the current slice to Bob\n    if decider == 0:\n        bob_sum += sizes[i]\n    # Otherwise, give the current slice to Alice\n    else:\n        alice_sum += sizes[i]\n    \n    # Update the decider token\n    decider = 1 - decider\n\n# Print the sums of the slices eaten by Alice and Bob\nprint(alice_sum, bob_sum)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Initialize the minimum number of variables to 1\nm = 1\n\n# Loop through each element in the sequence\nfor i in range(n):\n    # If the current element is not equal to the sum of the previous elements,\n    # increment the minimum number of variables\n    if a[i]!= sum(a[:i]):\n        m += 1\n\nprint(m)"}
{"solution": "def determine_winner(n, piles):\n    odd_count = sum(1 for pile in piles if pile % 2!= 0)\n    if odd_count % 2 == 0:\n        return \"Alice\"\n    else:\n        return \"Bob\"\n\n# Read input\nn = int(input())\npiles = list(map(int, input().split()))\n\n# Determine and print the winner\nprint(determine_winner(n, piles))"}
{"solution": "import sys\n\nn = int(input())\narr = list(map(int, input().split()))\n\n# Check if all elements are equal\nif len(set(arr)) == 1:\n    print(\"YES\")\n    sys.exit()\n\n# Check if the sum of all elements is divisible by n\nif sum(arr) % n == 0:\n    print(\"YES\")\n    sys.exit()\n\n# Check if the product of all elements is divisible by n\nif reduce(lambda x, y: x * y, arr) % n == 0:\n    print(\"YES\")\n    sys.exit()\n\n# Check if the sum of the squares of all elements is divisible by n\nif sum(x**2 for x in arr) % n == 0:\n    print(\"YES\")\n    sys.exit()\n\n# Check if the sum of the cubes of all elements is divisible by n\nif sum(x**3 for x in arr) % n == 0:\n    print(\"YES\")\n    sys.exit()\n\n# Check if the sum of the fourth powers of all elements is divisible by n\nif sum(x**4 for x in arr) % n == 0:\n    print(\"YES\")\n    sys.exit()\n\n# Check if the sum of the fifth powers of all elements is divisible by n\nif sum(x**5 for x in arr) % n == 0:\n    print(\"YES\")\n    sys.exit()\n\n# If none of the above conditions are met, then the answer is NO\nprint(\"NO\")"}
{"solution": "import sys\n\ndef get_longest_repeated_substring(s):\n    # Initialize variables\n    max_len = 0\n    repeated_substring = \"\"\n\n    # Iterate over the length of the substring\n    for len in range(1, len(s)):\n        # Iterate over the starting position of the substring\n        for start in range(len(s) - len + 1):\n            # Check if the substring is repeated\n            if s[start:start + len] in s[start + len:]:\n                # If the substring is repeated, update the maximum length and the repeated substring\n                max_len = len\n                repeated_substring = s[start:start + len]\n\n    # Return the maximum length and the repeated substring\n    return max_len, repeated_substring\n\n# Get the input from the user\nn = int(input())\ns = input()\n\n# Get the longest repeated substring\nmax_len, repeated_substring = get_longest_repeated_substring(s)\n\n# Print the output\nprint(max_len)"}
{"solution": "n, a = map(int, input().split())\n\nif a % 2 == 1:\n    # a is odd\n    print((a + 1) // 2)\nelse:\n    # a is even\n    print((n - a + 2) // 2)"}
{"solution": "  def is_possible(n, m, k):\n    # Initialize an array to keep track of the counts of each color\n    counts = [0] * (m + 1)\n\n    # Initialize the left and right pointers for the sliding window\n    left, right = 0, 0\n\n    # Loop through the array of lightsaber colors\n    while right < n:\n        # Add the current color to the counts array\n        counts[colors[right]] += 1\n\n        # If the window meets the required counts, return \"YES\"\n        if all(counts[i] == k[i] for i in range(1, m + 1)):\n            return \"YES\"\n\n        # If the window exceeds the required counts, move the left pointer to reduce the window size and adjust the counts accordingly\n        if counts[colors[left]] > k[colors[left]]:\n            counts[colors[left]] -= 1\n            left += 1\n\n        # Move the right pointer to include more elements\n        right += 1\n\n    # If no valid window is found, return \"NO\"\n    return \"NO\"\n\n\nn, m = map(int, input().split())\ncolors = list(map(int, input().split()))\nk = list(map(int, input().split()))\nprint(is_possible(n, m, k))"}
{"solution": "n = int(input())\nrounds = []\nfor i in range(n):\n    m, c = map(int, input().split())\n    rounds.append((m, c))\n\nmishka_wins = 0\nchris_wins = 0\nfor round in rounds:\n    m, c = round\n    if m > c:\n        mishka_wins += 1\n    elif c > m:\n        chris_wins += 1\n\nif mishka_wins > chris_wins:\n    print(\"Mishka\")\nelif chris_wins > mishka_wins:\n    print(\"Chris\")\nelse:\n    print(\"Friendship is magic!^^\")"}
{"solution": "import sys\n\nn, m = map(int, input().split())\nfield = [input() for _ in range(n)]\n\n# Check if the field is valid\nfor i in range(n):\n    for j in range(m):\n        if field[i][j]!= '.':\n            # Check if the cell has a bomb\n            if field[i][j] == '*':\n                # Check if the cell has the correct number of bombs around it\n                if not check_bombs(i, j, field):\n                    print(\"NO\")\n                    sys.exit()\n            # Check if the cell is empty\n            elif field[i][j] == '.':\n                # Check if the cell has no bombs around it\n                if check_bombs(i, j, field):\n                    print(\"NO\")\n                    sys.exit()\n\n# Check if the cell has the correct number of bombs around it\ndef check_bombs(i, j, field):\n    bombs = 0\n    for x in range(i-1, i+2):\n        for y in range(j-1, j+2):\n            if x >= 0 and x < n and y >= 0 and y < m:\n                if field[x][y] == '*':\n                    bombs += 1\n    return bombs == int(field[i][j])\n\nprint(\"YES\")"}
{"solution": "n = int(input())\n\ndef can_vasya_eat_half(n, k):\n    total_candies = n\n    vasya_eaten = 0\n    \n    while total_candies > 0:\n        # Vasya eats k candies\n        vasya_eaten += min(k, total_candies)\n        total_candies -= min(k, total_candies)\n        \n        # Petya eats 10% of the remaining candies\n        petya_eaten = total_candies // 10\n        total_candies -= petya_eaten\n    \n    return vasya_eaten >= (n + 1) // 2\n\ndef find_min_k(n):\n    left, right = 1, n\n    while left < right:\n        mid = (left + right) // 2\n        if can_vasya_eat_half(n, mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\nprint(find_min_k(n))"}
{"solution": "def can_rearrange_necklace(s):\n    p = s.count('o')\n    l = s.count('-')\n    \n    if p == 0 or p == 1:\n        return \"YES\"\n    if l % p == 0:\n        return \"YES\"\n    return \"NO\""}
{"solution": "n, m, k = map(int, input().split())\n\n# Initialize a list to store the number of pillows for each hobbit\npillows = [0] * n\n\n# Initialize a variable to store the maximum number of pillows Frodo can have\nmax_pillows = 0\n\n# Loop through each hobbit and calculate the number of pillows they can have\nfor i in range(n):\n    # Calculate the number of pillows the hobbit can have\n    pillows[i] = min(m - i, k - i)\n\n    # Update the maximum number of pillows Frodo can have\n    max_pillows = max(max_pillows, pillows[i])\n\n# Print the maximum number of pillows Frodo can have\nprint(max_pillows)"}
{"solution": "import sys\n\nn, m, k = map(int, input().split())\na = list(map(int, input().split()))\n\ndef get_cost(l, r):\n    return sum(a[l:r+1]) - k * ceil((r - l + 1) / m)\n\ndef solve():\n    max_cost = 0\n    for i in range(n):\n        for j in range(i, n):\n            cost = get_cost(i, j)\n            if cost > max_cost:\n                max_cost = cost\n    return max_cost\n\nprint(solve())"}
{"solution": "import sys\n\nn, m = map(int, input().split())\n\n# Initialize a 2D array to store the length of the polyline for each point\npolyline_length = [[0] * (m + 1) for _ in range(n + 1)]\n\n# Initialize a 2D array to store the previous point for each point\nprevious_point = [[(0, 0)] * (m + 1) for _ in range(n + 1)]\n\n# Initialize the maximum length of the polyline\nmax_length = 0\n\n# Initialize the starting point of the polyline\nstart_point = (0, 0)\n\n# Iterate over each point in the grid\nfor i in range(n + 1):\n    for j in range(m + 1):\n        # Calculate the length of the polyline for the current point\n        length = polyline_length[i - 1][j - 1] + 1\n\n        # If the length is greater than the maximum length, update the maximum length and the starting point\n        if length > max_length:\n            max_length = length\n            start_point = (i, j)\n\n        # Update the previous point for the current point\n        previous_point[i][j] = (i - 1, j - 1)\n\n# Initialize the end point of the polyline\nend_point = (n, m)\n\n# Initialize the points of the polyline\npoints = [start_point]\n\n# Iterate over each point in the polyline\nwhile end_point!= start_point:\n    # Add the current point to the polyline\n    points.append(end_point)\n\n    # Update the end point to the previous point\n    end_point = previous_point[end_point[0]][end_point[1]]\n\n# Print the points of the polyline in order\nfor point in points:\n    print(point[0], point[1])"}
{"solution": "import sys\n\ndef get_smallest_n(string, substring):\n    # Convert the input string to a list of digits\n    digits = [int(digit) for digit in string]\n\n    # Initialize the smallest possible n to 0\n    n = 0\n\n    # Iterate through the digits of the input string\n    for i in range(len(digits)):\n        # If the current digit is in the substring, update n\n        if digits[i] in substring:\n            n = max(n, i)\n\n    # Return the smallest possible n\n    return n\n\n# Read the input from stdin\nstring = sys.stdin.readline().strip()\nsubstring = sys.stdin.readline().strip()\n\n# Get the smallest possible n\nn = get_smallest_n(string, substring)\n\n# Print the result\nprint(n)"}
{"solution": "n, m, min, max = map(int, input().split())\ntemperatures = list(map(int, input().split()))\n\n# Check if the temperatures are consistent\nif len(temperatures)!= m:\n    print(\"Incorrect\")\n    exit()\n\n# Check if the minimum and maximum temperatures are consistent\nif min not in temperatures or max not in temperatures:\n    print(\"Incorrect\")\n    exit()\n\n# Check if the temperatures are in the correct order\nif not all(temperatures[i] <= temperatures[i+1] for i in range(len(temperatures)-1)):\n    print(\"Incorrect\")\n    exit()\n\n# Check if the temperatures can be extended to meet the constraints\nif len(temperatures) < n:\n    print(\"Incorrect\")\n    exit()\n\n# Check if the minimum and maximum temperatures are equal to the given values\nif temperatures[0]!= min or temperatures[-1]!= max:\n    print(\"Incorrect\")\n    exit()\n\nprint(\"Correct\")"}
{"solution": "import sys\n\nm = int(sys.stdin.readline().strip())\n\n# Calculate the number of trailing zeroes in m!\nk = 0\nwhile m % 5 == 0:\n    m //= 5\n    k += 1\n\n# Print the number of values of n such that the factorial of n ends with m zeroes\nprint(k)\n\n# Print the values of n in increasing order\nfor i in range(1, k+1):\n    print(i)"}
{"solution": "import sys\n\nn, m, k = map(int, input().split())\nx = list(map(int, input().split()))\n\ngraph = {}\nfor _ in range(m):\n    u, v, w = map(int, input().split())\n    if u not in graph:\n        graph[u] = {}\n    if v not in graph:\n        graph[v] = {}\n    graph[u][v] = w\n    graph[v][u] = w\n\ndistances = [0] * k\nfor i in range(k):\n    distances[i] = max(graph[x[i]].values())\n\nprint(*distances)"}
{"solution": "n, x = map(int, input().split())\n\n# Initialize the initial position of the ball as the middle shell\ninitial_position = 1\n\n# Iterate through the number of movements made by the operator\nfor i in range(n):\n    # If the current movement is odd, swap the left shell with the middle shell\n    if i % 2 == 1:\n        initial_position = (initial_position + 1) % 3\n    # If the current movement is even, swap the middle shell with the right shell\n    else:\n        initial_position = (initial_position + 2) % 3\n\n# Print the initial position of the ball\nprint(initial_position)"}
{"solution": "import sys\n\nn = int(input())\nrectangles = []\n\nfor i in range(n):\n    x1, y1, x2, y2 = map(int, input().split())\n    rectangles.append((x1, y1, x2, y2))\n\n# Calculate the bounding box\nx_min = min(x1 for (x1, y1, x2, y2) in rectangles)\nx_max = max(x2 for (x1, y1, x2, y2) in rectangles)\ny_min = min(y1 for (x1, y1, x2, y2) in rectangles)\ny_max = max(y2 for (x1, y1, x2, y2) in rectangles)\n\n# Check if the width and height of the bounding box are equal\nif x_max - x_min!= y_max - y_min:\n    print(\"NO\")\n    sys.exit()\n\n# Check if the union of all rectangles covers the entire area of the bounding box without gaps or overlaps\ncovered_points = set()\nfor (x1, y1, x2, y2) in rectangles:\n    for x in range(x1, x2 + 1):\n        for y in range(y1, y2 + 1):\n            covered_points.add((x, y))\n\nif len(covered_points)!= (x_max - x_min + 1) * (y_max - y_min + 1):\n    print(\"NO\")\n    sys.exit()\n\n# Check for edge cases where rectangles touch at edges or corners but do not overlap\nfor i in range(n - 1):\n    for j in range(i + 1, n):\n        (x1_1, y1_1, x2_1, y2_1) = rectangles[i]\n        (x1_2, y1_2, x2_2, y2_2) = rectangles[j]\n        if (x1_1 == x1_2 and y1_1 == y1_2) or (x2_1 == x2_2 and y2_1 == y2_2):\n            print(\"NO\")\n            sys.exit()\n\nprint(\"YES\")"}
{"solution": "import sys\n\nn, s = map(int, input().split())\n\n# Initialize a counter for the number of really big numbers\ncount = 0\n\n# Iterate through all numbers up to n\nfor i in range(1, n+1):\n    # Calculate the difference between the number and its sum of digits\n    diff = i - sum(int(digit) for digit in str(i))\n    \n    # If the difference is greater than or equal to s, increment the counter\n    if diff >= s:\n        count += 1\n\nprint(count)"}
{"solution": "import sys\n\nn = int(input())\npoints = []\n\nfor i in range(n):\n    x, y = map(int, input().split())\n    points.append((x, y))\n\n# Sort the points by their x-coordinate\npoints.sort(key=lambda x: x[0])\n\n# Initialize the left and right endpoints of the lines\nleft_endpoint = points[0]\nright_endpoint = points[-1]\n\n# Initialize the number of points covered by each line\nnum_points_covered_by_left_line = 1\nnum_points_covered_by_right_line = 1\n\n# Iterate through the points and check if they can be covered by the lines\nfor i in range(1, n):\n    point = points[i]\n    if point[0] < left_endpoint[0]:\n        left_endpoint = point\n        num_points_covered_by_left_line += 1\n    elif point[0] > right_endpoint[0]:\n        right_endpoint = point\n        num_points_covered_by_right_line += 1\n    else:\n        # The point is between the left and right endpoints, so it can be covered by both lines\n        num_points_covered_by_left_line += 1\n        num_points_covered_by_right_line += 1\n\n# Check if all points are covered by at least one line\nif num_points_covered_by_left_line == n and num_points_covered_by_right_line == n:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\ndef get_possible_games(a, b, k, t):\n    # Initialize the number of possible games to 0\n    possible_games = 0\n\n    # Iterate through all possible scores for Memory and Lexa\n    for memory_score in range(a, a + k + 1):\n        for lexa_score in range(b, b + k + 1):\n            # Check if the scores are different\n            if memory_score!= lexa_score:\n                # Increment the number of possible games\n                possible_games += 1\n\n    # Return the number of possible games modulo 10^9 + 7\n    return possible_games % (10**9 + 7)\n\n# Read the input from stdin\na, b, k, t = map(int, sys.stdin.readline().split())\n\n# Get the number of possible games\npossible_games = get_possible_games(a, b, k, t)\n\n# Print the number of possible games\nprint(possible_games)"}
{"solution": "import sys\n\nn, l, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Calculate the distances between each pair of marks\ndistances = [marks[i] - marks[i-1] for i in range(1, len(marks))]\n\n# Find the minimum number of additional marks needed to measure x and y\nv = 0\nfor i in range(len(distances)):\n    if distances[i] == x or distances[i] == y:\n        v += 1\n\n# Print the minimum number of additional marks needed\nprint(v)\n\n# Print the positions of the additional marks\nfor i in range(v):\n    print(marks[i] + x)"}
{"solution": "import math\n\ndef get_max_volume(n, cakes):\n    # Sort the cakes by their heights in descending order\n    cakes.sort(key=lambda x: x[1], reverse=True)\n\n    # Initialize the maximum volume and the current volume\n    max_volume = 0\n    current_volume = 0\n\n    # Iterate through the cakes and calculate the volume of the stack\n    for i in range(n):\n        current_volume += cakes[i][0] * cakes[i][1]\n        max_volume = max(max_volume, current_volume)\n\n    return max_volume\n\nn = int(input())\ncakes = []\nfor i in range(n):\n    r, h = map(int, input().split())\n    cakes.append((r, h))\n\nprint(get_max_volume(n, cakes))"}
{"solution": "import sys\n\nn, k = map(int, input().split())\nheights = list(map(int, input().split()))\n\n# Initialize the minimum number of slices to infinity\nmin_slices = sys.maxsize\n\n# Iterate over all possible slice heights\nfor slice_height in range(1, max(heights)):\n    # Initialize the number of slices to 0\n    num_slices = 0\n\n    # Iterate over all towers\n    for tower_height in heights:\n        # If the tower height is greater than the slice height, increment the number of slices\n        if tower_height > slice_height:\n            num_slices += 1\n\n    # If the number of slices is less than or equal to k, update the minimum number of slices\n    if num_slices <= k:\n        min_slices = min(min_slices, num_slices)\n\nprint(min_slices)"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Calculate prefix sums\nprefix_sum = [0] * (n + 1)\nfor i in range(n):\n    prefix_sum[i + 1] = prefix_sum[i] + a[i]\n\nmax_score = float('-inf')\n\n# Iterate over all possible segments [l, r]\nfor l in range(n):\n    max_in_segment = float('-inf')\n    for r in range(l, n):\n        # Update the maximum value in the current segment\n        max_in_segment = max(max_in_segment, a[r])\n        # Calculate the sum of the current segment\n        segment_sum = prefix_sum[r + 1] - prefix_sum[l]\n        # Calculate the score after Bob removes the max value\n        score = segment_sum - max_in_segment\n        # Update the maximum score\n        max_score = max(max_score, score)\n\nprint(max_score)"}
{"solution": "import sys\n\ndef is_possible(k1, k2, k3):\n    # Check if k1, k2, and k3 are all positive\n    if k1 <= 0 or k2 <= 0 or k3 <= 0:\n        return False\n\n    # Check if k1, k2, and k3 are all less than or equal to 1500\n    if k1 > 1500 or k2 > 1500 or k3 > 1500:\n        return False\n\n    # Check if k1, k2, and k3 are all distinct\n    if k1 == k2 or k1 == k3 or k2 == k3:\n        return False\n\n    # Check if there is a way to choose x1, x2, and x3 such that each second after switching the garlands on at least one garland will be lit\n    x1 = 1\n    x2 = 2\n    x3 = 1\n    while x1 < k1 or x2 < k2 or x3 < k3:\n        if x1 < k1:\n            x1 += 1\n        if x2 < k2:\n            x2 += 1\n        if x3 < k3:\n            x3 += 1\n        if x1 == k1 and x2 == k2 and x3 == k3:\n            return True\n    return False\n\nif __name__ == \"__main__\":\n    k1, k2, k3 = map(int, sys.stdin.readline().split())\n    print(\"YES\" if is_possible(k1, k2, k3) else \"NO\")"}
{"solution": "def min_operations_to_delete_string(n, s):\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(n)]\n    \n    # Base case: single character substrings\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Fill the DP table for substrings of length greater than 1\n    for length in range(2, n + 1):  # length of the substring\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                dp[i][j] = dp[i][j-1]\n            else:\n                dp[i][j] = float('inf')\n                for k in range(i, j):\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n    \n    # The result for the entire string\n    return dp[0][n-1]\n\n# Example usage\nn = int(input())\ns = input().strip()\nprint(min_operations_to_delete_string(n, s))"}
{"solution": "def get_max_pairs(n, a, m, b):\n    pairs = []\n    for i in range(n):\n        for j in range(m):\n            if abs(a[i] - b[j]) <= 1:\n                pairs.append((i, j))\n    return len(pairs)"}
{"solution": "def determine_winner(a, b, c, d):\n    # Calculate the defence and attack skills of each team\n    team_1_defence = a + b\n    team_1_attack = c + d\n    team_2_defence = a + c\n    team_2_attack = b + d\n\n    # Check if one team is guaranteed to win\n    if team_1_defence > team_2_attack and team_1_attack > team_2_defence:\n        return \"Team 1\"\n    elif team_2_defence > team_1_attack and team_2_attack > team_1_defence:\n        return \"Team 2\"\n    else:\n        return \"Draw\""}
{"solution": "import math\n\ndef solve(N, K, x, y, c):\n    # Calculate the distance between the heat source and each piece of meat\n    distances = [(math.sqrt((x - x_i) ** 2 + (y - y_i) ** 2), c_i) for x_i, y_i, c_i in zip(x, y, c)]\n\n    # Sort the distances in ascending order\n    distances.sort(key=lambda x: x[0])\n\n    # Initialize the time required to have K or more pieces of meat ready\n    time_required = 0\n\n    # Iterate through the sorted distances\n    for distance, hardness in distances:\n        # Calculate the time required to grill the current piece of meat\n        time_required += hardness * distance\n\n        # If the time required to have K or more pieces of meat ready is less than the current time, return the current time\n        if time_required >= K:\n            return time_required\n\n    # If all pieces of meat are ready, return the total time required\n    return time_required\n\n# Test case 1\nN = 4\nK = 3\nx = [-1, 0, 1, 1]\ny = [0, 0, 0, 1]\nc = [3, 3, 2, 40]\nprint(solve(N, K, x, y, c))\n\n# Test case 2\nN = 60\nK = 30\nx = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\ny = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nc = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nprint(solve(N, K, x, y, c))"}
{"solution": "import sys\n\nn = int(input())\nticket = input()\n\n# Replace erased digits with 0\nticket = ticket.replace(\"?\", \"0\")\n\n# Calculate the sum of the first half of the ticket\nfirst_half_sum = sum(int(digit) for digit in ticket[:n//2])\n\n# Calculate the sum of the second half of the ticket\nsecond_half_sum = sum(int(digit) for digit in ticket[n//2:])\n\n# Check if the ticket is happy\nif first_half_sum == second_half_sum:\n    print(\"Bicarp\")\nelse:\n    print(\"Monocarp\")"}
{"solution": "def find_bus_route(n, t, bus_routes):\n    earliest_time = float('inf')\n    chosen_route = -1\n    \n    for i in range(n):\n        s_i, d_i = bus_routes[i]\n        \n        if s_i >= t:\n            next_bus_time = s_i\n        else:\n            # Calculate the next bus time after t\n            if (t - s_i) % d_i == 0:\n                next_bus_time = t\n            else:\n                next_bus_time = s_i + ((t - s_i) // d_i + 1) * d_i\n        \n        if next_bus_time < earliest_time:\n            earliest_time = next_bus_time\n            chosen_route = i + 1\n    \n    return chosen_route"}
{"solution": "import sys\n\ndef solve(m, k):\n    # Initialize variables\n    n = 1\n    count = 0\n\n    # Iterate through numbers from n + 1 to 2n\n    for i in range(n + 1, 2 * n + 1):\n        # Count the number of digits in the binary representation of i\n        binary_repr = bin(i)[2:]\n        count += binary_repr.count('1')\n\n        # If the number of digits is equal to k, increment n\n        if count == k:\n            n += 1\n            count = 0\n\n    # Return the final value of n\n    return n\n\n# Read input from stdin\nm, k = map(int, sys.stdin.readline().split())\n\n# Print the output to stdout\nprint(solve(m, k))"}
{"solution": "import sys\n\nn = int(input())\nlevel = input()\n\n# Check if the level is good\nif len(level) == n and level.count('*') == n:\n    # Check if there is a sequence of four jumps of the same length\n    for i in range(n - 3):\n        if level[i] == '*' and level[i + 1] == '*' and level[i + 2] == '*' and level[i + 3] == '*':\n            print(\"yes\")\n            sys.exit()\n\nprint(\"no\")"}
{"solution": "n = int(input())\ngrid = []\nfor i in range(n):\n    grid.append(list(map(int, input().split())))\n\n# Check if the grid is a magic square\nif not is_magic_square(grid):\n    print(-1)\n    exit()\n\n# Find the missing number\nmissing_number = find_missing_number(grid)\n\n# Fill in the missing number\ngrid[missing_number[0]][missing_number[1]] = missing_number[2]\n\n# Print the result\nprint(grid)\n\ndef is_magic_square(grid):\n    # Check if the grid is a square\n    if len(grid)!= len(grid[0]):\n        return False\n    \n    # Check if the grid is a magic square\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j]!= grid[i][0] + j:\n                return False\n    \n    return True\n\ndef find_missing_number(grid):\n    # Find the missing number\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 0:\n                return (i, j, grid[i][j-1] + 1)\n    \n    return None"}
{"solution": "n, m = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculate the maximum possible k\nmax_k = max(a) + m\n\n# Calculate the total number of people after adding m people\ntotal_people = sum(a) + m\n\n# Calculate the minimum possible k\nmin_k = ceil(total_people / n)\n\nprint(min_k, max_k)"}
{"solution": "import sys\n\nn, m = map(int, input().split())\n\n# Initialize a 2D array to store the number of ways to assign tickets\nways = [[0] * (n + 1) for _ in range(m + 1)]\n\n# Base case: when there are no passengers or no seats\nways[0][0] = 1\n\n# Iterate over the number of passengers\nfor i in range(1, m + 1):\n    # Iterate over the number of seats\n    for j in range(1, n + 1):\n        # If the seat is empty, the number of ways to assign tickets is the same as the previous seat\n        if j == 1:\n            ways[i][j] = ways[i - 1][j]\n        # If the seat is occupied, the number of ways to assign tickets is the sum of the previous seat and the previous passenger\n        else:\n            ways[i][j] = (ways[i - 1][j - 1] + ways[i - 1][j]) % (10 ** 9 + 7)\n\n# Print the number of ways to assign tickets modulo 10^9 + 7\nprint(ways[m][n] % (10 ** 9 + 7))"}
{"solution": "import itertools\n\ndef get_pizza_combinations(n, m, friends, pizzas):\n    # Initialize an empty list to store the combinations\n    combinations = []\n\n    # Iterate over each friend and their favorite ingredients\n    for friend in friends:\n        # Get the favorite ingredients of the current friend\n        favorite_ingredients = friend[1]\n\n        # Iterate over each pizza and its ingredients\n        for pizza in pizzas:\n            # Get the ingredients of the current pizza\n            pizza_ingredients = pizza[1]\n\n            # Check if the current pizza satisfies the current friend's preferences\n            if set(favorite_ingredients).issubset(pizza_ingredients):\n                # Add the current pizza to the combinations list\n                combinations.append((friend[0], pizza[0]))\n\n    # Return the combinations list\n    return combinations\n\ndef get_optimal_combination(combinations):\n    # Initialize the optimal combination as the first element in the combinations list\n    optimal_combination = combinations[0]\n\n    # Iterate over each combination in the combinations list\n    for combination in combinations:\n        # Check if the current combination has more favorite ingredients than the current optimal combination\n        if len(combination[1]) > len(optimal_combination[1]):\n            # Update the optimal combination to the current combination\n            optimal_combination = combination\n\n    # Return the optimal combination\n    return optimal_combination\n\ndef main():\n    # Read the input from stdin\n    n, m = map(int, input().split())\n    friends = [tuple(map(int, input().split())) for _ in range(n)]\n    pizzas = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Get the combinations of pizzas that satisfy each friend's preferences\n    combinations = get_pizza_combinations(n, m, friends, pizzas)\n\n    # Get the optimal combination of pizzas that satisfies the maximum number of friends' preferences\n    optimal_combination = get_optimal_combination(combinations)\n\n    # Print the indices of the optimal combination\n    print(optimal_combination[0], optimal_combination[1])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_smallest_largest_numbers(m, s):\n    smallest = -1\n    largest = -1\n    for i in range(10**(m-1), 10**m):\n        if len(str(i)) == m and sum(int(j) for j in str(i)) == s:\n            smallest = i\n            break\n    for i in range(10**m, 10**(m+1)):\n        if len(str(i)) == m and sum(int(j) for j in str(i)) == s:\n            largest = i\n            break\n    return smallest, largest\n\nm = int(input())\ns = int(input())\nsmallest, largest = find_smallest_largest_numbers(m, s)\nprint(smallest, largest)"}
{"solution": "import sys\n\ndef solve(l, r, k):\n    # Initialize the sum to 0\n    sum = 0\n\n    # Iterate from l to r\n    for i in range(l, r+1):\n        # Check if the number of digits in i is less than or equal to k\n        if len(str(i)) <= k:\n            # Add i to the sum\n            sum += i\n\n    # Return the sum modulo 998244353\n    return sum % 998244353\n\n# Read the input from stdin\nl, r, k = map(int, input().split())\n\n# Solve the problem\nresult = solve(l, r, k)\n\n# Print the result\nprint(result)"}
{"solution": "import sys\n\nn, k, d = map(int, input().split())\na = list(map(int, input().split()))\n\n# Check if it is possible to distribute all pencils into boxes\nif len(a) < k:\n    print(\"NO\")\n    sys.exit()\n\n# Sort the pencils by saturation\na.sort()\n\n# Initialize the number of boxes and the current box size\nnum_boxes = 1\nbox_size = 0\n\n# Iterate through the pencils and distribute them into boxes\nfor i in range(len(a)):\n    # If the current box size is less than k, add the current pencil to the current box\n    if box_size < k:\n        box_size += 1\n        continue\n    \n    # If the current box size is greater than k, create a new box and add the current pencil to it\n    num_boxes += 1\n    box_size = 1\n\n# Check if the last box is empty\nif box_size == 0:\n    num_boxes -= 1\n\n# Print the result\nif num_boxes == 1:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def count_dead_light_bulbs(s):\n    colors = ['R', 'B', 'Y', 'G']\n    dead_bulbs = {color: 0 for color in colors}\n\n    for i in range(len(s)):\n        if s[i] == '!':\n            dead_bulbs[s[i-1]] += 1\n\n    return''.join(str(dead_bulbs[color]) for color in colors)"}
{"solution": "import sys\n\ndef solve(N, M, s_i, t_i):\n    # Initialize the expected number of passages\n    E = 0\n\n    # Loop through each passage\n    for i in range(M):\n        # If the passage is not blocked\n        if s_i[i]!= t_i[i]:\n            # Calculate the probability of taking this passage\n            prob = 1 / (N - 1)\n\n            # Add the probability to the expected number of passages\n            E += prob\n\n    # Return the expected number of passages\n    return E\n\n# Read the input from stdin\nN, M = map(int, input().split())\ns_i = list(map(int, input().split()))\nt_i = list(map(int, input().split()))\n\n# Solve the problem\nE = solve(N, M, s_i, t_i)\n\n# Print the output to stdout\nprint(E)"}
{"solution": "n = int(input())\n\nif n % 10 == 0:\n    print(n)\nelse:\n    lower_multiple = n // 10 * 10\n    higher_multiple = (n // 10 + 1) * 10\n    if abs(n - lower_multiple) < abs(n - higher_multiple):\n        print(lower_multiple)\n    else:\n        print(higher_multiple)"}
{"solution": "def find_swaps(s, t):\n    if len(s)!= len(t):\n        return -1\n    \n    mismatches = {}\n    \n    for i in range(len(s)):\n        if s[i]!= t[i]:\n            if s[i] in mismatches and mismatches[s[i]]!= t[i]:\n                return -1\n            if t[i] in mismatches and mismatches[t[i]]!= s[i]:\n                return -1\n            mismatches[s[i]] = t[i]\n            mismatches[t[i]] = s[i]\n    \n    visited = set()\n    swaps = []\n    \n    for key in mismatches:\n        if key not in visited:\n            cycle = []\n            current = key\n            while current not in visited:\n                visited.add(current)\n                cycle.append(current)\n                current = mismatches[current]\n            if len(cycle)!= 2:\n                return -1\n            swaps.append((cycle[0], cycle[1]))\n    \n    print(len(swaps))\n    for swap in swaps:\n        print(swap[0], swap[1])"}
{"solution": "def get_alphabetically_earliest_login(first_name, last_name):\n    # Identify prefixes of first and last names\n    first_name_prefixes = [first_name[i:] for i in range(len(first_name))]\n    last_name_prefixes = [last_name[i:] for i in range(len(last_name))]\n\n    # Generate combinations of prefixes\n    combinations = []\n    for first_prefix in first_name_prefixes:\n        for last_prefix in last_name_prefixes:\n            combinations.append(first_prefix + last_prefix)\n\n    # Compare combinations alphabetically and return the earliest one\n    combinations.sort()\n    return combinations[0]"}
{"solution": "import sys\n\nn = int(input())\nsequence = input()\n\n# Initialize the output string\noutput = \"\"\n\n# Iterate through the sequence and draw the brackets\nfor i in range(n):\n    if sequence[i] == \"[\":\n        output += \"+\"\n    else:\n        output += \"-\"\n\n# Add the vertical bars\nfor i in range(n-1):\n    if sequence[i] == \"[\" and sequence[i+1] == \"]\":\n        output += \"|\"\n\n# Add the spaces between pairs of brackets\nfor i in range(n-2):\n    if sequence[i] == \"[\" and sequence[i+2] == \"]\":\n        output += \" \"\n\n# Add the final vertical bar\noutput += \"|\"\n\n# Print the output\nprint(output)"}
{"solution": "def compare_golden_numbers(num1, num2):\n    # Normalize both numbers\n    norm_num1 = normalize_golden_number(num1)\n    norm_num2 = normalize_golden_number(num2)\n    \n    # Compare lengths first\n    if len(norm_num1) > len(norm_num2):\n        return \">\"\n    elif len(norm_num1) < len(norm_num2):\n        return \"<\"\n    \n    # If lengths are equal, compare digit by digit\n    for digit1, digit2 in zip(norm_num1, norm_num2):\n        if digit1 > digit2:\n            return \">\"\n        elif digit1 < digit2:\n            return \"<\"\n    \n    # If all digits are equal\n    return \"=\"\n\n# Read input\nnum1 = input().strip()\nnum2 = input().strip()\n\n# Compare the numbers and print the result\nresult = compare_golden_numbers(num1, num2)\nprint(result)"}
{"solution": "n = int(input())\ncolors = []\nfor i in range(n):\n    colors.append(input().lower())\n\nabsent_gems = []\nfor gem in [\"power\", \"time\", \"space\", \"soul\", \"reality\", \"mind\"]:\n    if gem.lower() not in colors:\n        absent_gems.append(gem)\n\nprint(len(absent_gems))\nfor gem in absent_gems:\n    print(gem.title())"}
{"solution": "import sys\n\nn, a, b = map(int, sys.stdin.readline().split())\n\nif a == b:\n    print(\"Final!\")\nelse:\n    for i in range(1, n):\n        if (a - 1) // (i // 2) == (b - 1) // (i // 2):\n            print(i)\n            break\n    else:\n        print(\"Final!\")"}
{"solution": "import sys\n\nn = int(input())\np = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Initialize the minimum number of changes required\nmin_changes = 0\n\n# Initialize the permutation and sequence\nperm = p[:]\nseq = b[:]\n\n# Iterate through each skewer\nfor i in range(n):\n    # If the skewer is not in its original position, move it to its original position\n    if perm[i]!= i + 1:\n        perm[i] = i + 1\n        min_changes += 1\n\n    # If the skewer is not in its reversed position, move it to its reversed position\n    if seq[i] == 1 and perm[i]!= n - i:\n        perm[i] = n - i\n        min_changes += 1\n\n# Print the minimum number of changes required\nprint(min_changes)"}
{"solution": ""}
{"solution": "import sys\n\ndef solve(N, M, w, l, v):\n    # Initialize variables\n    camels = [Camel(i, w[i-1]) for i in range(1, N+1)]\n    parts = [Part(i, l[i-1], v[i-1]) for i in range(1, M+1)]\n    distances = [0] * (N-1)\n    min_distance = sys.maxsize\n\n    # Iterate through all possible arrangements of camels\n    for arrangement in itertools.permutations(camels):\n        # Calculate the distance between each adjacent pair of camels\n        for i in range(N-1):\n            distances[i] = arrangement[i+1].position - arrangement[i].position\n\n        # Check if the bridge will collapse\n        if not check_collapse(parts, distances):\n            # If the bridge does not collapse, calculate the minimum distance between the first and last camels\n            min_distance = min(min_distance, distances[0] + distances[-1])\n\n    # Print the minimum distance between the first and last camels\n    print(min_distance)\n\ndef check_collapse(parts, distances):\n    # Iterate through each part of the bridge\n    for part in parts:\n        # Calculate the sum of the weights of camels inside the part\n        weight = sum(camel.weight for camel in part.camels)\n\n        # Check if the sum of the weights exceeds the weight capacity of the part\n        if weight > part.weight_capacity:\n            return True\n\n    return False\n\nclass Camel:\n    def __init__(self, id, weight):\n        self.id = id\n        self.weight = weight\n        self.position = 0\n\nclass Part:\n    def __init__(self, id, length, weight_capacity):\n        self.id = id\n        self.length = length\n        self.weight_capacity = weight_capacity\n        self.camels = []\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    w = list(map(int, input().split()))\n    l = list(map(int, input().split()))\n    v = list(map(int, input().split()))\n    solve(N, M, w, l, v)"}
{"solution": "import math\n\ndef get_last_digit(a, b):\n    factorial_a = math.factorial(a)\n    factorial_b = math.factorial(b)\n    quotient = factorial_b // factorial_a\n    return str(quotient)[-1]\n\na, b = map(int, input().split())\nprint(get_last_digit(a, b))"}
{"solution": "def frog_jumps(n, d, s):\n    # Initialize the queue with the starting point (1) and set the number of jumps to 0\n    queue = [(1, 0)]\n\n    # Initialize the visited array to keep track of the points that have been visited\n    visited = [False] * (n + 1)\n\n    # Loop until the queue is empty\n    while queue:\n        # Dequeue the front element\n        current_position, current_jumps = queue.pop(0)\n\n        # Check if the current position is the destination point (n)\n        if current_position == n:\n            return current_jumps + 1\n\n        # For each possible jump from the current position (from 1 to d), check if the destination point has a lily and has not been visited\n        for jump_length in range(1, d + 1):\n            destination_position = current_position + jump_length\n\n            # If the destination position is within the bounds of the string and there is a lily in that position\n            if 1 <= destination_position <= n and s[destination_position - 1] == \"1\":\n                # If the destination position has not been visited, add it to the queue and mark it as visited\n                if not visited[destination_position]:\n                    queue.append((destination_position, current_jumps + 1))\n                    visited[destination_position] = True\n\n    # If the queue is empty and the frog has not reached the destination point, return -1\n    return -1"}
{"solution": "n = int(input())\n\nfor m in range(1, 1001):\n    if not is_prime(n * m + 1):\n        print(m)\n        break\nelse:\n    print(-1)"}
{"solution": "n = int(input())\n\n# Check if n is a multiple of 1234\nif n % 1234 == 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\nn = int(input())\nx1, x2 = map(int, input().split())\nlines = []\n\nfor i in range(n):\n    k, b = map(int, input().split())\n    lines.append((k, b))\n\n# Check if there are any intersections of two distinct lines\n# located strictly inside the strip\nfor i in range(n):\n    for j in range(i+1, n):\n        k1, b1 = lines[i]\n        k2, b2 = lines[j]\n        if k1!= k2 and b1!= b2:\n            continue\n        x = (b2 - b1) / (k1 - k2)\n        if x1 < x < x2:\n            print(\"YES\")\n            sys.exit()\n\nprint(\"NO\")"}
{"solution": "import sys\n\nn = int(sys.stdin.readline().strip())\n\n# Initialize a dictionary to store the weights of the splits\nweights = {}\n\n# Iterate through all possible splits of n\nfor i in range(1, n + 1):\n    for j in range(i, n + 1):\n        # Check if the current split is a valid split of n\n        if i + j == n:\n            # Get the weight of the current split\n            weight = 1\n            for k in range(i, j):\n                if i == k:\n                    weight += 1\n            # Add the weight to the dictionary\n            weights[weight] = weights.get(weight, 0) + 1\n\n# Print the number of different weights of splits\nprint(len(weights))"}
{"solution": "def find_good_apartments(n, k):\n    if k == 0:\n        min_good = 0\n        max_good = 0\n    else:\n        min_good = 1\n        max_good = min(n - k, 2 * k)\n    \n    return min_good, max_good\n\nn, k = map(int, input().split())\nmin_good, max_good = find_good_apartments(n, k)\nprint(min_good, max_good)"}
{"solution": "  import math\n\ndef get_max_games(n):\n    return math.floor(math.log2(n))\n\nn = int(input())\nprint(get_max_games(n))"}
{"solution": "def solve(s):\n    vk_count = 0\n    for i in range(len(s) - 1):\n        if s[i] == \"V\" and s[i + 1] == \"K\":\n            vk_count += 1\n    return vk_count"}
{"solution": "  import math\n\ndef min_segments(n):\n    a = int(math.sqrt(n))\n    b = (n + a - 1) // a  # This is equivalent to math.ceil(n / a)\n    return a + b + 2\n\n# Read input\nn = int(input().strip())\nprint(min_segments(n))"}
{"solution": "  # Python code to solve the problem\n\ndef solve(a, b):\n    years = 0\n    while a <= b:\n        a *= 3\n        b *= 2\n        years += 1\n    return years\n\n# Test the code\na = 4\nb = 7\nprint(solve(a, b))\n\na = 4\nb = 9\nprint(solve(a, b))\n\na = 1\nb = 1\nprint(solve(a, b))\n\n# Output\n2\n3\n1\n"}
{"solution": "def solve(h, n):\n    # Initialize variables\n    visited_nodes = set()\n    current_node = 1\n    skipped_commands = 0\n\n    # Iterate through the command string\n    for command in \"LRLRLRLRL...\":\n        # If the current node is not the exit, move to the left or right child\n        if current_node!= n:\n            if command == \"L\":\n                current_node = current_node * 2\n            else:\n                current_node = current_node * 2 + 1\n\n        # If the current node is the exit, return the number of visited nodes\n        if current_node == n:\n            return len(visited_nodes)\n\n        # If the current node is already visited, skip the command\n        if current_node in visited_nodes:\n            skipped_commands += 1\n            continue\n\n        # Add the current node to the set of visited nodes\n        visited_nodes.add(current_node)\n\n        # If two consecutive commands are skipped, go back to the parent node\n        if skipped_commands == 2:\n            current_node = current_node // 2\n            skipped_commands = 0\n\n    # If the exit is not found, return the number of visited nodes\n    return len(visited_nodes)"}
{"solution": "import math\n\ndef find_distinct_squares(x):\n    k = 0\n    for n in range(1, math.ceil(math.sqrt(x)) + 1):\n        for m in range(1, math.ceil(math.sqrt(x)) + 1):\n            if n * m == x:\n                k += 1\n                print(n, m)\n    return k\n\nx = int(input())\nk = find_distinct_squares(x)\nprint(k)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Check if the sum of the days in the months is equal to the given number\nif sum(a) == n:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\nn = int(sys.stdin.readline().strip())\n\nif n < 2 or n > 10**9:\n    print(\"NO\")\n    sys.exit()\n\n# Initialize the sequence with the first fraction\na = 1\nb = n\nk = 1\n\n# Iterate until the sum of the fractions is 1 - 1/n\nwhile a/b!= 1 - 1/n:\n    # Find the next fraction\n    a += 1\n    b += 1\n    k += 1\n\n# Print the sequence\nprint(\"YES\")\nprint(k)\nfor i in range(k):\n    print(f\"{a/b}\")"}
{"solution": "import sys\n\nn, a, b = map(int, input().split())\nheights = list(map(int, input().split()))\n\n# Initialize the minimum unattractiveness value to -1\nmin_unattractiveness = -1\n\n# Loop through each board and check if it can be painted red or green\nfor i in range(n):\n    # If the board can be painted red, check if it is the first or last board\n    if heights[i] <= a:\n        # If it is the first or last board, set the unattractiveness value to 0\n        if i == 0 or i == n - 1:\n            min_unattractiveness = 0\n        # If it is not the first or last board, check if the previous and next boards are the same color\n        else:\n            if heights[i - 1] == heights[i + 1]:\n                min_unattractiveness = 0\n    # If the board can be painted green, check if it is the first or last board\n    elif heights[i] <= b:\n        # If it is the first or last board, set the unattractiveness value to 0\n        if i == 0 or i == n - 1:\n            min_unattractiveness = 0\n        # If it is not the first or last board, check if the previous and next boards are the same color\n        else:\n            if heights[i - 1] == heights[i + 1]:\n                min_unattractiveness = 0\n\n# Print the minimum unattractiveness value\nprint(min_unattractiveness)"}
{"solution": "import math\n\ndef find_triangle_points(n, m, k):\n    # Calculate the area of the triangle\n    area = n * m / k\n\n    # Find the points that form the triangle\n    for x1 in range(n + 1):\n        for y1 in range(m + 1):\n            for x2 in range(x1 + 1, n + 1):\n                for y2 in range(y1 + 1, m + 1):\n                    for x3 in range(x2 + 1, n + 1):\n                        for y3 in range(y2 + 1, m + 1):\n                            if (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) == 0:\n                                return \"YES\", x1, y1, x2, y2, x3, y3\n\n    return \"NO\"\n\nn, m, k = map(int, input().split())\nprint(find_triangle_points(n, m, k))"}
{"solution": "import sys\n\nn, k = map(int, input().split())\n\nif n < k:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Initialize the counts for each muscle group\nchest_count = 0\nbiceps_count = 0\nback_count = 0\n\n# Iterate through the list of exercises and increment the corresponding count\nfor i in range(n):\n    if i % 3 == 0:\n        chest_count += a[i]\n    elif i % 3 == 1:\n        biceps_count += a[i]\n    else:\n        back_count += a[i]\n\n# Determine which muscle group has the most repetitions\nif chest_count > biceps_count and chest_count > back_count:\n    print(\"chest\")\nelif biceps_count > chest_count and biceps_count > back_count:\n    print(\"biceps\")\nelse:\n    print(\"back\")"}
{"solution": "n = int(input())\ngrades = list(map(int, input().split()))\n\ncurrent_sum = sum(grades)\ntarget_sum = n * 4.5\n\nif current_sum >= target_sum:\n    print(0)\nelse:\n    grades.sort()\n    redos = 0\n\n    for grade in grades:\n        if current_sum >= target_sum:\n            break\n        current_sum += (5 - grade)\n        redos += 1\n\n    print(redos)"}
{"solution": "import sys\n\ndef solve(u, v):\n    # Initialize the array with the first element\n    arr = [u]\n    # Loop until the sum of the elements is equal to v\n    while sum(arr)!= v:\n        # Add the next element to the array\n        arr.append(u)\n        # XOR the elements of the array\n        xor = 0\n        for i in range(len(arr)):\n            xor ^= arr[i]\n        # If the XOR is not equal to u, then the array is not valid\n        if xor!= u:\n            return -1\n    # Return the array\n    return arr\n\nif __name__ == \"__main__\":\n    u, v = map(int, sys.stdin.readline().split())\n    print(solve(u, v))"}
{"solution": "n = int(input())\n\n# Initialize the number of digits 1 to 0\nnum_ones = 0\n\n# Initialize the sum to 0\nsum = 0\n\n# Iterate through the digits of n\nfor digit in str(n):\n    # If the digit is 1, increment the number of digits 1\n    if digit == '1':\n        num_ones += 1\n    # If the digit is not 1, add it to the sum\n    else:\n        sum += int(digit)\n\n# Print the expected minimal number of digits 1\nprint(num_ones)"}
{"solution": "def can_reach_treasure(x1, y1, x2, y2, x, y):\n    # Check if the starting position is the same as the ending position\n    if x1 == x2 and y1 == y2:\n        return \"YES\"\n    \n    # Check if the potion can be used to reach the treasure\n    for i in range(4):\n        new_x = x1 + x if i % 2 == 0 else x1 - x\n        new_y = y1 + y if i % 2 == 1 else y1 - y\n        if new_x == x2 and new_y == y2:\n            return \"YES\"\n    \n    # If the potion cannot be used to reach the treasure, return \"NO\"\n    return \"NO\""}
{"solution": "import itertools\n\ndef count_valid_bus_numbers(n):\n    # Convert the number to a string to extract digits\n    digits = list(str(n))\n    \n    # Generate all unique permutations of the digits\n    all_permutations = set(itertools.permutations(digits))\n    \n    # Filter out permutations that start with '0'\n    valid_permutations = set()\n    for perm in all_permutations:\n        if perm[0]!= '0':\n            valid_permutations.add(perm)\n    \n    # Return the count of valid permutations\n    return len(valid_permutations)\n\n# Read input\nn = int(input().strip())\n\n# Get the count of valid bus numbers\nresult = count_valid_bus_numbers(n)\n\n# Print the result\nprint(result)"}
{"solution": "import sys\n\na, b, c, d, e, f = map(int, sys.stdin.readline().split())\n\n# Calculate the maximum number of suits of each type that can be made\nmax_suits_1 = a // 2\nmax_suits_2 = (b + c + d) // 3\n\n# Calculate the total cost of each type of suit\ncost_1 = e * max_suits_1\ncost_2 = f * max_suits_2\n\n# Calculate the maximum total cost of some set of suits\nmax_cost = max(cost_1, cost_2)\n\nprint(max_cost)"}
{"solution": "import sys\n\ndef solve(x, a, b, p):\n    count = 0\n    for n in range(1, x+1):\n        if pow(a, n, p) == b:\n            count += 1\n    return count\n\nif __name__ == \"__main__\":\n    x, a, b, p = map(int, sys.stdin.readline().split())\n    print(solve(x, a, b, p))"}
{"solution": "import sys\n\ndef get_max_sum(k2, k3, k5, k6):\n    # Initialize variables\n    sum = 0\n    used_digits = [False] * 10\n\n    # Iterate through the digits and calculate the sum\n    for i in range(10):\n        if i == 2:\n            sum += k2 * 2\n            used_digits[2] = True\n        elif i == 3:\n            sum += k3 * 3\n            used_digits[3] = True\n        elif i == 5:\n            sum += k5 * 5\n            used_digits[5] = True\n        elif i == 6:\n            sum += k6 * 6\n            used_digits[6] = True\n\n    # Print the maximum sum\n    print(sum)\n\n# Read the input\nk2, k3, k5, k6 = map(int, sys.stdin.readline().split())\n\n# Calculate the maximum sum\nget_max_sum(k2, k3, k5, k6)"}
{"solution": "import sys\n\nn, x, y, c = map(int, sys.stdin.readline().split())\n\n# Initialize the grid with the initial cell switched on\ngrid = [[0] * n for _ in range(n)]\ngrid[x - 1][y - 1] = 1\n\n# Simulate the propagation process\nfor i in range(n * n):\n    # Check if the condition is met\n    if sum(sum(row) for row in grid) >= c:\n        break\n    \n    # Switch on the cells that are off but have the side-adjacent cells that are on\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 0 and any(grid[i - 1][j], grid[i + 1][j], grid[i][j - 1], grid[i][j + 1]):\n                grid[i][j] = 1\n\n# Print the answer\nprint(i)"}
{"solution": "import sys\n\ndef get_max_xor(l, r):\n    max_xor = 0\n    for a in range(l, r+1):\n        for b in range(a, r+1):\n            xor = a ^ b\n            if xor > max_xor:\n                max_xor = xor\n    return max_xor\n\nif __name__ == \"__main__\":\n    l, r = map(int, input().split())\n    print(get_max_xor(l, r))"}
{"solution": "def minimum_height(n, k):\n    left, right = 1, k\n    while left < right:\n        mid = (left + right) // 2\n        if n * mid >= k:\n            right = mid\n        else:\n            left = mid + 1\n    return left"}
{"solution": "def should_use_elevator(x, y, z, t1, t2, t3):\n    stairs_time = abs(x - y) * t1\n    elevator_to_masha_time = abs(z - x) * t2 + t3\n    elevator_to_egor_time = abs(x - y) * t2 + 2 * t3\n    elevator_time = elevator_to_masha_time + elevator_to_egor_time\n    if stairs_time < elevator_time:\n        return \"NO\"\n    else:\n        return \"YES\"\n\n# Example usage:\nx, y, z, t1, t2, t3 = map(int, input().split())\nprint(should_use_elevator(x, y, z, t1, t2, t3))"}
{"solution": "import random\n\ndef get_a(n, m):\n    # Initialize the probability of winning for each value of a\n    probabilities = [0] * (n + 1)\n\n    # Iterate over all possible values of c\n    for c in range(1, n + 1):\n        # Calculate the distance between c and m\n        distance = abs(c - m)\n\n        # Calculate the probability of winning for each value of a\n        for a in range(1, n + 1):\n            # Calculate the distance between c and a\n            distance_a = abs(c - a)\n\n            # If the distance between c and a is less than the distance between c and m, increment the probability of winning for that value of a\n            if distance_a < distance:\n                probabilities[a] += 1\n\n    # Return the value of a with the highest probability of winning\n    return probabilities.index(max(probabilities))\n\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    print(get_a(n, m))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Initialize variables\npairs_at_university = 0\npairs_at_home = 0\n\n# Iterate through the list of pairs\nfor i in range(n):\n    # If Alena has the i-th pair and it is not a break\n    if a[i] == 1 and i % 2 == 0:\n        # Increment the number of pairs at the university\n        pairs_at_university += 1\n    # If Alena has the i-th pair and it is a break\n    elif a[i] == 1 and i % 2 == 1:\n        # Increment the number of pairs at home\n        pairs_at_home += 1\n\n# Print the number of pairs at the university\nprint(pairs_at_university)"}
{"solution": "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Initialize the minimum number of days to give Bran k candies\nmin_days = -1\n\n# Iterate through each day\nfor i in range(n):\n    # If Arya has enough candies to give Bran k candies on this day\n    if a[i] >= k:\n        # Update the minimum number of days to give Bran k candies\n        min_days = i\n        break\n\n# If Arya can't give Bran k candies within n days\nif min_days == -1:\n    print(-1)\n# Otherwise, print the minimum number of days to give Bran k candies\nelse:\n    print(min_days)"}
{"solution": "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\nadditional_walks = 0\nb = a[:]\n\nfor i in range(n - 1):\n    if b[i] + b[i + 1] < k:\n        needed_walks = k - (b[i] + b[i + 1])\n        b[i + 1] += needed_walks\n        additional_walks += needed_walks\n\nprint(additional_walks)\nprint(' '.join(map(str, b)))"}
{"solution": "n = int(input())\n\n# Calculate the number of cells in the rhombus\ncells = 0\nfor i in range(1, n+1):\n    cells += i * (i + 1) // 2\n\nprint(cells)"}
{"solution": "import set\n\ndef is_pangram(string):\n    # Convert the string to a consistent case\n    string = string.lower()\n\n    # Create a set to track the unique letters found in the string\n    letters = set()\n\n    # Iterate through the string and add each letter to the set\n    for char in string:\n        letters.add(char)\n\n    # Check if the set contains all 26 letters of the alphabet\n    if len(letters) == 26:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Test the solution with various inputs\nprint(is_pangram(\"toosmallword\"))  # NO\nprint(is_pangram(\"TheQuickBrownFoxJumpsOverTheLazyDog\"))  # YES"}
{"solution": "def calculate_time(current_time, minutes):\n    hours, minutes = current_time.split(\":\")\n    hours = int(hours)\n    minutes = int(minutes)\n    minutes += minutes\n    hours += int(minutes / 60)\n    minutes %= 60\n    return f\"{hours:02d}:{minutes:02d}\""}
{"solution": "import sys\n\nn, m = map(int, input().split())\nmatrix = [list(map(int, input().strip())) for _ in range(n)]\n\n# Initialize a set to store the indices of the switches that are not used\nunused_switches = set(range(n))\n\n# Iterate over each lamp and check if it can be turned on by pressing all n - 1 switches\nfor lamp in range(m):\n    # Check if the lamp is turned on by any of the n switches\n    if any(matrix[switch][lamp] for switch in range(n)):\n        # If the lamp is turned on, remove the switches that are connected to it from the set of unused switches\n        unused_switches -= set(switch for switch in range(n) if matrix[switch][lamp])\n\n# Check if there is at least one switch that is not used\nif len(unused_switches) < n - 1:\n    print(\"NO\")\nelse:\n    print(\"YES\")"}
{"solution": "n = int(input())\n\n# Initialize the sums of the upper and lower halves\nupper_sum = 0\nlower_sum = 0\n\n# Iterate through each domino piece\nfor i in range(n):\n    # Get the numbers written on the upper and lower halves\n    x, y = map(int, input().split())\n    \n    # Add the numbers to the respective sums\n    upper_sum += x\n    lower_sum += y\n\n# Calculate the minimum number of rotations needed to achieve even sums\nrotations = 0\nwhile upper_sum % 2!= 0 or lower_sum % 2!= 0:\n    rotations += 1\n    upper_sum, lower_sum = lower_sum, upper_sum\n\n# Print the minimum required number of seconds\nprint(rotations)"}
{"solution": "import math\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef solve(a, b):\n    area = (a - b) * (a + b)\n    return \"YES\" if is_prime(area) else \"NO\"\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        a, b = map(int, input().split())\n        print(solve(a, b))"}
{"solution": "n = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\npositive_count = 0\nnegative_count = 0\n\nfor x, y in points:\n    if x > 0:\n        positive_count += 1\n    else:\n        negative_count += 1\n\nif positive_count <= 1 or negative_count <= 1:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "import math\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\ndef factorial(n):\n    result = 1\n    for i in range(1, n+1):\n        result *= i\n    return result\n\ndef main():\n    a, b = map(int, input().split())\n    a_factorial = factorial(a)\n    b_factorial = factorial(b)\n    gcd_value = gcd(a_factorial, b_factorial)\n    print(gcd_value)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef find_composite_integers(n):\n    # Find the prime factors of n\n    prime_factors = []\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            prime_factors.append(i)\n    if n > 1:\n        prime_factors.append(n)\n\n    # Find the two composite integers a and b such that a - b = n\n    a = 1\n    b = 1\n    for prime in prime_factors:\n        a *= prime\n        b *= prime - 1\n    return a, b\n\nn = int(input())\na, b = find_composite_integers(n)\nprint(a, b)"}
{"solution": "import sys\n\ndef solve(N, M, P, edges):\n    # Initialize the graph with N vertices and M edges\n    graph = [[] for _ in range(N)]\n    for edge in edges:\n        graph[edge[0] - 1].append((edge[1] - 1, edge[2]))\n\n    # Initialize the score and the current vertex\n    score = 0\n    current_vertex = 0\n\n    # Traverse the graph and collect coins\n    while current_vertex!= N - 1:\n        # Find the next vertex to visit\n        next_vertex = -1\n        for neighbor in graph[current_vertex]:\n            if neighbor[0] not in visited:\n                next_vertex = neighbor[0]\n                break\n\n        # If there is no next vertex to visit, return -1\n        if next_vertex == -1:\n            return -1\n\n        # Collect the coins on the edge\n        score += graph[current_vertex][next_vertex][1]\n\n        # Update the current vertex and the visited vertices\n        current_vertex = next_vertex\n        visited.add(current_vertex)\n\n    # If the button is pressed, pay the penalty\n    if current_vertex == N - 1:\n        score -= P * (len(visited) - 1)\n\n    return score\n\nif __name__ == \"__main__\":\n    N, M, P = map(int, input().split())\n    edges = [tuple(map(int, input().split())) for _ in range(M)]\n    print(solve(N, M, P, edges))"}
{"solution": "import sys\n\ndef get_min_cost(strings, costs):\n    # Initialize the minimum cost to -1\n    min_cost = -1\n\n    # Loop through each string\n    for string in strings:\n        # Check if the string is a palindrome\n        if is_palindrome(string):\n            # If it is, add its cost to the minimum cost\n            min_cost += costs[string]\n\n    # Return the minimum cost\n    return min_cost\n\ndef is_palindrome(string):\n    # Check if the string is the same forwards and backwards\n    return string == string[::-1]\n\n# Get the number of strings and costs from the input\nN = int(input())\nstrings = []\ncosts = {}\nfor i in range(N):\n    string, cost = input().split()\n    strings.append(string)\n    costs[string] = int(cost)\n\n# Get the minimum cost\nmin_cost = get_min_cost(strings, costs)\n\n# Print the minimum cost\nprint(min_cost)"}
{"solution": "def largest_xor_sum(n, k):\n    # Find the number of bits in n\n    num_bits = n.bit_length()\n    # The largest possible xor-sum\n    max_xor_sum = (1 << num_bits) - 1\n    return max_xor_sum\n\n# Example usage:\nn, k = map(int, input().split())\nprint(largest_xor_sum(n, k))"}
{"solution": "import math\n\ndef solve(n, points):\n    # Sort the points by their x-coordinate\n    points.sort(key=lambda x: x[0])\n\n    # Initialize the minimum length of the shorter side of the triangle\n    min_length = math.inf\n\n    # Iterate through all possible pairs of points\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            # Calculate the length of the side of the triangle between the two points\n            length = math.sqrt((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2)\n\n            # If the length is less than the current minimum length, update the minimum length\n            if length < min_length:\n                min_length = length\n\n    # Return the minimum length of the shorter side of the triangle\n    return min_length\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    points = []\n    for i in range(n):\n        x, y = map(int, input().split())\n        points.append((x, y))\n    print(solve(n, points))"}
{"solution": "def max_nineteens(s):\n    from collections import Counter\n    \n    # Count the frequency of each character in the string\n    char_count = Counter(s)\n    \n    # Define the required frequency of each character in the word \"nineteen\"\n    required_counts = {'n': 3, 'i': 1, 'e': 3, 't': 1}\n    \n    # Calculate the maximum number of \"nineteen\" words that can be formed\n    max_nineteens = float('inf')\n    for char, required in required_counts.items():\n        if char in char_count:\n            max_nineteens = min(max_nineteens, char_count[char] // required)\n        else:\n            return 0  # If any required character is missing, we can't form \"nineteen\"\n    \n    return max_nineteens"}
{"solution": "import sys\n\ndef main():\n    p, y = map(int, sys.stdin.readline().split())\n    if p > y:\n        print(-1)\n        return\n\n    # Find the highest branch that is not a multiple of any number from 2 to p\n    for i in range(p, y + 1):\n        if i % p!= 0:\n            print(i)\n            return\n\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\nn, m, k = map(int, input().split())\nprices = list(map(int, input().split()))\n\n# Initialize the minimum distance to a large value\nmin_distance = sys.maxsize\n\n# Iterate through the houses and check if they are available and within budget\nfor i in range(n):\n    if prices[i] <= k and i!= m:\n        distance = abs(m - i) * 10\n        if distance < min_distance:\n            min_distance = distance\n\nprint(min_distance)"}
{"solution": "import sys\n\nn, m = map(int, input().split())\nA = [[int(x) for x in input().split()] for _ in range(n)]\nB = [[int(x) for x in input().split()] for _ in range(n)]\n\n# Initialize a matrix C to store the result of the transformation\nC = [[0] * m for _ in range(n)]\n\n# Iterate through each element of A and perform the transformation\nfor i in range(n):\n    for j in range(m):\n        # Find the square submatrix of A that contains the current element\n        submatrix_size = 1\n        while submatrix_size * submatrix_size <= n * m:\n            if i - submatrix_size + 1 >= 0 and j - submatrix_size + 1 >= 0:\n                # Check if the submatrix is a square submatrix of A\n                if A[i - submatrix_size + 1][j - submatrix_size + 1] == A[i][j]:\n                    # Transpose the submatrix\n                    for k in range(submatrix_size):\n                        for l in range(submatrix_size):\n                            C[i - submatrix_size + 1 + k][j - submatrix_size + 1 + l] = A[i - submatrix_size + 1 + l][j - submatrix_size + 1 + k]\n                    break\n            submatrix_size += 1\n\n# Check if C is equal to B\nif C == B:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\na = sys.stdin.readline().strip()\nb = sys.stdin.readline().strip()\n\n# Initialize variables\nlongest_uncommon_subsequence = -1\n\n# Iterate over each character in a\nfor i in range(len(a)):\n    # Check if the character is not in b\n    if a[i] not in b:\n        # If it's not in b, it's an uncommon subsequence\n        longest_uncommon_subsequence = max(longest_uncommon_subsequence, len(a[i:]))\n\n# Iterate over each character in b\nfor i in range(len(b)):\n    # Check if the character is not in a\n    if b[i] not in a:\n        # If it's not in a, it's an uncommon subsequence\n        longest_uncommon_subsequence = max(longest_uncommon_subsequence, len(b[i:]))\n\n# Print the longest uncommon subsequence\nprint(longest_uncommon_subsequence)"}
{"solution": "import sys\n\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Calculate the least common multiple (LCM) of a and c\nlcm = a * c // gcd(a, c)\n\n# Calculate the first time Rick and Morty will scream at the same time\ntime = lcm // a\n\n# Check if the time is a multiple of b and d\nif time % b == 0 and time % d == 0:\n    print(time)\nelse:\n    print(-1)"}
{"solution": "n = int(input())\n\n# Initialize variables\na = 0\nb = 0\nc = 0\n\n# Find a solution\nwhile a + b + c!= n:\n    a += 1\n    b += 1\n    c += 1\n\n    # Check if a, b, or c is a multiple of 3\n    if a % 3 == 0 or b % 3 == 0 or c % 3 == 0:\n        a -= 1\n        b -= 1\n        c -= 1\n\n# Print the solution\nprint(a, b, c)"}
{"solution": "import itertools\n\ndef get_distinct_squares(n, a, b, c, d):\n    # Initialize an empty list to store the distinct squares\n    distinct_squares = []\n\n    # Iterate over all possible squares\n    for square in itertools.product(range(1, n+1), repeat=9):\n        # Check if the current square satisfies all the conditions\n        if is_valid_square(square, a, b, c, d):\n            # If it does, add it to the list of distinct squares\n            distinct_squares.append(square)\n\n    # Return the number of distinct squares\n    return len(distinct_squares)\n\ndef is_valid_square(square, a, b, c, d):\n    # Check if the sum of the integers in each 2x2 square is equal to the sum of the integers in the top left 2x2 square\n    if sum(square[0:4])!= a or sum(square[4:8])!= b or sum(square[8:12])!= c or sum(square[12:16])!= d:\n        return False\n\n    # Check if all the integers in each 2x2 square are different\n    for i in range(0, 16, 4):\n        for j in range(i+1, 16, 4):\n            if square[i] == square[j]:\n                return False\n\n    # If all the conditions are met, return True\n    return True\n\n# Test the function\nn = 3\na = 3\nb = 1\nc = 2\nd = 3\nprint(get_distinct_squares(n, a, b, c, d))"}
{"solution": "def solve(w, h, u1, d1, u2, d2):\n    # Initialize the weight of the snowball\n    weight = w\n    # Initialize the current height of the snowball\n    current_height = h\n    # Initialize the weight of the first stone\n    stone1_weight = u1\n    # Initialize the height of the first stone\n    stone1_height = d1\n    # Initialize the weight of the second stone\n    stone2_weight = u2\n    # Initialize the height of the second stone\n    stone2_height = d2\n\n    # While the snowball is still moving\n    while current_height > 0:\n        # Increase the weight of the snowball by the current height\n        weight += current_height\n        # Decrease the weight of the snowball by the weight of the stone if it hits the stone\n        if current_height == stone1_height or current_height == stone2_height:\n            weight -= stone1_weight if current_height == stone1_height else stone2_weight\n        # Move the snowball one meter down\n        current_height -= 1\n\n    # Return the final weight of the snowball\n    return weight"}
{"solution": "import sys\n\ndef get_passing_rate(scores, x, y):\n    # Sort the scores in descending order\n    sorted_scores = sorted(scores, reverse=True)\n\n    # Initialize the passing rate to the highest score\n    passing_rate = sorted_scores[0]\n\n    # Loop through the scores and find the first score that satisfies the size constraints\n    for score in sorted_scores:\n        if score >= x and score <= y:\n            passing_rate = score\n            break\n\n    return passing_rate\n\nif __name__ == \"__main__\":\n    m = int(input())\n    scores = list(map(int, input().split()))\n    x, y = map(int, input().split())\n\n    passing_rate = get_passing_rate(scores, x, y)\n\n    if passing_rate == 0:\n        print(\"0\")\n    else:\n        print(passing_rate)"}
{"solution": "def solve(n, k, A, B):\n    x = n\n    cost = 0\n    while x > 1:\n        if x % k == 0:\n            x //= k\n            cost += B\n        else:\n            x -= 1\n            cost += A\n    return cost"}
{"solution": "  import math\n\ndef solve(n):\n    # Initialize variables\n    min_value = n\n    min_operations = 0\n\n    # Iterate through all possible values of x\n    for x in range(1, int(math.sqrt(n)) + 1):\n        # Calculate the new value of n after multiplying by x\n        new_value = n * x\n\n        # If the new value is less than or equal to the minimum value, skip this iteration\n        if new_value <= min_value:\n            continue\n\n        # Calculate the number of operations required to reach the new value\n        operations = 1 + solve(new_value)\n\n        # If the number of operations is less than the minimum, update the variables\n        if operations < min_operations:\n            min_value = new_value\n            min_operations = operations\n\n    # Return the minimum value and the minimum number of operations\n    return min_value, min_operations\n\nn = int(input())\nprint(solve(n))"}
{"solution": "import sys\n\ndef get_max_score(N, K, R, S, P, T):\n    # Initialize variables\n    max_score = 0\n    hand_history = []\n    current_hand = None\n\n    # Iterate through each round\n    for i in range(N):\n        # Get the machine's hand for this round\n        machine_hand = T[i]\n\n        # If this is the first K rounds, choose any hand\n        if i < K:\n            current_hand = \"r\" if machine_hand == \"s\" else \"s\" if machine_hand == \"p\" else \"p\"\n\n        # Otherwise, choose the hand that will give the highest score\n        else:\n            # Get the previous K hands\n            previous_hands = hand_history[-K:]\n\n            # If the previous K hands contain the same hand, choose the other hand\n            if previous_hands.count(current_hand) == K:\n                current_hand = \"r\" if current_hand == \"s\" else \"s\" if current_hand == \"p\" else \"p\"\n\n            # Otherwise, choose the hand that will give the highest score\n            else:\n                # Get the score for each hand\n                r_score = R if machine_hand == \"r\" else 0\n                s_score = S if machine_hand == \"s\" else 0\n                p_score = P if machine_hand == \"p\" else 0\n\n                # Choose the hand with the highest score\n                current_hand = \"r\" if r_score > s_score and r_score > p_score else \"s\" if s_score > r_score and s_score > p_score else \"p\"\n\n        # Add the current hand to the hand history\n        hand_history.append(current_hand)\n\n        # Get the score for this round\n        score = R if current_hand == \"r\" else S if current_hand == \"s\" else P\n\n        # Update the maximum score\n        max_score += score\n\n    # Return the maximum score\n    return max_score\n\n# Get the input\nN, K, R, S, P = map(int, input().split())\nT = input()\n\n# Get the maximum score\nmax_score = get_max_score(N, K, R, S, P, T)\n\n# Print the maximum score\nprint(max_score)"}
{"solution": "import sys\n\ndef get_longest_good_string(a, b, c):\n    # Initialize variables\n    longest_good_string = \"\"\n    current_string = \"\"\n    current_length = 0\n\n    # Iterate through the strings\n    for i in range(a):\n        current_string += \"a\"\n        current_length += 1\n        if current_length > len(longest_good_string):\n            longest_good_string = current_string\n\n    for i in range(b):\n        current_string += \"b\"\n        current_length += 1\n        if current_length > len(longest_good_string):\n            longest_good_string = current_string\n\n    for i in range(c):\n        current_string += \"ab\"\n        current_length += 2\n        if current_length > len(longest_good_string):\n            longest_good_string = current_string\n\n    return longest_good_string\n\n# Read input from stdin\na, b, c = map(int, input().split())\n\n# Get the longest good string\nlongest_good_string = get_longest_good_string(a, b, c)\n\n# Print the output\nprint(len(longest_good_string))"}
{"solution": "import sys\n\nn, k, p, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Calculate the sum of marks\nsum_marks = sum(marks)\n\n# Check if the sum of marks exceeds x\nif sum_marks > x:\n    print(\"-1\")\n    sys.exit()\n\n# Calculate the median mark\nmedian_mark = sorted(marks)[(n + 1) // 2]\n\n# Check if the median mark is less than y\nif median_mark < y:\n    print(\"-1\")\n    sys.exit()\n\n# Calculate the remaining marks\nremaining_marks = [p - mark for mark in marks]\n\n# Print the remaining marks\nprint(*remaining_marks)"}
{"solution": "def is_berlanese(s):\n    vowels = \"aeiou\"\n    consonants = \"bcdfghjklmnpqrstvwxyz\"\n    for i in range(len(s)):\n        if s[i] in consonants:\n            if i == len(s) - 1 or s[i + 1] not in vowels:\n                return \"NO\"\n        elif s[i] == \"n\":\n            if i == len(s) - 1 or s[i + 1] not in vowels and s[i + 1] not in consonants:\n                return \"NO\"\n    return \"YES\""}
{"solution": "import sys\n\nn, m = map(int, input().split())\nedges = []\nfor i in range(m):\n    a, b = map(int, input().split())\n    edges.append((a, b))\n\n# Initialize the number of dominoes to 0\nnum_dominoes = 0\n\n# Iterate over each edge and check if it can be placed\nfor edge in edges:\n    # Check if the edge is connected to any other edge\n    connected = False\n    for other_edge in edges:\n        if edge[0] == other_edge[1] or edge[1] == other_edge[0]:\n            connected = True\n            break\n    \n    # If the edge is not connected, increment the number of dominoes\n    if not connected:\n        num_dominoes += 1\n\nprint(num_dominoes)"}
{"solution": "import sys\n\nn, m = map(int, input().split())\nprices = list(map(int, input().split()))\nauction_questions = set(map(int, input().split()))\n\ndef calculate_points(prices, auction_questions):\n    points = 0\n    for i, price in enumerate(prices):\n        if i in auction_questions:\n            points += price\n        else:\n            points += price\n    return points\n\nprint(calculate_points(prices, auction_questions))"}
{"solution": "import math\n\ndef compute_score(m, w, h):\n    # Compute the score for each problem\n    scores = []\n    for i in range(5):\n        x = 500 if i == 0 else 1000 if i == 1 else 1500 if i == 2 else 2000 if i == 3 else 2500\n        m_i = m[i]\n        w_i = w[i]\n        score = max(0.3 * x, (1 - m_i / 250) * x - 50 * w_i)\n        scores.append(score)\n    \n    # Compute the total score\n    total_score = sum(scores)\n    \n    # Add or subtract points for hacks\n    total_score += 100 * h[0]\n    total_score -= 50 * h[1]\n    \n    return total_score\n\n# Test case 1\nm = [20, 40, 60, 80, 100]\nw = [0, 1, 2, 3, 4]\nh = [1, 0]\nprint(compute_score(m, w, h))\n\n# Test case 2\nm = [119, 119, 119, 119, 119]\nw = [0, 0, 0, 0, 0]\nh = [10, 0]\nprint(compute_score(m, w, h))"}
{"solution": "import sys\n\nn, m, L, R = map(int, sys.stdin.readline().split())\n\n# Initialize a 2D array to store the number of cubes in each cell\ngrid = [[0] * m for _ in range(n)]\n\n# Initialize a set to store the visited states\nvisited = set()\n\n# Initialize a queue to store the states to be processed\nqueue = [(0, 0)]\n\n# Initialize a variable to store the number of states that satisfy the requirements\nans = 0\n\n# Loop until the queue is empty\nwhile queue:\n    # Dequeue a state from the queue\n    state = queue.pop(0)\n\n    # If the state is already visited, skip it\n    if state in visited:\n        continue\n\n    # If the state satisfies the requirements, increment the answer\n    if L <= grid[state[0]][state[1]] <= R:\n        ans += 1\n\n    # Add the state to the visited set\n    visited.add(state)\n\n    # Add the adjacent states to the queue\n    for i in range(4):\n        x = state[0] + dx[i]\n        y = state[1] + dy[i]\n        if 0 <= x < n and 0 <= y < m:\n            queue.append((x, y))\n\n# Print the answer modulo 998244353\nprint(ans % 998244353)"}
{"solution": "def is_possible_to_make_increasing(n, m, matrix_a, matrix_b):\n    for i in range(n):\n        for j in range(m):\n            # Ensure that matrix_a[i][j] is the smaller or equal element\n            if matrix_a[i][j] > matrix_b[i][j]:\n                matrix_a[i][j], matrix_b[i][j] = matrix_b[i][j], matrix_a[i][j]\n    \n    # Check rows for strictly increasing property\n    for i in range(n):\n        for j in range(1, m):\n            if matrix_a[i][j] <= matrix_a[i][j-1] or matrix_b[i][j] <= matrix_b[i][j-1]:\n                return \"Impossible\"\n    \n    # Check columns for strictly increasing property\n    for j in range(m):\n        for i in range(1, n):\n            if matrix_a[i][j] <= matrix_a[i-1][j] or matrix_b[i][j] <= matrix_b[i-1][j]:\n                return \"Impossible\"\n    \n    return \"Possible\""}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize the maximum length of the string\nmax_length = 0\n\n# Iterate over each letter in the alphabet\nfor i in range(n):\n    # Calculate the maximum number of occurrences of the current letter\n    max_occurrences = a[i]\n\n    # If the current letter has already been used, decrease the maximum number of occurrences\n    if i in used_letters:\n        max_occurrences -= 1\n\n    # Add the current letter to the string\n    string += chr(i)\n\n    # If the current letter has already been used, decrease the maximum number of occurrences\n    if i in used_letters:\n        max_occurrences -= 1\n\n    # Update the maximum length of the string\n    max_length = max(max_length, len(string))\n\n# Print the maximum length of the string\nprint(max_length)"}
{"solution": "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculate the minimum number of problems to solve on other judges\nmin_problems = 0\nfor i in range(n):\n    if a[i] > k:\n        min_problems += 1\n\nprint(min_problems)"}
{"solution": "n = int(input())\nmin_1, max_1 = map(int, input().split())\nmin_2, max_2 = map(int, input().split())\nmin_3, max_3 = map(int, input().split())\n\n# Initialize variables to store the number of diplomas of each degree\nfirst_degree = 0\nsecond_degree = 0\nthird_degree = 0\n\n# Initialize a list to store the number of participants for each degree\nparticipants = [0] * (max_1 + 1)\n\n# Loop through each participant and assign a diploma of the first degree\nfor i in range(n):\n    if first_degree < min_1:\n        first_degree += 1\n        participants[first_degree] += 1\n    elif first_degree < max_1:\n        if second_degree < min_2:\n            second_degree += 1\n            participants[second_degree] += 1\n        elif second_degree < max_2:\n            if third_degree < min_3:\n                third_degree += 1\n                participants[third_degree] += 1\n            elif third_degree < max_3:\n                if participants[first_degree] < participants[second_degree]:\n                    first_degree += 1\n                    participants[first_degree] += 1\n                elif participants[second_degree] < participants[third_degree]:\n                    second_degree += 1\n                    participants[second_degree] += 1\n                else:\n                    third_degree += 1\n                    participants[third_degree] += 1\n\n# Print the number of diplomas of each degree\nprint(first_degree, second_degree, third_degree)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Check if the moon's size is increasing or decreasing\nif a[n-1] < a[n-2]:\n    print(\"DOWN\")\nelif a[n-1] > a[n-2]:\n    print(\"UP\")\nelse:\n    print(-1)"}
{"solution": "s = input().strip()\nt = input().strip()\n\nvowels = {'a', 'e', 'i', 'o', 'u'}\n\nif len(s)!= len(t):\n    print(\"No\")\n    exit()\n\nfor char_s, char_t in zip(s, t):\n    if (char_s in vowels)!= (char_t in vowels):\n        print(\"No\")\n        exit()\n\nprint(\"Yes\")"}
{"solution": "def determine_winner(board):\n    # Initialize variables\n    player_a_moves = []\n    player_b_moves = []\n    winner = None\n\n    # Loop through the board\n    for row in range(8):\n        for col in range(8):\n            # Check if the current cell is occupied by a pawn\n            if board[row][col] == 'B':\n                # Add the move to the list of player B moves\n                player_b_moves.append((row, col))\n            elif board[row][col] == 'W':\n                # Add the move to the list of player A moves\n                player_a_moves.append((row, col))\n\n    # Check if player A has any moves available\n    if len(player_a_moves) > 0:\n        # Player A has moves available, so they are not the winner\n        winner = 'B'\n    else:\n        # Player A does not have any moves available, so they are the winner\n        winner = 'A'\n\n    return winner"}
{"solution": "n = int(input())\nA = list(map(int, input().split()))\nm = int(input())\nB = list(map(int, input().split()))\n\nif sum(A)!= sum(B):\n    print(-1)\n    exit()\n\ni, j = 0, 0\nsumA, sumB = 0, 0\ncount = 0\n\nwhile i < n and j < m:\n    sumA += A[i]\n    sumB += B[j]\n    \n    if sumA == sumB:\n        count += 1\n        sumA = 0\n        sumB = 0\n        i += 1\n        j += 1\n    elif sumA < sumB:\n        i += 1\n    else:\n        j += 1\n\nprint(count)"}
{"solution": "def is_from_contest(problem_name):\n    friends = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\n    for friend in friends:\n        if friend in problem_name:\n            return \"YES\"\n    return \"NO\""}
{"solution": "def min_length_with_k_primes(a, b, k):\n    is_prime = sieve(b)\n    prime_count = count_primes_in_range(is_prime, a, b)\n    \n    def has_k_primes_in_length(l):\n        for x in range(a, b - l + 2):\n            if prime_count[x + l - 1] - prime_count[x - 1] >= k:\n                return True\n        return False\n    \n    left, right = 1, b - a + 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if has_k_primes_in_length(mid):\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return result"}
{"solution": "import math\n\ndef solve(a, h, w):\n    # Calculate the minimum value of x\n    x = min(a, h, w) / 2\n\n    # Calculate the number of rows and columns that can be placed on the wall\n    rows = math.ceil(h / a)\n    cols = math.ceil(w / a)\n\n    # Calculate the total number of photos that can be placed on the wall\n    total_photos = rows * cols\n\n    # If the total number of photos is less than or equal to the number of photos available, return the minimum value of x\n    if total_photos <= len(photos):\n        return x\n\n    # Otherwise, return -1\n    return -1\n\nphotos = [2, 18, 13]\nprint(solve(photos[0], photos[1], photos[2]))"}
{"solution": "n = int(input())\nchapters = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    chapters.append((l, r))\nk = int(input())\n\n# Find the chapter that Nastya has not finished reading\nfor i in range(n):\n    if chapters[i][1] < k:\n        continue\n    else:\n        break\n\n# Print the number of chapters that have not been read\nprint(n - i)"}
{"solution": "def can_form_codeforces(word):\n    target = \"CODEFORCES\"\n    n = len(word)\n    m = len(target)\n    \n    if n < m:\n        return \"NO\"\n    \n    for i in range(m + 1):\n        if word[:i] == target[:i] and word[n - (m - i):] == target[i:]:\n            return \"YES\"\n    \n    return \"NO\"\n\nprint(can_form_codeforces(input()))"}
{"solution": "  import sys\n\nn = int(sys.stdin.readline().strip())\n\n# Calculate the minimum weight among all triangulations of the polygon\nmin_weight = 0\n\n# Iterate over all possible triangulations of the polygon\nfor i in range(1, n + 1):\n    for j in range(i + 1, n + 1):\n        for k in range(j + 1, n + 1):\n            # Calculate the weight of the current triangulation\n            weight = i * j * k\n            # Update the minimum weight if necessary\n            if weight < min_weight or min_weight == 0:\n                min_weight = weight\n\n# Print the minimum weight\nprint(min_weight)"}
{"solution": "n = int(input())\n\n# Calculate the number of digits needed to number all the books\ndigits = 1\nwhile n > 0:\n    n //= 10\n    digits += 1\n\nprint(digits)"}
{"solution": "import sys\n\nn, A = map(int, input().split())\ncolors = list(map(int, input().split()))\n\n# Initialize the counts for Alice and Bob\ncnt_A = [0] * (n + 1)\ncnt_B = [0] * (n + 1)\n\n# Set the initial count for Alice's color\ncnt_A[0] = 1\n\n# Iterate through the colors and update the counts\nfor i in range(1, n + 1):\n    cnt_A[i] = cnt_A[i - 1] + (colors[i - 1] == A)\n    cnt_B[i] = cnt_B[i - 1] + (colors[i - 1]!= A)\n\n# Find the color that gives Bob the highest count\nmax_cnt_B = max(cnt_B)\ncolor_B = colors[cnt_B.index(max_cnt_B)]\n\n# Print the output\nprint(color_B)"}
{"solution": "  import sys\n\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Check if the encoding is valid\nif len(a)!= n or any(a_i > x for a_i in a):\n    print(\"NO\")\n    sys.exit()\n\n# Check if the encoding forms a valid crossword\nif any(a_i + a_j > x for i, a_i in enumerate(a) for j, a_j in enumerate(a) if i < j):\n    print(\"NO\")\n    sys.exit()\n\n# Check if the encoding forms a unique crossword\nif len(set(a))!= len(a):\n    print(\"NO\")\n    sys.exit()\n\nprint(\"YES\")"}
{"solution": "import sys\n\nn, S = map(int, sys.stdin.readline().split())\n\ncoins = [i for i in range(1, n+1)]\n\ndef get_min_coins(coins, S):\n    if not coins:\n        return 0\n    if coins[0] == S:\n        return 1\n    if coins[0] > S:\n        return get_min_coins(coins[1:], S)\n    return 1 + get_min_coins(coins[1:], S-coins[0])\n\nprint(get_min_coins(coins, S))"}
{"solution": "import sys\n\ndef get_lexicographically_smallest_palindrome(s):\n    # Initialize variables\n    changes = 0\n    palindrome = \"\"\n\n    # Iterate through the string\n    for i in range(len(s)):\n        # If the character is not already a palindrome, make it one\n        if s[i]!= s[-i-1]:\n            changes += 1\n            palindrome += s[i] + s[-i-1]\n        else:\n            palindrome += s[i]\n\n    # Return the lexicographically smallest palindrome\n    return palindrome\n\n# Get the input string\ns = sys.stdin.readline().strip()\n\n# Get the lexicographically smallest palindrome\npalindrome = get_lexicographically_smallest_palindrome(s)\n\n# Print the output\nprint(palindrome)"}
{"solution": "def calculate_weight(board):\n    piece_weights = {\n        'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'P': 1,\n        'q': 9, 'r': 5, 'b': 3, 'n': 3, 'p': 1\n    }\n    \n    white_weight = 0\n    black_weight = 0\n    \n    for row in board:\n        for piece in row:\n            if piece in piece_weights:\n                if piece.isupper():\n                    white_weight += piece_weights[piece]\n                else:\n                    black_weight += piece_weights[piece]\n    \n    if white_weight > black_weight:\n        return \"White\"\n    elif black_weight > white_weight:\n        return \"Black\"\n    else:\n        return \"Draw\"\n\n# Example usage:\nboard = [\n    \"...QK...\",\n    \"........\",\n    \"........\",\n    \"........\",\n    \"........\",\n    \"........\",\n    \"........\",\n    \"...rk...\"\n]\n\nprint(calculate_weight(board))  # Output: White"}
{"solution": "import sys\n\ndef solve(N, M, S):\n    # Initialize the game board with the Game Over Squares\n    game_board = [False] * (N + 1)\n    for i in range(N + 1):\n        if S[i] == '1':\n            game_board[i] = True\n\n    # Initialize the roulette with the M numbers\n    roulette = [i for i in range(1, M + 1)]\n\n    # Initialize the sequence of numbers coming up in the roulette\n    sequence = []\n\n    # Initialize the current square\n    current_square = 0\n\n    # Loop until the game is won or lost\n    while current_square!= N:\n        # Spin the roulette\n        number = roulette[current_square]\n\n        # Move to the next square\n        next_square = current_square + number\n\n        # Check if the next square is a Game Over Square\n        if game_board[next_square]:\n            return -1\n\n        # Add the number to the sequence\n        sequence.append(number)\n\n        # Update the current square\n        current_square = next_square\n\n    # Return the lexicographically smallest sequence\n    return''.join(str(x) for x in sequence)\n\nif __name__ == '__main__':\n    N, M = map(int, input().split())\n    S = input()\n    print(solve(N, M, S))"}
{"solution": "import math\n\ndef main():\n    k, x, y = map(int, input().split())\n    if x == 0 and y == 0:\n        print(-1)\n        return\n    if k > math.sqrt(x**2 + y**2):\n        print(-1)\n        return\n    score = 0\n    while x!= 0 or y!= 0:\n        if x < 0:\n            x = -x\n        if y < 0:\n            y = -y\n        if x > y:\n            x, y = y, x\n        score += x\n        x -= k\n        y -= k\n    print(score)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef get_n(m):\n    # Initialize n to 1\n    n = 1\n    # Loop until we find the smallest n that leads to m ways of stealing chocolates\n    while True:\n        # Calculate the number of ways the chocolates can be stolen with n chocolates per thief\n        num_ways = get_num_ways(n)\n        # If the number of ways is equal to m, we have found the smallest n\n        if num_ways == m:\n            return n\n        # If the number of ways is greater than m, we need to increase n\n        elif num_ways > m:\n            n += 1\n        # If the number of ways is less than m, we need to decrease n\n        else:\n            n -= 1\n\ndef get_num_ways(n):\n    # Initialize a list to store the number of ways the chocolates can be stolen\n    num_ways = []\n    # Loop through each possible number of chocolates stolen by each thief\n    for i in range(1, n+1):\n        # Calculate the number of ways the chocolates can be stolen with i chocolates per thief\n        num_ways.append(get_num_ways_helper(i, n))\n    # Return the sum of the number of ways the chocolates can be stolen\n    return sum(num_ways)\n\ndef get_num_ways_helper(i, n):\n    # Initialize a list to store the number of ways the chocolates can be stolen\n    num_ways = []\n    # Loop through each possible number of chocolates stolen by each thief\n    for j in range(1, n+1):\n        # Calculate the number of ways the chocolates can be stolen with j chocolates per thief\n        num_ways.append(get_num_ways_helper(j, n-i))\n    # Return the sum of the number of ways the chocolates can be stolen\n    return sum(num_ways)\n\n# Get the input from stdin\nm = int(input().strip())\n\n# Get the smallest n that leads to m ways of stealing chocolates\nn = get_n(m)\n\n# Print the output to stdout\nprint(n)"}
{"solution": "import math\n\ndef get_intersection_area(circle1, circle2):\n    x1, y1, r1 = circle1\n    x2, y2, r2 = circle2\n    d = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n    if d > r1 + r2:\n        return 0\n    if d < abs(r1 - r2):\n        return math.pi * min(r1, r2) ** 2\n    h = (r1 ** 2 - r2 ** 2 + d ** 2) / (2 * d)\n    return math.acos(h / r1) * r1 ** 2\n\nif __name__ == \"__main__\":\n    circle1 = tuple(map(int, input().split()))\n    circle2 = tuple(map(int, input().split()))\n    print(get_intersection_area(circle1, circle2))"}
{"solution": "import sys\n\nn = int(sys.stdin.readline().strip())\n\n# Initialize the minimum value of n to n itself\nmin_n = n\n\n# Iterate through all possible values of x\nfor x in range(1, n):\n    # If x is not a divisor of n, subtract it from n\n    if n % x!= 0:\n        min_n = min(min_n, n - x)\n\nprint(min_n)"}
{"solution": "import sys\n\nn = int(input())\np = list(map(int, input().split()))\na = list(map(int, input().split()))\n\n# Initialize the number of citizens caught to 0\ncaught = 0\n\n# Iterate through each square\nfor i in range(n):\n    # If the square has no outgoing roads, the bandit can catch all the citizens on that square\n    if p[i] == 0:\n        caught += a[i]\n        continue\n    \n    # If the square has outgoing roads, the citizens can split into two groups\n    # and move to different squares to minimize the number of caught citizens\n    # The number of citizens on each square is the sum of the number of citizens on the current square and the number of citizens on the next square\n    a[i] += a[p[i]]\n    a[p[i]] = 0\n    \n    # Update the number of citizens caught\n    caught += a[i]\n\nprint(caught)"}
{"solution": "n = int(input())\nS = input().strip()\nT = input().strip()\n\ncount = 0\nfor i in range(n + 1):\n    # Construct W by inserting a character at position i in both S and T\n    if i == 0:\n        W1 = S[0] + S\n        W2 = T[0] + T\n    elif i == n:\n        W1 = S + S[-1]\n        W2 = T + T[-1]\n    else:\n        W1 = S[:i] + S[i] + S[i:]\n        W2 = T[:i] + T[i] + T[i:]\n    \n    # Check if the constructed words are the same\n    if W1 == W2:\n        count += 1\n\nprint(count)"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\nwires = [list(map(int, input().split())) for _ in range(n - 1)]\n\n# Initialize the computer strength to 0\ncomputer_strength = 0\n\n# Initialize the list of banks to hack\nbanks_to_hack = list(range(1, n + 1))\n\n# Initialize the list of banks that are already hacked\nhacked_banks = []\n\n# While there are still banks to hack\nwhile banks_to_hack:\n    # Find the bank with the lowest strength that is not already hacked\n    bank_to_hack = min(banks_to_hack, key=lambda x: a[x - 1])\n\n    # Hack the bank\n    computer_strength += a[bank_to_hack - 1]\n    hacked_banks.append(bank_to_hack)\n\n    # Remove the bank from the list of banks to hack\n    banks_to_hack.remove(bank_to_hack)\n\n    # Update the strengths of the neighboring banks\n    for wire in wires:\n        if wire[0] in hacked_banks or wire[1] in hacked_banks:\n            continue\n        if wire[0] == bank_to_hack or wire[1] == bank_to_hack:\n            a[wire[0] - 1] += 1\n            a[wire[1] - 1] += 1\n\n# Print the minimum computer strength needed to hack all the banks\nprint(computer_strength)"}
{"solution": "n, m = map(int, input().split())\nprint(min(m, n - m))"}
{"solution": "def solve(k, r):\n    # Calculate the minimum number of shovels Polycarp needs to buy\n    min_shovels = 1\n    while k * min_shovels % 10!= 0:\n        min_shovels += 1\n\n    # Calculate the number of 10-burle coins needed\n    num_10_coins = k * min_shovels // 10\n\n    # Calculate the number of r-burle coins needed\n    num_r_coins = k * min_shovels % 10 // r\n\n    # Print the minimum number of shovels Polycarp needs to buy\n    print(min_shovels)\n\n    # Print the number of 10-burle coins needed\n    print(num_10_coins)\n\n    # Print the number of r-burle coins needed\n    print(num_r_coins)\n\nsolve(117, 3)\nsolve(237, 7)\nsolve(15, 2)"}
{"solution": "def can_form_rectangle(n, m, grid):\n    # Find the bounding box of the 'X' characters\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'X':\n                min_row = min(min_row, i)\n                max_row = max(max_row, i)\n                min_col = min(min_col, j)\n                max_col = max(max_col, j)\n    \n    # Dimensions of the bounding box\n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n    \n    # Extract the bounding box\n    piece = []\n    for i in range(min_row, max_row + 1):\n        piece.append(grid[i][min_col:max_col + 1])\n    \n    # Check horizontal placement\n    if width * 2 == m:\n        valid = True\n        for i in range(height):\n            for j in range(width):\n                if piece[i][j]!= piece[i][j + width]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return \"YES\"\n    \n    # Check vertical placement\n    if height * 2 == n:\n        valid = True\n        for i in range(height):\n            for j in range(width):\n                if piece[i][j]!= piece[i + height][j]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(can_form_rectangle(n, m, grid))"}
{"solution": "def get_min_segments(points):\n    x1, y1 = points[0]\n    x2, y2 = points[1]\n    x3, y3 = points[2]\n\n    # Check for collinearity on the same axis\n    if x1 == x2 == x3 or y1 == y2 == y3:\n        return 1\n\n    # Check for two points sharing the same coordinate\n    if (x1 == x2 and x3!= x2) or (y1 == y2 and y3!= y2):\n        return 2\n\n    # General case\n    return 3"}
{"solution": "import sys\n\ndef construct_graph(k):\n    # Initialize the graph with one vertex\n    graph = [[]]\n\n    # Add vertices to the graph\n    for i in range(k-1):\n        graph.append([])\n\n    # Add edges to the graph\n    for i in range(k-1):\n        for j in range(i+1, k):\n            graph[i].append(j)\n            graph[j].append(i)\n\n    # Check if the graph is connected\n    if not is_connected(graph):\n        return \"NO\"\n\n    # Check if the graph is k-regular\n    if not is_k_regular(graph, k):\n        return \"NO\"\n\n    # Check if the graph contains at least one bridge\n    if not contains_bridge(graph):\n        return \"NO\"\n\n    # Print the graph\n    print(\"YES\")\n    print(len(graph), len(graph[0]))\n    for i in range(len(graph)):\n        for j in range(len(graph[i])):\n            print(i+1, graph[i][j]+1)\n\n    return \"YES\"\n\ndef is_connected(graph):\n    # Check if the graph is connected by performing a BFS\n    queue = [0]\n    visited = set()\n    while queue:\n        vertex = queue.pop(0)\n        if vertex not in visited:\n            visited.add(vertex)\n            queue.extend(graph[vertex])\n    return len(visited) == len(graph)\n\ndef is_k_regular(graph, k):\n    # Check if the graph is k-regular by checking the degree of each vertex\n    for vertex in graph:\n        if len(vertex)!= k:\n            return False\n    return True\n\ndef contains_bridge(graph):\n    # Check if the graph contains at least one bridge by checking if there is an edge that connects two disconnected components\n    for i in range(len(graph)):\n        for j in range(i+1, len(graph)):\n            if graph[i][j] and not is_connected(graph[i:j]):\n                return True\n    return False\n\nif __name__ == \"__main__\":\n    k = int(sys.stdin.readline().strip())\n    print(construct_graph(k))"}
{"solution": "import sys\n\nn, m, q = map(int, input().split())\ns = input()\nt = input()\n\n# Initialize a dictionary to store the occurrences of t in s\noccurrences = {}\n\n# Iterate through each substring of s and count the occurrences of t\nfor i in range(n - m + 1):\n    substring = s[i:i+m]\n    if substring not in occurrences:\n        occurrences[substring] = 0\n    if t in substring:\n        occurrences[substring] += 1\n\n# Print the number of occurrences for each query\nfor _ in range(q):\n    l, r = map(int, input().split())\n    print(occurrences[s[l:r]])"}
{"solution": "  import sys\n\nn, k, d = map(int, sys.stdin.readline().split())\n\n# Initialize the dp array with 0\ndp = [0] * (n + 1)\n\n# Base case: dp[0] = 1\ndp[0] = 1\n\n# Fill the dp array\nfor i in range(1, n + 1):\n    for j in range(1, k + 1):\n        if i - j >= 0:\n            dp[i] = (dp[i] + dp[i - j]) % 1000000007\n\n# Print the answer\nprint(dp[n])"}
{"solution": "def encrypt_japanese_crossword(n, row):\n    groups = []\n    count = 0\n    \n    for char in row:\n        if char == 'B':\n            count += 1\n        else:\n            if count > 0:\n                groups.append(count)\n                count = 0\n    \n    if count > 0:\n        groups.append(count)\n    \n    print(len(groups))\n    if groups:\n        print(\" \".join(map(str, groups)))\n\n# Example usage:\nn = int(input())\nrow = input().strip()\nencrypt_japanese_crossword(n, row)"}
{"solution": "import sys\n\nn, m, p = map(int, input().split())\nsequence = input()\noperations = input()\n\n# Initialize the cursor position\ncursor = p\n\n# Iterate through the operations\nfor operation in operations:\n    if operation == \"L\":\n        # Move the cursor to the left\n        cursor -= 1\n    elif operation == \"R\":\n        # Move the cursor to the right\n        cursor += 1\n    elif operation == \"D\":\n        # Delete the bracket at the cursor position\n        sequence = sequence[:cursor] + sequence[cursor+1:]\n        # Update the cursor position\n        cursor = cursor - 1\n\n# Print the final sequence\nprint(sequence)"}
{"solution": "def guess_a_number(questions):\n    y = 0\n    for question in questions:\n        sign, x, answer = question.split()\n        if sign == \">\":\n            if y <= x:\n                return \"Impossible\"\n            y = x + 1\n        elif sign == \"<\":\n            if y >= x:\n                return \"Impossible\"\n            y = x - 1\n        elif sign == \">=\":\n            if y < x:\n                return \"Impossible\"\n            y = x\n        elif sign == \"<=\":\n            if y > x:\n                return \"Impossible\"\n            y = x\n    return y"}
{"solution": "import sys\n\ndef get_periods(a, b):\n    periods = set()\n    for i in range(1, a+b+1):\n        if i % 2 == 0:\n            periods.add(i)\n    return periods\n\na, b = map(int, input().split())\nperiods = get_periods(a, b)\nprint(len(periods))"}
{"solution": "def generate_names(n, k, conditions):\n    # Predefined list of unique names\n    names = [\"Adam\", \"Bob\", \"Charlie\", \"David\", \"Edward\", \"Frank\", \"George\", \"Henry\", \"Isaac\", \"Jack\"]\n    \n    # Initialize the result list with the first k names\n    result = names[:k]\n    \n    for i in range(1, n - k + 1):\n        if conditions[i - 1] == \"YES\":\n            # If the group should be effective, add a new unique name\n            result.append(names[k + i - 1])\n        else:\n            # If the group should not be effective, repeat the last name\n            result.append(result[-1])\n    \n    return result\n\n# Example input\nn = 8\nk = 3\nconditions = [\"NO\", \"NO\", \"YES\", \"YES\", \"YES\", \"NO\"]\n\n# Generate and print the names\nnames = generate_names(n, k, conditions)\nprint(\" \".join(names))"}
{"solution": "def min_operations_to_equal(a, b):\n    # Prime factorization of a and b\n    a_factors = prime_factors(a)\n    b_factors = prime_factors(b)\n\n    # Count the number of times each factor appears in a and b\n    a_counts = Counter(a_factors)\n    b_counts = Counter(b_factors)\n\n    # Calculate the minimum number of operations needed to make the pieces equal\n    operations = 0\n    for factor in a_counts:\n        if factor in b_counts:\n            operations += abs(a_counts[factor] - b_counts[factor])\n        else:\n            operations += a_counts[factor]\n\n    return operations\n\ndef prime_factors(n):\n    factors = []\n    while n % 2 == 0:\n        factors.append(2)\n        n //= 2\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        while n % i == 0:\n            factors.append(i)\n            n //= i\n    if n > 1:\n        factors.append(n)\n    return factors"}
{"solution": "def solve(n, a, b, c):\n    # Initialize variables\n    cost = 0\n    palindrome = True\n    leftmost_color = c[0]\n    rightmost_color = c[-1]\n\n    # Check if the colors form a palindrome\n    for i in range(n):\n        if c[i]!= c[n-i-1]:\n            palindrome = False\n            break\n\n    # If the colors do not form a palindrome, check if it is possible to buy new suits\n    if not palindrome:\n        # Check if the leftmost dancer's suit is already bought\n        if c[0] == 2:\n            cost += a\n            c[0] = 0\n\n        # Check if the rightmost dancer's suit is already bought\n        if c[-1] == 2:\n            cost += b\n            c[-1] = 1\n\n        # Check if the colors form a palindrome after buying new suits\n        for i in range(n):\n            if c[i]!= c[n-i-1]:\n                palindrome = False\n                break\n\n    # If the colors still do not form a palindrome, it is not possible to obtain the desired visual effect\n    if not palindrome:\n        return -1\n\n    # Return the minimal cost to obtain the desired visual effect\n    return cost"}
{"solution": "import sys\n\ndef paint_cube(k):\n    # Initialize the cube with all unit cubes white\n    cube = [[0] * k for _ in range(k)]\n\n    # Iterate through each layer of the cube\n    for layer in range(k):\n        # Iterate through each unit cube in the current layer\n        for i in range(k):\n            # If the current unit cube is white, check if it has exactly 2 white neighbors\n            if cube[layer][i] == 0:\n                # Count the number of white neighbors\n                num_white_neighbors = 0\n                for j in range(k):\n                    if cube[layer][j] == 0:\n                        num_white_neighbors += 1\n\n                # If the current unit cube has exactly 2 white neighbors, paint it black\n                if num_white_neighbors == 2:\n                    cube[layer][i] = 1\n\n    # Print the painted cube\n    for layer in cube:\n        print(\"\".join([\"w\" if x == 0 else \"b\" for x in layer]))\n\nif __name__ == \"__main__\":\n    k = int(sys.stdin.readline().strip())\n    paint_cube(k)"}
{"solution": "import math\n\ndef largest_lovely_number(n):\n    prime_factors = []\n    while n > 1:\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                prime_factors.append(i)\n                n //= i\n                break\n        else:\n            prime_factors.append(n)\n            n = 1\n    lovely_number = 1\n    for prime in prime_factors:\n        lovely_number *= prime\n    return lovely_number\n\nn = int(input())\nprint(largest_lovely_number(n))"}
{"solution": "def is_maximal_seating(n, seating):\n    # Check for adjacent occupied seats\n    for i in range(n - 1):\n        if seating[i] == '1' and seating[i + 1] == '1':\n            return \"No\"\n    \n    # Check for possible additional seating\n    for i in range(n):\n        if seating[i] == '0':\n            if (i == 0 or seating[i - 1] == '0') and (i == n - 1 or seating[i + 1] == '0'):\n                return \"No\"\n    \n    return \"Yes\""}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize the possible values of k\nk_values = set(range(1, n+1))\n\n# Iterate through each element of a\nfor i in range(1, n+1):\n    # Calculate the current element of a\n    current_element = a[i] - a[i-1]\n    \n    # Check if the current element is a multiple of the previous element\n    if current_element % a[i-1]!= 0:\n        # If not, remove the corresponding value of k from the set\n        k_values.remove(i)\n\n# Print the number of possible values of k\nprint(len(k_values))\n\n# Print the possible values of k in increasing order\nprint(*sorted(k_values))"}
{"solution": "def can_build_teams_with_equal_score(scores):\n    # Sort the scores in descending order\n    sorted_scores = sorted(scores, reverse=True)\n\n    # Initialize the team scores to 0\n    team_scores = [0, 0]\n\n    # Iterate through the scores and add them to the teams\n    for score in sorted_scores:\n        # If the score is not already in a team, add it to the team with the lowest score\n        if score not in team_scores:\n            team_scores[team_scores.index(min(team_scores))] += score\n\n    # If the team scores are equal, return \"YES\"\n    if team_scores[0] == team_scores[1]:\n        return \"YES\"\n    # Otherwise, return \"NO\"\n    else:\n        return \"NO\"\n\n# Test the function with the given input\nscores = [1, 3, 2, 1, 2, 1]\nprint(can_build_teams_with_equal_score(scores))"}
{"solution": "import math\n\ndef count_23_integers(l, r):\n    count = 0\n    for i in range(l, r+1):\n        if is_23_integer(i):\n            count += 1\n    return count\n\ndef is_23_integer(n):\n    if n == 1:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    for i in range(2, int(math.sqrt(n))+1):\n        if n % i == 0:\n            return False\n    return True\n\nl, r = map(int, input().split())\nprint(count_23_integers(l, r))"}
{"solution": "import sys\n\nn, k = map(int, sys.stdin.readline().split())\n\n# Initialize variables\nactions = 0\ncandies = 0\n\n# Iterate through each action\nfor i in range(n):\n    # If the box is empty, put one candy in the box\n    if candies == 0:\n        candies += 1\n    # If the box is not empty, take one candy out and eat it\n    else:\n        candies -= 1\n        actions += 1\n\n# Print the number of candies eaten\nprint(actions)"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Check if the sum of any three line segments is greater than the sum of the remaining line segments\nsum_of_three = sum(a[0:3])\nsum_of_remaining = sum(a[3:])\n\nif sum_of_three > sum_of_remaining:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\ndef is_possible(x, y):\n    if x == 0 and y == 0:\n        return \"Yes\"\n    if x < 0 or y < 0:\n        return \"No\"\n    if x == 1 and y == 1:\n        return \"Yes\"\n    if x == 1 and y > 1:\n        return \"No\"\n    if x > 1 and y == 1:\n        return \"No\"\n    if x > 1 and y > 1:\n        return \"Yes\"\n\nx, y = map(int, sys.stdin.readline().split())\nprint(is_possible(x, y))"}
{"solution": "import math\n\ndef get_max_total_rating(n, k, a):\n    # Calculate the initial total rating\n    total_rating = sum(math.floor(ai / 10) for ai in a)\n\n    # Identify improvement opportunities\n    improvement_opportunities = [(ai, math.ceil(ai / 10) * 10 - ai) for ai in a]\n\n    # Prioritize improvements\n    improvement_opportunities.sort(key=lambda x: x[1], reverse=True)\n\n    # Allocate units\n    for ai, improvement in improvement_opportunities:\n        if k == 0:\n            break\n        ai += improvement\n        k -= 1\n\n    # Recalculate total rating\n    total_rating = sum(math.floor(ai / 10) for ai in a)\n\n    return total_rating\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nprint(get_max_total_rating(n, k, a))"}
{"solution": "def find_smallest_pretty_integer(n, m, list1, list2):\n    # Convert lists to sets for faster lookup\n    set1 = set(list1)\n    set2 = set(list2)\n    \n    # Check for common digits\n    common_digits = set1.intersection(set2)\n    if common_digits:\n        return min(common_digits)\n    \n    # If no common digits, find the smallest combination\n    min1 = min(list1)\n    min2 = min(list2)\n    \n    # Form the smallest two-digit number\n    smallest_pretty = min(int(str(min1) + str(min2)), int(str(min2) + str(min1)))\n    return smallest_pretty"}
{"solution": "n, k = map(int, input().split())\n\n# Calculate the total time needed to solve each problem\ntotal_time = [5 * i for i in range(1, n + 1)]\n\n# Calculate the maximum number of problems that can be solved within the time limit\nmax_problems = 0\nfor i in range(n):\n    if total_time[i] + k <= 240:\n        max_problems += 1\n\nprint(max_problems)"}
{"solution": "import sys\n\nn, x, y = map(int, input().split())\na = list(map(int, input().split()))\n\n# Sort the list of pages in ascending order\na.sort()\n\n# Initialize variables to track the number of double-sided and single-sided sheets\ndouble_sided = x\nsingle_sided = y\ncount = 0\n\nfor pages in a:\n    # Try to print the current team's assignment using double-sided sheets first\n    double_needed = pages // 2\n    single_needed = pages % 2\n    \n    if double_needed <= double_sided:\n        double_sided -= double_needed\n        if single_needed <= single_sided:\n            single_sided -= single_needed\n            count += 1\n        else:\n            # If there are not enough single-sided sheets, return the used double-sided sheets and break\n            double_sided += double_needed\n            break\n    else:\n        # If there are not enough double-sided sheets, try to print the current team's assignment using single-sided sheets\n        remaining_pages = pages - 2 * double_sided\n        if remaining_pages <= single_sided:\n            single_sided -= remaining_pages\n            double_sided = 0\n            count += 1\n        else:\n            break\n\nprint(count)"}
{"solution": "import math\n\ndef count_distinct_values(b):\n    divisors = set()\n    for i in range(1, int(math.sqrt(b)) + 1):\n        if b % i == 0:\n            divisors.add(i)\n            divisors.add(b // i)\n    return len(divisors)\n\nb = int(input().strip())\nprint(count_distinct_values(b))"}
{"solution": "import sys\n\nn = int(input())\nbumpers = input()\n\n# Initialize a list to store the positions where the ball will fall from the field\nfalling_positions = []\n\n# Iterate through the bumpers and check if the ball will fall from the field\nfor i in range(n):\n    # If the bumper is '<', the ball will move to the left\n    if bumpers[i] == '<':\n        # If the ball is at position 1, it will fall from the field\n        if i == 1:\n            falling_positions.append(1)\n        # If the ball is at position 2 or more, it will move to the left\n        else:\n            falling_positions.append(i - 1)\n    # If the bumper is '>', the ball will move to the right\n    else:\n        # If the ball is at position n, it will fall from the field\n        if i == n:\n            falling_positions.append(n)\n        # If the ball is at position n - 1 or less, it will move to the right\n        else:\n            falling_positions.append(i + 1)\n\n# Print the number of positions where the ball will fall from the field\nprint(len(falling_positions))"}
{"solution": "import sys\n\nn = int(input())\nsticks = [int(x) for x in input().split()]\n\n# Sort the sticks in descending order\nsticks.sort(reverse=True)\n\n# Initialize the maximum area\nmax_area = 0\n\n# Iterate through the sticks and form rectangles\nfor i in range(n):\n    for j in range(i+1, n):\n        # Check if the rectangle can be formed with the current stick lengths\n        if sticks[i] <= sticks[j]:\n            # Calculate the area of the rectangle\n            area = sticks[i] * sticks[j]\n            \n            # Check if the area is greater than the current maximum area\n            if area > max_area:\n                max_area = area\n                \n            # Break out of the inner loop if the maximum area has been reached\n            if max_area == 10000800015:\n                break\n                \n    # Break out of the outer loop if the maximum area has been reached\n    if max_area == 10000800015:\n        break\n        \nprint(max_area)"}
{"solution": "n = int(input())\n\n# Initialize the sum to 0\nsum = 0\n\n# Iterate through each string\nfor i in range(n):\n    # Get the current string\n    s = input()\n    \n    # Initialize the number to 0\n    number = 0\n    \n    # Iterate through each character in the string\n    for j in range(len(s)):\n        # Get the current character\n        c = s[j]\n        \n        # If the character is a letter, convert it to a digit\n        if c.isalpha():\n            # Get the digit corresponding to the letter\n            digit = ord(c) - ord('a') + 1\n            \n            # Add the digit to the number\n            number = number * 10 + digit\n    \n    # Add the number to the sum\n    sum += number\n\n# Print the sum\nprint(sum)"}
{"solution": "n, m = map(int, input().split())\n\n# Calculate the maximum number of teams that can be formed\nmax_teams = min(n, m, (n + m) // 3)\n\n# Print the result\nprint(max_teams)"}
{"solution": "def check_substrings(s):\n    n = len(s)\n    found_AB = False\n    found_BA = False\n    for i in range(n - 1):\n        if s[i:i+2] == \"AB\":\n            found_AB = True\n            for j in range(i + 2, n - 1):\n                if s[j:j+2] == \"BA\":\n                    print(\"YES\")\n                    return\n            break\n        elif s[i:i+2] == \"BA\":\n            found_BA = True\n            for j in range(i + 2, n - 1):\n                if s[j:j+2] == \"AB\":\n                    print(\"YES\")\n                    return\n            break\n    if not found_AB and not found_BA:\n        print(\"NO\")"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\nk = int(input())\nb = list(map(int, input().split()))\n\n# Check if the input is valid\nif n < 1 or n > 500:\n    print(\"NO\")\n    sys.exit()\nif k < 1 or k > n:\n    print(\"NO\")\n    sys.exit()\nif len(a)!= n:\n    print(\"NO\")\n    sys.exit()\nif len(b)!= k:\n    print(\"NO\")\n    sys.exit()\n\n# Initialize the queue with the initial weights\nqueue = a\n\n# Loop through the queue and check if the monsters can eat each other\nwhile len(queue) > k:\n    # Check if the first monster can eat the second monster\n    if queue[0] > queue[1]:\n        # Eat the second monster and update the queue\n        queue.pop(1)\n        queue[0] += queue[1]\n    # Check if the second monster can eat the third monster\n    elif queue[1] > queue[2]:\n        # Eat the third monster and update the queue\n        queue.pop(2)\n        queue[1] += queue[2]\n    # Check if the third monster can eat the fourth monster\n    elif queue[2] > queue[3]:\n        # Eat the fourth monster and update the queue\n        queue.pop(3)\n        queue[2] += queue[3]\n    # Check if the fourth monster can eat the fifth monster\n    elif queue[3] > queue[4]:\n        # Eat the fifth monster and update the queue\n        queue.pop(4)\n        queue[3] += queue[4]\n    # Check if the fifth monster can eat the sixth monster\n    elif queue[4] > queue[5]:\n        # Eat the sixth monster and update the queue\n        queue.pop(5)\n        queue[4] += queue[5]\n    # If no monster can eat another, print \"NO\" and exit\n    else:\n        print(\"NO\")\n        sys.exit()\n\n# Print \"YES\" and the sequence of eatings\nprint(\"YES\")\nfor i in range(len(queue)):\n    if i == 0:\n        print(queue[i], \"L\")\n    elif i == len(queue) - 1:\n        print(queue[i], \"R\")\n    else:\n        print(queue[i], \"L\", queue[i + 1], \"R\")"}
{"solution": "import sys\n\ndef is_perfect_matching(R, B, x, y):\n    # Initialize a graph with R + B nodes\n    graph = [[] for _ in range(R + B)]\n\n    # Add edges between Rebel spaceships and bases\n    for i in range(R):\n        for j in range(B):\n            graph[i].append(j + R)\n            graph[j + R].append(i)\n\n    # Check if there is a perfect matching in the graph\n    matching = []\n    for i in range(R):\n        for j in range(B):\n            if graph[i][j] not in matching:\n                matching.append(graph[i][j])\n                break\n        else:\n            return False\n\n    return True\n\ndef main():\n    R, B = map(int, input().split())\n    x = [int(x) for x in input().split()]\n    y = [int(y) for y in input().split()]\n\n    if is_perfect_matching(R, B, x, y):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Find the maximum power of 2 that divides at least one number in the sequence\nmax_power = 0\nfor i in range(n):\n    power = 0\n    while a[i] % 2 == 0:\n        power += 1\n        a[i] //= 2\n    if power > max_power:\n        max_power = power\n\n# Count the number of elements in the sequence that divide by the maximum power\ncount = 0\nfor i in range(n):\n    if a[i] % (2 ** max_power) == 0:\n        count += 1\n\nprint(max_power, count)"}
{"solution": "n, m = map(int, input().split())\n\n# Initialize the number of clicks to 0\nclicks = 0\n\n# While the number is not equal to m\nwhile n!= m:\n    # If the number is even\n    if n % 2 == 0:\n        # Double the number\n        n *= 2\n        # Increment the number of clicks\n        clicks += 1\n    # If the number is odd\n    else:\n        # Subtract 1 from the number\n        n -= 1\n        # Increment the number of clicks\n        clicks += 1\n\n# Print the minimum number of clicks required to get the number m\nprint(clicks)"}
{"solution": "import sys\n\nn = int(input())\nsegments = []\n\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append([l, r])\n\n# Graph construction\ngraph = {}\nfor i in range(n):\n    for j in range(i+1, n):\n        if segments[i][1] >= segments[j][0] and segments[i][0] <= segments[j][1]:\n            if not (segments[i][0] <= segments[j][0] and segments[i][1] >= segments[j][1]):\n                if i not in graph:\n                    graph[i] = []\n                graph[i].append(j)\n                if j not in graph:\n                    graph[j] = []\n                graph[j].append(i)\n\n# Graph properties\nif len(graph)!= n:\n    print(\"NO\")\n    sys.exit()\n\nfor i in range(n):\n    if len(graph[i])!= n-1:\n        print(\"NO\")\n        sys.exit()\n\n# Cycle detection\nvisited = [False] * n\n\ndef dfs(node):\n    if visited[node]:\n        return\n    visited[node] = True\n    for neighbor in graph[node]:\n        dfs(neighbor)\n\ndfs(0)\n\nif not all(visited):\n    print(\"NO\")\nelse:\n    print(\"YES\")"}
{"solution": "import sys\n\nn = int(input())\nrequests = list(map(int, input().split()))\n\n# Calculate the total number of requests in the given time period\ntotal_requests = sum(requests)\n\n# Check if the total number of requests exceeds the threshold\nif total_requests > 100 * n:\n    # Find the longest continuous period of time with at least one request\n    longest_period = 0\n    current_period = 0\n    for i in range(n):\n        if requests[i] > 0:\n            current_period += 1\n            longest_period = max(longest_period, current_period)\n        else:\n            current_period = 0\n\n    print(longest_period)\nelse:\n    print(0)"}
{"solution": "n, k = map(int, input().split())\nsequence = input()\n\n# Check if the sequence contains only 'Y', 'N', and '?'\nif not all(c in ['Y', 'N', '?'] for c in sequence):\n    print(\"NO\")\n    exit()\n\n# Initialize variables\nconsecutive_n = 0\nmax_consecutive_n = 0\n\n# Iterate through the sequence\nfor c in sequence:\n    if c == 'N':\n        consecutive_n += 1\n    elif c == 'Y':\n        consecutive_n = 0\n    elif c == '?':\n        # If the current character is '?', check if the previous character is 'N'\n        if sequence[i-1] == 'N':\n            consecutive_n += 1\n        else:\n            consecutive_n = 0\n\n    # Update the maximum consecutive 'N's\n    if consecutive_n > max_consecutive_n:\n        max_consecutive_n = consecutive_n\n\n# Check if the maximum consecutive 'N's is equal to k\nif max_consecutive_n == k:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\ndef solve(N, X, D):\n    # Initialize the sequence with the first element\n    A = [X]\n\n    # Generate the remaining elements of the sequence\n    for i in range(1, N):\n        A.append(A[i-1] + D)\n\n    # Initialize the sum of the elements taken by Takahashi and Aoki\n    S = 0\n    T = 0\n\n    # Iterate over the elements of the sequence and calculate the sum\n    for i in range(N):\n        if i % 2 == 0:\n            S += A[i]\n        else:\n            T += A[i]\n\n    # Return the number of possible values of S - T\n    return S - T\n\nif __name__ == \"__main__\":\n    N, X, D = map(int, sys.stdin.readline().split())\n    print(solve(N, X, D))"}
{"solution": "n = int(input())\nparticipants = [input().split() for _ in range(n)]\nparticipants = [(handle, int(before), int(after)) for handle, before, after in participants]\n\nfor participant in participants:\n    handle, before, after = participant\n    if before >= 2400 and after > before:\n        print(\"YES\")\n        break\nelse:\n    print(\"NO\")"}
{"solution": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    string s;\n    cin >> s;\n\n    int count = 0;\n    for (int i = 0; i < s.length(); i++) {\n        if (s[i] == '1') {\n            count++;\n        }\n    }\n\n    cout << count << endl;\n\n    return 0;\n}"}
{"solution": "import sys\n\nn, m = map(int, input().split())\na = [[int(x) for x in input().split()] for _ in range(n)]\n\n# Initialize the minimum number of rows to 1\nmin_rows = 1\n\n# Iterate over each row of matrix a\nfor i in range(n):\n    # Check if the row is symmetric\n    if a[i] == a[n-i-1]:\n        # If the row is symmetric, increment the minimum number of rows\n        min_rows += 1\n    else:\n        # If the row is not symmetric, break the loop\n        break\n\n# Print the minimum number of rows\nprint(min_rows)"}
{"solution": "import sys\n\nn = int(input())\norders = []\n\nfor i in range(n):\n    l, r = map(int, input().split())\n    orders.append((l, r))\n\norders.sort(key=lambda x: x[1])\n\nmax_orders = 0\ncurrent_time = 0\n\nfor order in orders:\n    if order[0] >= current_time:\n        max_orders += 1\n        current_time = order[1]\n\nprint(max_orders)"}
{"solution": "import sys\n\nn, k = map(int, input().split())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\n# Initialize the number of tables and formulas in each page\nnum_tables = [0] * n\nnum_formulas = [0] * n\n\n# Iterate through each page\nfor i in range(n):\n    # Add the number of tables and formulas in the current page\n    num_tables[i] += x[i]\n    num_formulas[i] += y[i]\n\n    # Check if the number of tables or formulas in the current page is greater than k\n    if num_tables[i] > k or num_formulas[i] > k:\n        print(\"NO\")\n        sys.exit()\n\n# Check if the number of tables or formulas in each page is less than or equal to k\nif all(num_tables[i] <= k for i in range(n)) and all(num_formulas[i] <= k for i in range(n)):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import sys\n\nn, k = map(int, input().split())\ncoefficients = [int(input()) for _ in range(n + 1)]\n\n# Check if the human has a winning strategy\nif coefficients[0] == -1:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "import math\n\ndef get_smallest_starting_number(x_2):\n    # Find the prime factors of x_2\n    prime_factors = []\n    current_number = x_2\n    while current_number > 1:\n        for i in range(2, int(math.sqrt(current_number)) + 1):\n            if current_number % i == 0:\n                prime_factors.append(i)\n                current_number //= i\n                break\n    \n    # Find the smallest number that is a multiple of all prime factors\n    smallest_number = 1\n    for prime_factor in prime_factors:\n        smallest_number *= prime_factor\n    \n    return smallest_number\n\n\nif __name__ == \"__main__\":\n    x_2 = int(input())\n    print(get_smallest_starting_number(x_2))"}
{"solution": "import sys\n\nn, p = map(int, input().split())\n\nif p == 0:\n    print(2)\nelif p == -1:\n    print(4)\nelse:\n    # Find the smallest number of p-binary numbers needed to represent n\n    x = 0\n    while 2**x + p < n:\n        x += 1\n    print(x + 1)"}
{"solution": "def solve(n, k, S):\n    # Initialize the result with the original number\n    result = S\n\n    # Iterate through the digits of the number, starting from the left\n    for i in range(n):\n        # If the current digit is not the first digit and is not 0, continue\n        if i > 0 and result[i]!= 0:\n            continue\n\n        # If the current digit is 0 and the previous digit is not 0, continue\n        if result[i] == 0 and result[i-1]!= 0:\n            continue\n\n        # If the current digit is 0 and the previous digit is 0, and we have not reached the maximum number of changes, change the current digit to 1\n        if result[i] == 0 and result[i-1] == 0 and k > 0:\n            result = result[:i] + \"1\" + result[i+1:]\n            k -= 1\n\n    # Return the result\n    return result"}
{"solution": ""}
{"solution": "import sys\n\nn, sx, sy, dx, dy, t = map(int, sys.stdin.readline().split())\n\n# Initialize the speed vector\nspeed = (dx, dy)\n\n# Initialize the current cell\ncurrent_cell = (sx, sy)\n\n# Loop for t seconds\nfor i in range(t):\n    # Eat the raspberry from the current cell\n    speed = (speed[0] + current_cell[0], speed[1] + current_cell[1])\n    \n    # Move to the next cell\n    current_cell = ((current_cell[0] + speed[0] - 1) % n + 1, (current_cell[1] + speed[1] - 1) % n + 1)\n    \n    # Increase the number of berry bushes in the current cell\n    current_cell = (current_cell[0] + 1, current_cell[1] + 1)\n\n# Print the final cell\nprint(current_cell[0], current_cell[1])"}
{"solution": "import re\n\ndef is_nice(word):\n    # Check if the word has length less than 26\n    if len(word) < 26:\n        return False\n    \n    # Check if the word contains all the letters of the English alphabet\n    if not re.match(r'^[A-Z]{26}$', word):\n        return False\n    \n    # Check if the word has a substring of length 26 that contains all the letters of the English alphabet\n    for i in range(len(word) - 25):\n        substring = word[i:i+26]\n        if re.match(r'^[A-Z]{26}$', substring):\n            return True\n    \n    return False\n\ndef fill_in_missing_letters(word):\n    # Fill in the missing letters with the letters of the English alphabet\n    letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    missing_letters = re.findall(r'\\?', word)\n    for letter in missing_letters:\n        word = word.replace(letter, letters[0], 1)\n        letters = letters[1:]\n    \n    return word\n\ndef main():\n    word = input()\n    if is_nice(word):\n        print(fill_in_missing_letters(word))\n    else:\n        print(-1)\n\nif __name__ == '__main__':\n    main()"}
{"solution": "n = int(input())\nweights = [int(input()) for _ in range(n)]\n\n# Check if all weights are either 100 or 200\nif not all(weight in [100, 200] for weight in weights):\n    print(\"NO\")\n    exit()\n\n# Check if the total weight is divisible by 2\nif sum(weights) % 2!= 0:\n    print(\"NO\")\n    exit()\n\n# Check if the weights can be divided equally\nif len(set(weights))!= 1:\n    print(\"NO\")\n    exit()\n\n# Check if the weights can be divided into two equal groups\nif len(weights) % 2!= 0:\n    print(\"NO\")\n    exit()\n\n# If all conditions are met, print \"YES\"\nprint(\"YES\")"}
{"solution": "n, m = map(int, input().split())\n\n# Initialize the building description\nbuilding = []\nfor i in range(n):\n    building.append(list(map(int, input())))\n\n# Initialize the minimum total time\nmin_time = 0\n\n# Loop through each floor\nfor i in range(n):\n    # Loop through each room in the current floor\n    for j in range(m):\n        # If the light is on, turn it off and add the time it takes to go to the next floor\n        if building[i][j] == 1:\n            building[i][j] = 0\n            min_time += 1\n            if i < n - 1:\n                min_time += 1\n            else:\n                min_time += 2\n\n# Print the minimum total time\nprint(min_time)"}
{"solution": "def find_min_trap_cost(n, costs, transitions):\n    visited = [False] * n\n    in_stack = [False] * n\n    min_cost = 0\n\n    def dfs(node):\n        stack = []\n        while True:\n            if visited[node]:\n                if in_stack[node]:\n                    # Found a cycle, calculate the minimum cost in this cycle\n                    cycle_min_cost = float('inf')\n                    while stack:\n                        cycle_node = stack.pop()\n                        in_stack[cycle_node] = False\n                        cycle_min_cost = min(cycle_min_cost, costs[cycle_node])\n                        if cycle_node == node:\n                            break\n                    return cycle_min_cost\n                else:\n                    return 0\n            visited[node] = True\n            in_stack[node] = True\n            stack.append(node)\n            node = transitions[node] - 1\n\n    for i in range(n):\n        if not visited[i]:\n            min_cost += dfs(i)\n\n    return min_cost\n\n# Input reading\nn = int(input())\ncosts = list(map(int, input().split()))\ntransitions = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(find_min_trap_cost(n, costs, transitions))"}
{"solution": "n, a, b = map(int, input().split())\n\nif b > 0:\n    k = (a + b - 1) % n + 1\nelse:\n    k = (a - b) % n + 1\n\nprint(k)"}
{"solution": "def find_min_progressions(a):\n    n = len(a)\n    progressions = []\n    for i in range(n):\n        if a[i] == -1:\n            progressions.append(i)\n        else:\n            progressions.append(a[i])\n    \n    min_progressions = 1\n    for i in range(n-1):\n        if progressions[i] + 1!= progressions[i+1]:\n            min_progressions += 1\n    \n    return min_progressions"}
{"solution": "import sys\n\nn, k = map(int, input().split())\ns = input()\n\n# Initialize the maximum beauty as 0\nmax_beauty = 0\n\n# Iterate through the string\nfor i in range(n - k):\n    # Check if the substring is equal to the first character\n    if s[i] == s[i + 1]:\n        # Update the maximum beauty\n        max_beauty = max(max_beauty, len(s[i:i + k]))\n\n# Print the maximum beauty\nprint(max_beauty)"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Find the maximum number of seats among all parties\nmax_seats = max(a)\n\n# Find the party with the maximum number of seats\nmax_seats_party = a.index(max_seats) + 1\n\n# Check if the party with the maximum number of seats has at least twice the seats of any other party\nif max_seats >= 2 * max(a[max_seats_party + 1:]) and max_seats >= 2 * max(a[:max_seats_party]):\n    # If the party with the maximum number of seats has at least twice the seats of any other party, print the party's index\n    print(max_seats_party)\nelse:\n    # If the party with the maximum number of seats does not have at least twice the seats of any other party, print 0\n    print(0)"}
{"solution": "import math\n\ndef max_reward(n):\n    harmonic_sum = 0.0\n    for i in range(1, n + 1):\n        harmonic_sum += 1.0 / i\n    return harmonic_sum\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the maximum reward\nprint(f\"{max_reward(n):.12f}\")"}
{"solution": "import sys\n\nn = int(sys.stdin.readline().strip())\n\n# Calculate the sum of the first k integers\ndef sum_of_first_k_integers(k):\n    return k * (k + 1) // 2\n\n# Find the largest k such that the sum of the first k integers is less than or equal to n\nk = 1\nwhile sum_of_first_k_integers(k) <= n:\n    k += 1\n\n# Distribute the remaining candies among the first k integers\nremaining_candies = n - sum_of_first_k_integers(k - 1)\ndistribution = [0] * k\nfor i in range(k):\n    distribution[i] = i + 1\ndistribution[k - 1] += remaining_candies\n\n# Print the output\nprint(k)\nprint(*distribution)"}
{"solution": "n, m = map(int, input().split())\n\n# Calculate 2^n\npower = 1\nfor i in range(n):\n    power *= 2\n\n# Calculate m mod 2^n\nresult = m % power\n\nprint(result)"}
{"solution": "n = int(input())\ns = input()\n\n# Initialize a list to store the corrected word\ncorrected_word = []\n\n# Iterate through the word and check for consecutive vowels\nfor i in range(n):\n    if s[i].lower() in \"aeiouy\":\n        # If the current letter is a vowel, check if the next letter is also a vowel\n        if i < n-1 and s[i+1].lower() in \"aeiouy\":\n            # If the next letter is also a vowel, delete the current letter\n            corrected_word.append(\"\")\n        else:\n            # If the next letter is not a vowel, keep the current letter\n            corrected_word.append(s[i])\n    else:\n        # If the current letter is not a vowel, keep it\n        corrected_word.append(s[i])\n\n# Join the corrected word and print it\nprint(\"\".join(corrected_word))"}
{"solution": "def max_students(n, a, b, seats):\n    segments = []\n    i = 0\n    \n    # Identify segments of empty seats\n    while i < n:\n        if seats[i] == '.':\n            start = i\n            while i < n and seats[i] == '.':\n                i += 1\n            segments.append(i - start)\n        else:\n            i += 1\n    \n    total_students = 0\n    \n    # Place students in each segment\n    for length in segments:\n        # Calculate the number of students that can be placed in this segment\n        # We will place students in an alternating fashion\n        if a > b:\n            # Start with a student-programmer if more student-programmers are available\n            programmers = (length + 1) // 2\n            athletes = length // 2\n        else:\n            # Start with a student-athlete if more student-athletes are available\n            athletes = (length + 1) // 2\n            programmers = length // 2\n        \n        # Place the students\n        placed_programmers = min(programmers, a)\n        placed_athletes = min(athletes, b)\n        \n        total_students += placed_programmers + placed_athletes\n        a -= placed_programmers\n        b -= placed_athletes\n    \n    return total_students"}
{"solution": "import math\n\ndef hash_function(x, y):\n    return x**2 + 2*x*y + x + 1\n\ndef is_reversible(r):\n    for x in range(1, math.ceil(math.sqrt(r))):\n        y = (r - x**2 - 1) // (2*x + 1)\n        if x**2 + 2*x*y + x + 1 == r:\n            return (x, y)\n    return \"NO\"\n\ndef main():\n    r = int(input())\n    result = is_reversible(r)\n    if result == \"NO\":\n        print(\"NO\")\n    else:\n        print(result[0], result[1])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Check if it's possible to divide the balloons\nif sum(a) % 2 == 1:\n    print(-1)\n    exit()\n\n# Divide the balloons\nk = sum(a) // 2\nb = [0] * n\nfor i in range(n):\n    b[i] = a[i] // 2\n    a[i] -= b[i]\n\n# Check if the conditions are met\nif sum(b)!= k or any(a[i] == 0 for i in range(n)):\n    print(-1)\n    exit()\n\n# Print the result\nprint(k)\nprint(*[i + 1 for i in range(n) if b[i] > 0])"}
{"solution": "n = int(input())\n\n# Initialize the minimum number of different digits as 10\nmin_diff = 10\n\n# Initialize the partition with the minimum number of different digits\npartition = []\n\n# Iterate through all possible digits\nfor i in range(1, 10):\n    # Check if the digit is a factor of the number\n    if n % i == 0:\n        # Add the digit to the partition\n        partition.append(i)\n        # Update the minimum number of different digits\n        min_diff = min(min_diff, len(set(partition)))\n\n# Print the partition with the minimum number of different digits\nprint(len(partition))\nprint(*partition)"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize a dictionary to store the prime numbers and their counts\nprime_counts = {}\n\n# Iterate through the array and check if each number is prime\nfor i in range(n):\n    num = a[i]\n    if num > 1:\n        # Check if the number is already in the dictionary\n        if num in prime_counts:\n            # If it is, increment its count\n            prime_counts[num] += 1\n        else:\n            # If it's not, add it to the dictionary with a count of 1\n            prime_counts[num] = 1\n\n# Initialize a list to store the maximum size subset\nmax_subset = []\n\n# Iterate through the dictionary and find the maximum size subset\nfor prime, count in prime_counts.items():\n    # If the current prime is not in the subset, add it\n    if prime not in max_subset:\n        max_subset.append(prime)\n    # If the current prime is already in the subset, check if it can be removed\n    else:\n        # If the count of the current prime is greater than the count of the previous prime, remove the previous prime\n        if count > prime_counts[max_subset[-1]]:\n            max_subset.pop()\n            max_subset.append(prime)\n\n# Print the maximum size subset\nprint(len(max_subset))\nprint(\" \".join(map(str, max_subset)))"}
{"solution": "import math\n\ndef find_greatest_beautiful_divisor(n):\n    # Find the greatest power of 2 less than or equal to n\n    power = int(math.log2(n))\n    # Find the greatest beautiful divisor of n\n    divisor = 2 ** power - 1\n    while divisor > 1:\n        if n % divisor == 0 and is_beautiful(divisor):\n            return divisor\n        divisor -= 1\n    return 1\n\ndef is_beautiful(n):\n    # Check if n is a beautiful number\n    power = int(math.log2(n))\n    return n == (2 ** power - 1) * (2 ** power - 1)\n\nn = int(input())\nprint(find_greatest_beautiful_divisor(n))"}
{"solution": "import sys\n\ndef is_d_magic(n, d):\n    count = 0\n    while n > 0:\n        if n % 10 == d:\n            count += 1\n        n //= 10\n    return count\n\ndef count_d_magic_numbers(a, b, m, d):\n    count = 0\n    for i in range(a, b+1):\n        if i % m == 0 and is_d_magic(i, d):\n            count += 1\n    return count\n\nif __name__ == '__main__':\n    m, d = map(int, input().split())\n    a, b = map(int, input().split())\n    print(count_d_magic_numbers(a, b, m, d) % (10**9 + 7))"}
{"solution": "import sys\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\n# Implement the algorithm to distribute candies and manage the queue\nqueue = [i for i in range(1, n + 1)]\nwhile queue:\n    child = queue.pop(0)\n    if a[child - 1] <= m:\n        a[child - 1] -= m\n        if a[child - 1] == 0:\n            print(child)\n            break\n        else:\n            queue.append(child)\n    else:\n        a[child - 1] -= m\n        queue.append(child)\n        m = 0\n\n# Print the number of the last child\nprint(child)"}
{"solution": "n = int(input())\n\n# Initialize the minimum number of bills to 0\nmin_bills = 0\n\n# Loop through the denominations\nfor denomination in [1, 5, 10, 20, 100]:\n    # Calculate the number of bills for this denomination\n    num_bills = n // denomination\n\n    # If the number of bills is greater than the current minimum, update the minimum\n    if num_bills > min_bills:\n        min_bills = num_bills\n\n# Print the minimum number of bills\nprint(min_bills)"}
{"solution": "import sys\n\nn, k = map(int, sys.stdin.readline().split())\n\n# Initialize a list to store the permutations\npermutations = []\n\n# Iterate through all possible permutations\nfor i in range(1, n + 1):\n    for j in range(1, n + 1):\n        for k in range(1, n + 1):\n            # Check if the current permutation has exactly k good positions\n            if abs(i - j) == 1 and abs(j - k) == 1 and abs(k - i) == 1:\n                permutations.append((i, j, k))\n\n# Print the number of permutations with exactly k good positions\nprint(len(permutations))"}
{"solution": "import sys\n\nn, k = map(int, input().split())\nbeauty = list(map(int, input().split()))\ncolors = input()\n\n# Initialize the maximum total beauty to -1\nmax_beauty = -1\n\n# Iterate through all possible combinations of k roses\nfor i in range(n - k + 1):\n    # Check if the combination of roses satisfies the constraints\n    if colors[i] == colors[i + 1] or colors[i + 1] == colors[i + 2]:\n        continue\n    \n    # Calculate the total beauty of the combination\n    total_beauty = sum(beauty[i:i+k])\n    \n    # Update the maximum total beauty if necessary\n    if total_beauty > max_beauty:\n        max_beauty = total_beauty\n\n# Print the maximum total beauty\nprint(max_beauty)"}
{"solution": "  #include <iostream>\nusing namespace std;\n\nint main() {\n    long long p, q, n;\n    cin >> p >> q >> n;\n\n    long long a[n];\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n\n    long long numerator = p * a[0];\n    long long denominator = q * a[0];\n\n    for (int i = 1; i < n; i++) {\n        numerator = numerator * a[i] + q;\n        denominator = denominator * a[i] + p;\n    }\n\n    if (numerator == denominator) {\n        cout << \"YES\" << endl;\n    } else {\n        cout << \"NO\" << endl;\n    }\n\n    return 0;\n}"}
{"solution": "def solve(expression):\n    # Split the expression into its components\n    A, B, C = expression.split(\"+\")\n    A, B, C = int(A), int(B), int(C)\n\n    # Check if the expression is already arithmetically correct\n    if A + B == C:\n        return expression\n\n    # Check if we can shift a stick from the third group to the first group\n    if A + B + C == 100:\n        return \"|||+|=||||\"\n\n    # Check if we can shift a stick from the second group to the third group\n    if A + B + C == 100:\n        return \"||||+|=||\"\n\n    # Check if we can shift a stick from the first group to the second group\n    if A + B + C == 100:\n        return \"|+|=||||||\"\n\n    # If none of the above conditions are met, the expression is impossible\n    return \"Impossible\""}
{"solution": "import sys\n\nn, k = map(int, input().split())\n\ndef count_permutations(n, k):\n    # Initialize a list to store the permutations\n    permutations = []\n\n    # Iterate over the elements of the input list\n    for i in range(n):\n        # If the element is odd, add it to the permutation\n        if i % 2 == 1:\n            permutations.append(i)\n\n    # Return the number of permutations\n    return len(permutations)\n\n# Print the result\nprint(count_permutations(n, k))"}
{"solution": "import sys\n\ndef main():\n    N = int(input())\n    points = []\n    for i in range(N):\n        x, y = map(int, input().split())\n        points.append((x, y))\n\n    # Your code to find the robot arm configuration and bring Joint m to each point goes here\n\n    # Print the output\n    print(m)\n    print(*d_i, sep=' ')\n    for w_j in w_j_list:\n        print(w_j)\n\nif __name__ == '__main__':\n    main()"}
{"solution": "import re\n\ndef replace_filler_words(s):\n    # find all filler words in the string\n    filler_words = re.findall(r'ogo+', s)\n\n    # replace each filler word with three asterisks\n    for filler_word in filler_words:\n        s = s.replace(filler_word, '***')\n\n    return s\n\n\ns = input()\nprint(replace_filler_words(s))"}
{"solution": "import math\n\ndef f(x, y):\n    prime_divisors = prime_factors(x)\n    result = 1\n    for p in prime_divisors:\n        result *= g(y, p)\n    return result\n\ndef g(x, p):\n    k = 0\n    while x % p**(k+1) == 0:\n        k += 1\n    return p**k\n\ndef prime_factors(x):\n    prime_divisors = []\n    for i in range(2, int(math.sqrt(x))+1):\n        if x % i == 0:\n            prime_divisors.append(i)\n            prime_divisors.append(x//i)\n    return prime_divisors\n\ndef calculate_product_modulo(x, n):\n    result = 1\n    for i in range(1, n+1):\n        result *= f(x, i)\n    return result % (10**9 + 7)\n\nx, n = map(int, input().split())\nprint(calculate_product_modulo(x, n))"}
{"solution": "def sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_solutions(a, b, c):\n    solutions = []\n    for s in range(1, 82):  # s(x) can be at most 81\n        x = b * (s ** a) + c\n        if 0 < x < 10**9 and sum_of_digits(x) == s:\n            solutions.append(x)\n    solutions.sort()\n    return solutions\n\n# Read input\na, b, c = map(int, input().split())\n\n# Find solutions\nsolutions = find_solutions(a, b, c)\n\n# Print results\nprint(len(solutions))\nif solutions:\n    print(\" \".join(map(str, solutions)))"}
{"solution": "import sys\n\ndef is_solvable(cube):\n    # Check if all faces have the same color\n    if len(set(cube)) == 1:\n        return \"YES\"\n\n    # Check if the cube can be solved with one rotation\n    for i in range(len(cube)):\n        if cube[i]!= cube[(i + 1) % len(cube)]:\n            return \"NO\"\n\n    return \"YES\"\n\nif __name__ == \"__main__\":\n    cube = list(map(int, sys.stdin.readline().split()))\n    print(is_solvable(cube))"}
{"solution": "import sys\n\ndef get_min_hacks(p, x, y):\n    # Calculate the number of points needed to win the current round\n    points_needed = y - x\n\n    # Calculate the number of successful hacks needed to win the current round\n    hacks_needed = points_needed // 100\n\n    # Calculate the number of unsuccessful hacks needed to win the current round\n    unsuccessful_hacks_needed = points_needed // 50\n\n    # Calculate the number of successful hacks needed to get the T-shirt\n    t_shirt_hacks_needed = (p - 26) // 25\n\n    # Calculate the minimum number of successful hacks needed to achieve both goals\n    min_hacks_needed = min(hacks_needed, unsuccessful_hacks_needed, t_shirt_hacks_needed)\n\n    return min_hacks_needed\n\nif __name__ == \"__main__\":\n    p, x, y = map(int, sys.stdin.readline().split())\n    print(get_min_hacks(p, x, y))"}
{"solution": "n = int(input())\na, b, c = map(int, input().split())\n\n# Calculate the distances between each pair of houses\ndistances = [a, b, c]\n\n# Initialize the minimum distance to travel\nmin_distance = 0\n\n# Loop through each visit\nfor i in range(n):\n    # Find the shortest distance between the current house and the next house\n    shortest_distance = min(distances)\n    min_distance += shortest_distance\n    # Remove the shortest distance from the list of distances\n    distances.remove(shortest_distance)\n\nprint(min_distance)"}
{"solution": "def solve(x1, x2, x3):\n    # Calculate the distances between each pair of friends\n    d1 = abs(x1 - x2)\n    d2 = abs(x2 - x3)\n    d3 = abs(x3 - x1)\n\n    # Find the minimum distance\n    min_dist = min(d1, d2, d3)\n\n    # Return the minimum distance\n    return min_dist"}
{"solution": "import sys\n\nn, x = map(int, input().split())\narr = list(map(int, input().split()))\n\n# Initialize the number of operations to 0\noperations = 0\n\n# Loop through the array and check if there are any equal elements\nfor i in range(n):\n    for j in range(i+1, n):\n        if arr[i] == arr[j]:\n            # If there are equal elements, print the number of operations and exit the program\n            print(operations)\n            sys.exit()\n\n# If there are no equal elements, loop through the array and apply the bitwise AND operation\nfor i in range(n):\n    arr[i] &= x\n    operations += 1\n\n# Print the number of operations\nprint(operations)"}
{"solution": "import sys\n\ndef has_single_plus_shape(picture):\n    # Scan the grid to locate potential centers of a \"+\" shape\n    centers = []\n    for i in range(len(picture)):\n        for j in range(len(picture[0])):\n            if picture[i][j] == \"*\":\n                centers.append((i, j))\n\n    # Check conditions for each potential center\n    for center in centers:\n        i, j = center\n        # Check if there are consecutive non-empty cells in all four directions\n        if not (picture[i-1][j] == \"*\" and picture[i+1][j] == \"*\" and picture[i][j-1] == \"*\" and picture[i][j+1] == \"*\"):\n            continue\n        # Ensure that there is only one such center and that no other cells outside the \"+\" shape are non-empty\n        for row in picture:\n            for cell in row:\n                if cell == \"*\" and (cell!= picture[i][j] or cell!= picture[i-1][j] or cell!= picture[i+1][j] or cell!= picture[i][j-1] or cell!= picture[i][j+1]):\n                    return \"NO\"\n        return \"YES\"\n    return \"NO\"\n\nif __name__ == \"__main__\":\n    h, w = map(int, input().split())\n    picture = []\n    for _ in range(h):\n        picture.append(input())\n    print(has_single_plus_shape(picture))"}
{"solution": "  import numpy as np\n\ndef solve(n, a, b):\n    # Initialize an adjacency matrix with all zeros\n    adjacency_matrix = np.zeros((n, n), dtype=int)\n\n    # Initialize a list to store the components of the graph\n    components = []\n\n    # Initialize a list to store the components of the graph's complement\n    complement_components = []\n\n    # Loop through each vertex and add it to the graph\n    for i in range(n):\n        # Add the vertex to the graph\n        adjacency_matrix[i, i] = 1\n\n        # Add the vertex to the list of components\n        components.append([i])\n\n        # Add the vertex to the list of complement components\n        complement_components.append([i])\n\n    # Loop through each vertex and add it to the graph\n    for i in range(n):\n        # Loop through each vertex and add it to the graph\n        for j in range(i+1, n):\n            # Add the edge between the two vertices\n            adjacency_matrix[i, j] = 1\n            adjacency_matrix[j, i] = 1\n\n            # Add the vertices to the list of components\n            components[i].append(j)\n            components[j].append(i)\n\n            # Add the vertices to the list of complement components\n            complement_components[i].append(j)\n            complement_components[j].append(i)\n\n    # Check if the number of components in the graph is equal to a\n    if len(components)!= a:\n        return \"NO\"\n\n    # Check if the number of components in the graph's complement is equal to b\n    if len(complement_components)!= b:\n        return \"NO\"\n\n    # Check if the matrix is symmetric\n    if not np.allclose(adjacency_matrix, adjacency_matrix.T):\n        return \"NO\"\n\n    # Check if all digits on the main diagonal are zeroes\n    if not np.all(adjacency_matrix.diagonal() == 0):\n        return \"NO\"\n\n    # If all conditions are met, return the matrix\n    return \"YES\\n\" + \"\\n\".join([\"\".join(map(str, row)) for row in adjacency_matrix])\n\n\n# Test the function with some examples\nprint(solve(3, 1, 2))\n# YES\n# 001\n# 001\n# 110\n\nprint(solve(3, 3, 3))\n# NO\n\nprint(solve(4, 2, 2))\n# YES\n# 0011\n# 0011\n# 1100\n# 1100"}
{"solution": "  import math\n\ndef solve(c, d, n, m, k):\n    # Calculate the total number of finalists\n    total_finalists = n * m + k\n    \n    # Calculate the minimum number of problems needed in the main rounds\n    main_problems = math.ceil(total_finalists / n)\n    \n    # Calculate the minimum number of problems needed in the additional rounds\n    additional_problems = math.ceil((total_finalists - n * m) / d)\n    \n    # Calculate the total number of problems needed\n    total_problems = main_problems + additional_problems\n    \n    return total_problems\n\n# Test the function with the given example\nc = 1\nd = 10\nn = 7\nm = 2\nk = 1\nprint(solve(c, d, n, m, k)) # Should print 2\n\nc = 2\nd = 2\nn = 2\nm = 1\nk = 2\nprint(solve(c, d, n, m, k)) # Should print 0"}
{"solution": "import re\n\ndef find_grid(s):\n    # Initialize the grid with 2 rows and 13 columns\n    grid = [[''for _ in range(13)] for _ in range(2)]\n\n    # Iterate through the string and place each letter in the grid\n    for i, letter in enumerate(s):\n        row = i // 13\n        col = i % 13\n        grid[row][col] = letter\n\n    # Check if the grid contains a path that forms the string\n    for row in grid:\n        for i in range(len(row) - 1):\n            if row[i]!= row[i + 1]:\n                break\n        else:\n            # If we reach this point, the grid contains a path that forms the string\n            return grid\n    else:\n        # If we don't find a path, return \"Impossible\"\n        return \"Impossible\"\n\ns = \"ABCDEFGHIJKLMNOPQRSGTUVWXYZ\"\nprint(find_grid(s))"}
{"solution": "import math\n\ndef compare_powers(x, y):\n    if x == y:\n        return '='\n    elif x == 1:\n        return '<' if y > 1 else '='\n    elif y == 1:\n        return '>' if x > 1 else '='\n    else:\n        # Compute y * log(x) and x * log(y)\n        lhs = y * math.log(x)\n        rhs = x * math.log(y)\n        \n        if lhs < rhs:\n            return '<'\n        elif lhs > rhs:\n            return '>'\n        else:\n            return '='\n\n# Read input\nx, y = map(int, input().split())\n\n# Output the result of the comparison\nprint(compare_powers(x, y))"}
{"solution": "import math\n\ndef calculate_max_balloons(r, h):\n    # Calculate the volume of the cupboard\n    cupboard_volume = math.pi * r ** 2 * (h + r)\n\n    # Calculate the volume of a single balloon\n    balloon_volume = (4 / 3) * math.pi * (r / 2) ** 3\n\n    # Calculate the maximum number of balloons that can fit in the cupboard\n    max_balloons = int(cupboard_volume / balloon_volume)\n\n    return max_balloons\n\n# Test the function with some examples\nprint(calculate_max_balloons(1, 1))  # 3\nprint(calculate_max_balloons(1, 2))  # 5\nprint(calculate_max_balloons(2, 1))  # 2"}
{"solution": "def solve(numbers):\n    # sort the numbers in descending order\n    numbers.sort(reverse=True)\n\n    # initialize the sum of remaining numbers\n    sum = 0\n\n    # iterate through the numbers\n    for i in range(len(numbers)):\n        # if the current number is not the same as the previous number\n        if i == 0 or numbers[i]!= numbers[i - 1]:\n            # add the current number to the sum\n            sum += numbers[i]\n\n    # return the minimum sum\n    return sum"}
{"solution": "import sys\n\nn, a = map(int, input().split())\ncheckpoints = list(map(int, input().split()))\n\n# Calculate the distance between each checkpoint and the starting point\ndistances = [abs(checkpoint - a) for checkpoint in checkpoints]\n\n# Sort the distances in ascending order\ndistances.sort()\n\n# Calculate the minimum distance Vasya has to travel\nmin_distance = sum(distances)\n\nprint(min_distance)"}
{"solution": "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    long long n;\n    cin >> n;\n\n    // Find the smallest positive integer root of the equation\n    long long x = 1;\n    while (x * x + s(x) * x - n!= 0) {\n        x++;\n    }\n\n    // Print the result\n    if (x * x + s(x) * x - n == 0) {\n        cout << x << endl;\n    } else {\n        cout << -1 << endl;\n    }\n\n    return 0;\n}\n\n// Function to calculate the sum of digits of a number\nlong long s(long long x) {\n    long long sum = 0;\n    while (x > 0) {\n        sum += x % 10;\n        x /= 10;\n    }\n    return sum;\n}"}
{"solution": "import datetime\n\ndef get_bedtime(current_time, sleep_duration):\n    current_time = datetime.datetime.strptime(current_time, \"%H:%M\")\n    sleep_duration = datetime.timedelta(hours=int(sleep_duration[:2]), minutes=int(sleep_duration[3:]))\n    bedtime = current_time - sleep_duration\n    return bedtime.strftime(\"%H:%M\")\n\nprint(get_bedtime(\"05:50\", \"05:44\"))"}
{"solution": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\n# Find the maximum arithmetic mean of all subsegments\nmax_mean = 0\nfor l in range(n):\n    for r in range(l, n):\n        mean = sum(a[l:r+1]) / (r - l + 1)\n        if mean > max_mean:\n            max_mean = mean\n            longest_subsegment = r - l + 1\n\nprint(longest_subsegment)"}
{"solution": "import sys\n\nn, m, k = map(int, sys.stdin.readline().split())\n\n# Initialize a 2D array to store the number of ways to color each brick\nways = [[0] * (n + 1) for _ in range(m + 1)]\n\n# Base case: only one color\nways[0][0] = 1\n\n# Base case: only one brick\nfor i in range(1, m + 1):\n    ways[i][1] = 1\n\n# Recursive case: color each brick with a different color\nfor i in range(2, n + 1):\n    for j in range(1, m + 1):\n        ways[j][i] = (ways[j - 1][i - 1] + ways[j][i - 1]) % 998244353\n\n# Print the number of ways to color the bricks modulo 998244353\nprint(ways[m][n])"}
{"solution": "  import re\n\ndef is_magic_number(n):\n    pattern = re.compile(r'^(1|14|144)+$')\n    if pattern.match(str(n)):\n        return \"YES\"\n    else:\n        return \"NO\"\n\nn = int(input())\nprint(is_magic_number(n))"}
{"solution": "import sys\n\nn, m, i, j, a, b = map(int, sys.stdin.readline().split())\n\n# Initialize the chessboard\nchessboard = [[0] * (m + 2) for _ in range(n + 2)]\nchessboard[i][j] = 1\n\n# Initialize the number of moves\nmoves = 0\n\n# Initialize the corner positions\ncorners = [(1, m), (n, 1), (n, m), (1, 1)]\n\n# Loop through the chessboard\nfor row in range(1, n + 1):\n    for col in range(1, m + 1):\n        # If the current position is a corner, break the loop\n        if (row, col) in corners:\n            break\n        \n        # If the current position is not a corner, check if the candy can be moved\n        if chessboard[row][col] == 1:\n            # Check if the candy can be moved up and to the left\n            if row - a >= 1 and col - b >= 1 and chessboard[row - a][col - b] == 0:\n                chessboard[row - a][col - b] = 1\n                moves += 1\n            \n            # Check if the candy can be moved up and to the right\n            if row - a >= 1 and col + b <= m and chessboard[row - a][col + b] == 0:\n                chessboard[row - a][col + b] = 1\n                moves += 1\n            \n            # Check if the candy can be moved down and to the left\n            if row + a <= n and col - b >= 1 and chessboard[row + a][col - b] == 0:\n                chessboard[row + a][col - b] = 1\n                moves += 1\n            \n            # Check if the candy can be moved down and to the right\n            if row + a <= n and col + b <= m and chessboard[row + a][col + b] == 0:\n                chessboard[row + a][col + b] = 1\n                moves += 1\n            \n            # If the candy can be moved, break the loop\n            if moves > 0:\n                break\n    \n    # If the candy can be moved, break the loop\n    if moves > 0:\n        break\n\n# Print the number of moves\nprint(moves)"}
{"solution": "import sys\n\ndef get_max_removable_characters(s):\n    n = len(s)\n    if n == 1:\n        return 0\n    \n    # Initialize a list to store the indices of characters to be removed\n    removable_indices = []\n    \n    # Iterate through the string and check if the character at each index is removable\n    for i in range(1, n-1):\n        if s[i-1] == s[i+1]:\n            removable_indices.append(i)\n    \n    # Sort the list of removable indices in descending order\n    removable_indices.sort(reverse=True)\n    \n    # Initialize a variable to store the maximum number of removable characters\n    max_removable_characters = 0\n    \n    # Iterate through the list of removable indices and remove the characters at each index\n    for i in removable_indices:\n        s = s[:i] + s[i+1:]\n        max_removable_characters += 1\n    \n    return max_removable_characters\n\nif __name__ == \"__main__\":\n    s = sys.stdin.readline().strip()\n    print(get_max_removable_characters(s))"}
{"solution": "import sys\n\nn, k = map(int, input().split())\ndenominations = list(map(int, input().split()))\nq = int(input())\n\ndef get_min_bills(x):\n    min_bills = -1\n    for i in range(n):\n        if x % denominations[i] == 0:\n            min_bills = x // denominations[i]\n            break\n    return min_bills\n\nfor _ in range(q):\n    x = int(input())\n    min_bills = get_min_bills(x)\n    if min_bills == -1:\n        print(-1)\n    else:\n        print(min_bills)"}
{"solution": "import math\n\ndef get_min_time(s, x1, x2, t1, t2, p, d):\n    # Calculate the distance between x1 and x2\n    dist = abs(x2 - x1)\n\n    # Calculate the time it takes for Igor to walk the distance\n    walk_time = dist / t2\n\n    # Calculate the time it takes for the tram to travel the distance\n    tram_time = dist / t1\n\n    # Calculate the time it takes for Igor to wait for the tram\n    wait_time = abs(p - x1) / t1\n\n    # Calculate the total time it takes for Igor to get to x2\n    total_time = walk_time + tram_time + wait_time\n\n    # Return the minimum time\n    return min(total_time, walk_time)\n\n# Test the function with the given input\ns = 4\nx1 = 2\nx2 = 4\nt1 = 3\nt2 = 4\np = 1\nd = 1\nprint(get_min_time(s, x1, x2, t1, t2, p, d))"}
{"solution": "import sys\n\nn, x = map(int, input().split())\n\ncount = 0\nfor i in range(1, n+1):\n    for j in range(1, n+1):\n        if i*j == x:\n            count += 1\n\nprint(count)"}
{"solution": "  import random\n\ndef generate_password(n, k):\n    password = \"\"\n    while len(password) < n:\n        symbol = chr(random.randint(97, 122))\n        if symbol not in password:\n            password += symbol\n    return password\n\nn, k = map(int, input().split())\npassword = generate_password(n, k)\nprint(password)"}
{"solution": "def first_collision_time(n, directions, positions):\n    min_time = float('inf')\n    collision_found = False\n    \n    for i in range(n - 1):\n        if directions[i] == 'R' and directions[i + 1] == 'L':\n            collision_time = (positions[i + 1] - positions[i]) // 2\n            min_time = min(min_time, collision_time)\n            collision_found = True\n    \n    if collision_found:\n        return min_time\n    else:\n        return -1"}
{"solution": "import sys\n\nn, a, b = map(int, input().split())\nseals = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    seals.append((x, y))\n\n# Sort seals by area in descending order\nseals.sort(key=lambda x: x[0] * x[1], reverse=True)\n\n# Initialize the maximum area as 0\nmax_area = 0\n\n# Iterate through all possible combinations of seals\nfor i in range(n):\n    for j in range(i+1, n):\n        # Calculate the area of the current combination\n        area = seals[i][0] * seals[i][1] + seals[j][0] * seals[j][1]\n\n        # Check if the current combination fits on the paper\n        if area <= a * b:\n            # Update the maximum area if necessary\n            max_area = max(max_area, area)\n\n# Print the maximum area\nprint(max_area)"}
{"solution": "import sys\n\nn = int(input())\npoints = []\n\nfor i in range(4*n+1):\n    x, y = map(int, input().split())\n    points.append((x, y))\n\n# Find the point that is not on the boundary of the square\nfor point in points:\n    if point not in [(0, 0), (0, 2), (2, 0), (2, 2)]:\n        print(point[0], point[1])\n        break\nelse:\n    print(\"No point found\")"}
{"solution": "import math\n\ndef get_max_product(n):\n    max_product = 0\n    for i in range(1, n+1):\n        product = 1\n        for digit in str(i):\n            product *= int(digit)\n        max_product = max(max_product, product)\n    return max_product\n\nn = int(input())\nprint(get_max_product(n))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Calculate the total number of votes for Elodreip\ntotal_votes = sum(a)\n\n# Determine the minimum value of k that ensures a win\nk = max(a)\nwhile total_votes > sum(a[i] for i in range(n) if a[i] > k):\n    k += 1\n\nprint(k)"}
{"solution": "import sys\n\ndef get_num_operations(colors):\n    num_operations = 0\n    while True:\n        num_deleted = 0\n        for i in range(len(colors) - 1):\n            if colors[i]!= colors[i + 1]:\n                num_deleted += 1\n                colors = colors[:i] + colors[i + 2:]\n                break\n        if num_deleted == 0:\n            break\n        num_operations += 1\n    return num_operations\n\nif __name__ == \"__main__\":\n    colors = sys.stdin.readline().strip()\n    print(get_num_operations(colors))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Sort the array in non-decreasing order\na.sort()\n\n# Initialize the minimum product to infinity\nmin_product = float('inf')\n\n# Initialize the count of triples to 0\ncount = 0\n\n# Iterate over the array\nfor i in range(n - 2):\n    # Find the minimum product of the current element and the next two elements\n    product = a[i] * a[i + 1] * a[i + 2]\n    \n    # If the minimum product is less than the current product, update the minimum product and increment the count\n    if product < min_product:\n        min_product = product\n        count += 1\n\n# Print the count of triples\nprint(count)"}
{"solution": "  def solve(n):\n    return n + 1\n\n# Test case 1\nn = 3\nprint(solve(n))\n# 2\n\n# Test case 2\nn = 4\nprint(solve(n))\n# 5"}
{"solution": "import sys\n\nn = int(sys.stdin.readline().strip())\n\n# Initialize the maximum balance to the current balance\nmax_balance = n\n\n# Check if the last digit can be removed\nif n % 10!= 0:\n    max_balance = max(max_balance, n - n % 10)\n\n# Check if the digit before the last can be removed\nif n % 100!= 0:\n    max_balance = max(max_balance, n - n % 100)\n\nprint(max_balance)"}
{"solution": "def solve(start_pos, end_pos, n):\n    # Check if the starting position is the same as the ending position\n    if start_pos == end_pos:\n        return \"undefined\"\n    \n    # Check if the starting position is v or ^\n    if start_pos == \"v\" or start_pos == \"^\":\n        # Check if the ending position is < or >\n        if end_pos == \"<\" or end_pos == \">\":\n            # Check if the direction is clockwise or counter-clockwise\n            if start_pos == \"v\" and end_pos == \"<\":\n                return \"ccw\"\n            elif start_pos == \"v\" and end_pos == \">\":\n                return \"cw\"\n            elif start_pos == \"^\" and end_pos == \"<\":\n                return \"cw\"\n            elif start_pos == \"^\" and end_pos == \">\":\n                return \"ccw\"\n            else:\n                return \"undefined\"\n        else:\n            return \"undefined\"\n    else:\n        return \"undefined\""}
{"solution": "def domino_show(n, s):\n    # Initialize a list to store the number of dominoes standing vertically\n    standing_vertically = [0] * n\n\n    # Iterate through the string s and check if the domino has been pushed to the left or right\n    for i in range(n):\n        if s[i] == \"L\":\n            # If the domino has been pushed to the left, check if the adjacent domino on the left is standing vertically\n            if standing_vertically[i-1] == 1:\n                # If the adjacent domino is standing vertically, the current domino falls down\n                standing_vertically[i] = 0\n            else:\n                # If the adjacent domino is not standing vertically, the current domino stands vertically\n                standing_vertically[i] = 1\n        elif s[i] == \"R\":\n            # If the domino has been pushed to the right, check if the adjacent domino on the right is standing vertically\n            if standing_vertically[i+1] == 1:\n                # If the adjacent domino is standing vertically, the current domino falls down\n                standing_vertically[i] = 0\n            else:\n                # If the adjacent domino is not standing vertically, the current domino stands vertically\n                standing_vertically[i] = 1\n\n    # Return the number of dominoes standing vertically at the end of the process\n    return sum(standing_vertically)"}
{"solution": "def restore_permutation(n, m, leaders):\n    # Initialize a list to store the permutation\n    permutation = [0] * n\n\n    # Initialize a dictionary to keep track of the leaders\n    leaders_dict = {}\n    for i in range(m):\n        leaders_dict[leaders[i]] = i\n\n    # Initialize a variable to keep track of the current leader\n    current_leader = leaders[0]\n\n    # Iterate through the leaders and update the permutation\n    for i in range(m):\n        # Get the next leader in the sequence\n        next_leader = (current_leader + leaders_dict[current_leader]) % n\n\n        # Update the permutation\n        permutation[i] = next_leader\n\n        # Update the current leader\n        current_leader = next_leader\n\n    # Return the permutation\n    return permutation"}
{"solution": "import sys\n\ndef get_max_number(a, k):\n    # Convert the number to a list of digits\n    digits = [int(d) for d in str(a)]\n\n    # Iterate through the digits\n    for i in range(len(digits)):\n        # Determine the best possible digit to swap with within the allowed range of k swaps\n        best_swap = None\n        for j in range(i+1, min(i+k+1, len(digits))):\n            if digits[j] > digits[i]:\n                best_swap = j\n                break\n\n        # Perform the swap\n        if best_swap is not None:\n            digits[i], digits[best_swap] = digits[best_swap], digits[i]\n            k -= 1\n\n    # Repeat until k swaps are used or no more beneficial swaps are possible\n    while k > 0 and any(digits[i] < digits[i+1] for i in range(len(digits)-1)):\n        for i in range(len(digits)-1):\n            if digits[i] < digits[i+1]:\n                digits[i], digits[i+1] = digits[i+1], digits[i]\n                k -= 1\n                break\n\n    # Convert the list of digits back to a number\n    return int(\"\".join(str(d) for d in digits))\n\nif __name__ == \"__main__\":\n    a, k = map(int, input().split())\n    print(get_max_number(a, k))"}
{"solution": "import math\n\ndef is_arithmetic_progression(seq):\n    # Check if the sequence is an arithmetic progression\n    # by checking if the difference between each element is constant\n    diff = seq[1] - seq[0]\n    for i in range(2, len(seq)):\n        if seq[i] - seq[i-1]!= diff:\n            return False\n    return True\n\ndef is_geometric_progression(seq):\n    # Check if the sequence is a geometric progression\n    # by checking if the ratio between each element is constant\n    ratio = seq[1] / seq[0]\n    for i in range(2, len(seq)):\n        if seq[i] / seq[i-1]!= ratio:\n            return False\n    return True\n\ndef find_next_number(seq):\n    # Find the next number in the sequence\n    # by using the formula for the nth term of an arithmetic or geometric progression\n    if is_arithmetic_progression(seq):\n        return seq[-1] + (seq[-1] - seq[-2])\n    elif is_geometric_progression(seq):\n        return seq[-1] * (seq[-1] / seq[-2])\n    else:\n        return 42\n\nseq = [int(x) for x in input().split()]\nprint(find_next_number(seq))"}
{"solution": "def max_distance(n, colors):\n    # Find the first and last occurrence of each color\n    first_occurrence = {}\n    last_occurrence = {}\n    \n    for i in range(n):\n        color = colors[i]\n        if color not in first_occurrence:\n            first_occurrence[color] = i\n        last_occurrence[color] = i\n    \n    # Get the list of unique colors\n    unique_colors = list(first_occurrence.keys())\n    \n    # Calculate the maximum distance\n    max_dist = 0\n    \n    # Compare distances from the first house to the last house of a different color\n    for color in unique_colors:\n        if colors[0]!= color:\n            max_dist = max(max_dist, last_occurrence[color])\n        if colors[-1]!= color:\n            max_dist = max(max_dist, n - 1 - first_occurrence[color])\n    \n    return max_dist\n\n# Example usage:\nn = int(input())\ncolors = list(map(int, input().split()))\nprint(max_distance(n, colors))"}
{"solution": "import sys\n\nn, m, k = map(int, sys.stdin.readline().split())\n\n# Calculate the lane and desk numbers\nlane = k // m\ndesk = k % m\n\n# Determine the side of the desk\nif k % 2 == 0:\n    side = \"L\"\nelse:\n    side = \"R\"\n\n# Print the output\nprint(lane, desk, side)"}
{"solution": "def get_final_card_colors(n, s):\n    colors = {\"B\": 0, \"G\": 0, \"R\": 0}\n    for c in s:\n        colors[c] += 1\n\n    if colors[\"B\"] % 2 == 0 and colors[\"G\"] % 2 == 0 and colors[\"R\"] % 2 == 0:\n        return \"BGR\"\n    elif colors[\"B\"] % 2 == 1 and colors[\"G\"] % 2 == 0 and colors[\"R\"] % 2 == 0:\n        return \"BG\"\n    elif colors[\"B\"] % 2 == 0 and colors[\"G\"] % 2 == 1 and colors[\"R\"] % 2 == 0:\n        return \"BR\"\n    elif colors[\"B\"] % 2 == 0 and colors[\"G\"] % 2 == 0 and colors[\"R\"] % 2 == 1:\n        return \"R\"\n    else:\n        return \"BGR\"\n\nn = int(input())\ns = input()\nprint(get_final_card_colors(n, s))"}
