{"solution": "import re\n\ndef max_accordion_length(s):\n    # Identify valid accordion patterns in the input string\n    accordions = re.findall(r'\\[.*?:.*?\\|*?.*?:.*?\\]', s)\n\n    # If no valid accordions are found, return -1\n    if not accordions:\n        return -1\n\n    # Calculate the length of each valid accordion\n    lengths = [len(a) for a in accordions]\n\n    # Return the maximum possible length of the resulting accordion\n    return max(lengths)\n\n# Get the input string\ns = input()\n\n# Print the maximum possible length of the resulting accordion\nprint(max_accordion_length(s))"}
{"solution": "def max_sum_digits(x):\n    # Convert the number to string\n    num_str = str(x)\n    # Initialize the result\n    result = ''\n    # Iterate over the digits of the number\n    for i in range(len(num_str)):\n        # If the current digit is not 9\n        if num_str[i] != '9':\n            # Find the maximum digit that can be placed at the current position\n            max_digit = str(int(num_str[i]) - 1)\n            # Replace the current digit with the maximum digit\n            result += max_digit\n            # Fill the remaining positions with 9\n            result += '9' * (len(num_str) - i - 1)\n            # Break the loop\n            break\n        # If the current digit is 9\n        else:\n            # Add the current digit to the result\n            result += num_str[i]\n    # If the result is empty, it means that the number is a sequence of 9s\n    if not result:\n        # Return the number as it is\n        return x\n    # Return the result as an integer\n    return int(result)\n\n# Read the input\nx = int(input())\n# Print the output\nprint(max_sum_digits(x))"}
{"solution": "# Get the current year in Berland\nn = int(input())\n\n# Calculate the next lucky year\nnext_lucky_year = (n // 10 + 1) * 10\n\n# Calculate the number of years until the next lucky year\nyears_until_next_lucky_year = next_lucky_year - n\n\n# Print the result\nprint(years_until_next_lucky_year)"}
{"solution": "def max_painted_sections(n, q, painters):\n    # Create a list to store the painted sections\n    painted = [0] * n\n\n    # Mark the sections painted by each painter\n    for l, r in painters:\n        for i in range(l-1, r):\n            painted[i] = 1\n\n    # Count the number of painted sections\n    painted_sections = sum(painted)\n\n    # If we can hire q-2 painters, we're done\n    if q - 2 >= len(painters):\n        return painted_sections\n\n    # Otherwise, we need to find the two painters that paint the fewest overlapping sections\n    min_overlap = float('inf')\n    min_overlap_painters = (-1, -1)\n\n    for i in range(len(painters)):\n        for j in range(i+1, len(painters)):\n            overlap = sum(min(painted[k], 1) for k in range(n) if painted[k] == 1 and k >= painters[i][0]-1 and k < painters[i][1] and k >= painters[j][0]-1 and k < painters[j][1])\n            if overlap < min_overlap:\n                min_overlap = overlap\n                min_overlap_painters = (i, j)\n\n    # Remove the two painters that paint the fewest overlapping sections\n    for i in range(min_overlap_painters[0], min_overlap_painters[1]+1):\n        painted[i-1] = 0\n\n    # Recursively call the function with q-2 painters\n    return max_painted_sections(n, q-2, painters[:min_overlap_painters[0]] + painters[min_overlap_painters[1]+1:])\n\n# Read the input\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Print the output\nprint(max_painted_sections(n, q, painters))"}
{"solution": "def is_lucky(time):\n    return '7' in time\n\ndef calculate_time(hh, mm, x):\n    mm -= x\n    if mm < 0:\n        mm += 60\n        hh -= 1\n    if hh < 0:\n        hh += 24\n    return f'{hh:02d}:{mm:02d}'\n\nx = int(input())\nhh, mm = map(int, input().split())\n\ntime = f'{hh:02d}:{mm:02d}'\npresses = 0\n\nwhile not is_lucky(time):\n    time = calculate_time(hh, mm, x)\n    presses += 1\n\nprint(presses)"}
{"solution": "# Read the input\nn, pos, l, r = map(int, input().split())\n\n# Calculate the minimum number of seconds required\n# to close all the tabs outside the segment [l, r]\nif pos < l:\n    # If the cursor is to the left of the segment,\n    # move it to the left endpoint of the segment\n    # and close all the tabs to the right of it\n    seconds = l - pos + r - l\nelif pos > r:\n    # If the cursor is to the right of the segment,\n    # move it to the right endpoint of the segment\n    # and close all the tabs to the left of it\n    seconds = pos - l + r - l\nelse:\n    # If the cursor is inside the segment,\n    # close all the tabs to the left and to the right of it\n    seconds = min(pos - l, r - pos) * 2\n\n# Print the result\nprint(seconds)"}
{"solution": "def min_blows(n, x, blows):\n    blows.sort(key=lambda x: x[0] - x[1], reverse=True)\n    if blows[0][0] <= blows[0][1]:\n        return -1\n    num_blows = 0\n    while x > 0:\n        for d, h in blows:\n            if x > d:\n                x -= d\n                x += h\n                num_blows += 1\n                break\n            elif d > h:\n                num_blows += (x + d - 1) // d\n                x = 0\n                break\n    return num_blows\n\nt = int(input())\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [list(map(int, input().split())) for _ in range(n)]\n    print(min_blows(n, x, blows))"}
{"solution": "n, m = map(int, input().split())\ndays = 1\ngrains = n\n\nwhile grains > 0:\n    grains -= days\n    if grains < m:\n        grains += m\n    if grains > n:\n        grains = n\n    days += 1\n\nprint(days)"}
{"solution": "def min_extra_tiles(hand):\n    suits = {'m': [], 'p': [], 's': []}\n    for tile in hand:\n        suits[tile[1]].append(int(tile[0]))\n\n    for suit in suits.values():\n        suit.sort()\n        if len(suit) >= 3:\n            if suit[0] + 2 == suit[1] + 1 == suit[2]:\n                return 0\n            if suit[0] == suit[1] == suit[2]:\n                return 0\n            if len(suit) >= 4:\n                if suit[0] == suit[1] == suit[2] or suit[1] == suit[2] == suit[3]:\n                    return 0\n\n    for i in range(1, 8):\n        for suit in suits:\n            if i in suits[suit] and i + 1 in suits[suit] and i + 2 in suits[suit]:\n                return 0\n\n    return 1\n\nhand = input().split()\nprint(min_extra_tiles(hand))"}
{"solution": "def find_sofa(d, n, m, sofas, cnt):\n    left, right, top, bottom = cnt\n    for i, sofa in enumerate(sofas, start=1):\n        x1, y1, x2, y2 = sofa\n        l, r, t, b = 0, 0, 0, 0\n        for j, other_sofa in enumerate(sofas, start=1):\n            if i == j:\n                continue\n            ox1, oy1, ox2, oy2 = other_sofa\n            if x1 < ox1 and y1 == oy1:\n                l += 1\n            elif x2 > ox2 and y2 == oy2:\n                r += 1\n            elif y1 < oy1 and x1 == ox1:\n                t += 1\n            elif y2 > oy2 and x2 == ox2:\n                b += 1\n        if l == left and r == right and t == top and b == bottom:\n            return i\n    return -1\n\nd = int(input())\nn, m = map(int, input().split())\nsofas = [list(map(int, input().split())) for _ in range(d)]\ncnt = list(map(int, input().split()))\n\nprint(find_sofa(d, n, m, sofas, cnt))"}
{"solution": "n = int(input())\nmin_days_off = n % 7 if n % 7 < 2 else 2\nmax_days_off = 2 * (n // 7) + min_days_off\nprint(min_days_off, max_days_off)"}
{"solution": "# Read the input\nn, a, b, p, q = map(int, input().split())\n\n# Calculate the number of tiles that will be painted red\nred_tiles = n // a\n\n# Calculate the number of tiles that will be painted blue\nblue_tiles = n // b\n\n# Calculate the number of tiles that can be painted either red or blue\nboth_tiles = n // (a * b)\n\n# Calculate the maximum number of chocolates Joty can get by painting tiles red\nmax_red_chocolates = (red_tiles - both_tiles) * p + both_tiles * max(p, q)\n\n# Calculate the maximum number of chocolates Joty can get by painting tiles blue\nmax_blue_chocolates = (blue_tiles - both_tiles) * q + both_tiles * max(p, q)\n\n# Print the maximum number of chocolates Joty can get\nprint(max(max_red_chocolates, max_blue_chocolates))"}
{"solution": "n = int(input())\ntrophies = input()\n\n# Find the length of the longest subsegment of golden trophies\nmax_length = 0\ncurrent_length = 0\nfor trophy in trophies:\n    if trophy == 'G':\n        current_length += 1\n        max_length = max(max_length, current_length)\n    else:\n        current_length = 0\n\n# If there are no silver trophies, return the length of the longest subsegment\nif 'S' not in trophies:\n    print(max_length)\nelse:\n    # Consider swapping a silver trophy with a golden trophy that is adjacent to a subsegment of golden trophies\n    max_possible_length = max_length\n    for i in range(1, n - 1):\n        if trophies[i] == 'S':\n            if trophies[i - 1] == 'G' and trophies[i + 1] == 'G':\n                # Calculate the length of the subsegment if we swap the trophies\n                left_length = 0\n                right_length = 0\n                j = i - 1\n                while j >= 0 and trophies[j] == 'G':\n                    left_length += 1\n                    j -= 1\n                j = i + 1\n                while j < n and trophies[j] == 'G':\n                    right_length += 1\n                    j += 1\n                max_possible_length = max(max_possible_length, left_length + right_length + 1)\n\n    print(max_possible_length)"}
{"solution": "from collections import defaultdict, deque\n\n# Read the number of courses and main courses\nn, k = map(int, input().split())\n\n# Read the main courses\nmain_courses = set(map(int, input().split()))\n\n# Create a graph of courses and their dependencies\ngraph = defaultdict(list)\nin_degree = [0] * (n + 1)\nfor i in range(1, n + 1):\n    dependencies = list(map(int, input().split()))\n    for j in dependencies[1:]:\n        graph[j].append(i)\n        in_degree[i] += 1\n\n# Initialize a queue with main courses that have no dependencies\nqueue = deque([i for i in main_courses if in_degree[i] == 0])\n\n# Initialize a list to store the order of courses\norder = []\n\n# Perform topological sorting\nwhile queue:\n    course = queue.popleft()\n    order.append(course)\n    for next_course in graph[course]:\n        in_degree[next_course] -= 1\n        if in_degree[next_course] == 0:\n            queue.append(next_course)\n\n# Check if all main courses are in the order\nif len(order) < k:\n    print(-1)\nelse:\n    print(len(order))\n    print(' '.join(map(str, order)))"}
{"solution": "import sys\n\ndef solve(n, k, p):\n    stack = []\n    b = []\n    i = 0\n    for x in range(1, n+1):\n        if i < k and p[i] == x:\n            i += 1\n        elif stack and stack[-1] == x:\n            stack.pop()\n            b.append(x)\n        else:\n            stack.append(x)\n    while stack:\n        b.append(stack.pop())\n    if b == sorted(b):\n        return b\n    else:\n        return -1\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    p = list(map(int, sys.stdin.readline().split()))\n    result = solve(n, k, p)\n    if result == -1:\n        print(-1)\n    else:\n        print(' '.join(map(str, result)))\n\nif __name__ == '__main__':\n    main()"}
{"solution": "# Get the input\na, b, c = map(int, input().split())\n\n# Check if b is equal to a\nif b == a:\n    print(\"YES\")\n# Check if c is zero\nelif c == 0:\n    print(\"NO\")\n# Check if b is on the same side of a as a+c\nelif (b > a and b > a + c) or (b < a and b < a + c):\n    print(\"NO\")\n# Check if the difference between b and a is a multiple of c\nelif (b - a) % c == 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "# Read the input\ncnt_1 = int(input())\ncnt_2 = int(input())\ncnt_3 = int(input())\ncnt_4 = int(input())\n\n# Check if it is possible to form a regular bracket sequence\nif cnt_1 > 0 and cnt_4 > 0:\n    # If there are \"(( and ))\", it is not possible to form a regular bracket sequence\n    print(0)\nelif abs(cnt_1 - cnt_4) > 1 or cnt_3 > 0:\n    # If the difference between the number of \"(( and ))\" is more than 1 or there are \")(\"\n    print(0)\nelse:\n    # Otherwise, it is possible to form a regular bracket sequence\n    print(1)"}
{"solution": "# Get the input values\nn, k, t = map(int, input().split())\n\n# Calculate the current position of the wave\nposition = t % (2 * k)\n\n# Calculate the number of standing spectators based on the position\nif position <= k:\n    # The wave is still increasing\n    standing = position\nelse:\n    # The wave is decreasing\n    standing = 2 * k - position\n\n# Print the result\nprint(standing)"}
{"solution": "def minimal_string(s):\n    t = []\n    u = []\n    while s:\n        # Extract the first character of s and append t with this character\n        t.append(s[0])\n        s = s[1:]\n        # While t has more than one character and the last character of t is lexicographically smaller than the first character of s\n        while len(t) > 1 and t[-1] < s[0]:\n            # Extract the last character of t and append u with this character\n            u.append(t.pop())\n    # Append the remaining characters of t to u in reverse order\n    u.extend(reversed(t))\n    return ''.join(u)\n\ns = input()\nprint(minimal_string(s))"}
{"solution": "def check_records(n, records):\n    prev_plays, prev_clears = records[0]\n    for plays, clears in records[1:]:\n        if plays < prev_plays or clears < prev_clears or clears > plays:\n            return False\n        prev_plays, prev_clears = plays, clears\n    return True\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        n = int(input())\n        records = [list(map(int, input().split())) for _ in range(n)]\n        if check_records(n, records):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def next_palindrome(time):\n    hours, minutes = map(int, time.split(':'))\n    while True:\n        minutes += 1\n        if minutes == 60:\n            minutes = 0\n            hours = (hours + 1) % 24\n        time = f'{hours:02d}:{minutes:02d}'\n        if time == time[::-1]:\n            return minutes\n\ndef min_sleep(current_time):\n    hours, minutes = map(int, current_time.split(':'))\n    return next_palindrome(current_time) - minutes\n\ncurrent_time = input()\nprint(min_sleep(current_time))"}
{"solution": "# Read the size of the permutation\nn = int(input())\n\n# Read the permutation\na = list(map(int, input().split()))\n\n# Find the indices of the minimum and maximum elements\nmin_index = a.index(1)\nmax_index = a.index(n)\n\n# Calculate the current distance between the minimum and maximum elements\ncurrent_distance = abs(min_index - max_index)\n\n# Calculate the distances if we swap the minimum or maximum element with the first or last element\ndistances = [\n    abs(0 - max_index),\n    abs(n - 1 - max_index),\n    abs(0 - min_index),\n    abs(n - 1 - min_index)\n]\n\n# Print the maximum possible distance\nprint(max(current_distance, max(distances)))"}
{"solution": "def is_s_palindrome(s):\n    # Check if the length of the string is odd\n    if len(s) % 2 == 0:\n        return 'NIE'\n\n    # Split the string into two halves\n    mid = len(s) // 2\n    first_half = s[:mid]\n    second_half = s[mid+1:]\n\n    # Check if the second half is a mirror reflection of the first half\n    if first_half == second_half[::-1]:\n        return 'TAK'\n    else:\n        return 'NIE'\n\n# Get the input string\ns = input()\n\n# Print the result\nprint(is_s_palindrome(s))"}
{"solution": "def max_permutation(a, b):\n    # Convert numbers to lists of digits\n    a = list(str(a))\n    b = list(str(b))\n\n    # Count the frequency of each digit in a and b\n    count_a = [0] * 10\n    count_b = [0] * 10\n    for digit in a:\n        count_a[int(digit)] += 1\n    for digit in b:\n        count_b[int(digit)] += 1\n\n    # Construct the maximum possible number\n    result = []\n    for i in range(9, -1, -1):\n        # Add as many digits of i as possible, but not more than in a and not more than in b\n        while count_a[i] > 0 and count_b[i] > 0:\n            result.append(str(i))\n            count_a[i] -= 1\n            count_b[i] -= 1\n\n    # Convert the result back to a number\n    result = int(''.join(result))\n\n    # If the result is too large, replace the last digit with the smallest possible one that makes the result not larger than b\n    if result > int(''.join(b)):\n        for i in range(len(b) - 1, -1, -1):\n            if b[i] > result % 10:\n                # Find the smallest digit in b that is larger than the last digit of the result\n                for j in range(int(b[i]) - 1, result % 10, -1):\n                    if str(j) in b:\n                        # Replace the last digit of the result with this digit\n                        result = result // 10 * 10 + j\n                        # Remove this digit from b\n                        b.remove(str(j))\n                        break\n                break\n\n    return result\n\n# Read the input\na = int(input())\nb = int(input())\n\n# Print the output\nprint(max_permutation(a, b))"}
{"solution": "def check_win(board, player):\n    # Check rows, columns, and diagonals for a win\n    for i in range(10):\n        for j in range(10):\n            if i < 6 and all(board[i+k][j] == player for k in range(5)):\n                return True\n            if j < 6 and all(board[i][j+k] == player for k in range(5)):\n                return True\n            if i < 6 and j < 6 and all(board[i+k][j+k] == player for k in range(5)):\n                return True\n            if i < 6 and j >= 4 and all(board[i+k][j-k] == player for k in range(5)):\n                return True\n    return False\n\ndef can_win(board, player):\n    # Check if the player can win in one turn\n    for i in range(10):\n        for j in range(10):\n            if board[i][j] == '.':\n                board[i][j] = player\n                if check_win(board, player):\n                    return True\n                board[i][j] = '.'\n    return False\n\n# Read the input\nboard = [list(input()) for _ in range(10)]\n\n# Check if Alice can win in one turn\nif can_win(board, 'X'):\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "def solve(n, k):\n    # Check if it's possible to place k ones in the matrix\n    if k > n * n or k < n:\n        return -1\n\n    # Initialize the matrix with zeros\n    matrix = [[0] * n for _ in range(n)]\n\n    # Place ones in the matrix\n    for i in range(n):\n        for j in range(n):\n            # If i <= j and there are still ones to place\n            if i <= j and k > 0:\n                # Place a one in the current cell and its symmetric cell\n                matrix[i][j] = matrix[j][i] = 1\n                k -= 2\n                # If i == j, we only placed one one, so increment k\n                if i == j:\n                    k += 1\n\n    # If there are still ones to place, place them in the diagonal\n    for i in range(n):\n        if k > 0:\n            matrix[i][i] = 1\n            k -= 1\n\n    return matrix\n\n# Read the input\nn, k = map(int, input().split())\n\n# Solve the problem\nresult = solve(n, k)\n\n# Print the output\nif result == -1:\n    print(-1)\nelse:\n    for row in result:\n        print(' '.join(map(str, row)))"}
{"solution": "# Read the input values\nx, y, z = map(float, input().split())\n\n# Calculate all possible expressions\nexpressions = [\n    x ** y ** z,\n    x ** z ** y,\n    (x ** y) ** z,\n    (x ** z) ** y,\n    y ** x ** z,\n    y ** z ** x,\n    (y ** x) ** z,\n    (y ** z) ** x,\n    z ** x ** y,\n    z ** y ** x,\n    (z ** x) ** y,\n    (z ** y) ** x\n]\n\n# Find the maximum value and its index\nmax_value = max(expressions)\nmax_index = expressions.index(max_value) + 1\n\n# Define the expressions as strings\nexpression_strings = [\n    \"x^y^z\",\n    \"x^z^y\",\n    \"(x^y)^z\",\n    \"(x^z)^y\",\n    \"y^x^z\",\n    \"y^z^x\",\n    \"(y^x)^z\",\n    \"(y^z)^x\",\n    \"z^x^y\",\n    \"z^y^x\",\n    \"(z^x)^y\",\n    \"(z^y)^x\"\n]\n\n# Print the expression corresponding to the maximum value\nprint(expression_strings[max_index - 1])"}
{"solution": "def min_operations(s):\n    n = len(s)\n    min_ops = n\n\n    # Check for all possible substrings\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            # If the string is made up of repeated substrings\n            if s[:i] * (n // i) == s:\n                min_ops = i + 1\n                break\n\n    # Check for all possible prefixes\n    for i in range(n // 2, 0, -1):\n        if s[:i] == s[i:2 * i]:\n            min_ops = i + 1\n            break\n\n    return min_ops\n\nn = int(input())\ns = input()\nprint(min_operations(s))"}
{"solution": "n = int(input())\nfiles = []\nfor _ in range(n):\n    name, type_ = input().split()\n    files.append((name, int(type_)))\n\nexamples = [name for name, type_ in files if type_ == 1]\nregular_tests = [name for name, type_ in files if type_ == 0]\n\nscript = []\nfor i, name in enumerate(examples, start=1):\n    script.append(f\"move {name} {i}\")\n\nfor i, name in enumerate(regular_tests, start=len(examples)+1):\n    script.append(f\"move {name} {i}\")\n\nprint(len(script))\nfor line in script:\n    print(line)"}
{"solution": "def min_replacements(ticket):\n    first_half_sum = sum(int(digit) for digit in ticket[:3])\n    second_half_sum = sum(int(digit) for digit in ticket[3:])\n    diff = abs(first_half_sum - second_half_sum)\n    return min(diff, 10 - diff)\n\nticket = input()\nprint(min_replacements(ticket))"}
{"solution": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef min_traps(m, x):\n    if gcd(x, m) != 1:\n        return -1\n    cycle_length = 0\n    visited = set()\n    current_room = 0\n    while current_room not in visited:\n        visited.add(current_room)\n        current_room = (current_room * x) % m\n        cycle_length += 1\n    return cycle_length\n\nm, x = map(int, input().split())\nprint(min_traps(m, x))"}
{"solution": "MOD = 10**6 + 3\n\ndef power(base, exponent, modulus):\n    result = 1\n    base %= modulus\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % modulus\n        base = (base * base) % modulus\n        exponent //= 2\n    return result\n\ndef inverse(number, modulus):\n    return power(number, modulus - 2, modulus)\n\ndef binomial_coefficient(n, k, modulus):\n    if k > n:\n        return 0\n    if k > n - k:\n        k = n - k\n    result = 1\n    for i in range(k):\n        result = (result * (n - i)) % modulus\n        result = (result * inverse(i + 1, modulus)) % modulus\n    return result\n\ndef birthday_paradox(n, k):\n    total_days = 1 << n\n    A = total_days\n    B = total_days\n    for i in range(1, k):\n        A = (A * (total_days - i)) % MOD\n        B = (B * (total_days - i)) % MOD\n        A = (A - binomial_coefficient(total_days, i, MOD) + MOD) % MOD\n    return A, B\n\nn, k = map(int, input().split())\nA, B = birthday_paradox(n, k)\nprint(A, B)"}
{"solution": "# Read the number of moves\nn = int(input())\n\n# Initialize Limak's position\nposition = [0, 0]  # [latitude, longitude]\n\n# Initialize a flag to check if the conditions are satisfied\nvalid = True\n\n# Process each move\nfor _ in range(n):\n    # Read the move\n    t, dir = input().split()\n    t = int(t)\n\n    # Update Limak's position\n    if dir == \"North\":\n        position[0] += t\n    elif dir == \"South\":\n        position[0] -= t\n    elif dir == \"East\":\n        position[1] += t\n    elif dir == \"West\":\n        position[1] -= t\n\n    # Check the conditions\n    if position[0] > 20000 or position[0] < -20000 or position[1] > 40000 or position[1] < -40000:\n        valid = False\n        break\n    if position[0] == 20000 and dir != \"South\":\n        valid = False\n        break\n    if position[0] == -20000 and dir != \"North\":\n        valid = False\n        break\n\n# Check if the journey ends on the North Pole\nif position[0] != 0:\n    valid = False\n\n# Print the result\nprint(\"YES\" if valid else \"NO\")"}
{"solution": "def solve(a1, b1, a2, b2, L, R):\n    # If a1 and a2 are equal, the problem simplifies to finding the number of common elements in two arithmetic sequences\n    if a1 == a2:\n        if b1 == b2:\n            return (R - L) // a1 + 1 if L <= b1 <= R else 0\n        elif (b1 - b2) % a1 == 0:\n            diff = (b2 - b1) // a1\n            return max(0, min(R, b2 + a1 * (diff - 1)) - max(L, b2 + a1 * diff) // a1 + 1)\n        else:\n            return 0\n    # If a1 and a2 are not equal, we can find the number of common elements by solving a linear Diophantine equation\n    else:\n        count = 0\n        x = max(L, (b2 - b1) // (a1 - a2))\n        while True:\n            y = (a1 * x + b1 - b2) / a2\n            if y < 0 or y > R:\n                break\n            if y == int(y):\n                count += 1\n            x += 1\n            if x > R:\n                break\n        return count\n\na1, b1, a2, b2, L, R = map(int, input().split())\nprint(solve(a1, b1, a2, b2, L, R))"}
{"solution": "# Get the input values\nn, a, b = map(int, input().split())\n\n# Calculate the maximum possible number of cake pieces that can be distributed to each plate\nx = min(a, b) // n\n\n# Check if there are any remaining pieces that can be distributed to the plates with the lower number of pieces\nremaining_pieces = min(a, b) % n\nwhile remaining_pieces > 0 and x < min(a // n, b // n):\n    x += 1\n    remaining_pieces -= 1\n\n# Print the result\nprint(x)"}
{"solution": "def check_flag(flag):\n    # Check if the flag is a square\n    if len(flag) != len(flag[0]):\n        return False\n\n    # Check if the flag is divided into three equal stripes\n    stripe_size = len(flag) // 3\n    if stripe_size * 3 != len(flag):\n        return False\n\n    # Check if each stripe has exactly one color\n    for i in range(3):\n        stripe = flag[i * stripe_size: (i + 1) * stripe_size]\n        if not all(row.count(row[0]) == len(row) for row in stripe):\n            return False\n\n    # Check if each color is used in exactly one stripe\n    colors = set(row[0] for row in flag)\n    if len(colors) != 3:\n        return False\n\n    return True\n\n# Read input\nn, m = map(int, input().split())\nflag = [input() for _ in range(n)]\n\n# Check flag and print result\nif check_flag(flag):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def ayrat_location(n):\n    # Ayrat's movement follows a spiral pattern.\n    # The spiral can be divided into rings.\n    # Each ring has 6 segments.\n    # The length of each segment increases by 1 for each ring.\n    # First, we need to find out which ring Ayrat is on.\n\n    ring = 0\n    while (ring + 1) * 6 <= n:\n        n -= (ring + 1) * 6\n        ring += 1\n\n    # Now we know which ring Ayrat is on and how many moves he has left in this ring.\n    # Each segment in the ring is ring + 1 units long.\n    # We can divide the remaining moves by the segment length to find out which segment Ayrat is in.\n\n    segment = n // (ring + 1)\n\n    # The remaining moves in the segment determine Ayrat's position within the segment.\n    remainder = n % (ring + 1)\n\n    # The coordinates of Ayrat's position can be calculated based on the ring and the segment.\n    # The x coordinate increases in the first 2 segments of each ring.\n    # The y coordinate increases in the next 2 segments.\n    # The x coordinate decreases in the last 2 segments.\n\n    if segment == 0:\n        x = ring\n        y = -ring + remainder\n    elif segment == 1:\n        x = ring - remainder\n        y = ring\n    elif segment == 2:\n        x = -ring\n        y = ring - remainder\n    elif segment == 3:\n        x = -ring + remainder\n        y = -ring\n    elif segment == 4:\n        x = ring - remainder\n        y = -ring\n    else:\n        x = ring\n        y = remainder - ring\n\n    return x, y\n\nn = int(input())\nx, y = ayrat_location(n)\nprint(x, y)"}
{"solution": "# Get the input values\na, b, c = map(int, input().split())\n\n# Check all possible combinations of shots from Ebony and Ivory guns\nfor i in range(c // a + 1):\n    for j in range(c // b + 1):\n        # If the combination results in exactly c units of damage, print \"Yes\" and exit\n        if a * i + b * j == c:\n            print(\"Yes\")\n            exit()\n\n# If no combination results in exactly c units of damage, print \"No\"\nprint(\"No\")"}
{"solution": "def check_tracks(n, L, k_barriers, s_barriers):\n    k_diff = [k_barriers[i] - k_barriers[i-1] for i in range(1, n)] + [L - k_barriers[-1] + k_barriers[0]]\n    s_diff = [s_barriers[i] - s_barriers[i-1] for i in range(1, n)] + [L - s_barriers[-1] + s_barriers[0]]\n\n    for i in range(n):\n        if k_diff == s_diff[i:] + s_diff[:i]:\n            return \"YES\"\n\n    return \"NO\"\n\nn, L = map(int, input().split())\nk_barriers = list(map(int, input().split()))\ns_barriers = list(map(int, input().split()))\n\nprint(check_tracks(n, L, k_barriers, s_barriers))"}
{"solution": "def is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindrome_substring(s):\n    n = len(s)\n    max_length = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            substring = s[i:j]\n            if not is_palindrome(substring):\n                max_length = max(max_length, len(substring))\n    return max_length\n\ns = input()\nprint(longest_non_palindrome_substring(s))"}
{"solution": "n = int(input())\nratings = []\nfor _ in range(n):\n    a, b = map(int, input().split())\n    ratings.append((a, b))\n\n# Check if the round is rated\nrated = False\nfor i in range(n):\n    if ratings[i][0] != ratings[i][1]:\n        rated = True\n        break\n\n# Check if the round is unrated\nunrated = True\nfor i in range(n - 1):\n    if ratings[i][0] < ratings[i + 1][0] and ratings[i][1] > ratings[i + 1][1]:\n        unrated = False\n        break\n\n# Determine the output\nif rated:\n    print(\"rated\")\nelif unrated:\n    print(\"unrated\")\nelse:\n    print(\"maybe\")"}
{"solution": "n = int(input())\narr = list(map(int, input().split()))\n\n# Find the indices of all zero elements\nzero_indices = [i for i, x in enumerate(arr) if x == 0]\n\n# Calculate the distance to the nearest zero for each element\ndistances = []\nfor i in range(n):\n    min_distance = min(abs(i - zero_index) for zero_index in zero_indices)\n    distances.append(min_distance)\n\n# Print the distances\nprint(' '.join(map(str, distances)))"}
{"solution": "def count_cyclical_strings(n, s):\n    # Initialize the count of cyclical strings\n    count = 0\n\n    # Generate all binary strings of length n\n    for i in range(1 << n):\n        # Convert the integer to binary string\n        binary = bin(i)[2:].zfill(n)\n\n        # Check if the binary string contains s as a substring\n        if s in binary + binary:\n            count += 1\n\n    return count\n\n# Read the input\nn = int(input())\ns = input()\n\n# Print the output\nprint(count_cyclical_strings(n, s))"}
{"solution": "import math\n\ndef find_min_angle_vectors(vectors):\n    # Calculate the angle of each vector\n    angles = [math.atan2(y, x) for x, y in vectors]\n\n    # Sort the vectors based on their angles\n    sorted_vectors = sorted(zip(vectors, range(1, len(vectors) + 1)), key=lambda x: angles[x[1] - 1])\n\n    # Initialize the minimum angle and the pair of vectors with this angle\n    min_angle = float('inf')\n    min_angle_vectors = (0, 0)\n\n    # Iterate over the sorted vectors\n    for i in range(len(sorted_vectors)):\n        # Calculate the angle between the current vector and the next vector in the sorted list\n        angle = abs(angles[sorted_vectors[i][1] - 1] - angles[sorted_vectors[(i + 1) % len(sorted_vectors)][1] - 1])\n\n        # Update the minimum angle and the pair of vectors with this angle if necessary\n        if angle < min_angle:\n            min_angle = angle\n            min_angle_vectors = (sorted_vectors[i][1], sorted_vectors[(i + 1) % len(sorted_vectors)][1])\n\n    # Return the pair of vectors with the minimal non-oriented angle\n    return min_angle_vectors\n\n# Read the input\nn = int(input())\nvectors = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Find the pair of vectors with the minimal non-oriented angle\na, b = find_min_angle_vectors(vectors)\n\n# Print the output\nprint(a, b)"}
{"solution": "def min_time(d, k, a, b, t):\n    time = 0\n    while d > 0:\n        if d > k:\n            time += a * k\n            d -= k\n        else:\n            time += a * d\n            d = 0\n        if d > 0:\n            time += t\n    return min(time, d * b)\n\nd, k, a, b, t = map(int, input().split())\nprint(min_time(d, k, a, b, t))"}
{"solution": "def max_gcd_sequence(n, k):\n    # If the sum is less than the number of elements, no sequence is possible\n    if n < k:\n        return [-1]\n\n    # The maximum GCD is the largest number that can be divided evenly into n\n    # and is less than or equal to n // k\n    max_gcd = n // k\n\n    # If the remaining sum after distributing max_gcd to each element is less than k,\n    # no sequence is possible\n    if n - max_gcd * k < k:\n        return [-1]\n\n    # Start the sequence with max_gcd and increment each subsequent element by 1\n    sequence = [max_gcd + i for i in range(k)]\n\n    return sequence\n\nn, k = map(int, input().split())\nprint(*max_gcd_sequence(n, k))"}
{"solution": "def count_pairs(n, m):\n    # Count the number of multiples of 5 in the range [1, n] and [1, m]\n    n_multiples_of_5 = n // 5\n    m_multiples_of_5 = m // 5\n\n    # Count the number of pairs that sum to a multiple of 5\n    # This is equal to the product of the number of multiples of 5 in each range\n    pairs_sum_to_multiple_of_5 = n_multiples_of_5 * m_multiples_of_5\n\n    # Count the number of pairs that sum to a number that is not a multiple of 5,\n    # but is less than 5 more than a multiple of 5\n    # This is equal to the product of the number of multiples of 5 in one range\n    # and the number of remaining numbers in the other range\n    n_remainder = n % 5\n    m_remainder = m % 5\n    pairs_sum_to_near_multiple_of_5 = n_multiples_of_5 * m_remainder + m_multiples_of_5 * n_remainder\n\n    # Count the number of pairs that sum to a number that is more than 5 more than a multiple of 5\n    # This is equal to the product of the number of remaining numbers in each range\n    pairs_sum_to_more_than_multiple_of_5 = n_remainder * m_remainder\n\n    # If the sum of a number from the first range and a number from the second range is more than 5 more than a multiple of 5,\n    # it is not divisible by 5, so we subtract this number from the total\n    total_pairs = pairs_sum_to_multiple_of_5 + pairs_sum_to_near_multiple_of_5 - pairs_sum_to_more_than_multiple_of_5\n\n    return total_pairs\n\n# Read the input\nn, m = map(int, input().split())\n\n# Print the output\nprint(count_pairs(n, m))"}
{"solution": "def max_beauty(n, x, a):\n    # Initialize variables to keep track of maximum beauty and current sum\n    max_beauty = 0\n    current_sum = 0\n\n    # Iterate through the array\n    for i in range(n):\n        # Multiply the current element by x and add it to the current sum\n        current_sum = max(a[i] * x, current_sum + a[i])\n\n        # Update the maximum beauty\n        max_beauty = max(max_beauty, current_sum)\n\n    # Return the maximum beauty\n    return max_beauty\n\n# Get input\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Print the maximum possible beauty of array a after multiplying all values belonging to some consecutive subarray x\nprint(max_beauty(n, x, a))"}
{"solution": "def count_smaller_or_equal(n, m, x):\n    count = 0\n    for i in range(1, n + 1):\n        count += min(x // i, m)\n    return count\n\ndef find_kth_largest(n, m, k):\n    left, right = 1, n * m\n    while left < right:\n        mid = (left + right) // 2\n        if count_smaller_or_equal(n, m, mid) < k:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\nn, m, k = map(int, input().split())\nprint(find_kth_largest(n, m, k))"}
{"solution": "def find_kth_digit(k):\n    if k < 10:\n        return k\n\n    count = 9\n    length = 1\n    while k > count * length:\n        k -= count * length\n        length += 1\n        count *= 10\n\n    start_number = 10 ** (length - 1)\n    number = start_number + (k - 1) // length\n    position = (k - 1) % length\n\n    return int(str(number)[position])\n\nk = int(input())\nprint(find_kth_digit(k))"}
{"solution": "# Read input\nn, m, r = map(int, input().split())\ns = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Sort buy and sell prices\ns.sort()\nb.sort(reverse=True)\n\n# Buy shares at the lowest price\nwhile r >= s[0]:\n    r -= s[0]\n    s.pop(0)\n    if not s:\n        break\n\n# Sell shares at the highest price\nfor price in b:\n    if price > s[0]:\n        break\n    r += price\n    s.pop(0)\n    if not s:\n        break\n\n# Print the maximum number of bourles\nprint(r)"}
{"solution": "def find_error(t):\n    n = len(t)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0 and t[:i] * (n // i) == t:\n            return t[:i]\n    return None\n\nt = input()\ns = find_error(t)\nif s is None:\n    print('NO')\nelse:\n    print('YES')\n    print(s)"}
{"solution": "import math\n\ndef find_teams(n):\n    result = []\n    while n > 0:\n        x = math.floor((math.sqrt(8*n + 1) - 1) / 2)\n        if x*(x-1)//2 == n:\n            result.append(x)\n        n -= x*(x-1)//2\n    if n == 0:\n        return sorted(result)\n    else:\n        return [-1]\n\nn = int(input())\nprint('\\n'.join(map(str, find_teams(n))))"}
{"solution": "from collections import Counter\n\ndef max_beauty(n, s, b):\n    # Count the frequency of each character in the string\n    freq = Counter(s)\n\n    # Check if it's possible to form an antipalindromic string\n    if any(freq[c] > n // 2 for c in freq):\n        return -1\n\n    # Sort the beauty values in descending order\n    b.sort(reverse=True)\n\n    # Initialize the maximum possible beauty\n    max_beauty = 0\n\n    # Iterate over the first half of the string\n    for i in range(n // 2):\n        # If the current character is not equal to its corresponding character in the second half\n        if s[i] != s[n - i - 1]:\n            # Add the beauty values of the current index and its corresponding index to the maximum possible beauty\n            max_beauty += b[i] + b[n - i - 1]\n\n    return max_beauty\n\n# Read the input\nn = int(input())\ns = input()\nb = list(map(int, input().split()))\n\n# Print the maximum possible beauty\nprint(max_beauty(n, s, b))"}
{"solution": "def can_weigh(w, m):\n    # If the item has mass 0, it can be weighed\n    if m == 0:\n        return True\n    # If the item has mass greater than 0, but there are no weights left, it cannot be weighed\n    elif w > m:\n        return False\n    # If the item has mass equal to the current weight, it can be weighed\n    elif m == w:\n        return True\n    # If the item has mass less than the current weight, check if it can be weighed using the remaining weights\n    elif m < w:\n        return can_weigh(w, m) or can_weigh(w - 1, m)\n    # If the item has mass greater than the current weight, check if it can be weighed using the current weight and the remaining weights\n    else:\n        return can_weigh(w, m - w) or can_weigh(w - 1, m)\n\n# Get the input\nw, m = map(int, input().split())\n\n# Check if the item can be weighed\nif can_weigh(w, m):\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "def solve(n, k):\n    if k > n:\n        return \"No\"\n    if k == n:\n        return \"Yes\\n\" + \" \".join([\"1\"] * k)\n    if k == 1:\n        if n & (n - 1) == 0:\n            return \"Yes\\n\" + str(int(math.log2(n)))\n        else:\n            return \"No\"\n    if n & 1 == 0:\n        return solve(n // 2, k - 1) + \" \" + str(1)\n    else:\n        return solve(n // 2, k - 2) + \" \" + str(1) + \" \" + str(1)\n\nn, k = map(int, input().split())\nprint(solve(n, k))"}
{"solution": "def champagne_flow(n, t):\n    # Create a 2D list to represent the pyramid of glasses\n    pyramid = [[0.0] * i for i in range(1, n+1)]\n\n    # Pour champagne into the top glass\n    pyramid[0][0] = t\n\n    # Simulate the flow of champagne over time\n    for i in range(n-1):\n        for j in range(i+1):\n            # If the glass is full, distribute the champagne to the two glasses below\n            if pyramid[i][j] > 1:\n                overflow = pyramid[i][j] - 1\n                pyramid[i][j] = 1\n                pyramid[i+1][j] += overflow / 2\n                pyramid[i+1][j+1] += overflow / 2\n\n    # Count the number of completely full glasses\n    full_glasses = sum(row.count(1) for row in pyramid)\n\n    return full_glasses\n\n# Get the input\nn, t = map(int, input().split())\n\n# Print the output\nprint(champagne_flow(n, t))"}
{"solution": "def calculate_area(points):\n    x_coordinates = set()\n    y_coordinates = set()\n\n    for point in points:\n        x_coordinates.add(point[0])\n        y_coordinates.add(point[1])\n\n    if len(x_coordinates) == 2 and len(y_coordinates) == 2:\n        length = max(x_coordinates) - min(x_coordinates)\n        width = max(y_coordinates) - min(y_coordinates)\n        return length * width\n    else:\n        return -1\n\nn = int(input())\npoints = []\nfor _ in range(n):\n    x, y = map(int, input().split())\n    points.append((x, y))\n\nprint(calculate_area(points))"}
{"solution": "# Get the input\nn = int(input())\na = int(input())\nb = int(input())\n\n# Calculate the total length of wood needed for two doors\ntotal_length = 2 * (a + b)\n\n# Calculate the minimum number of wooden bars needed\nmin_bars = total_length // n\n\n# If the total length is not a multiple of n, an additional bar is needed\nif total_length % n != 0:\n    min_bars += 1\n\n# Print the result\nprint(min_bars)"}
{"solution": "def can_sort(n, arr, swaps):\n    # Create a list of tuples where each tuple contains the value and its index\n    indexed_arr = sorted((val, i) for i, val in enumerate(arr))\n\n    # Initialize a list to keep track of visited elements\n    visited = [False] * n\n\n    # Iterate over the sorted list of tuples\n    for val, i in indexed_arr:\n        # If the element has not been visited\n        if not visited[i]:\n            # Initialize a cycle size and a cycle start\n            cycle_size = 0\n            cycle_start = i\n            # While the element has not been visited\n            while not visited[i]:\n                # Mark the element as visited\n                visited[i] = True\n                # Increment the cycle size\n                cycle_size += 1\n                # If we can swap with the next element and it has not been visited\n                if i < n - 1 and swaps[i] == '1' and not visited[i + 1]:\n                    # Move to the next element\n                    i += 1\n                else:\n                    # Break the loop\n                    break\n            # If the cycle size is not equal to the number of elements from the cycle start to the current element\n            if cycle_size != i - cycle_start + 1:\n                # Return False\n                return False\n\n    # If all cycles have the correct size, return True\n    return True\n\n# Read the input\nn = int(input())\narr = list(map(int, input().split()))\nswaps = input()\n\n# Print the result\nprint('YES' if can_sort(n, arr, swaps) else 'NO')"}
{"solution": "def calculate_waiting_time(seat):\n    row = int(seat[:-1])\n    column = seat[-1]\n\n    # Calculate the base waiting time for the row\n    base_waiting_time = (row - 1) * 6\n\n    # Calculate the additional waiting time for the column\n    if column in ['f', 'e', 'd']:\n        # If the seat is on the right side of the plane\n        if row % 2 == 1:\n            # If the row is served by the first flight attendant\n            additional_waiting_time = ['f', 'e', 'd'].index(column)\n        else:\n            # If the row is served by the second flight attendant\n            additional_waiting_time = 3 + ['f', 'e', 'd'].index(column)\n    else:\n        # If the seat is on the left side of the plane\n        if row % 2 == 1:\n            # If the row is served by the first flight attendant\n            additional_waiting_time = 3 + ['a', 'b', 'c'].index(column)\n        else:\n            # If the row is served by the second flight attendant\n            additional_waiting_time = 6 + ['a', 'b', 'c'].index(column)\n\n    # Calculate the total waiting time\n    total_waiting_time = base_waiting_time + additional_waiting_time\n\n    return total_waiting_time\n\n# Get the input\nseat = input()\n\n# Calculate and print the waiting time\nprint(calculate_waiting_time(seat))"}
{"solution": "def convert_base(number, base):\n    result = 0\n    for i in range(len(number)):\n        result += number[i] * (base ** (len(number) - i - 1))\n    return result\n\nn, bx = map(int, input().split())\nx = list(map(int, input().split()))\nm, by = map(int, input().split())\ny = list(map(int, input().split()))\n\nx_decimal = convert_base(x, bx)\ny_decimal = convert_base(y, by)\n\nif x_decimal < y_decimal:\n    print('<')\nelif x_decimal > y_decimal:\n    print('>')\nelse:\n    print('=')"}
{"solution": "def game_winner(n, a):\n    # If there are no elements or all elements are 0, BitAryo wins\n    if n == 0 or all(i == 0 for i in a):\n        return \"BitAryo\"\n\n    # If there is only one element, BitLGM can take it all, so BitLGM wins\n    if n == 1:\n        return \"BitLGM\"\n\n    # If there are two elements and they are equal, BitLGM can always mirror BitAryo's moves, so BitLGM wins\n    if n == 2 and a[0] == a[1]:\n        return \"BitLGM\"\n\n    # If there are two elements and the first one is smaller, BitAryo can reduce the second one to make it equal to the first one, and then BitLGM will be forced to mirror the moves, so BitAryo wins\n    if n == 2 and a[0] < a[1]:\n        return \"BitAryo\"\n\n    # If there are three elements and they are all equal, BitLGM can always mirror BitAryo's moves, so BitLGM wins\n    if n == 3 and a[0] == a[1] == a[2]:\n        return \"BitLGM\"\n\n    # If there are three elements and the first two are equal but smaller than the third one, BitAryo can reduce the third one to make it equal to the first two, and then BitLGM will be forced to mirror the moves, so BitAryo wins\n    if n == 3 and a[0] == a[1] < a[2]:\n        return \"BitAryo\"\n\n    # If none of the above conditions are met, BitLGM can win by making the first player's best move worse\n    return \"BitLGM\"\n\nn = int(input())\na = list(map(int, input().split()))\nprint(game_winner(n, a))"}
{"solution": "from collections import defaultdict\n\ndef count_valid_decks(n, k, deck):\n    # Store the count of each factor in the magic number k\n    factors = defaultdict(int)\n    temp = k\n    i = 2\n    while i * i <= temp:\n        if temp % i:\n            i += 1\n        else:\n            temp //= i\n            factors[i] += 1\n    if temp > 1:\n        factors[temp] += 1\n\n    # Initialize the count of valid decks\n    count = 0\n\n    # Iterate through the deck using a sliding window approach\n    left = 0\n    right = 0\n    product = 1\n    while right < n:\n        # Update the product and the count of factors\n        product *= deck[right]\n        for factor, freq in factors.items():\n            while product % factor == 0:\n                product //= factor\n                factors[factor] -= 1\n\n        # If the product is 1, the current window is a valid deck\n        if product == 1:\n            count += 1\n\n        # Move the window to the right\n        right += 1\n\n        # If the window is too large, move it to the left\n        while left < right and all(freq <= 0 for freq in factors.values()):\n            product //= deck[left]\n            for factor, freq in factors.items():\n                while product % factor == 0:\n                    product //= factor\n                    factors[factor] += 1\n            left += 1\n\n    return count\n\n# Read the input\nn, k = map(int, input().split())\ndeck = list(map(int, input().split()))\n\n# Print the result\nprint(count_valid_decks(n, k, deck))"}
{"solution": "# Read the input\nn, k = map(int, input().split())\ns = input()\n\n# Count the occurrences of each color\ncolor_count = {}\nfor c in s:\n    if c in color_count:\n        color_count[c] += 1\n    else:\n        color_count[c] = 1\n\n# Check if it is possible to distribute the balloons\ncan_distribute = True\nfor count in color_count.values():\n    if count > k:\n        can_distribute = False\n        break\n\n# Print the result\nif can_distribute:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def find_closest_minimums(n, arr):\n    # Find the minimum value in the array\n    min_val = min(arr)\n\n    # Initialize variables to keep track of the previous index and the minimum distance\n    prev_index = -1\n    min_dist = float('inf')\n\n    # Iterate through the array\n    for i in range(n):\n        # If the current element is the minimum value\n        if arr[i] == min_val:\n            # If this is not the first occurrence of the minimum value\n            if prev_index != -1:\n                # Update the minimum distance\n                min_dist = min(min_dist, i - prev_index)\n            # Update the previous index\n            prev_index = i\n\n    # Return the minimum distance\n    return min_dist\n\n# Read the input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Find the distance between two closest minimums\nresult = find_closest_minimums(n, arr)\n\n# Print the result\nprint(result)"}
{"solution": "import math\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef lcm(a, b):\n    return (a * b) // gcd(a, b)\n\ndef count_tie_lengths(t, w, b):\n    l = lcm(w, b)\n    return t // l - (t // w - t // b)\n\ndef main():\n    t, w, b = map(int, input().split())\n    total_lengths = t\n    tie_lengths = count_tie_lengths(t, w, b)\n    g = gcd(tie_lengths, total_lengths)\n    print(f\"{tie_lengths // g}/{total_lengths // g}\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Get the input\nx, y, z = map(int, input().split())\n\n# Calculate the difference between upvotes and downvotes\ndiff = x - y\n\n# If the difference is greater than z, the result is \"+\"\nif diff > z:\n    print(\"+\")\n# If the difference is less than -z, the result is \"-\"\nelif diff < -z:\n    print(\"-\")\n# If the difference is between -z and z, the result is uncertain\nelif -z <= diff <= z:\n    print(\"?\")\n# If the difference is equal to 0, the result is \"0\"\nelse:\n    print(\"0\")"}
{"solution": "def calculate_min_changes(n, operations, x, y):\n    # Initialize the current position of the robot\n    curr_x, curr_y = 0, 0\n\n    # Initialize the minimum and maximum indices of changed operations\n    min_index, max_index = float('inf'), float('-inf')\n\n    # Iterate through the operations\n    for i in range(n):\n        # Update the current position based on the operation\n        if operations[i] == 'U':\n            curr_y += 1\n        elif operations[i] == 'D':\n            curr_y -= 1\n        elif operations[i] == 'L':\n            curr_x -= 1\n        elif operations[i] == 'R':\n            curr_x += 1\n\n        # Check if the current position matches the target coordinates\n        if curr_x == x and curr_y == y:\n            # Update the minimum and maximum indices of changed operations\n            min_index = min(min_index, i)\n            max_index = max(max_index, i)\n\n    # Check if it's impossible to reach the target coordinates\n    if min_index == float('inf') or max_index == float('-inf'):\n        return -1\n\n    # Calculate the length of the changed subsegment\n    length = max_index - min_index + 1\n\n    return length\n\n# Read the input\nn = int(input())\noperations = input()\nx, y = map(int, input().split())\n\n# Calculate the minimum length of the changed subsegment\nresult = calculate_min_changes(n, operations, x, y)\n\n# Print the result\nprint(result)"}
{"solution": "def calculate_prefixes(n, x, s):\n    balance = [0] * (n + 1)\n    count = [0] * (2 * n + 1)\n    count[n] = 1\n    result = 0\n\n    for i in range(n):\n        balance[i + 1] = balance[i] + (1 if s[i] == '1' else -1)\n        if balance[i + 1] + x <= 2 * n:\n            result += count[balance[i + 1] + x]\n        count[balance[i + 1] + n] += 1\n\n    if balance[n] == x:\n        result -= 1\n    if balance[n] == 0 and x == 0:\n        return -1\n    if balance[n] == 0:\n        result += 1\n    if x % balance[n] == 0 and x // balance[n] > 0:\n        return -1\n\n    return result\n\nT = int(input())\nfor _ in range(T):\n    n, x = map(int, input().split())\n    s = input()\n    print(calculate_prefixes(n, x, s))"}
{"solution": "# Get the input\nn, k = map(int, input().split())\n\n# Convert the number to string\nn_str = str(n)\n\n# Count the number of trailing zeros\ntrailing_zeros = 0\nfor i in range(len(n_str) - 1, -1, -1):\n    if n_str[i] == '0':\n        trailing_zeros += 1\n    else:\n        break\n\n# If the number of trailing zeros is greater than or equal to k,\n# we don't need to remove any digits\nif trailing_zeros >= k:\n    print(0)\nelse:\n    # Count the number of non-zero digits from the end\n    non_zero_digits = 0\n    for i in range(len(n_str) - 1, -1, -1):\n        if n_str[i] != '0':\n            non_zero_digits += 1\n        if non_zero_digits == k:\n            break\n\n    # Print the result\n    print(len(n_str) - i)"}
{"solution": "def calculate_questions(n, m, k, x, y):\n    total_students = n * m\n    cycle_length = 2 * (n - 1) if n > 1 else 1\n    full_cycles = k // total_students\n    remaining_questions = k % total_students\n\n    max_questions = full_cycles + (1 if remaining_questions >= (x - 1) * m + y else 0)\n    min_questions = full_cycles\n\n    if remaining_questions >= total_students - (n - x) * m:\n        sergei_questions = max_questions\n    elif remaining_questions >= (n - x) * m:\n        sergei_questions = max_questions - 1\n    else:\n        sergei_questions = min_questions\n\n    return max_questions, min_questions, sergei_questions\n\nn, m, k, x, y = map(int, input().split())\nmax_questions, min_questions, sergei_questions = calculate_questions(n, m, k, x, y)\nprint(max_questions, min_questions, sergei_questions)"}
{"solution": "def max_beauty(ribbon, turns):\n    n = len(ribbon)\n    max_subribbon = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            subribbon = ribbon[i:j]\n            count = ribbon.count(subribbon)\n            if count > 1:\n                max_subribbon = max(max_subribbon, count + (turns // (n - len(subribbon))))\n    return max_subribbon\n\nn = int(input())\nribbons = [input() for _ in range(3)]\nbeauties = [max_beauty(ribbon, n) for ribbon in ribbons]\nmax_beauty = max(beauties)\nwinners = [name for name, beauty in zip([\"Kuro\", \"Shiro\", \"Katie\"], beauties) if beauty == max_beauty]\n\nif len(winners) == 1:\n    print(winners[0])\nelse:\n    print(\"Draw\")"}
{"solution": "c, v0, v1, a, l = map(int, input().split())\ndays = 0\npages_read = 0\n\nwhile pages_read < c:\n    pages_read += max(min(v0 + days * a, v1), l)\n    days += 1\n\nprint(days)"}
{"solution": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_primes(n):\n    primes = [i for i in range(2, n) if is_prime(i)]\n    for i in range(3):\n        for j in range(i, len(primes)):\n            for k in range(j, len(primes)):\n                if primes[i] + primes[j] + primes[k] == n:\n                    return [primes[i], primes[j], primes[k]]\n\nn = int(input())\nprimes = find_primes(n)\nprint(len(primes))\nprint(' '.join(map(str, primes)))"}
{"solution": "def find_bomb_location(depot):\n    n = len(depot)\n    m = len(depot[0])\n\n    # Count the number of walls in each row and column\n    row_counts = [0] * n\n    col_counts = [0] * m\n    for i in range(n):\n        for j in range(m):\n            if depot[i][j] == '*':\n                row_counts[i] += 1\n                col_counts[j] += 1\n\n    # Check if there is a cell that can wipe out all walls\n    for i in range(n):\n        for j in range(m):\n            if row_counts[i] + col_counts[j] - (1 if depot[i][j] == '*' else 0) == 0:\n                return (i + 1, j + 1)\n\n    # If no such cell is found, return None\n    return None\n\n# Read the input\nn, m = map(int, input().split())\ndepot = [input() for _ in range(n)]\n\n# Find the bomb location\nbomb_location = find_bomb_location(depot)\n\n# Print the output\nif bomb_location is None:\n    print('NO')\nelse:\n    print('YES')\n    print(*bomb_location)"}
{"solution": "# Get the input\nn, m, a, b = map(int, input().split())\n\n# Calculate the remainder of n divided by m\nremainder = n % m\n\n# If remainder is 0, no action is needed\nif remainder == 0:\n    print(0)\n# If building a box is cheaper than demolishing boxes\nelif a <= b:\n    # Calculate the number of boxes to build\n    build = m - remainder\n    print(build * a)\n# If demolishing a box is cheaper than building boxes\nelse:\n    # Calculate the cost of demolishing all boxes and building the necessary ones\n    demolish_all = n * b\n    build = remainder\n    print(min(demolish_all, build * a))"}
{"solution": "# Read the input\nn = int(input())\nseq = list(map(int, input().split()))\n\n# Separate the odd and even numbers\nodd_nums = [num for num in seq if num % 2 != 0]\neven_nums = [num for num in seq if num % 2 == 0]\n\n# If there are any odd numbers, the maximum odd sum is the sum of all odd numbers\nif odd_nums:\n    print(sum(odd_nums))\n# If there are no odd numbers, the maximum odd sum is the maximum even number\nelse:\n    print(max(even_nums))"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(n, T, songs):\n    dp = [[[0] * (1 << n) for _ in range(3)] for _ in range(T + 1)]\n    dp[0] = [[1] * (1 << n) for _ in range(3)]\n\n    for t in range(1, T + 1):\n        for g in range(3):\n            for mask in range(1 << n):\n                for i in range(n):\n                    if (mask >> i) & 1 and songs[i][0] <= t and songs[i][1] != g:\n                        dp[t][g][mask] = (dp[t][g][mask] + dp[t - songs[i][0]][songs[i][1] - 1][mask ^ (1 << i)]) % MOD\n\n    return sum(dp[T][g][(1 << n) - 1] for g in range(3)) % MOD\n\nn, T = map(int, input().split())\nsongs = [list(map(int, input().split())) for _ in range(n)]\nprint(solve(n, T, songs))"}
{"solution": "import sys\n\nMOD = 10**9 + 7\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef pow_mod(a, b):\n    result = 1\n    while b > 0:\n        if b % 2 == 1:\n            result = (result * a) % MOD\n        a = (a * a) % MOD\n        b //= 2\n    return result\n\ndef expected_length(m):\n    phi = [0] * (m + 1)\n    phi[1] = 1\n    for i in range(2, m + 1):\n        if phi[i] == 0:\n            for j in range(i, m + 1, i):\n                if phi[j] == 0:\n                    phi[j] = j\n                phi[j] = (phi[j] // i) * (i - 1)\n    dp = [0] * (m + 1)\n    dp[1] = 1\n    for i in range(2, m + 1):\n        for j in range(i, m + 1, i):\n            dp[j] = (dp[j] + dp[j // i] * phi[i]) % MOD\n    return dp[m]\n\nm = int(sys.stdin.readline())\nresult = expected_length(m)\nprint(result * pow_mod(sum(pow_mod(i, m) for i in range(1, m + 1)), MOD - 2) % MOD)"}
{"solution": "def gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_good_pairs(l, r, x, y):\n    count = 0\n    for a in range(l, r + 1):\n        for b in range(a, r + 1):\n            if gcd(a, b) == x and lcm(a, b) == y:\n                count += 2 if a != b else 1\n    return count\n\nl, r, x, y = map(int, input().split())\nprint(count_good_pairs(l, r, x, y))"}
{"solution": "import math\n\ndef smallest_k(a, b):\n    # Calculate the least common multiple of a and b\n    lcm = abs(a*b) // math.gcd(a, b)\n\n    # Initialize k as 0\n    k = 0\n\n    # Loop until the least common multiple of a+k and b+k is the smallest possible\n    while True:\n        # Calculate the least common multiple of a+k and b+k\n        new_lcm = abs((a+k)*(b+k)) // math.gcd(a+k, b+k)\n\n        # If the new least common multiple is smaller than the current smallest possible, update the smallest possible\n        if new_lcm < lcm:\n            lcm = new_lcm\n        # If the new least common multiple is equal to the current smallest possible, return k\n        elif new_lcm == lcm:\n            return k\n\n        # Increment k\n        k += 1\n\n# Read the input\na, b = map(int, input().split())\n\n# Print the smallest non-negative integer k\nprint(smallest_k(a, b))"}
{"solution": "# Read the input\nn, k = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Calculate the current average\navg = sum(marks) / n\n\n# Calculate the desired average\ndesired_avg = k\n\n# Calculate the number of marks needed to reach the desired average\nmarks_needed = int((desired_avg * (n + 1) - sum(marks) + 0.5))\n\n# Print the result\nprint(marks_needed)"}
{"solution": "n = int(input())\nnumbers = list(map(int, input().split()))\n\npositive_count = sum(1 for num in numbers if num > 0)\nnegative_count = sum(1 for num in numbers if num < 0)\n\nif positive_count >= (n + 1) // 2:\n    print(1)\nelif negative_count >= (n + 1) // 2:\n    print(-1)\nelse:\n    print(0)"}
{"solution": "def count_pairs(n):\n    # Calculate the maximum possible number of nines at the end of the total cost\n    max_nines = 0\n    while 10 ** (max_nines + 1) - 1 <= n:\n        max_nines += 1\n\n    # Calculate the maximum possible total cost that ends with max_nines number of nines\n    max_cost = 10 ** max_nines - 1\n\n    # Initialize the count of pairs\n    count = 0\n\n    # Iterate through all possible pairs of shovels\n    for i in range(1, n):\n        for j in range(i + 1, n + 1):\n            # Check if the total cost of the pair ends with max_nines number of nines\n            if (i + j) % (10 ** max_nines) == max_cost:\n                count += 1\n\n    return count\n\n# Read the input\nn = int(input())\n\n# Print the output\nprint(count_pairs(n))"}
{"solution": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef solve(a, b):\n    if a < b:\n        a, b = b, a\n    if a % b == 0:\n        return 0, a, b\n    if a % 2 == 0 and b % 2 == 0:\n        return 1 + solve(a // 2, b), a // 2, b\n    if a % 3 == 0 and b % 3 == 0:\n        return 1 + solve(a // 3, b), a // 3, b\n    if a % 2 == 0:\n        return 1 + solve(a // 2, b * 2), a // 2, b * 2\n    if b % 2 == 0:\n        return 1 + solve(a, b // 2), a, b // 2\n    if a % 3 == 0:\n        return 1 + solve(a // 3, b * 3), a // 3, b * 3\n    if b % 3 == 0:\n        return 1 + solve(a, b // 3), a, b // 3\n    return -1, 0, 0\n\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\n\ng = gcd(a1 * b1, a2 * b2)\na1 //= g\nb1 //= g\na2 //= g\nb2 //= g\n\nif a1 > b1:\n    a1, b1 = b1, a1\nif a2 > b2:\n    a2, b2 = b2, a2\n\nif a1 == a2 and b1 == b2:\n    print(0)\n    print(a1, b1)\n    print(a2, b2)\nelse:\n    m1, a1, b1 = solve(a1, b1)\n    m2, a2, b2 = solve(a2, b2)\n    if m1 == -1 or m2 == -1 or a1 != a2 or b1 != b2:\n        print(-1)\n    else:\n        print(m1 + m2)\n        print(a1, b1)\n        print(a2, b2)"}
{"solution": "def optimal_strategy(x_p, y_p, x_v, y_v):\n    # If Vasiliy is already at (0, 0), Polycarp cannot win\n    if x_v == 0 and y_v == 0:\n        return \"Vasiliy\"\n    # If Polycarp is already at (0, 0), he wins\n    elif x_p == 0 and y_p == 0:\n        return \"Polycarp\"\n    # If Polycarp is closer to (0, 0) than Vasiliy, he wins\n    elif x_p + y_p <= x_v + y_v:\n        return \"Polycarp\"\n    # If Vasiliy can reach (0, 0) in one move, he wins\n    elif x_v == 1 and y_v == 1:\n        return \"Vasiliy\"\n    # If Vasiliy is not closer to (0, 0) than Polycarp and cannot reach (0, 0) in one move, Polycarp wins\n    else:\n        return \"Polycarp\"\n\n# Get the starting coordinates of both pawns\nx_p, y_p, x_v, y_v = map(int, input().split())\n\n# Print the name of the winner\nprint(optimal_strategy(x_p, y_p, x_v, y_v))"}
{"solution": "def days_in_month(month):\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        return 31\n    elif month == 2:\n        return 28\n    else:\n        return 30\n\ndef columns_needed(month, first_day):\n    days_in_month = days_in_month(month)\n    if first_day == 1:\n        return (days_in_month - 1) // 7 + 1\n    else:\n        return (days_in_month + first_day - 2) // 7 + 1\n\nmonth, first_day = map(int, input().split())\nprint(columns_needed(month, first_day))"}
{"solution": "def count_zeros(n):\n    binary = bin(n)[2:]\n    return binary.count('0')\n\ndef count_years(a, b):\n    count = 0\n    for year in range(a, b + 1):\n        if count_zeros(year) == 1:\n            count += 1\n    return count\n\na, b = map(int, input().split())\nprint(count_years(a, b))"}
{"solution": "# Read the input\nn = int(input())\n\n# Calculate the total number of segments\ntotal_segments = (n * (n + 1)) // 2\n\n# Initialize the number of layers to 0\nlayers = 0\n\n# Initialize the current layer size to 0\ncurrent_layer_size = 0\n\n# Iterate through all possible segment lengths\nfor length in range(n, 0, -1):\n    # Calculate the number of segments of this length\n    num_segments = n - length + 1\n\n    # If adding these segments to the current layer would exceed the total number of segments,\n    # start a new layer\n    if current_layer_size + num_segments > total_segments:\n        layers += 1\n        current_layer_size = 0\n\n    # Add these segments to the current layer\n    current_layer_size += num_segments\n\n# Add the last layer\nlayers += 1\n\n# Print the result\nprint(layers)"}
{"solution": "import sys\nfrom functools import lru_cache\n\ndef factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n - 1)\n\n@lru_cache(maxsize=None)\ndef count_ways(n, k, s, cubes):\n    if n == 0:\n        return 1 if s == 0 else 0\n    if k == 0 or s < 0:\n        return 0\n    return count_ways(n - 1, k, s, cubes) + count_ways(n - 1, k - 1, s - factorial(cubes[n - 1]), cubes)\n\nn, k, s = map(int, sys.stdin.readline().split())\ncubes = list(map(int, sys.stdin.readline().split()))\nprint(count_ways(n, k, s, cubes))"}
{"solution": "def can_achieve_array(n, k, a):\n    v = [0] * n\n    for i in range(n):\n        if a[i] < v[i]:\n            return False\n        diff = a[i] - v[i]\n        j = 0\n        while diff > 0:\n            if diff % k != 0:\n                return False\n            diff //= k\n            if i + j >= n:\n                return False\n            v[i + j] += k ** j\n            j += 1\n    return True\n\ndef solve():\n    T = int(input())\n    for _ in range(T):\n        n, k = map(int, input().split())\n        a = list(map(int, input().split()))\n        if can_achieve_array(n, k, a):\n            print('YES')\n        else:\n            print('NO')\n\nsolve()"}
{"solution": "def divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count\n\na, b, c = map(int, input().split())\nmod = 1073741824\nresult = 0\n\nfor i in range(1, a + 1):\n    for j in range(1, b + 1):\n        for k in range(1, c + 1):\n            result = (result + divisors(i * j * k)) % mod\n\nprint(result)"}
{"solution": "from collections import deque\n\ndef get_neighbors(state):\n    # Find the index of the empty cell\n    empty_index = state.index('X')\n\n    # Generate possible moves\n    moves = []\n    if empty_index % 2 == 0:\n        moves.append(empty_index + 1)\n    if empty_index % 2 == 1:\n        moves.append(empty_index - 1)\n    if empty_index < 3:\n        moves.append(empty_index + 2)\n    if empty_index > 1:\n        moves.append(empty_index - 2)\n\n    # Generate new states\n    neighbors = []\n    for move in moves:\n        new_state = list(state)\n        new_state[empty_index], new_state[move] = new_state[move], new_state[empty_index]\n        neighbors.append(''.join(new_state))\n\n    return neighbors\n\ndef bfs(start):\n    visited = set()\n    queue = deque([start])\n    visited.add(start)\n\n    while queue:\n        current_state = queue.popleft()\n\n        for neighbor in get_neighbors(current_state):\n            if neighbor not in visited:\n                queue.append(neighbor)\n                visited.add(neighbor)\n\n    return visited\n\n# Get input\nbessie_start = ''.join(input().split())\nelsie_start = ''.join(input().split())\n\n# Perform BFS for both puzzles\nbessie_configs = bfs(bessie_start)\nelsie_configs = bfs(elsie_start)\n\n# Check if there is any overlap between the two sets of configurations\nif bessie_configs & elsie_configs:\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "def convert_to_decimal(n, k):\n    decimal = 0\n    power = 0\n    while k > 0:\n        decimal += (k % 10) * (n ** power)\n        k //= 10\n        power += 1\n    return decimal\n\nn = int(input())\nk = int(input())\n\nprint(convert_to_decimal(n, k))"}
{"solution": "# Read the number of elements in the array\nn = int(input())\n\n# Read the elements of the array\narr = list(map(int, input().split()))\n\n# Initialize the state of the array\nstate = \"increasing\"\n\n# Iterate through the array\nfor i in range(n - 1):\n    # Compare the current element with the next one\n    if arr[i] < arr[i + 1]:\n        # If the array is decreasing, it is not unimodal\n        if state == \"decreasing\":\n            print(\"NO\")\n            exit()\n        # If the array is constant, it becomes increasing\n        elif state == \"constant\":\n            state = \"increasing\"\n    elif arr[i] > arr[i + 1]:\n        # If the array is increasing, it becomes decreasing\n        if state == \"increasing\":\n            state = \"decreasing\"\n        # If the array is constant, it remains constant\n        elif state == \"constant\":\n            continue\n        # If the array is decreasing, it remains decreasing\n        elif state == \"decreasing\":\n            continue\n    else:\n        # If the array is increasing or decreasing, it becomes constant\n        if state != \"constant\":\n            state = \"constant\"\n\n# If the loop completes without finding any violations, the array is unimodal\nprint(\"YES\")"}
{"solution": "def f(x):\n    return x // 2 if x % 2 == 0 else x - 1\n\ndef path_length(x):\n    length = 1\n    while x != 1:\n        x = f(x)\n        length += 1\n    return length\n\ndef solve(n, k):\n    count = [0] * (n + 1)\n    for x in range(1, n + 1):\n        y = x\n        while y != 1:\n            count[y] += 1\n            y = f(y)\n    for y in range(n, 0, -1):\n        if count[y] >= k:\n            return y\n\nn, k = map(int, input().split())\nprint(solve(n, k))"}
{"solution": "def billiard_pocket(n, m, x, y, vx, vy):\n    # Check if the ball is already in a pocket\n    if (x == 0 and y == 0) or (x == n and y == 0) or (x == 0 and y == m) or (x == n and y == m):\n        return (x, y)\n\n    # Calculate the time it takes for the ball to hit a side\n    tx = float('inf')\n    ty = float('inf')\n    if vx < 0:\n        tx = x / abs(vx)\n    elif vx > 0:\n        tx = (n - x) / vx\n    if vy < 0:\n        ty = y / abs(vy)\n    elif vy > 0:\n        ty = (m - y) / vy\n\n    # Determine the pocket the ball will fall into\n    if tx < ty:\n        if vx < 0:\n            return (0, y + vy * tx)\n        else:\n            return (n, y + vy * tx)\n    else:\n        if vy < 0:\n            return (x + vx * ty, 0)\n        else:\n            return (x + vx * ty, m)\n\n# Get the input\nn, m, x, y, vx, vy = map(int, input().split())\n\n# Print the output\nresult = billiard_pocket(n, m, x, y, vx, vy)\nif result[0] == x and result[1] == y:\n    print(-1)\nelse:\n    print(*result)"}
{"solution": "def can_place_paintings(board, painting1, painting2):\n    # Sort the dimensions of the board, painting1, and painting2 in descending order\n    board = sorted(board, reverse=True)\n    painting1 = sorted(paining1, reverse=True)\n    painting2 = sorted(painting2, reverse=True)\n\n    # Check all possible configurations\n    for _ in range(2):\n        for _ in range(2):\n            # Check if painting1 and painting2 can be placed horizontally\n            if board[0] >= painting1[0] + painting2[0] and board[1] >= max(painting1[1], painting2[1]):\n                return True\n            # Check if painting1 and painting2 can be placed vertically\n            if board[0] >= max(painting1[0], painting2[0]) and board[1] >= painting1[1] + painting2[1]:\n                return True\n            # Rotate painting2\n            painting2 = painting2[::-1]\n        # Rotate painting1\n        painting1 = painting1[::-1]\n\n    # If no configuration is possible, return False\n    return False\n\n# Get the input\nboard = list(map(int, input().split()))\npainting1 = list(map(int, input().split()))\npainting2 = list(map(int, input().split()))\n\n# Print the output\nprint(\"YES\" if can_place_paintings(board, painting1, painting2) else \"NO\")"}
{"solution": "def geometric_progression(b1, q, l, m, bad_numbers):\n    count = 0\n    i = 0\n    while abs(b1) <= l:\n        if b1 not in bad_numbers:\n            count += 1\n        i += 1\n        b1 = b1 * q\n    return count if abs(q) <= 1 else 'inf'\n\nb1, q, l, m = map(int, input().split())\nbad_numbers = set(map(int, input().split()))\nprint(geometric_progression(b1, q, l, m, bad_numbers))"}
{"solution": "def find_frame(screen):\n    n = len(screen)\n    m = len(screen[0])\n\n    # Find the top-left and bottom-right coordinates of the white pixels\n    top_left = (n, m)\n    bottom_right = (0, 0)\n    for i in range(n):\n        for j in range(m):\n            if screen[i][j] == 'w':\n                top_left = (min(top_left[0], i), min(top_left[1], j))\n                bottom_right = (max(bottom_right[0], i), max(bottom_right[1], j))\n\n    # Check if the frame exists\n    if bottom_right[0] - top_left[0] + 1 > m or bottom_right[1] - top_left[1] + 1 > n:\n        return -1\n\n    # Create a copy of the screen to draw the frame\n    frame = [list(row) for row in screen]\n\n    # Draw the frame\n    for i in range(top_left[1], bottom_right[1] + 1):\n        frame[top_left[0]][i] = '+'\n        frame[bottom_right[0]][i] = '+'\n    for i in range(top_left[0] + 1, bottom_right[0]):\n        frame[i][top_left[1]] = '+'\n        frame[i][bottom_right[1]] = '+'\n\n    # Convert the frame to a string representation\n    frame_str = '\\n'.join([''.join(row) for row in frame])\n\n    return frame_str\n\n# Read the input\nn, m = map(int, input().split())\nscreen = [input() for _ in range(n)]\n\n# Find the frame\nresult = find_frame(screen)\n\n# Print the result\nprint(result)"}
{"solution": "def extended_euclidean(a, b):\n    if a == 0:\n        return b, 0, 1\n    else:\n        gcd, x, y = extended_euclidean(b % a, a)\n        return gcd, y - (b // a) * x, x\n\ndef solve_equation(n, a, b):\n    gcd, x, y = extended_euclidean(a, b)\n    if n % gcd != 0:\n        return \"NO\"\n    else:\n        x *= n // gcd\n        y *= n // gcd\n        return \"YES\\n{} {}\".format(x, y)\n\nn = int(input())\na = int(input())\nb = int(input())\n\nprint(solve_equation(n, a, b))"}
{"solution": "def number_to_words(n):\n    # Define the words for the numbers\n    under_20 = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten', 'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen', 'eighteen', 'nineteen']\n    tens = ['twenty', 'thirty', 'forty', 'fifty', 'sixty', 'seventy', 'eighty', 'ninety']\n\n    if n < 20:\n        return under_20[n]\n    elif n < 100:\n        if n % 10 == 0:\n            return tens[n // 10 - 2]\n        else:\n            return tens[n // 10 - 2] + '-' + under_20[n % 10]\n\n# Get the input\ns = int(input())\n\n# Print the output\nprint(number_to_words(s))"}
{"solution": "# Get the number of elements in the array\nn = int(input())\n\n# Get the array elements\narr = list(map(int, input().split()))\n\n# Initialize the maximum number of consecutive elements that can be erased\nmax_erased = 0\n\n# Iterate through the array\nfor i in range(1, n - 1):\n    # If the difference between the current element and the next element is equal to 1,\n    # then we can erase the current element\n    if arr[i + 1] - arr[i] == 1:\n        # Calculate the number of consecutive elements that can be erased\n        j = i\n        while j < n - 1 and arr[j + 1] - arr[j] == 1:\n            j += 1\n        # Update the maximum number of consecutive elements that can be erased\n        max_erased = max(max_erased, j - i)\n\n# Print the maximum number of consecutive elements that can be erased\nprint(max_erased)"}
{"solution": "# Read the input\nn = int(input())\nproblems = list(map(int, input().split()))\n\n# Calculate the total number of problems\ntotal_problems = sum(problems)\n\n# Calculate the threshold\nthreshold = total_problems // 2\nif total_problems % 2 == 0:\n    threshold -= 1\n\n# Initialize the variables\nsolved_problems = 0\nday = 0\n\n# Iterate through the days\nfor i in range(n):\n    # Add the problems solved on the current day\n    solved_problems += problems[i]\n\n    # Check if the threshold has been reached\n    if solved_problems > threshold:\n        day = i + 1\n        break\n\n# Print the output\nprint(day)"}
{"solution": "from collections import deque\n\ndef is_valid(x, y, n):\n    return 0 <= x < n and 0 <= y < n\n\ndef min_steps(n, board):\n    dp = [[[float('inf')] * 3 for _ in range(n)] for _ in range(n)]\n    dx = [-2, -2, -1, -1, 1, 1, 2, 2]\n    dy = [-1, 1, -2, 2, -2, 2, -1, 1]\n    q = deque()\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                dp[i][j] = [0, 0, 0]\n                q.append((i, j, 0, 0))\n                q.append((i, j, 0, 1))\n                q.append((i, j, 0, 2))\n    while q:\n        x, y, steps, piece = q.popleft()\n        for i in range(n):\n            nx, ny = x + dx[i], y + dy[i]\n            if is_valid(nx, ny, n) and dp[nx][ny][piece] > steps + 1:\n                dp[nx][ny][piece] = steps + 1\n                q.append((nx, ny, steps + 1, piece))\n        if piece < 2:\n            for i in range(piece + 1, 3):\n                if dp[x][y][i] > steps + 1:\n                    dp[x][y][i] = steps + 1\n                    q.append((x, y, steps + 1, i))\n    min_steps = float('inf')\n    min_replacements = float('inf')\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == n * n:\n                min_steps = min(min_steps, dp[i][j][0])\n                min_replacements = min(min_replacements, dp[i][j][1])\n                min_replacements = min(min_replacements, dp[i][j][2])\n    return min_steps, min_replacements\n\nn = int(input())\nboard = [list(map(int, input().split())) for _ in range(n)]\nsteps, replacements = min_steps(n, board)\nprint(steps, replacements)"}
{"solution": "def min_time(n, m, k, a, b):\n    # Calculate the apartment, entrance, and floor of a and b\n    a_apartment = (a - 1) % (m * k) + 1\n    a_entrance = (a - 1) // (m * k) + 1\n    a_floor = (a_apartment - 1) // k + 1\n\n    b_apartment = (b - 1) % (m * k) + 1\n    b_entrance = (b - 1) // (m * k) + 1\n    b_floor = (b_apartment - 1) // k + 1\n\n    # Calculate the time it takes to move between entrances\n    entrance_diff = min(abs(a_entrance - b_entrance), n - abs(a_entrance - b_entrance))\n    entrance_time = entrance_diff * 15\n\n    # Calculate the time it takes to move between floors\n    floor_time = abs(a_floor - b_floor) * 5\n\n    # Calculate the time it takes to use the elevator\n    elevator_time = 10 + abs(a_floor - b_floor)\n\n    # Return the minimum time\n    return min(entrance_time + floor_time, elevator_time)\n\n# Get the input\nn, m, k = map(int, input().split())\na, b = map(int, input().split())\n\n# Print the output\nprint(min_time(n, m, k, a, b))"}
{"solution": "def divisible_by_64(s):\n    # Count the number of zeros and ones in the string\n    count_zeros = s.count('0')\n    count_ones = s.count('1')\n\n    # If there are less than 6 zeros, it's impossible to form a number divisible by 64\n    if count_zeros < 6:\n        return 'no'\n\n    # If there are no ones, it's impossible to form a number divisible by 64\n    if count_ones == 0:\n        return 'no'\n\n    # Find the index of the first '1' from the right\n    index_first_one = s.rfind('1')\n\n    # Count the number of zeros after the first '1'\n    count_zeros_after_first_one = s[index_first_one:].count('0')\n\n    # If there are at least 6 zeros after the first '1', it's possible to form a number divisible by 64\n    if count_zeros_after_first_one >= 6:\n        return 'yes'\n    else:\n        return 'no'\n\n# Read the input\ns = input()\n\n# Print the output\nprint(divisible_by_64(s))"}
{"solution": "def solve(s):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    i = 0\n    result = ''\n    for char in s:\n        if char == alphabet[i]:\n            result += char\n            i += 1\n            if i == 26:\n                break\n        elif char < alphabet[i]:\n            result += alphabet[i]\n            i += 1\n            if i == 26:\n                break\n    if i == 26:\n        return result\n    else:\n        return '-1'\n\ns = input()\nprint(solve(s))"}
{"solution": "def calculate_expected_value(n, m, r, k):\n    total_cells = n * m\n    total_scoop_positions = (n - r + 1) * (m - r + 1)\n    max_fish_in_scoop = r * r\n\n    if k >= max_fish_in_scoop:\n        return max_fish_in_scoop\n\n    probability_of_catching_fish = k / total_cells\n    probability_of_not_catching_fish = (total_cells - k) / total_cells\n\n    expected_value = 0\n    for i in range(k):\n        expected_value += probability_of_catching_fish * (i + 1) * (probability_of_not_catching_fish ** (k - i - 1))\n\n    return expected_value * total_scoop_positions\n\nn, m, r, k = map(int, input().split())\nprint(calculate_expected_value(n, m, r, k))"}
{"solution": "def max_product(n, a):\n    # Count the number of negative numbers and zeros in the array\n    neg_count = 0\n    zero_count = 0\n    for i in range(n):\n        if a[i] < 0:\n            neg_count += 1\n        elif a[i] == 0:\n            zero_count += 1\n\n    # If there are an odd number of negative numbers, we need to make one of them positive\n    if neg_count % 2 == 1:\n        # Find the smallest absolute value in the array\n        min_abs = float('inf')\n        min_index = -1\n        for i in range(n):\n            if abs(a[i]) < min_abs:\n                min_abs = abs(a[i])\n                min_index = i\n        # Apply the operation to make it positive\n        a[min_index] = -a[min_index] - 1\n\n    # If there are no zeros, we can apply the operation to all elements to make them negative\n    if zero_count == 0:\n        for i in range(n):\n            a[i] = -a[i] - 1\n\n    # If there is at least one zero, we can make all elements negative except for one zero\n    else:\n        for i in range(n):\n            if a[i] != 0:\n                a[i] = -a[i] - 1\n\n    return a\n\n# Read the input\nn = int(input())\na = list(map(int, input().split()))\n\n# Print the output\nprint(*max_product(n, a))"}
{"solution": "import math\n\ndef find_kth_divisor(n, k):\n    divisors = []\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    divisors.sort()\n    if k > len(divisors):\n        return -1\n    else:\n        return divisors[k - 1]\n\nn, k = map(int, input().split())\nprint(find_kth_divisor(n, k))"}
{"solution": "from itertools import permutations\n\ndef can_form(num, cubes):\n    for i in range(1, num + 1):\n        digits = [int(d) for d in str(i)]\n        if not any(all(d in cube for d in digits) for cube in cubes):\n            return False\n    return True\n\ndef solve(cubes):\n    for num in range(9876, -1, -1):\n        if can_form(num, cubes):\n            return num\n    return 0\n\nn = int(input())\ncubes = []\nfor _ in range(n):\n    cube = list(map(int, input().split()))\n    cubes.append(cube)\n\nprint(solve(cubes))"}
{"solution": "def k_rounding(n, k):\n    # Calculate the number of zeros needed\n    zeros_needed = k - len(str(n)) + 1\n    if zeros_needed < 0:\n        zeros_needed = 0\n\n    # Calculate the smallest multiple of n that ends with zeros_needed zeros\n    multiplier = 10 ** zeros_needed\n    result = (multiplier // n) * n\n\n    return result\n\nn, k = map(int, input().split())\nprint(k_rounding(n, k))"}
{"solution": "def solve(n, m, A):\n    B = [[0] * m for _ in range(n)]\n    operations = []\n\n    for i in range(n - 1):\n        for j in range(m - 1):\n            if A[i][j] == 1 and B[i][j] == 0:\n                if A[i][j + 1] == 0 and A[i + 1][j] == 0 and A[i + 1][j + 1] == 0:\n                    return -1\n                B[i][j] = B[i][j + 1] = B[i + 1][j] = B[i + 1][j + 1] = 1\n                operations.append((i + 1, j + 1))\n\n    if A != B:\n        return -1\n\n    return operations\n\ndef main():\n    n, m = map(int, input().split())\n    A = [list(map(int, input().split())) for _ in range(n)]\n\n    result = solve(n, m, A)\n\n    if result == -1:\n        print(-1)\n    else:\n        print(len(result))\n        for op in result:\n            print(*op)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import numpy as np\n\ndef calculate_probabilities(r, s, p):\n    total = r + s + p\n    transitions = np.array([\n        [(s * (s + p - 1)) / (total * (total - 1)), (s * (r + 1)) / (total * (total - 1)), (s * p) / (total * (total - 1))],\n        [(r * (r + p - 1)) / (total * (total - 1)), (r * (s + 1)) / (total * (total - 1)), (r * p) / (total * (total - 1))],\n        [(p * (r + s - 1)) / (total * (total - 1)), (p * (s + 1)) / (total * (total - 1)), (p * r) / (total * (total - 1))]\n    ])\n    initial_state = np.array([r/total, s/total, p/total])\n    final_state = np.linalg.matrix_power(transitions, 10**6) @ initial_state\n    return final_state\n\nr, s, p = map(int, input().split())\nprobabilities = calculate_probabilities(r, s, p)\nprint(\" \".join(map(str, probabilities)))"}
{"solution": "# Get the input values\nl_1, r_1, l_2, r_2, k = map(int, input().split())\n\n# Calculate the overlapping time\noverlap_start = max(l_1, l_2)\noverlap_end = min(r_1, r_2)\n\n# Check if there's an overlap and if Sonya is available during the overlap\nif overlap_start <= overlap_end and overlap_start <= k <= overlap_end:\n    # Calculate the total overlap time and subtract the minute when Sonya is unavailable\n    total_time = (overlap_end - overlap_start) - 1\nelse:\n    # If there's no overlap or Sonya is not available during the overlap, they can't spend any time together\n    total_time = 0\n\n# Print the result\nprint(total_time)"}
{"solution": "import sys\n\ndef main():\n    N, M = map(int, sys.stdin.readline().split())\n\n    # Store the lines and their endpoints\n    lines = []\n    for _ in range(N):\n        A, B, C = map(int, sys.stdin.readline().split())\n        lines.append((A, B, C, 'ns'))\n    for _ in range(M):\n        D, E, F = map(int, sys.stdin.readline().split())\n        lines.append((D, E, F, 'ew'))\n\n    # Calculate the minimum and maximum x and y values\n    min_x, max_x, min_y, max_y = 0, 0, 0, 0\n    for line in lines:\n        if line[3] == 'ns':\n            min_x = max(min_x, line[0])\n            max_x = min(max_x, line[1])\n        else:\n            min_y = max(min_y, line[1])\n            max_y = min(max_y, line[2])\n\n    # Calculate the area\n    if min_x > max_x or min_y > max_y:\n        print('INF')\n    else:\n        print((max_x - min_x) * (max_y - min_y))\n\nif __name__ == '__main__':\n    main()"}
{"solution": "# Get the input\nt, s, x = map(int, input().split())\n\n# Calculate the first barking time after x\nfirst_bark_after_x = t + s * ((x - t) // s)\n\n# Check if the pineapple will bark at time x\nif x == first_bark_after_x or x == first_bark_after_x + 1:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def find_segments(n, segments):\n    # Sort segments based on start and end points\n    segments.sort(key=lambda x: (x[0], -x[1]))\n\n    # Initialize stack with the first segment\n    stack = [segments[0]]\n\n    # Iterate over the remaining segments\n    for i in range(1, n):\n        # If the current segment lies within the segment at the top of the stack, return the indices\n        if segments[i][0] >= stack[-1][0] and segments[i][1] <= stack[-1][1]:\n            return i + 1, stack[-1][2]\n\n        # If the current segment does not overlap with the segment at the top of the stack, push it onto the stack\n        if segments[i][0] > stack[-1][1]:\n            stack.append(segments[i])\n\n    # If no answer exists, return -1 -1\n    return -1, -1\n\n# Read input\nn = int(input())\nsegments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r, i + 1))\n\n# Find indices\ni, j = find_segments(n, segments)\n\n# Print output\nprint(i, j)"}
{"solution": "n = int(input())\ns = input()\n\n# Count the number of each nucleotide type\ncounts = {'A': 0, 'C': 0, 'G': 0, 'T': 0}\nfor nucleotide in s:\n    if nucleotide != '?':\n        counts[nucleotide] += 1\n\n# Calculate the number of each type that should be in the decoded genome\ntarget_count = n // 4\n\n# Check if it is possible to decode the genome\nfor count in counts.values():\n    if count > target_count:\n        print(\"===\")\n        exit()\n\n# Replace unrecognized nucleotides\ndecoded_genome = list(s)\nfor i in range(n):\n    if decoded_genome[i] == '?':\n        for nucleotide in 'ACGT':\n            if counts[nucleotide] < target_count:\n                decoded_genome[i] = nucleotide\n                counts[nucleotide] += 1\n                break\n\nprint(''.join(decoded_genome))"}
{"solution": "def check_win(board, player):\n    # Check rows, columns, and diagonals for a win\n    for i in range(4):\n        if all(board[i][j] == player for j in range(4)):\n            return True\n        if all(board[j][i] == player for j in range(4)):\n            return True\n    if all(board[i][i] == player for i in range(4)):\n        return True\n    if all(board[i][3 - i] == player for i in range(4)):\n        return True\n    return False\n\ndef can_win(board):\n    # Iterate through each empty cell and simulate placing an X in that position\n    for i in range(4):\n        for j in range(4):\n            if board[i][j] == '.':\n                board[i][j] = 'x'\n                if check_win(board, 'x'):\n                    return True\n                board[i][j] = '.'\n    return False\n\n# Read the input board\nboard = [list(input()) for _ in range(4)]\n\n# Check if Ilya could have won by making a single turn\nif can_win(board):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Calculate the total sum of the array\ntotal_sum = sum(a)\n\n# If the total sum is odd, it's impossible to divide the array\nif total_sum % 2 != 0:\n    print('NO')\nelse:\n    # Calculate the target sum for each part of the array\n    target_sum = total_sum // 2\n\n    # Initialize the current sum and the index of the element to move\n    current_sum = 0\n    move_index = -1\n\n    # Iterate through the array\n    for i in range(n):\n        # Add the current element to the current sum\n        current_sum += a[i]\n\n        # If the current sum equals to the target sum,\n        # we can divide the array by moving the next element\n        if current_sum == target_sum:\n            move_index = i + 1\n            break\n\n    # If we found the element to move, print 'YES'\n    if move_index != -1:\n        print('YES')\n    else:\n        print('NO')"}
{"solution": "def solve(n, k, a, b):\n    a.sort()\n    b.sort(reverse=True)\n    i = 0\n    j = 0\n    while i < n and j < k:\n        if a[i] == 0:\n            a[i] = b[j]\n            j += 1\n        if i > 0 and a[i] >= a[i - 1]:\n            return \"No\"\n        i += 1\n    return \"Yes\"\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nprint(solve(n, k, a, b))"}
{"solution": "# Get the input\nx, y, z = map(int, input().split())\na, b, c = map(int, input().split())\n\n# Check if Andrew can eat enough green grapes\nif x > a:\n    print(\"NO\")\nelse:\n    # Subtract the green grapes Andrew will eat from the total\n    a -= x\n    # Check if Dmitry can eat enough non-black grapes\n    if y > a + b:\n        print(\"NO\")\n    else:\n        # Subtract the non-black grapes Dmitry will eat from the total\n        y -= min(a, y)\n        a -= min(a, y)\n        # Check if Michal can eat enough remaining grapes\n        if z > a + b + c:\n            print(\"NO\")\n        else:\n            print(\"YES\")"}
{"solution": "# Read the input\ntraffic_lights = [list(map(int, input().split())) for _ in range(4)]\n\n# Check for possible accidents\nfor i in range(4):\n    # If the pedestrian light is green\n    if traffic_lights[i][3] == 1:\n        # Check if any of the car lights are green\n        if traffic_lights[i][0] == 1 or traffic_lights[i][1] == 1 or traffic_lights[i][2] == 1:\n            print(\"YES\")\n            exit()\n\n# If no accidents are possible\nprint(\"NO\")"}
{"solution": "# Define the possible finger movements between the keys on the phone's keyboard\nmovements = {\n    '1': ['2', '4', '5'],\n    '2': ['1', '3', '5', '6', '8'],\n    '3': ['2', '6', '9'],\n    '4': ['1', '5', '7'],\n    '5': ['1', '2', '4', '6', '8'],\n    '6': ['2', '3', '5', '7', '9'],\n    '7': ['4', '6', '8'],\n    '8': ['2', '5', '7', '9', '0'],\n    '9': ['3', '6', '8'],\n    '0': ['8']\n}\n\n# Define a function to check if there are any other numbers that have the same finger movements as the input number\ndef check_movements(number):\n    # Convert the input number to a list of digits\n    digits = list(number)\n\n    # Initialize a set to store all possible numbers that have the same finger movements as the input number\n    possible_numbers = set()\n\n    # Define a recursive function to generate all possible numbers that have the same finger movements as the input number\n    def generate_numbers(current_number, index):\n        # If we have generated a number with the same length as the input number, add it to the set of possible numbers\n        if index == len(digits):\n            possible_numbers.add(current_number)\n            return\n\n        # Get the possible next digits that have the same finger movements as the current digit\n        next_digits = movements[digits[index]]\n\n        # Recursively generate all possible numbers that have the same finger movements as the input number, starting with each possible next digit\n        for next_digit in next_digits:\n            generate_numbers(current_number + next_digit, index + 1)\n\n    # Generate all possible numbers that have the same finger movements as the input number, starting with the first digit\n    generate_numbers(digits[0], 1)\n\n    # If there is only one possible number (the input number itself), then Mike can be sure that he is calling the correct number\n    if len(possible_numbers) == 1:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read the input\nn = int(input())\nnumber = input()\n\n# Check if there are any other numbers that have the same finger movements as the input number\nresult = check_movements(number)\n\n# Print the output\nprint(result)"}
{"solution": "import heapq\n\ndef max_sold_products(n, f, k, l):\n    # Calculate the potential number of products that could be sold on each day if it were a sell-out day\n    potential_sales = [min(2*k[i], l[i]) - min(k[i], l[i]) for i in range(n)]\n\n    # Choose the f days with the highest potential number of products sold\n    max_sales_days = heapq.nlargest(f, range(n), key=potential_sales.__getitem__)\n\n    # Calculate the total number of sold products\n    total_sold = sum(min(k[i], l[i]) for i in range(n))\n    total_sold += sum(min(2*k[i], l[i]) for i in max_sales_days)\n\n    return total_sold\n\n# Read input\nn, f = map(int, input().split())\nk = []\nl = []\nfor _ in range(n):\n    ki, li = map(int, input().split())\n    k.append(ki)\n    l.append(li)\n\n# Print output\nprint(max_sold_products(n, f, k, l))"}
{"solution": "# Read the input\nn, k = map(int, input().split())\n\n# Calculate the maximum messiness\nmax_messiness = 0\n\n# If the number of swaps is greater than or equal to n-1,\n# we can sort the cows in reverse order\nif k >= n - 1:\n    for i in range(1, n):\n        max_messiness += i\nelse:\n    # If the number of swaps is less than n-1,\n    # we can swap the first k cows with the last k cows\n    for i in range(1, k + 1):\n        max_messiness += i\n    # Then, the remaining cows will be in their original positions\n    for i in range(k + 1, n):\n        max_messiness += k\n\n# Print the result\nprint(max_messiness)"}
{"solution": "# Read the input\nn, m, k, l = map(int, input().split())\n\n# Calculate the number of coins that can be gifted by each friend\ncoins_per_friend = (n - k) // m\n\n# Check if it's possible to meet all the conditions\nif coins_per_friend < 1 or coins_per_friend * m < l:\n    print(-1)\nelse:\n    # Calculate the minimum number of coins one friend can gift\n    min_coins = l // m\n    if l % m != 0:\n        min_coins += 1\n    print(min_coins)"}
{"solution": "def min_cells_to_paint(n, m, grid):\n    # Find the top-left and bottom-right coordinates of the existing black square\n    top_left = (-1, -1)\n    bottom_right = (-1, -1)\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'B':\n                if top_left == (-1, -1):\n                    top_left = (i, j)\n                bottom_right = (i, j)\n\n    # If there are no black cells, return -1\n    if top_left == (-1, -1):\n        return -1\n\n    # Calculate the side length of the square\n    side_length = max(bottom_right[0] - top_left[0] + 1, bottom_right[1] - top_left[1] + 1)\n\n    # Count the number of white cells that need to be painted black\n    count = 0\n    for i in range(top_left[0], top_left[0] + side_length):\n        for j in range(top_left[1], top_left[1] + side_length):\n            if i < 0 or i >= n or j < 0 or j >= m or grid[i][j] == 'W':\n                count += 1\n\n    return count\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\n\n# Print output\nprint(min_cells_to_paint(n, m, grid))"}
{"solution": "# Read the number of piles\nn = int(input())\n\n# Read the initial number of stones in each pile\nx = list(map(int, input().split()))\n\n# Read the final number of stones in each pile\ny = list(map(int, input().split()))\n\n# Calculate the difference in the number of stones in each pile\ndiff = [yi - xi for xi, yi in zip(x, y)]\n\n# Calculate the total difference in the number of stones\ntotal_diff = sum(diff)\n\n# If the total difference is not zero, the records cannot be consistent\nif total_diff != 0:\n    print(\"No\")\nelse:\n    # If the total difference is zero, check if it's possible to move stones around\n    # to convert the initial configuration to the final configuration\n    for i in range(n):\n        if diff[i] < 0:\n            # If there are more stones in the initial configuration than in the final configuration,\n            # we need to add stones to this pile\n            for j in range(n):\n                if diff[j] > 0:\n                    # If there are fewer stones in another pile than in the final configuration,\n                    # we can move stones from this pile to the current pile\n                    move = min(-diff[i], diff[j])\n                    diff[i] += move\n                    diff[j] -= move\n                    if diff[i] == 0:\n                        break\n    # If all differences are zero, the records are consistent\n    if all(d == 0 for d in diff):\n        print(\"Yes\")\n    else:\n        print(\"No\")"}
{"solution": "n = int(input())\nangles = list(map(int, input().split()))\n\n# Calculate the total sum of angles\ntotal_sum = sum(angles)\n\n# Initialize the minimum difference as the total sum\nmin_diff = total_sum\n\n# Initialize the sum of the first sector\nsector_sum = 0\n\n# Iterate through the angles\nfor i in range(n):\n    # Add the current angle to the sector sum\n    sector_sum += angles[i]\n\n    # Calculate the difference between the total sum and twice the sector sum\n    diff = abs(total_sum - 2 * sector_sum)\n\n    # Update the minimum difference if the current difference is smaller\n    min_diff = min(min_diff, diff)\n\n# Print the minimum difference\nprint(min_diff)"}
{"solution": "MOD = 10**9 + 7\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1:\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\ndef findWays(n, m):\n    if n > m:\n        return 0\n    if n == m:\n        return power(2, n, MOD)\n    return (power(2, m, MOD) - power(2, m - n, MOD)) % MOD\n\nn, m = map(int, input().split())\nprint(findWays(n, m))"}
{"solution": "import math\n\ndef find_pythagorean_triple(n):\n    if n % 2 != 0:\n        return -1\n\n    m = 2\n    while True:\n        for k in range(1, m):\n            if math.gcd(k, m) == 1 and (m - k) % 2 != 0:\n                a = m * m - k * k\n                b = 2 * m * k\n                c = m * m + k * k\n                if n == a or n == b or n == c:\n                    return (b if n == a else a, c)\n        m += 1\n\nn = int(input())\nresult = find_pythagorean_triple(n)\nif result == -1:\n    print(-1)\nelse:\n    print(*result)"}
{"solution": "def are_remainders_distinct(n, k):\n    remainders = set()\n    for i in range(1, k + 1):\n        remainder = n % i\n        if remainder in remainders:\n            return False\n        remainders.add(remainder)\n    return True\n\nn, k = map(int, input().split())\nif are_remainders_distinct(n, k):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "# Fast input/output methods\nimport sys\nread_input = sys.stdin.readline\nwrite_output = sys.stdout.write\n\n# Read the input numbers\na = read_input().strip()\nb = read_input().strip()\n\n# Compare the lengths of the numbers\nif len(a) < len(b):\n    write_output(\"<\")\nelif len(a) > len(b):\n    write_output(\">\")\nelse:\n    # Compare the numbers digit by digit from left to right\n    for i in range(len(a)):\n        if a[i] < b[i]:\n            write_output(\"<\")\n            break\n        elif a[i] > b[i]:\n            write_output(\">\")\n            break\n    else:\n        write_output(\"=\")"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(n, p, colors):\n    # dp[i][j][k] is the number of ways to put arrows and color pieces\n    # such that the score has parity k and the last piece has color j\n    dp = [[[0, 0] for _ in range(2)] for _ in range(n + 1)]\n\n    # Base case: no pieces\n    dp[0][0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(2):\n            for k in range(2):\n                # If the current piece is already colored, skip it\n                if colors[i - 1] != -1 and colors[i - 1] != j:\n                    continue\n\n                # Try putting an arrow from the current piece to a later piece\n                for l in range(i + 1, n + 1):\n                    # If the target piece is already colored, skip it\n                    if colors[l - 1] != -1 and colors[l - 1] == j:\n                        continue\n\n                    # Update the number of ways to put arrows and color pieces\n                    dp[l][j ^ 1][k] = (dp[l][j ^ 1][k] + dp[i][j][k]) % MOD\n\n    # Return the number of ways to put arrows and color pieces such that the score has parity p\n    return sum(dp[n][j][p] for j in range(2)) % MOD\n\ndef main():\n    n, p = map(int, input().split())\n    colors = list(map(int, input().split()))\n    print(solve(n, p, colors))\n\nif __name__ == '__main__':\n    main()"}
{"solution": "def min_cost(n, a, b, c):\n    # Calculate the number of copybooks Alyona needs to buy\n    k = (4 - n % 4) % 4\n\n    # Calculate the cost of buying k copybooks\n    cost = 0\n    if k >= 3:\n        cost += c\n        k -= 3\n    if k >= 2:\n        cost += b\n        k -= 2\n    if k >= 1:\n        cost += a\n\n    return cost\n\n# Read the input\nn, a, b, c = map(int, input().split())\n\n# Print the minimum cost\nprint(min_cost(n, a, b, c))"}
{"solution": "import sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(node, visited, stack, graph):\n    visited[node] = True\n    stack[node] = True\n\n    for neighbor in graph[node]:\n        if not visited[neighbor] and dfs(neighbor, visited, stack, graph):\n            return True\n        elif stack[neighbor]:\n            return True\n\n    stack[node] = False\n    return False\n\ndef is_cyclic(graph):\n    visited = [False] * len(graph)\n    stack = [False] * len(graph)\n\n    for node in range(len(graph)):\n        if not visited[node] and dfs(node, visited, stack, graph):\n            return True\n\n    return False\n\ndef make_acyclic(graph, edges):\n    for edge in edges:\n        graph[edge[0]].remove(edge[1])\n        if not is_cyclic(graph):\n            return True\n        graph[edge[0]].add(edge[1])\n\n    return False\n\nn, m = map(int, input().split())\ngraph = [set() for _ in range(n)]\nedges = []\n\nfor _ in range(m):\n    u, v = map(int, input().split())\n    graph[u-1].add(v-1)\n    edges.append((u-1, v-1))\n\nif make_acyclic(graph, edges):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def min_coins(n, m, antennas):\n    antennas.sort()\n    coins = 0\n    i = 0\n    right = 0\n    while i < n:\n        if antennas[i][0] - antennas[i][1] > right + 1:\n            return -1\n        j = i\n        while j < n and antennas[j][0] <= right + 1:\n            right = max(right, antennas[j][0] + antennas[j][1])\n            j += 1\n        if right >= m:\n            return coins\n        coins += antennas[j - 1][0] - antennas[i][0] + min(antennas[j - 1][1], antennas[j][0] - antennas[i][0])\n        right += antennas[j - 1][1] + 1\n        i = j\n    return coins\n\nn, m = map(int, input().split())\nantennas = [list(map(int, input().split())) for _ in range(n)]\nprint(min_coins(n, m, antennas))"}
{"solution": "def max_weight_subset(W, cnt):\n    # Initialize a list to store the maximum weight of a good subset for each possible weight\n    dp = [0] * (W + 1)\n\n    # Iterate over each possible weight\n    for i in range(1, 9):\n        # Iterate over each possible number of items with weight i\n        for j in range(cnt[i - 1] + 1):\n            # Iterate over each possible weight from W to i * j\n            for k in range(W, i * j - 1, -1):\n                # Update the maximum weight of a good subset for weight k\n                dp[k] = max(dp[k], dp[k - i * j] + i * j)\n\n    # Return the maximum weight of a good subset\n    return dp[W]\n\n# Read the input\nW = int(input())\ncnt = list(map(int, input().split()))\n\n# Print the output\nprint(max_weight_subset(W, cnt))"}
{"solution": "def min_cost(n, L, costs):\n    # Initialize a list to store the minimum cost for each possible amount of lemonade\n    dp = [float('inf')] * (L + 1)\n    dp[0] = 0\n\n    # Iterate over each type of bottle\n    for i in range(n):\n        # Calculate the volume of the current bottle\n        volume = 2 ** i - 1\n\n        # Iterate over each possible amount of lemonade\n        for j in range(L + 1):\n            # If it's possible to buy the current bottle, update the minimum cost\n            if j >= volume:\n                dp[j] = min(dp[j], dp[j - volume] + costs[i])\n\n    # Return the minimum cost to buy at least L liters of lemonade\n    return dp[L]\n\n# Read the input\nn, L = map(int, input().split())\ncosts = list(map(int, input().split()))\n\n# Print the minimum cost\nprint(min_cost(n, L, costs))"}
{"solution": "# Read the number of elements\nn = int(input())\n\n# Read the elements of the array\narr = list(map(int, input().split()))\n\n# Sort the array\narr.sort()\n\n# Initialize the mex value\nmex = 1\n\n# Iterate over the sorted array\nfor i in range(n):\n    # If the current element is equal to mex, increment mex\n    if arr[i] == mex:\n        mex += 1\n\n# Print the maximum possible value of mex\nprint(mex)"}
{"solution": "# Read in the number of digits in the ticket and the ticket itself\nn = int(input())\nticket = input()\n\n# Calculate the sum of all the digits in the ticket\ntotal_sum = sum(int(digit) for digit in ticket)\n\n# If the sum is not divisible by 2, output \"NO\" and exit\nif total_sum % 2 != 0:\n    print(\"NO\")\nelse:\n    # Iterate through the ticket, keeping track of the sum of the digits in the current segment\n    current_sum = 0\n    for digit in ticket:\n        current_sum += int(digit)\n        # If the sum of the current segment is equal to half the sum of all the digits, start a new segment\n        if current_sum == total_sum // 2:\n            current_sum = 0\n    # If it is possible to divide the ticket into segments with equal sums, output \"YES\". Otherwise, output \"NO\".\n    if current_sum == 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "def determine_gender(username):\n    distinct_chars = set(username)\n    if len(distinct_chars) % 2 == 0:\n        return \"IGNORE HIM!\"\n    else:\n        return \"CHAT WITH HER!\"\n\n# Test the function with the provided examples\nprint(determine_gender(\"wjmzbmr\"))  # Expected output: \"CHAT WITH HER!\"\nprint(determine_gender(\"xiaodao\"))  # Expected output: \"IGNORE HIM!\"\nprint(determine_gender(\"sevenkplus\"))  # Expected output: \"CHAT WITH HER!\""}
{"solution": "# Read input\nn, k = map(int, input().split())\ntabs = list(map(int, input().split()))\n\n# Initialize max_diff\nmax_diff = 0\n\n# Iterate over all possible starting points\nfor b in range(1, n + 1):\n    # Initialize counts of test and social tabs\n    e, s = 0, 0\n\n    # Iterate over all tabs\n    for i in range(n):\n        # If tab is not closed\n        if (i + 1 - b) % k != 0:\n            # If tab contains test info\n            if tabs[i] == 1:\n                e += 1\n            # If tab contains social network\n            else:\n                s += 1\n\n    # Update max_diff\n    max_diff = max(max_diff, abs(e - s))\n\n# Print result\nprint(max_diff)"}
{"solution": "# Get the input\nn, c0, c1 = map(int, input().split())\n\n# Calculate the minimum cost\nmin_cost = 0\nbits = 1\nwhile n > 0:\n    # Calculate the number of letters that can be represented with 'bits' bits\n    letters = min(n, 2**bits)\n    # Add the cost of these letters to the minimum cost\n    min_cost += letters * (bits * c1 + (n - letters) * c0)\n    # Update the number of remaining letters\n    n -= letters\n    # Move to the next bit length\n    bits += 1\n\n# Print the minimum cost\nprint(min_cost)"}
{"solution": "# Get the input\nn, a, x, b, y = map(int, input().split())\n\n# Initialize Daniel's and Vlad's positions\ndaniel_pos = a\nvlad_pos = b\n\n# Loop through the time\nfor _ in range(2 * n):\n    # Check if Daniel and Vlad are at the same station\n    if daniel_pos == vlad_pos:\n        print(\"YES\")\n        break\n\n    # Move Daniel and Vlad to their next stations\n    daniel_pos = daniel_pos % n + 1\n    vlad_pos = vlad_pos - 1 if vlad_pos > 1 else n\n\n# If Daniel and Vlad never meet\nelse:\n    print(\"NO\")"}
{"solution": "def generate_powers(base, limit):\n    powers = set()\n    power = 1\n    while power <= limit:\n        powers.add(power)\n        power *= base\n    return powers\n\ndef find_max_golden_age(x, y, l, r):\n    x_powers = generate_powers(x, r)\n    y_powers = generate_powers(y, r)\n\n    unlucky_years = set()\n    for x_power in x_powers:\n        for y_power in y_powers:\n            if l <= x_power + y_power <= r:\n                unlucky_years.add(x_power + y_power)\n\n    unlucky_years = sorted(list(unlucky_years))\n\n    max_golden_age = 0\n    prev_year = l - 1\n    for year in unlucky_years:\n        max_golden_age = max(max_golden_age, year - prev_year - 1)\n        prev_year = year\n\n    max_golden_age = max(max_golden_age, r - prev_year)\n\n    return max_golden_age\n\nx, y, l, r = map(int, input().split())\nprint(find_max_golden_age(x, y, l, r))"}
{"solution": "def max_divisor(n):\n    for i in range(n-1, 1, -1):\n        if n % i == 0:\n            return i\n\ndef min_tax(n):\n    if n == 2:\n        return 1\n    elif n % 2 == 0:\n        return 2\n    else:\n        return max_divisor(n)\n\nn = int(input())\nprint(min_tax(n))"}
{"solution": "def check_typo(word):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    consonant_count = 0\n    for i in range(len(word)):\n        if word[i] not in vowels:\n            consonant_count += 1\n            if consonant_count >= 3 and i > 1 and word[i] != word[i-1] and word[i-1] != word[i-2]:\n                return True\n        else:\n            consonant_count = 0\n    return False\n\ndef fix_typo(word):\n    if not check_typo(word):\n        return word\n    else:\n        vowels = ['a', 'i', 'e', 'o', 'u']\n        consonant_count = 0\n        for i in range(len(word)):\n            if word[i] not in vowels:\n                consonant_count += 1\n                if consonant_count >= 3 and i > 1 and word[i] != word[i-1] and word[i-1] != word[i-2]:\n                    return fix_typo(word[:i-1]) + ' ' + fix_typo(word[i-1:])\n            else:\n                consonant_count = 0\n\nword = input()\nprint(fix_typo(word))"}
{"solution": "import sys\n\ndef min_time_to_prepare_potions():\n    n, m, k = map(int, sys.stdin.readline().split())\n    x, s = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n    c = list(map(int, sys.stdin.readline().split()))\n    d = list(map(int, sys.stdin.readline().split()))\n\n    # Initialize the minimum time to prepare n potions without using any spells\n    min_time = n * x\n\n    # Try using each spell of the first type\n    for i in range(m):\n        if b[i] <= s:\n            # Calculate the time required to prepare n potions using this spell\n            time = n * a[i]\n            # Try using each spell of the second type\n            for j in range(k):\n                if b[i] + d[j] <= s:\n                    # Calculate the time required to prepare n potions using both spells\n                    time = min(time, (n - c[j]) * a[i])\n            # Update the minimum time\n            min_time = min(min_time, time)\n\n    # Try using each spell of the second type\n    for i in range(k):\n        if d[i] <= s:\n            # Calculate the time required to prepare n potions using this spell\n            time = 0 if n <= c[i] else (n - c[i]) * x\n            # Update the minimum time\n            min_time = min(min_time, time)\n\n    print(min_time)\n\nmin_time_to_prepare_potions()"}
{"solution": "def max_points(n, k, M, t):\n    # Sort the subtasks in ascending order of time required to solve\n    t.sort()\n\n    # Initialize the maximum number of points to 0\n    max_points = 0\n\n    # Loop through all possible number of tasks that Polycarp can complete\n    for i in range(min(n, M // k) + 1):\n        # Calculate the time required to solve i tasks completely\n        time_required = i * k * t[0]\n\n        # Calculate the remaining time available\n        remaining_time = M - time_required\n\n        # Calculate the number of additional subtasks that Polycarp can solve\n        additional_subtasks = remaining_time // t[1]\n\n        # Calculate the total number of points that Polycarp can earn\n        total_points = i * (k + 1) + additional_subtasks\n\n        # Update the maximum number of points\n        max_points = max(max_points, total_points)\n\n    return max_points\n\n# Read the input\nn, k, M = map(int, input().split())\nt = list(map(int, input().split()))\n\n# Print the maximum number of points that Polycarp can earn\nprint(max_points(n, k, M, t))"}
{"solution": "MOD = 998244353\n\ndef main():\n    n = int(input())\n    if n % 2 == 0:\n        print(0)\n        return\n\n    fact = [1]\n    inv_fact = [1]\n    for i in range(1, n + 1):\n        fact.append(fact[-1] * i % MOD)\n        inv_fact.append(pow(fact[-1], MOD - 2, MOD))\n\n    def C(n, k):\n        if k < 0 or k > n:\n            return 0\n        return fact[n] * inv_fact[k] * inv_fact[n - k] % MOD\n\n    def S(n, k):\n        return C(n, k) * fact[k] % MOD\n\n    def f(n):\n        if n == 1:\n            return 1\n        if n % 2 == 0:\n            return 0\n        return (S(n - 1, (n - 1) // 2) - S(n - 1, (n - 3) // 2)) % MOD\n\n    print(f(n))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_position(n, m, k):\n    # Lara moves down n-1 cells initially\n    if k < n - 1:\n        return k + 1, 1\n    k -= n - 1\n\n    # Lara then moves in a snake-like pattern\n    # Calculate the number of full cycles she has made\n    cycle_length = 2 * m - 1\n    cycles = k // cycle_length\n    k %= cycle_length\n\n    # Calculate Lara's position within the current cycle\n    if k < m - 1:\n        # She moves right\n        return n - (cycles % 2 * (n - 1)), k + 1\n    elif k == m - 1:\n        # She moves up\n        return n - ((cycles + 1) % 2 * (n - 1)), m\n    else:\n        # She moves left\n        return n - ((cycles + 1) % 2 * (n - 1)), m - (k - (m - 1))\n\nn, m, k = map(int, input().split())\nrow, col = find_position(n, m, k)\nprint(row, col)"}
{"solution": "import math\n\ndef find_divisors(x):\n    divisors = []\n    for i in range(1, int(math.sqrt(x)) + 1):\n        if x % i == 0:\n            divisors.append((i, x // i))\n    return divisors\n\ndef find_min_max(x):\n    divisors = find_divisors(x)\n    if not divisors:\n        return (1, x)\n    else:\n        return max(divisors)\n\nx = int(input())\na, b = find_min_max(x)\nprint(a, b)"}
{"solution": "# Get the input\na = int(input())\nb = int(input())\nc = int(input())\n\n# Calculate the maximum number of lemons that can be used\nlemons = min(a, b // 2, c // 4)\n\n# Calculate the maximum total number of fruits that can be used\ntotal_fruits = lemons * (1 + 2 + 4)\n\n# Print the result\nprint(total_fruits)"}
{"solution": "# Read the number of players in each team\nn = int(input())\n\n# Read the ratings of all players\nratings = list(map(int, input().split()))\n\n# Sort the ratings in descending order\nratings.sort(reverse=True)\n\n# Check if it's possible to divide the players into two teams\n# such that the first team always wins, regardless of the drawing\nfor i in range(n):\n    if ratings[i] <= ratings[n + i]:\n        print(\"NO\")\n        break\nelse:\n    print(\"YES\")"}
{"solution": "import math\n\ndef is_coprime(a, b):\n    return math.gcd(a, b) == 1\n\ndef make_coprime(arr):\n    insertions = 0\n    new_arr = [arr[0]]\n\n    for i in range(1, len(arr)):\n        if not is_coprime(new_arr[-1], arr[i]):\n            for j in range(2, min(arr[i-1], arr[i]) + 1):\n                if is_coprime(new_arr[-1], j) and is_coprime(j, arr[i]):\n                    new_arr.append(j)\n                    insertions += 1\n                    break\n        new_arr.append(arr[i])\n\n    return insertions, new_arr\n\nn = int(input())\narr = list(map(int, input().split()))\n\ninsertions, new_arr = make_coprime(arr)\nprint(insertions)\nprint(' '.join(map(str, new_arr)))"}
{"solution": "import math\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculate total sum and min/max values\ntotal_sum = sum(a)\nmin_val = min(a)\nmax_val = max(a)\n\n# Calculate range of possible divisors\ndivisor_range = range(1, math.gcd(total_sum, k) + 1)\n\n# Iterate through possible divisors in reverse order\nfor divisor in reversed(divisor_range):\n    # Calculate adjusted values\n    adjusted_values = [val % divisor for val in a]\n\n    # Check if all adjusted values can be made equal\n    if max(adjusted_values) - min(adjusted_values) <= k:\n        print(divisor)\n        break"}
{"solution": "def cat_furrier_transform(x):\n    operations = []\n    n = 0\n    while x != (2**n - 1) and len(operations) < 40:\n        x = x ^ (2**n - 1)\n        operations.append(n)\n        if len(operations) < 40:\n            x += 1\n            n += 1\n    return operations\n\nx = int(input())\noperations = cat_furrier_transform(x)\nprint(len(operations))\nfor i in range(0, len(operations), 2):\n    print(operations[i], end=' ')"}
{"solution": "# Get the input\nn, k = map(int, input().split())\nbuckets = list(map(int, input().split()))\n\n# Find the maximum watering capacity of the buckets\nmax_capacity = max(buckets)\n\n# Calculate the minimum number of hours needed to water the garden\nmin_hours = k // max_capacity\n\n# If the garden length is not a multiple of the maximum capacity, add one more hour\nif k % max_capacity != 0:\n    min_hours += 1\n\n# Print the result\nprint(min_hours)"}
{"solution": "def can_reach_insect(n, k, line):\n    # Find the positions of the grasshopper and the insect\n    g_pos = line.index('G')\n    t_pos = line.index('T')\n\n    # If the grasshopper is to the right of the insect, swap their positions\n    if g_pos > t_pos:\n        g_pos, t_pos = t_pos, g_pos\n\n    # Check if the grasshopper can reach the insect in one jump\n    if (t_pos - g_pos) % k == 0:\n        # Check if there are no obstacles in the way\n        for i in range(g_pos + k, t_pos, k):\n            if line[i] == '#':\n                return False\n        return True\n    else:\n        return False\n\n# Read the input\nn, k = map(int, input().split())\nline = input()\n\n# Print the result\nif can_reach_insect(n, k, line):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def calculate_x_coordinate(y1, y2, yw, xb, yb, r):\n    # Calculate the slope of the line from the ball to the goal\n    m = (y2 - y1) / (0 - xb)\n\n    # Calculate the y-intercept of the line from the ball to the goal\n    b = yb - m * xb\n\n    # Calculate the y-coordinate of the point where the ball hits the wall\n    y_hit = yw - r\n\n    # Calculate the x-coordinate of the point where the ball hits the wall\n    x_hit = (y_hit - b) / m\n\n    # Check if the ball will hit the goal after bouncing off the wall\n    if y1 <= y_hit + r <= y2:\n        return x_hit\n    else:\n        return -1\n\n# Get the input values\ny1, y2, yw, xb, yb, r = map(int, input().split())\n\n# Calculate the x-coordinate of the point to aim for\nx_coordinate = calculate_x_coordinate(y1, y2, yw, xb, yb, r)\n\n# Print the result\nprint(x_coordinate)"}
{"solution": "# Get the input values\nb, d, s = map(int, input().split())\n\n# Calculate the minimum number of meals Vasiliy could have missed\nmin_missed_meals = max(0, b + d + s - 2 * max(b, d, s) + 1)\n\n# Print the result\nprint(min_missed_meals)"}
{"solution": "def find_matrix_dimensions(n, path):\n    x, y = 1, 1\n    current_position = (1, 1)\n    visited = set()\n    visited.add(current_position)\n\n    for i in range(1, n):\n        current_value = path[i]\n        previous_value = path[i - 1]\n        diff = current_value - previous_value\n\n        if diff == 1:\n            if current_position[1] < y:\n                current_position = (current_position[0], current_position[1] + 1)\n            else:\n                x += 1\n                current_position = (current_position[0] + 1, current_position[1])\n        elif diff == -1:\n            if current_position[1] > 1:\n                current_position = (current_position[0], current_position[1] - 1)\n            else:\n                x += 1\n                current_position = (current_position[0] + 1, current_position[1])\n        elif diff == y:\n            current_position = (current_position[0] + 1, current_position[1])\n        elif diff == -y:\n            current_position = (current_position[0] - 1, current_position[1])\n        else:\n            return \"NO\"\n\n        visited.add(current_position)\n\n    return \"YES\\n{} {}\".format(x, y)\n\nn = int(input())\npath = list(map(int, input().split()))\n\nprint(find_matrix_dimensions(n, path))"}
{"solution": "def min_chars_to_remove(a, b):\n    m, n = len(a), len(b)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if a[i - 1] == b[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    lcs_length = dp[m][n]\n    return n - lcs_length\n\ndef find_subsequence(a, b):\n    i, j = 0, 0\n    subsequence = ''\n\n    while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n            subsequence += a[i]\n            i += 1\n        j += 1\n\n    return subsequence\n\na = input()\nb = input()\n\nmin_chars_removed = min_chars_to_remove(a, b)\nsubsequence = find_subsequence(a, b)\n\nif len(subsequence) == 0:\n    print('-')\nelse:\n    print(subsequence)"}
{"solution": "# Read the input\nn = int(input())\ns = input()\n\n# Initialize the minimum number of stones in the pile\nmin_stones = 0\n\n# Initialize the current number of stones in the pile\ncurrent_stones = 0\n\n# Iterate over the operations\nfor i in range(n):\n    # If Vasya took a stone, decrease the current number of stones\n    if s[i] == '-':\n        current_stones -= 1\n    # If Vasya added a stone, increase the current number of stones\n    else:\n        current_stones += 1\n    # Update the minimum number of stones in the pile\n    min_stones = min(min_stones, current_stones)\n\n# Print the minimum number of stones in the pile\nprint(-min_stones)"}
{"solution": "# Get the input\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# Calculate the maximum number of liters of kefir Kolya can drink\n# by buying plastic bottles\nplastic_bottles = n // a\n\n# Calculate the maximum number of liters of kefir Kolya can drink\n# by buying glass bottles and returning them for refund\nglass_bottles = 0\nif b - c > a:\n    # It's not optimal to buy glass bottles\n    max_glass_bottles = n // a\nelse:\n    # Kolya can buy a glass bottle, return it and buy a plastic bottle\n    max_glass_bottles = n // (b - c)\n    # Calculate how many plastic bottles Kolya can buy with the remaining money\n    remaining_money = n % (b - c)\n    plastic_bottles_from_refund = remaining_money // a\n    # The total number of glass bottles Kolya can buy is the maximum number of glass bottles\n    # he can buy without considering plastic bottles plus the number of glass bottles\n    # he can buy by returning them for refund\n    glass_bottles = min(n // b, max_glass_bottles + plastic_bottles_from_refund)\n\n# The total number of liters of kefir Kolya can drink is the maximum number of liters\n# he can drink by buying plastic bottles plus the maximum number of liters he can drink\n# by buying glass bottles and returning them for refund\ntotal_liters = plastic_bottles + glass_bottles\nprint(total_liters)"}
{"solution": "def card_game(n, k1, deck1, k2, deck2):\n    fights = 0\n    while deck1 and deck2:\n        card1 = deck1.pop(0)\n        card2 = deck2.pop(0)\n        if card1 > card2:\n            deck1.extend([card2, card1])\n        else:\n            deck2.extend([card1, card2])\n        fights += 1\n        if fights > 10000:\n            return -1, -1\n    if deck1:\n        return fights, 1\n    else:\n        return fights, 2\n\nn = int(input())\nk1 = int(input())\ndeck1 = list(map(int, input().split()))\nk2 = int(input())\ndeck2 = list(map(int, input().split()))\n\nfights, winner = card_game(n, k1, deck1, k2, deck2)\n\nif fights == -1:\n    print(-1)\nelse:\n    print(fights, winner)"}
{"solution": "def check_password(password):\n    if len(password) < 5:\n        return False\n    if not any(char.isupper() for char in password):\n        return False\n    if not any(char.islower() for char in password):\n        return False\n    if not any(char.isdigit() for char in password):\n        return False\n    return True\n\npassword = input()\nif check_password(password):\n    print(\"Correct\")\nelse:\n    print(\"Too weak\")"}
{"solution": "n = int(input())\ngroup_a = list(map(int, input().split()))\ngroup_b = list(map(int, input().split()))\n\n# Count the number of students with each academic performance in both groups\ncount_a = [0] * 6\ncount_b = [0] * 6\nfor i in range(n):\n    count_a[group_a[i]] += 1\n    count_b[group_b[i]] += 1\n\n# Calculate the minimum number of exchanges required for each academic performance\nexchanges = 0\nfor i in range(1, 6):\n    diff = abs(count_a[i] - count_b[i])\n    if diff % 2 == 1:\n        print(-1)\n        exit()\n    exchanges += diff // 2\n\nprint(exchanges)"}
{"solution": "import sys\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    horizontal = sys.stdin.readline().strip()\n    vertical = sys.stdin.readline().strip()\n\n    graph = [[] for _ in range(n * m)]\n\n    for i in range(n):\n        for j in range(m - 1):\n            if horizontal[i] == '<':\n                graph[i * m + j].append(i * m + j + 1)\n                graph[i * m + j + 1].append(i * m + j)\n            else:\n                graph[i * m + j + 1].append(i * m + j)\n                graph[i * m + j].append(i * m + j + 1)\n\n    for i in range(n - 1):\n        for j in range(m):\n            if vertical[j] == '^':\n                graph[i * m + j].append((i + 1) * m + j)\n                graph[(i + 1) * m + j].append(i * m + j)\n            else:\n                graph[(i + 1) * m + j].append(i * m + j)\n                graph[i * m + j].append((i + 1) * m + j)\n\n    def dfs(node, visited):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited)\n\n    for i in range(n * m):\n        visited = [False] * (n * m)\n        dfs(i, visited)\n        if not all(visited):\n            print(\"NO\")\n            return\n\n    print(\"YES\")\n\nsolve()"}
{"solution": "# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize result string\nresult = \"\"\n\n# Iterate over the input list\nfor i in range(n - 1):\n    # If current element is 1 and next element is 0, place brackets\n    if a[i] == 1 and a[i + 1] == 0:\n        result += \"(\" + str(a[i]) + \"->\" + str(a[i + 1]) + \")\"\n        # If there are more elements, add \"->\" after the bracket\n        if i < n - 2:\n            result += \"->\"\n    else:\n        # Otherwise, just add the elements and \"->\"\n        result += str(a[i]) + \"->\"\n\n# Add the last element to the result\nresult += str(a[-1])\n\n# Check if it's possible to place brackets so that the value of the expression is false\nif \"1->0\" in result:\n    print(\"YES\")\n    print(result)\nelse:\n    print(\"NO\")"}
{"solution": "def calculate_values(a, b):\n    while a != 0 and b != 0:\n        if a >= 2 * b:\n            a = a - 2 * b\n        elif b >= 2 * a:\n            b = b - 2 * a\n        else:\n            break\n    return a, b\n\nn, m = map(int, input().split())\nresult = calculate_values(n, m)\nprint(result[0], result[1])"}
{"solution": "def count_divisible_numbers(k, a, b):\n    # Calculate the number of multiples of k that are less than or equal to b\n    count_b = b // k\n\n    # Calculate the number of multiples of k that are less than a\n    count_a = (a - 1) // k\n\n    # The number of k-divisible numbers on the segment [a, b] is the difference between the two counts\n    return count_b - count_a\n\n# Read the input values\nk, a, b = map(int, input().split())\n\n# Print the result\nprint(count_divisible_numbers(k, a, b))"}
{"solution": "def find_kth_digit(k):\n    if k <= 9:\n        return k\n\n    count = 9\n    length = 1\n    while k > count * length:\n        k -= count * length\n        count *= 10\n        length += 1\n\n    start_number = 10 ** (length - 1)\n    block_number = (k - 1) // length\n    digit_number = (k - 1) % length\n\n    return int(str(start_number + block_number)[digit_number])\n\nk = int(input())\nprint(find_kth_digit(k))"}
{"solution": "n = int(input())\ns = input()\n\n# Count the number of '8's in the first 10 positions\ncount_eight = s[:10].count('8')\n\n# If there is at least one '8' in the first 10 positions, Vasya can win\nif count_eight > 0:\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(n, x, pos):\n    # dp[i][j][k] is the number of permutations of length i\n    # such that the number x is at position j and the binary\n    # search algorithm finds x in the first k elements\n    dp = [[[0] * (n + 1) for _ in range(n)] for _ in range(n + 1)]\n    dp[0][0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            for k in range(i + 1):\n                # Place the number x at position j\n                if j == pos:\n                    dp[i][j][k] = (dp[i - 1][j][k] * (i - 1)) % MOD\n                    if k > 0:\n                        dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j][k - 1]) % MOD\n                # Place a number other than x at position j\n                else:\n                    dp[i][j][k] = (dp[i - 1][j][k] * (i - 1)) % MOD\n                    if k > 0 and j < pos:\n                        dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j][k - 1]) % MOD\n\n    return dp[n][pos][n]\n\nn, x, pos = map(int, input().split())\nprint(solve(n, x, pos))"}
{"solution": "def decrypt_message(s, k):\n    def backtrack(i, curr_len, curr_msg):\n        if curr_len > k:\n            return False\n        if i == len(s):\n            return curr_len == k\n        if s[i] == '?':\n            if backtrack(i + 1, curr_len, curr_msg):\n                return True\n            if curr_len < k:\n                curr_msg.append(curr_msg[-1])\n                if backtrack(i + 1, curr_len + 1, curr_msg):\n                    return True\n                curr_msg.pop()\n        elif s[i] == '*':\n            if backtrack(i + 1, curr_len, curr_msg):\n                return True\n            while curr_len < k:\n                curr_msg.append(curr_msg[-1])\n                curr_len += 1\n                if backtrack(i + 1, curr_len, curr_msg):\n                    return True\n            while curr_len > k:\n                curr_msg.pop()\n                curr_len -= 1\n        else:\n            if curr_len < k:\n                curr_msg.append(s[i])\n                if backtrack(i + 1, curr_len + 1, curr_msg):\n                    return True\n                curr_msg.pop()\n        return False\n\n    msg = []\n    if backtrack(0, 0, msg):\n        return ''.join(msg)\n    else:\n        return 'Impossible'\n\ns = input()\nk = int(input())\nprint(decrypt_message(s, k))"}
{"solution": "def min_turns(angle):\n    # Normalize the angle to be between 0 and 360\n    angle = angle % 360\n\n    # If the angle is negative, convert it to positive\n    if angle < 0:\n        angle += 360\n\n    # Calculate the minimum number of 90 degree turns needed\n    turns = min(angle % 90, 90 - angle % 90)\n\n    # If the angle is less than 90 or between 270 and 360, no turns are needed\n    if angle < 90 or angle >= 270:\n        return 0\n    # If the angle is between 90 and 180, one turn is needed\n    elif angle < 180:\n        return 1\n    # If the angle is between 180 and 270, two turns are needed\n    else:\n        return 2\n\n# Get the camera angle from the user\nangle = int(input())\n\n# Print the minimum number of 90 degree turns needed\nprint(min_turns(angle))"}
{"solution": "# Get the input\na, b, c = map(int, input().split())\nx, y, z = map(int, input().split())\n\n# Calculate the difference between the required and available spheres\ndiff_blue = a - x\ndiff_violet = b - y\ndiff_orange = c - z\n\n# Check if it's possible to obtain the required numbers of spheres\nif diff_blue >= 0 and diff_violet >= 0 and diff_orange >= 0:\n    # Check if the difference can be made up by transforming spheres\n    if diff_blue + diff_violet >= diff_orange and diff_blue + diff_orange >= diff_violet and diff_violet + diff_orange >= diff_blue:\n        print(\"Yes\")\n    else:\n        print(\"No\")\nelse:\n    print(\"No\")"}
{"solution": "def solve(n, k, m):\n    dp = [[0] * k for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(k):\n            for d in range(10):\n                dp[i][(j * 10 + d) % k] = (dp[i][(j * 10 + d) % k] + dp[i - 1][j]) % m\n    return dp[n][0]\n\nn, k, m = map(int, input().split())\nprint(solve(n, k, m))"}
{"solution": "# Get the input\nl, r, a = map(int, input().split())\n\n# Calculate the minimum number of left-handers and right-handers\nmin_lr = min(l, r)\n\n# Calculate the maximum number of ambidexters that can be used\nmax_a = min(l + r - min_lr, a)\n\n# Calculate the maximum possible size of the team\nteam_size = 2 * (min_lr + max_a)\n\n# Print the result\nprint(team_size)"}
{"solution": "def min_moves(n, k):\n    # Initialize the minimum moves to 0\n    moves = 0\n\n    # Throw stones to the leftmost manhole\n    moves += (k - 1) * 2\n\n    # Open the leftmost manhole and pick the coin\n    moves += 1\n\n    # Throw stones to the rightmost manhole\n    moves += (n - k) * 2\n\n    # Open the rightmost manhole and pick the coin\n    moves += 1\n\n    # Throw stones from the rightmost manhole to the leftmost manhole\n    moves += (n - 2) * 2\n\n    # Open the leftmost manhole and pick the coin\n    moves += 1\n\n    # Repeat the process for the remaining manholes\n    for i in range(2, n):\n        # Throw stones from the current manhole to the leftmost manhole\n        moves += (i - 1) * 2\n\n        # Open the current manhole and pick the coin\n        moves += 1\n\n        # Throw stones from the current manhole to the rightmost manhole\n        moves += (n - i - 1) * 2\n\n        # Open the rightmost manhole and pick the coin\n        moves += 1\n\n        # Throw stones from the rightmost manhole to the current manhole\n        moves += (n - i - 1) * 2\n\n    return moves\n\n# Read the input\nn, k = map(int, input().split())\n\n# Print the minimum number of moves\nprint(min_moves(n, k))"}
{"solution": "def min_tower_height(n, m):\n    # Calculate the maximum number of blocks each type of student could use\n    max_two_blocks = n * 2\n    max_three_blocks = m * 3\n\n    # Initialize the minimum possible height of the tallest tower\n    min_height = max(max_two_blocks, max_three_blocks)\n\n    # If there are students using both types of pieces, we need to consider\n    # the possibility of creating a duplicate tower by combining the pieces\n    # of both types\n    if n > 0 and m > 0:\n        # Calculate the number of additional blocks needed to avoid creating\n        # a duplicate tower\n        additional_blocks = min(n, m)\n        min_height += additional_blocks\n\n    return min_height\n\n# Read the input\nn, m = map(int, input().split())\n\n# Print the minimum possible height of the tallest tower\nprint(min_tower_height(n, m))"}
{"solution": "from collections import Counter\n\n# Get the number of cards\nn = int(input())\n\n# Get the numbers on the cards\ncards = [int(input()) for _ in range(n)]\n\n# Count the frequency of each number\nfreq = Counter(cards)\n\n# Check if there are two numbers with frequency n/2\nfor num, count in freq.items():\n    if count == n // 2 and cards.count(num) == n // 2:\n        # Remove the chosen numbers from the list\n        cards.remove(num)\n        cards.remove(num)\n        # Print the result\n        print(\"YES\")\n        print(num, cards[0])\n        break\nelse:\n    # Print the result\n    print(\"NO\")"}
{"solution": "def can_arrange_soldiers(n, k, soldiers):\n    # Calculate the total number of soldiers\n    total_soldiers = sum(soldiers)\n\n    # If the total number of soldiers is greater than the total number of seats, return False\n    if total_soldiers > 8 * n:\n        return False\n\n    # Sort the soldiers in descending order\n    soldiers.sort(reverse=True)\n\n    # Initialize a list to represent the seats in the airplane\n    seats = [0] * (8 * n)\n\n    # Iterate through the soldiers\n    for soldier in soldiers:\n        # Initialize a variable to keep track of the number of seats assigned to the current soldier\n        seats_assigned = 0\n\n        # Iterate through the seats\n        for i in range(len(seats)):\n            # If the current seat is empty and it is not a neighbor of a seat assigned to a different soldier, assign it to the current soldier\n            if seats[i] == 0 and (i % 8 == 0 or seats[i - 1] == 0) and (i % 8 == 7 or seats[i + 1] == 0):\n                seats[i] = 1\n                seats_assigned += 1\n\n            # If the number of seats assigned to the current soldier is equal to the number of soldiers in the current group, break the loop\n            if seats_assigned == soldier:\n                break\n\n        # If the number of seats assigned to the current soldier is less than the number of soldiers in the current group, return False\n        if seats_assigned < soldier:\n            return False\n\n    # If all soldiers have been assigned a seat, return True\n    return True\n\n# Read the input\nn, k = map(int, input().split())\nsoldiers = list(map(int, input().split()))\n\n# Check if it is possible to arrange the soldiers\nif can_arrange_soldiers(n, k, soldiers):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n = int(input())\nsticks = list(map(int, input().split()))\n\nsticks.sort()\n\nmin_cost = float('inf')\noptimal_t = 0\n\nfor t in range(1, 101):\n    cost = 0\n    for stick in sticks:\n        if abs(stick - t) > 1:\n            cost += abs(stick - t) - 1\n    if cost < min_cost:\n        min_cost = cost\n        optimal_t = t\n\nprint(optimal_t, min_cost)"}
{"solution": "# Read input\nn, m = map(int, input().split())\nsky_map = [input() for _ in range(n)]\n\n# Find the boundaries of the stars\nmin_row, max_row, min_col, max_col = n, 0, m, 0\nfor i in range(n):\n    for j in range(m):\n        if sky_map[i][j] == '*':\n            min_row = min(min_row, i)\n            max_row = max(max_row, i)\n            min_col = min(min_col, j)\n            max_col = max(max_col, j)\n\n# Calculate the side length of the square\nside_length = max(max_row - min_row + 1, max_col - min_col + 1)\n\n# Print the result\nprint(side_length)"}
{"solution": "import sys\nfrom functools import lru_cache\n\nMOD = 10**9 + 7\n\n@lru_cache(maxsize=None)\ndef inv(n):\n    return pow(n, MOD - 2, MOD)\n\n@lru_cache(maxsize=None)\ndef comb(n, k):\n    if k > n:\n        return 0\n    return fac[n] * ifac[k] * ifac[n - k] % MOD\n\ndef solve(n, k, a):\n    zeros = a.count(0)\n    ones = n - zeros\n    if k >= zeros * ones:\n        return 0\n    fac = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fac[i] = fac[i - 1] * i % MOD\n    ifac = [1] * (n + 1)\n    ifac[n] = pow(fac[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        ifac[i - 1] = ifac[i] * i % MOD\n    ans = 0\n    for i in range(zeros + 1):\n        for j in range(ones + 1):\n            if i * j > k or (zeros - i) * (ones - j) > k:\n                continue\n            ans = (ans + comb(zeros, i) * comb(ones, j) % MOD) % MOD\n    return ans * inv(comb(n, zeros)) % MOD\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    print(solve(n, k, a))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef min_steps(x, y):\n    if x == y:\n        return 0\n    elif x % y == 0:\n        return math.ceil(math.log(x // y, 2))\n    else:\n        gcd = math.gcd(x, y)\n        return 1 + min_steps(x // gcd, y)\n\nx, y = map(int, input().split())\nprint(min_steps(x, y))"}
{"solution": "# Read the input matrix A\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Calculate the determinant of matrix A\ndet_A = a * d - b * c\n\n# If matrix A is degenerate\nif det_A == 0:\n    # Calculate the average value of the elements in matrix A\n    avg = (a + b + c + d) / 4\n    # Create matrix B with all elements equal to the average value\n    B = [[avg, avg], [avg, avg]]\n# If matrix A is not degenerate\nelse:\n    # Create matrix B such that its determinant is zero\n    # and the difference between A and B is minimized\n    B = [[a, b], [c, d]]\n    if a != 0:\n        B[0][0] = -(b * B[1][1] - c * B[1][0]) / a\n    elif b != 0:\n        B[0][1] = -(a * B[1][1] - c * B[1][0]) / b\n    elif c != 0:\n        B[1][0] = -(a * B[0][1] - b * B[0][0]) / c\n    elif d != 0:\n        B[1][1] = -(a * B[0][1] - b * B[0][0]) / d\n\n# Calculate the norm ||A - B||\nnorm = max(abs(A[0][0] - B[0][0]), abs(A[0][1] - B[0][1]), abs(A[1][0] - B[1][0]), abs(A[1][1] - B[1][1]))\n\n# Print the result\nprint(norm)"}
{"solution": "# Read input\nn, a, b = map(int, input().split())\ngroups = list(map(int, input().split()))\n\n# Initialize variables\ndenied_service = 0\none_seaters = a\ntwo_seaters = b\nsingle_at_two_seater = 0\n\n# Iterate over groups\nfor group in groups:\n    # If group is of one person\n    if group == 1:\n        # If there is a vacant one-seater table\n        if one_seaters > 0:\n            one_seaters -= 1\n        # If there is a vacant two-seater table\n        elif two_seaters > 0:\n            two_seaters -= 1\n            single_at_two_seater += 1\n        # If there is a single person at a two-seater table\n        elif single_at_two_seater > 0:\n            single_at_two_seater -= 1\n        # If none of the above, deny service\n        else:\n            denied_service += 1\n    # If group is of two persons\n    else:\n        # If there is a vacant two-seater table\n        if two_seaters > 0:\n            two_seaters -= 1\n        # If none of the above, deny service to both\n        else:\n            denied_service += 2\n\n# Print output\nprint(denied_service)"}
{"solution": "# Get input\nA, B, C, N = map(int, input().split())\n\n# Check if a valid solution exists\nif A + B - C > N or A + C > N or B + C > N or A + B - C < 1:\n    print(-1)\nelse:\n    # Calculate the number of students who did not pass the exam\n    not_passed = N - (A + B - C)\n    print(not_passed)"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(x, k):\n    # Base case: if there is only one month, the number of dresses does not change\n    if k == 0:\n        return x\n\n    # The number of dresses doubles each month\n    x = (x * 2) % MOD\n\n    # With 50% probability, the wardrobe eats one of the dresses, except for the last month\n    # So, we add 0.5 * x to the expected number of dresses for each month except the last one\n    expected_dresses = x\n    for _ in range(k - 1):\n        expected_dresses = (expected_dresses + x // 2) % MOD\n        x = (x * 2) % MOD\n\n    # For the last month, the number of dresses doubles, but the wardrobe does not eat any dresses\n    expected_dresses = (expected_dresses + x) % MOD\n\n    return expected_dresses\n\n# Read the input\nx, k = map(int, input().split())\n\n# Print the result\nprint(solve(x, k))"}
{"solution": "MOD = 998244353\n\ndef inverse(n):\n    return pow(n, MOD - 2, MOD)\n\ndef solve():\n    n = int(input())\n    intervals = [list(map(int, input().split())) for _ in range(n)]\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for l, r in intervals:\n        new_dp = [0] * (n + 1)\n        for i in range(l, n + 1):\n            new_dp[i] = (new_dp[i - 1] + dp[i - l]) % MOD\n        dp = new_dp\n    return (dp[n] * inverse(sum(dp)) % MOD) * inverse(pow(2, n, MOD)) % MOD\n\nprint(solve())"}
{"solution": "def count_ways(n):\n    # Initialize count of ways\n    count = 0\n\n    # Loop through all possible lengths of the first part\n    for i in range(1, n // 4 + 1):\n        # Loop through all possible lengths of the second part\n        for j in range(i, (n - i) // 3 + 1):\n            # Calculate the length of the third part\n            k = n - i - j\n            # Check if the lengths can form a rectangle but not a square\n            if i != j and i != k and j != k and i + j > k:\n                count += 1\n\n    return count\n\n# Read the input\nn = int(input())\n\n# Print the output\nprint(count_ways(n))"}
{"solution": "# Read input\nn, s = map(int, input().split())\nkegs = list(map(int, input().split()))\n\n# Sort the kegs in descending order\nkegs.sort(reverse=True)\n\n# Calculate the total volume of kvass in all kegs\ntotal_volume = sum(kegs)\n\n# Check if it's possible to pour s liters of kvass\nif total_volume < s:\n    print(-1)\nelse:\n    # Calculate the minimum possible volume of kvass in the least keg\n    min_volume = (total_volume - s) // (n - 1)\n\n    # Subtract the minimum possible volume from the least keg\n    kegs[-1] -= min_volume\n\n    # Print the remaining volume in the least keg\n    print(kegs[-1])"}
{"solution": "def days_to_apple(h1, h2, a, b):\n    # Initialize the current height of the caterpillar and the number of days\n    current_height = h1\n    days = 0\n\n    # Simulate the caterpillar's movement over time\n    while True:\n        # The caterpillar moves up by a cm per hour for 12 hours (day)\n        current_height += 12 * a\n\n        # If the caterpillar has reached the apple, return the number of days\n        if current_height >= h2:\n            return days\n\n        # The caterpillar slips down by b cm per hour for 12 hours (night)\n        current_height -= 12 * b\n\n        # If the caterpillar has slipped below the starting height, it can't reach the apple\n        if current_height < h1:\n            return -1\n\n        # Increment the number of days\n        days += 1\n\n# Read the input\nh1, h2 = map(int, input().split())\na, b = map(int, input().split())\n\n# Print the output\nprint(days_to_apple(h1, h2, a, b))"}
{"solution": "# Get the input\nC, Hr, Hb, Wr, Wb = map(int, input().split())\n\n# Calculate the maximum number of red and blue candies Om Nom can eat\nmax_red = C // Wr\nmax_blue = C // Wb\n\n# Calculate the maximum joy Om Nom can get from eating red candies\nmax_joy_red = max_red * Hr\n\n# Calculate the maximum joy Om Nom can get from eating blue candies\nmax_joy_blue = max_blue * Hb\n\n# Calculate the maximum joy Om Nom can get from eating both red and blue candies\nmax_joy = 0\nfor i in range(max_red + 1):\n    for j in range(max_blue + 1):\n        if i * Wr + j * Wb <= C:\n            joy = i * Hr + j * Hb\n            if joy > max_joy:\n                max_joy = joy\n\n# Print the maximum joy Om Nom can get\nprint(max_joy)"}
{"solution": "def min_steps_to_finish(x1, y1, x2, y2):\n    # Calculate the absolute difference between the start and finish positions\n    dx = abs(x2 - x1)\n    dy = abs(y2 - y1)\n\n    # The robot can move diagonally as many steps as the minimum of dx and dy\n    diagonal_steps = min(dx, dy)\n\n    # The remaining steps will be the maximum of dx and dy minus the diagonal steps\n    remaining_steps = max(dx, dy) - diagonal_steps\n\n    # The total number of steps is the sum of the diagonal steps and the remaining steps\n    total_steps = diagonal_steps + remaining_steps\n\n    return total_steps\n\n# Get the start and finish positions from the user\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\n\n# Print the minimal number of steps to get the finish position\nprint(min_steps_to_finish(x1, y1, x2, y2))"}
{"solution": "n = int(input())\nvotes = list(input())\n\nwhile len(votes) > 1:\n    new_votes = []\n    for i in range(len(votes)):\n        if i < len(votes) - 1 and votes[i] != votes[i + 1]:\n            continue\n        new_votes.append(votes[i])\n    votes = new_votes\n\nprint(votes[0])"}
{"solution": "def gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef count_tv_sets(a, b, x, y):\n    g = gcd(x, y)\n    x //= g\n    y //= g\n\n    max_width = min(a, b * x)\n    max_height = min(b, a * y)\n\n    return max_width // x\n\na, b, x, y = map(int, input().split())\nprint(count_tv_sets(a, b, x, y))"}
{"solution": "def power(n, p):\n    count = 0\n    while n:\n        n //= p\n        count += n\n    return count\n\ndef trailing_zeros(n, b):\n    count = 0\n    while n:\n        n //= b\n        count += n\n    return count\n\ndef solve(n, b):\n    p = 5\n    count = 0\n    while p <= n:\n        count += n // p\n        p *= 5\n    count -= trailing_zeros(b, 5)\n    return count\n\nn, b = map(int, input().split())\nprint(solve(n, b))"}
{"solution": "def frog_jumps(m, a, b):\n    # Initialize the sum and the set of reachable positions\n    total_sum = 0\n    reachable = {0}\n\n    # Iterate over all positions from 0 to m\n    for i in range(m + 1):\n        # Update the set of reachable positions\n        reachable = {j + a for j in reachable if j + a <= i} | {j - b for j in reachable if j - b >= 0}\n\n        # Add the number of reachable positions to the sum\n        total_sum += len(reachable)\n\n    return total_sum\n\n# Read the input\nm, a, b = map(int, input().split())\n\n# Print the result\nprint(frog_jumps(m, a, b))"}
{"solution": "# Read the input\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Check if the first and last elements are odd\nif sequence[0] % 2 == 0 or sequence[-1] % 2 == 0:\n    print(\"No\")\nelse:\n    # Count the number of odd elements in the sequence\n    odd_count = sum(1 for num in sequence if num % 2 == 1)\n\n    # If the number of odd elements is even, it's not possible to divide the sequence into an odd number of subsegments\n    if odd_count % 2 == 0:\n        print(\"No\")\n    else:\n        # If the number of odd elements is odd, it's possible to divide the sequence into an odd number of subsegments\n        print(\"Yes\")"}
{"solution": "# Get the coordinates of the two known trees\nx1, y1, x2, y2 = map(int, input().split())\n\n# Check if the two known trees are on the same horizontal line\nif x1 == x2:\n    # Calculate the distance between the two known trees\n    distance = abs(y1 - y2)\n    # Calculate the coordinates of the two remaining trees\n    x3, y3 = x1 + distance, y1\n    x4, y4 = x2 + distance, y2\n# Check if the two known trees are on the same vertical line\nelif y1 == y2:\n    # Calculate the distance between the two known trees\n    distance = abs(x1 - x2)\n    # Calculate the coordinates of the two remaining trees\n    x3, y3 = x1, y1 + distance\n    x4, y4 = x2, y2 + distance\n# If the two known trees are not on the same horizontal or vertical line, there is no solution\nelse:\n    print(-1)\n    exit()\n\n# Check if the calculated coordinates are within the valid range\nif -1000 <= x3 <= 1000 and -1000 <= y3 <= 1000 and -1000 <= x4 <= 1000 and -1000 <= y4 <= 1000:\n    # Print the coordinates of the two remaining trees\n    print(x3, y3, x4, y4)\nelse:\n    # If the calculated coordinates are not within the valid range, there is no solution\n    print(-1)"}
{"solution": "MOD = 1000000007\n\ndef matrix_multiply(A, B):\n    C = [[0, 0], [0, 0]]\n    for i in range(2):\n        for j in range(2):\n            for k in range(2):\n                C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % MOD\n    return C\n\ndef matrix_power(A, n):\n    result = [[1, 0], [0, 1]]\n    while n > 0:\n        if n % 2 == 1:\n            result = matrix_multiply(result, A)\n        A = matrix_multiply(A, A)\n        n //= 2\n    return result\n\ndef solve(x, y, n):\n    if n == 1:\n        return x % MOD\n    elif n == 2:\n        return y % MOD\n    else:\n        A = [[1, 1], [1, 0]]\n        A_n_minus_2 = matrix_power(A, n - 2)\n        return (A_n_minus_2[0][0] * y + A_n_minus_2[0][1] * x) % MOD\n\nx, y = map(int, input().split())\nn = int(input())\nprint(solve(x, y, n))"}
{"solution": "def split_array(n, arr):\n    result = []\n    start = 0\n\n    for i in range(n):\n        if arr[i] == 0:\n            if start < i:\n                result.append((start, i))\n            start = i + 1\n        elif i == n - 1:\n            result.append((start, i + 1))\n\n    if not result:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(len(result))\n        for r in result:\n            print(r[0] + 1, r[1])\n\nn = int(input())\narr = list(map(int, input().split()))\nsplit_array(n, arr)"}
{"solution": "def min_score(n, m, k):\n    MOD = 1000000009\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    score = 0\n    for i in range(1, n + 1):\n        if i < m:\n            dp[i] = dp[i - 1]\n        elif i == m:\n            dp[i] = (dp[i - 1] + dp[i - k] * (i - k + 1)) % MOD\n        else:\n            dp[i] = (dp[i - 1] + dp[i - k] * (i - k + 1) - dp[i - m - 1] + MOD) % MOD\n        score = (score + dp[i]) % MOD\n    return score\n\nn, m, k = map(int, input().split())\nprint(min_score(n, m, k))"}
{"solution": "def is_divisible_by_eight(n):\n    # Check if the number itself is divisible by 8\n    if int(n) % 8 == 0:\n        return True\n\n    # Check each digit of the number\n    for i in range(len(n)):\n        # Remove the current digit\n        new_n = n[:i] + n[i+1:]\n        # Check if the new number is not empty and is divisible by 8\n        if new_n and int(new_n) % 8 == 0:\n            return True\n\n    return False\n\nn = input()\nif is_divisible_by_eight(n):\n    print(\"YES\")\n    # Find the first divisible number by removing digits\n    for i in range(len(n)):\n        new_n = n[:i] + n[i+1:]\n        if new_n and int(new_n) % 8 == 0:\n            print(new_n)\n            break\nelse:\n    print(\"NO\")"}
{"solution": "def find_floor(n, m, memory):\n    memory.sort(key=lambda x: x[0])\n    flats_per_floor = memory[0][0]\n    for i in range(1, m):\n        if memory[i][0] // flats_per_floor != memory[i][1]:\n            return -1\n    return (n - 1) // flats_per_floor + 1\n\nn, m = map(int, input().split())\nmemory = [list(map(int, input().split())) for _ in range(m)]\nprint(find_floor(n, m, memory))"}
{"solution": "def count_bishwocks(board):\n    # Count the number of empty squares in each row\n    row_counts = [row.count('0') for row in board]\n\n    # Calculate the maximum number of bishwocks that can be placed in each row\n    row_bishwocks = [count // 3 for count in row_counts]\n\n    # Calculate the number of squares that are occupied by pawns in the columns between the two rows\n    col_pawns = [board[0][i] == 'X' and board[1][i] == 'X' for i in range(len(board[0]))]\n\n    # Calculate the maximum number of bishwocks that can be placed in the columns between the two rows\n    col_bishwocks = [0] * len(board[0])\n    for i in range(1, len(board[0]) - 1):\n        if col_pawns[i - 1] == 0 and col_pawns[i] == 0 and col_pawns[i + 1] == 0:\n            col_bishwocks[i] = 1\n\n    # Calculate the total number of bishwocks that can be placed on the board\n    total_bishwocks = sum(row_bishwocks) + sum(col_bishwocks)\n\n    return total_bishwocks\n\n# Read the input\nboard = [input(), input()]\n\n# Print the output\nprint(count_bishwocks(board))"}
{"solution": "n = int(input())\ns = input()\n\n# Find all lowercase letters and their positions\nlowercase_letters = [(i, c) for i, c in enumerate(s) if c.islower()]\n\n# Initialize maximum number of elements in pretty set\nmax_elements = 0\n\n# Iterate through all possible subsets of lowercase letters\nfor i in range(1 << len(lowercase_letters)):\n    # Convert integer to binary and check which letters are included in the subset\n    subset = [lowercase_letters[j] for j in range(len(lowercase_letters)) if (i & (1 << j)) > 0]\n\n    # Check if subset is pretty\n    is_pretty = True\n    for j in range(len(subset) - 1):\n        # Check if there are any uppercase letters between positions from the subset\n        if any(c.isupper() for c in s[subset[j][0]+1:subset[j+1][0]]):\n            is_pretty = False\n            break\n\n    # Update maximum number of elements in pretty set\n    if is_pretty:\n        max_elements = max(max_elements, len(subset))\n\n# Print maximum number of elements in pretty set\nprint(max_elements)"}
{"solution": "# Read the number of elements\nn = int(input())\n\n# Read the elements of the sequence\na = list(map(int, input().split()))\n\n# Sort the sequence in descending order\na.sort(reverse=True)\n\n# Initialize the sums of the two sequences\nb_sum = 0\nc_sum = 0\n\n# Iterate through the sorted sequence\nfor i in range(n):\n    # If adding the current element to b results in a larger difference, add it to b\n    if b_sum - c_sum < a[i]:\n        b_sum += a[i]\n    # Otherwise, add it to c\n    else:\n        c_sum += a[i]\n\n# Print the maximum possible value of B - C\nprint(b_sum - c_sum)"}
{"solution": "def min_refuels(a, b, f, k):\n    # Calculate the distance the bus can travel without refueling\n    max_distance = b\n\n    # Calculate the distance the bus travels in one journey\n    journey_distance = 2 * a\n\n    # Check if the bus can make a single journey without refueling\n    if journey_distance > max_distance:\n        return -1\n\n    # Calculate the number of refueling stops needed for one journey\n    refuels_per_journey = 1 if max_distance < journey_distance else 0\n\n    # Calculate the number of refueling stops needed for k journeys\n    total_refuels = refuels_per_journey * k\n\n    # If the bus needs to refuel during the first journey, it needs to refuel one more time\n    if f <= a and f > max_distance:\n        total_refuels += 1\n\n    return total_refuels\n\n# Read the input\na, b, f, k = map(int, input().split())\n\n# Print the result\nprint(min_refuels(a, b, f, k))"}
{"solution": "def split_string(n, p, q, s):\n    for i in range(0, n, p):\n        if n - i >= q and s[i:i+p] + s[i+p:i+p+q] == s[i:i+p+q]:\n            return [s[i:i+p], s[i+p:i+p+q]]\n        elif n - i == p:\n            return [s[i:i+p]]\n    return [-1]\n\nn, p, q = map(int, input().split())\ns = input()\nresult = split_string(n, p, q, s)\n\nif result != [-1]:\n    print(len(result))\n    for string in result:\n        print(string)\nelse:\n    print(-1)"}
{"solution": "def solve(n, m, s, d, obstacles):\n    obstacles.sort()\n    prev_pos = 0\n    for obstacle in obstacles:\n        if obstacle - prev_pos < s:\n            return \"IMPOSSIBLE\"\n        elif obstacle - prev_pos >= s + d:\n            return \"IMPOSSIBLE\"\n        else:\n            print(f\"RUN {s}\")\n            print(f\"JUMP {obstacle - prev_pos - s}\")\n            prev_pos = obstacle\n    if m - prev_pos >= s:\n        print(f\"RUN {m - prev_pos}\")\n    else:\n        return \"IMPOSSIBLE\"\n\nn, m, s, d = map(int, input().split())\nobstacles = list(map(int, input().split()))\nsolve(n, m, s, d, obstacles)"}
{"solution": "def count_pairs(s, x):\n    # If s is odd and x is even, there are no solutions\n    if s % 2 != x % 2:\n        return 0\n\n    # Calculate the difference between a and b\n    diff = (s - x) // 2\n\n    # Calculate the bitwise AND of a and b\n    and_val = s - diff\n\n    # If the difference is less than the bitwise AND, there are no solutions\n    if diff < and_val:\n        return 0\n\n    # Calculate the number of set bits in the bitwise AND\n    set_bits = bin(and_val).count('1')\n\n    # Calculate the number of possible values for a and b\n    # using the combination formula\n    return 2 ** (set_bits - 1)\n\n# Read the input\ns, x = map(int, input().split())\n\n# Print the output\nprint(count_pairs(s, x))"}
{"solution": "# Read input\nn, k = map(int, input().split())\n\n# Calculate the minimum number of actions needed\n# This is equal to the number of groups of 2k+1 skewers, rounded up\nl = (n + 2*k) // (2*k + 1)\n\n# Print the minimum number of actions needed\nprint(l)\n\n# Print the number of the skewer that is to be turned over at each step\n# This is equal to the middle skewer of each group of 2k+1 skewers\nfor i in range(1, l+1):\n    print((i-1)*(2*k+1) + k + 1)"}
{"solution": "def min_operations(n):\n    # Convert the number to string for easy manipulation\n    n = str(n)\n\n    # Initialize the minimum operations to infinity\n    min_ops = float('inf')\n\n    # Iterate over all possible lengths of the square root\n    for i in range(1, len(n) // 2 + 2):\n        # Iterate over all possible starting indices of the square root\n        for j in range(len(n) - i + 1):\n            # Extract the potential square root\n            sqrt = int(n[j:j + i])\n\n            # Calculate the square of the potential square root\n            square = sqrt * sqrt\n\n            # Convert the square to string for easy comparison\n            square = str(square)\n\n            # If the square is not a substring of the number, continue\n            if square not in n:\n                continue\n\n            # Calculate the number of operations required to obtain the square\n            ops = len(n) - len(square)\n\n            # Update the minimum number of operations\n            min_ops = min(min_ops, ops)\n\n    # If the minimum number of operations is still infinity, return -1\n    if min_ops == float('inf'):\n        return -1\n\n    # Otherwise, return the minimum number of operations\n    return min_ops\n\n# Read the input\nn = int(input())\n\n# Print the output\nprint(min_operations(n))"}
{"solution": "import math\n\nMOD = 10**9 + 7\n\ndef f_max(n):\n    return n - math.ceil(math.log2(n))\n\ndef count_permutations(n):\n    f_max_n = f_max(n)\n    dp = [0] * (f_max_n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        new_dp = [0] * (f_max_n + 1)\n        for j in range(1, min(i, f_max_n) + 1):\n            if math.gcd(i, j) == 1:\n                new_dp[j] = (new_dp[j] + dp[j - 1]) % MOD\n            new_dp[j] = (new_dp[j] + dp[j]) % MOD\n        dp = new_dp\n    return dp[f_max_n]\n\nn = int(input())\nprint(count_permutations(n))"}
{"solution": "def min_jump_ability(string):\n    vowels = ['A', 'E', 'I', 'O', 'U', 'Y']\n    max_distance = 0\n    current_distance = 0\n    prev_vowel_index = -1\n\n    for i in range(len(string)):\n        if string[i] in vowels:\n            if prev_vowel_index != -1:\n                current_distance = i - prev_vowel_index\n                max_distance = max(max_distance, current_distance)\n            prev_vowel_index = i\n\n    return max_distance\n\nstring = input()\nprint(min_jump_ability(string))"}
{"solution": "# Get the input and convert it to a list of integers\nbags = list(map(int, input().split()))\n\n# Sort the list of bags in ascending order\nbags.sort()\n\n# Check if it's possible to distribute the bags\nif bags[0] + bags[3] == bags[1] + bags[2]:\n    print(\"YES\")\nelif bags[0] + bags[1] + bags[2] == bags[3]:\n    print(\"YES\")\nelif bags[0] + bags[1] == bags[2] + bags[3]:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def optimal_pie_distribution(n, slices):\n    # Initialize the sum of pie sizes for Alice and Bob\n    alice_sum = 0\n    bob_sum = 0\n\n    # Iterate over the slices in reverse order\n    for i in range(n - 1, -1, -2):\n        # The player with the decider token chooses the larger slice\n        if i >= 0:\n            alice_sum += slices[i]\n        # The other player chooses the remaining slice\n        if i - 1 >= 0:\n            bob_sum += slices[i - 1]\n\n    return alice_sum, bob_sum\n\n# Read the input\nn = int(input())\nslices = list(map(int, input().split()))\n\n# Calculate the optimal distribution of pie sizes\nalice_pie, bob_pie = optimal_pie_distribution(n, slices)\n\n# Print the output\nprint(alice_pie, bob_pie)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# dp[i][j] is True if it's possible to perform the operations using the first i elements of a and j variables\ndp = [[False] * (n + 1) for _ in range(n + 1)]\n\n# Base case: it's always possible to perform the first operation using 1 variable\ndp[1][1] = True\n\nfor i in range(2, n + 1):\n    for j in range(1, i + 1):\n        # Try to assign a[i - 1] using j variables\n        for k in range(1, j + 1):\n            # Check if a[i - 1] can be obtained by adding two numbers from the first i - 1 elements that can be obtained using k - 1 variables\n            for l in range(1, i):\n                if a[i - 1] == a[l - 1] + a[i - l - 1] and dp[l][k - 1] and dp[i - l][k - 1]:\n                    dp[i][j] = True\n                    break\n            if dp[i][j]:\n                break\n\n# Find the minimum number of variables required\nfor i in range(1, n + 1):\n    if dp[n][i]:\n        print(i)\n        break\nelse:\n    print(-1)"}
{"solution": "n = int(input())\npiles = list(map(int, input().split()))\n\n# If there are only two piles and they have the same number of stones, Bob wins.\n# Otherwise, Alice can win by making a move that leaves the piles in a state where Bob can't win.\nif n == 2:\n    if piles[0] == piles[1]:\n        print(\"Bob\")\n    else:\n        print(\"Alice\")\nelse:\n    # If there are more than two piles, Alice can win by making a move that leaves an odd number of piles with one stone.\n    # Bob can only make moves that leave an even number of piles with one stone, so Alice can always leave Bob in a losing position.\n    if piles.count(1) % 2 == 1:\n        print(\"Alice\")\n    else:\n        print(\"Bob\")"}
{"solution": "def can_make_equal(n, arr):\n    arr.sort()\n    d = arr[1] - arr[0]\n    for i in range(2, n):\n        if arr[i] - arr[i-1] != d:\n            return \"NO\"\n    if (arr[0] + d) % d == 0 or arr[0] % d == 0:\n        return \"YES\"\n    return \"NO\"\n\nn = int(input())\narr = list(map(int, input().split()))\nprint(can_make_equal(n, arr))"}
{"solution": "def max_length_substring(n, s):\n    max_len = 0\n    for len_sub in range(n//2, 0, -1):\n        for i in range(n - 2*len_sub + 1):\n            if s[i:i+len_sub] == s[i+len_sub:i+2*len_sub]:\n                return len_sub\n    return 0\n\nn = int(input())\ns = input()\nprint(max_length_substring(n, s))"}
{"solution": "# Read the input\nn, a = map(int, input().split())\n\n# Calculate the minimum time\nif a <= n // 2:\n    # Scenario 1: Drive directly to house 'a'\n    time = a\nelse:\n    # Scenario 2: Drive to the house opposite to 'a' and then to house 'a'\n    time = min(a, n - a + 1)\n\n# Print the minimum time\nprint(time)"}
{"solution": "def find_interval(n, m, lightsabers, desired_counts):\n    window_counts = [0] * m\n    left, right = 0, 0\n\n    while right < n:\n        window_counts[lightsabers[right] - 1] += 1\n\n        if right - left + 1 == sum(desired_counts):\n            if window_counts == desired_counts:\n                return \"YES\"\n            window_counts[lightsabers[left] - 1] -= 1\n            left += 1\n\n        right += 1\n\n    return \"NO\"\n\nn, m = map(int, input().split())\nlightsabers = list(map(int, input().split()))\ndesired_counts = list(map(int, input().split()))\n\nprint(find_interval(n, m, lightsabers, desired_counts))"}
{"solution": "# Read the number of rounds\nn = int(input())\n\n# Initialize the scores\nmishka_score = 0\nchris_score = 0\n\n# Iterate over the rounds\nfor _ in range(n):\n    # Read the dice values\n    mishka, chris = map(int, input().split())\n\n    # Update the scores\n    if mishka > chris:\n        mishka_score += 1\n    elif chris > mishka:\n        chris_score += 1\n\n# Determine the winner\nif mishka_score > chris_score:\n    print(\"Mishka\")\nelif chris_score > mishka_score:\n    print(\"Chris\")\nelse:\n    print(\"Friendship is magic!^^\")"}
{"solution": "def is_valid(field, n, m):\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                continue\n            elif field[i][j] == '.':\n                if not is_safe(field, i, j, n, m):\n                    return False\n            else:\n                if not is_valid_number(field, i, j, n, m):\n                    return False\n    return True\n\ndef is_safe(field, i, j, n, m):\n    for x in range(max(0, i-1), min(n, i+2)):\n        for y in range(max(0, j-1), min(m, j+2)):\n            if field[x][y] == '*':\n                return False\n    return True\n\ndef is_valid_number(field, i, j, n, m):\n    count = 0\n    for x in range(max(0, i-1), min(n, i+2)):\n        for y in range(max(0, j-1), min(m, j+2)):\n            if field[x][y] == '*':\n                count += 1\n    return count == int(field[i][j])\n\nn, m = map(int, input().split())\nfield = [list(input()) for _ in range(n)]\n\nif is_valid(field, n, m):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def calculate_candies(n, k):\n    vasya_eats = 0\n    petya_eats = 0\n    candies = n\n\n    while candies > 0:\n        vasya_eats += min(k, candies)\n        candies -= min(k, candies)\n\n        if candies < 10:\n            break\n\n        petya_eats += candies // 10\n        candies -= candies // 10\n\n    return vasya_eats >= n // 2\n\ndef find_min_k(n):\n    left = 1\n    right = n\n\n    while left < right:\n        mid = (left + right) // 2\n\n        if calculate_candies(n, mid):\n            right = mid\n        else:\n            left = mid + 1\n\n    return left\n\nn = int(input())\nprint(find_min_k(n))"}
{"solution": "def solve(s):\n    pearls = [i for i in range(len(s)) if s[i] == 'o']\n    links_between_pearls = [pearls[i+1] - pearls[i] - 1 for i in range(len(pearls) - 1)] + [len(s) - pearls[-1] - 1 + pearls[0]]\n    avg_links = sum(links_between_pearls) / len(pearls)\n    return 'YES' if avg_links.is_integer() and all(x == avg_links for x in links_between_pearls) else 'NO'\n\ns = input()\nprint(solve(s))"}
{"solution": "def max_pillows(n, m, k):\n    # Calculate the number of pillows Frodo can give to the hobbits on his left and right\n    left_pillows = k - 1\n    right_pillows = n - k\n\n    # Calculate the maximum number of pillows Frodo can have so that no one is hurt\n    max_frodo_pillows = min(left_pillows, right_pillows, m - n + 1)\n\n    return max_frodo_pillows\n\n# Read the input\nn, m, k = map(int, input().split())\n\n# Print the output\nprint(max_pillows(n, m, k))"}
{"solution": "from collections import deque\nimport math\n\ndef max_cost_subarray(n, m, k, a):\n    max_cost = 0\n    curr_sum = 0\n    window = deque()\n    prefix_sum = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + a[i - 1]\n\n    for i in range(n):\n        while window and window[0] < i - m + 1:\n            window.popleft()\n\n        while window and prefix_sum[i + 1] - prefix_sum[window[-1]] >= prefix_sum[window[-1] + m] - prefix_sum[window[-1]] - k:\n            window.pop()\n\n        window.append(i)\n        curr_cost = prefix_sum[i + 1] - prefix_sum[window[0]] - k * math.ceil((i - window[0] + 1) / m)\n        max_cost = max(max_cost, curr_cost)\n\n    return max_cost\n\nn, m, k = map(int, input().split())\na = list(map(int, input().split()))\nprint(max_cost_subarray(n, m, k, a))"}
{"solution": "import math\n\ndef calculate_distance(point1, point2):\n    return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2)\n\ndef find_longest_polyline(n, m):\n    if n > m:\n        n, m = m, n\n\n    if n == 0:\n        return [(0, 0), (0, m), (0, m//2), (0, m//2 + m//4)]\n    elif n == 1:\n        return [(0, 0), (0, m), (1, m), (1, 0)]\n    else:\n        diagonal = calculate_distance((0, 0), (n, m))\n        side = calculate_distance((0, 0), (n, 0)) + calculate_distance((n, 0), (n, m))\n        if diagonal > side:\n            return [(0, 0), (n, m), (n, 0), (0, m)]\n        else:\n            return [(0, 0), (n, 0), (n, m//2), (0, m)]\n\nn, m = map(int, input().split())\npoints = find_longest_polyline(n, m)\nfor point in points:\n    print(*point)"}
{"solution": "def find_smallest_number(shuffled_string, substring):\n    # Count the frequency of each digit in the shuffled string and substring\n    shuffled_count = [0] * 10\n    substring_count = [0] * 10\n    for digit in shuffled_string:\n        shuffled_count[int(digit)] += 1\n    for digit in substring:\n        substring_count[int(digit)] += 1\n\n    # Calculate the number of extra digits for each number from 0 to 9\n    extra_digits = [shuffled_count[i] - substring_count[i] for i in range(10)]\n\n    # Find the smallest possible initial integer n\n    n = \"\"\n    for digit in shuffled_string:\n        # If the current digit is in the substring, add it to n\n        if substring_count[int(digit)] > 0:\n            n += digit\n            substring_count[int(digit)] -= 1\n        # Otherwise, add the smallest possible digit that has not been used up yet\n        else:\n            for i in range(10):\n                if extra_digits[i] > 0:\n                    n += str(i)\n                    extra_digits[i] -= 1\n                    break\n\n    # Remove leading zeroes, unless n is \"0\"\n    if n != \"0\":\n        n = n.lstrip(\"0\")\n\n    return n\n\n# Read input\nshuffled_string = input()\nsubstring = input()\n\n# Find and print the smallest possible initial integer n\nn = find_smallest_number(shuffled_string, substring)\nprint(n)"}
{"solution": "n, m, min_temp, max_temp = map(int, input().split())\ntemps = list(map(int, input().split()))\n\n# Check if the existing temperatures are within the required range\nif min(temps) < min_temp or max(temps) > max_temp:\n    print('Incorrect')\nelse:\n    # Check if it's possible to add the necessary temperatures\n    if min_temp in temps and max_temp in temps:\n        # If both the minimum and maximum temperatures are already in the set,\n        # we need to add at least n - m - 2 temperatures\n        if n - m - 2 >= 0:\n            print('Correct')\n        else:\n            print('Incorrect')\n    elif min_temp in temps or max_temp in temps:\n        # If only one of the minimum or maximum temperatures is in the set,\n        # we need to add at least n - m - 1 temperatures\n        if n - m - 1 >= 0:\n            print('Correct')\n        else:\n            print('Incorrect')\n    else:\n        # If neither the minimum nor maximum temperatures are in the set,\n        # we need to add at least n - m temperatures\n        if n - m >= 0:\n            print('Correct')\n        else:\n            print('Incorrect')"}
{"solution": "def count_trailing_zeroes(n):\n    count = 0\n    i = 5\n    while n / i >= 1:\n        count += int(n / i)\n        i *= 5\n    return count\n\ndef find_n(m):\n    left, right = 1, 5 * m\n    while left < right:\n        mid = (left + right) // 2\n        if count_trailing_zeroes(mid) < m:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\ndef solve(m):\n    n = find_n(m)\n    count = 0\n    while count_trailing_zeroes(n) == m:\n        count += 1\n        n += 1\n    return count, [i for i in range(n - count, n)]\n\nm = int(input())\nk, values = solve(m)\nprint(k)\nprint(*values)"}
{"solution": "import heapq\nimport sys\n\ndef dijkstra(graph, start):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n\n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node].items():\n            distance = max(current_distance, weight)\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n\n    return distances\n\ndef main():\n    n, m, k = map(int, sys.stdin.readline().split())\n    special_vertices = set(map(int, sys.stdin.readline().split()))\n\n    graph = {i: {} for i in range(1, n + 1)}\n\n    for _ in range(m):\n        u, v, w = map(int, sys.stdin.readline().split())\n        graph[u][v] = graph[v][u] = min(graph[u].get(v, float('inf')), w)\n\n    results = []\n\n    for vertex in special_vertices:\n        distances = dijkstra(graph, vertex)\n        max_distance = max(distances[v] for v in special_vertices if v != vertex)\n        results.append(max_distance)\n\n    print(*results)\n\nif __name__ == '__main__':\n    main()"}
{"solution": "# Get the number of movements made by the operator\nn = int(input())\n\n# Get the index of the shell where the ball was found after n movements\nx = int(input())\n\n# If the number of movements is even, the ball's position will be the same as the final position\nif n % 2 == 0:\n    print(x)\n# If the number of movements is odd, the ball's initial position can be determined by reversing the last movement\nelse:\n    if x == 0:\n        print(1)\n    elif x == 1:\n        print(0)\n    else:\n        print(2)"}
{"solution": "def is_square(rectangles):\n    x_coords = set()\n    y_coords = set()\n\n    for rect in rectangles:\n        x1, y1, x2, y2 = rect\n        x_coords.update([x1, x2])\n        y_coords.update([y1, y2])\n\n    if len(x_coords) != 3 or len(y_coords) != 3:\n        return False\n\n    x_coords = sorted(list(x_coords))\n    y_coords = sorted(list(y_coords))\n\n    if x_coords[2] - x_coords[0] != y_coords[2] - y_coords[0]:\n        return False\n\n    area = (x_coords[2] - x_coords[0]) * (y_coords[2] - y_coords[0])\n    total_rect_area = 0\n\n    for rect in rectangles:\n        x1, y1, x2, y2 = rect\n        total_rect_area += (x2 - x1) * (y2 - y1)\n\n    return area == total_rect_area\n\nn = int(input())\nrectangles = []\nfor _ in range(n):\n    rect = list(map(int, input().split()))\n    rectangles.append(rect)\n\nprint(\"YES\" if is_square(rectangles) else \"NO\")"}
{"solution": "def sum_of_digits(n):\n    return sum(int(digit) for digit in str(n))\n\ndef count_really_big_numbers(n, s):\n    count = 0\n    for i in range(1, n + 1):\n        if i - sum_of_digits(i) >= s:\n            count += 1\n    return count\n\nn, s = map(int, input().split())\nprint(count_really_big_numbers(n, s))"}
{"solution": "from collections import defaultdict\n\ndef solve():\n    n = int(input())\n    x_points = defaultdict(set)\n    y_points = defaultdict(set)\n\n    for _ in range(n):\n        x, y = map(int, input().split())\n        x_points[x].add(y)\n        y_points[y].add(x)\n\n    for x, y_set in x_points.items():\n        if len(y_set) > 1:\n            y1, y2 = sorted(y_set)\n            if len(x_points[x]) == 2 and len(y_points[y1]) == 2 and len(y_points[y2]) == 2:\n                print(\"YES\")\n                return\n\n    for y, x_set in y_points.items():\n        if len(x_set) > 1:\n            x1, x2 = sorted(x_set)\n            if len(y_points[y]) == 2 and len(x_points[x1]) == 2 and len(x_points[x2]) == 2:\n                print(\"YES\")\n                return\n\n    print(\"NO\")\n\nsolve()"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(a, b, k, t):\n    dp = [[0] * (2 * k + 1) for _ in range(2 * k + 1)]\n    dp[a][b] = 1\n\n    for _ in range(t):\n        new_dp = [[0] * (2 * k + 1) for _ in range(2 * k + 1)]\n        for i in range(2 * k + 1):\n            for j in range(2 * k + 1):\n                for x in range(-k, k + 1):\n                    for y in range(-k, k + 1):\n                        new_dp[(i + x) % (2 * k + 1)][(j + y) % (2 * k + 1)] += dp[i][j]\n                        new_dp[(i + x) % (2 * k + 1)][(j + y) % (2 * k + 1)] %= MOD\n        dp = new_dp\n\n    ans = 0\n    for i in range(2 * k + 1):\n        for j in range(i + 1, 2 * k + 1):\n            ans += dp[i][j]\n            ans %= MOD\n    return ans\n\na, b, k, t = map(int, input().split())\nprint(solve(a, b, k, t))"}
{"solution": "def solve(n, l, x, y, marks):\n    marks_set = set(marks)\n    add_marks = []\n\n    if x not in [marks[j] - marks[i] for i in range(n) for j in range(i+1, n)]:\n        if x in marks_set:\n            add_marks.append(x + y)\n        else:\n            add_marks.append(x)\n\n    if y not in [marks[j] - marks[i] for i in range(n) for j in range(i+1, n)]:\n        if y not in marks_set:\n            add_marks.append(y)\n\n    return len(add_marks), add_marks\n\nn, l, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\n\nv, p = solve(n, l, x, y, marks)\n\nprint(v)\nprint(*p)"}
{"solution": "import sys\nimport math\n\ndef calculate_max_volume():\n    n = int(sys.stdin.readline())\n    cakes = []\n\n    for _ in range(n):\n        r, h = map(int, sys.stdin.readline().split())\n        cakes.append((r, h))\n\n    cakes.sort(key=lambda x: x[0])\n\n    dp = [0] * n\n    dp[0] = math.pi * cakes[0][0] ** 2 * cakes[0][1]\n\n    for i in range(1, n):\n        dp[i] = dp[i-1]\n        for j in range(i):\n            if cakes[i][0] > cakes[j][0] and cakes[i][1] > cakes[j][1]:\n                dp[i] = max(dp[i], dp[j] + math.pi * cakes[i][0] ** 2 * cakes[i][1])\n\n    return dp[-1]\n\nprint(calculate_max_volume())"}
{"solution": "def min_slices(n, k, h):\n    h.sort()\n    min_height = h[0]\n    slices = 0\n    while h[-1] > min_height:\n        cost = 0\n        for i in range(n):\n            if h[i] > min_height:\n                cost += h[i] - min_height\n                h[i] = min_height\n        if cost > k:\n            break\n        slices += 1\n        min_height -= 1\n    return slices\n\nn, k = map(int, input().split())\nh = list(map(int, input().split()))\nprint(min_slices(n, k, h))"}
{"solution": "# Read the input\nn = int(input())\ncards = list(map(int, input().split()))\n\n# Initialize the maximum score\nmax_score = 0\n\n# Iterate over all possible segments\nfor i in range(n):\n    for j in range(i, n):\n        # Calculate the score for the current segment\n        score = sum(cards[:i]) + sum(cards[i+1:j]) + sum(cards[j+1:])\n        # Update the maximum score\n        max_score = max(max_score, score)\n\n# Print the maximum score\nprint(max_score)"}
{"solution": "import math\n\n# Get the three time intervals\nk1, k2, k3 = map(int, input().split())\n\n# Calculate the GCD of the three time intervals\ngcd = math.gcd(k1, math.gcd(k2, k3))\n\n# Output \"YES\" if the GCD is 1, and \"NO\" otherwise\nif gcd == 1:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n = int(input())\ns = input()\n\n# Initialize the count of operations\ncount = 0\n\n# Initialize the previous character\nprev_char = s[0]\n\n# Iterate over the string\nfor i in range(1, n):\n    # If the current character is the same as the previous character\n    if s[i] == prev_char:\n        # Continue to the next character\n        continue\n    else:\n        # Increment the count of operations\n        count += 1\n        # Update the previous character\n        prev_char = s[i]\n\n# Increment the count of operations for the last character\ncount += 1\n\n# Print the result\nprint(count)"}
{"solution": "# Read the number of boys and their dancing skills\nn = int(input())\nboys = sorted(list(map(int, input().split())))\n\n# Read the number of girls and their dancing skills\nm = int(input())\ngirls = sorted(list(map(int, input().split())))\n\n# Initialize the counter for the number of pairs\npairs = 0\n\n# Initialize the pointers for the boys and girls arrays\ni = j = 0\n\n# Iterate through both arrays simultaneously\nwhile i < n and j < m:\n    # If the difference between the current boy and girl's skills is less than or equal to 1,\n    # increment the counter and move both pointers\n    if abs(boys[i] - girls[j]) <= 1:\n        pairs += 1\n        i += 1\n        j += 1\n    # If the difference is greater than 1, move the pointer for the boy with the lower skill\n    elif boys[i] < girls[j]:\n        i += 1\n    else:\n        j += 1\n\n# Print the maximum possible number of pairs\nprint(pairs)"}
{"solution": "# Read input data\nplayer_stats = [list(map(int, input().split())) for _ in range(4)]\n\n# Separate players into their respective teams\nteam1_stats = player_stats[:2]\nteam2_stats = player_stats[2:]\n\n# Determine optimal strategy for each team\nteam1_defence = max(team1_stats, key=lambda x: x[0])[0]\nteam1_attack = max(team1_stats, key=lambda x: x[1])[1]\nteam2_defence = max(team2_stats, key=lambda x: x[0])[0]\nteam2_attack = max(team2_stats, key=lambda x: x[1])[1]\n\n# Determine the winner\nif team1_defence > team2_attack and team1_attack > team2_defence:\n    print(\"Team 1\")\nelif team2_defence > team1_attack and team2_attack > team1_defence:\n    print(\"Team 2\")\nelse:\n    print(\"Draw\")"}
{"solution": "import math\n\ndef calculate_time(x, y, points, k):\n    times = []\n    for point in points:\n        distance = math.sqrt((x - point[0])**2 + (y - point[1])**2)\n        time = distance * point[2]\n        times.append(time)\n    times.sort()\n    return times[k-1]\n\ndef find_optimal_location(points, k):\n    left, right = -1000, 1000\n    for _ in range(100):\n        mid1 = (left * 2 + right) / 3\n        mid2 = (left + right * 2) / 3\n        time1 = calculate_time(mid1, mid1, points, k)\n        time2 = calculate_time(mid2, mid2, points, k)\n        if time1 < time2:\n            right = mid2\n        else:\n            left = mid1\n    return (left + right) / 2\n\nn, k = map(int, input().split())\npoints = [list(map(int, input().split())) for _ in range(n)]\noptimal_location = find_optimal_location(points, k)\nprint(calculate_time(optimal_location, optimal_location, points, k))"}
{"solution": "def determine_winner(n, ticket):\n    left_sum = 0\n    right_sum = 0\n    left_unknown = 0\n    right_unknown = 0\n\n    for i in range(n // 2):\n        if ticket[i] == '?':\n            left_unknown += 1\n        else:\n            left_sum += int(ticket[i])\n\n    for i in range(n // 2, n):\n        if ticket[i] == '?':\n            right_unknown += 1\n        else:\n            right_sum += int(ticket[i])\n\n    if left_unknown == 0 and right_unknown == 0:\n        return \"Bicarp\" if left_sum == right_sum else \"Monocarp\"\n\n    if left_unknown % 2 == 0 and right_unknown % 2 == 0:\n        return \"Bicarp\"\n\n    if left_unknown % 2 == 1 and right_unknown % 2 == 1:\n        return \"Monocarp\" if (left_sum + 45 * (left_unknown // 2)) != (right_sum + 45 * (right_unknown // 2)) else \"Bicarp\"\n\n    return \"Monocarp\"\n\nn = int(input())\nticket = input()\nprint(determine_winner(n, ticket))"}
{"solution": "import sys\n\ndef find_bus_route(n, t, bus_schedules):\n    valid_routes = []\n    for i, (s, d) in enumerate(bus_schedules, start=1):\n        if s <= t and (t - s) % d == 0:\n            valid_routes.append(i)\n    return valid_routes[0] if valid_routes else None\n\ndef main():\n    n, t = map(int, sys.stdin.readline().split())\n    bus_schedules = [tuple(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    result = find_bus_route(n, t, bus_schedules)\n    if result is not None:\n        print(result)\n    else:\n        print(\"No valid bus route found.\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def count_numbers_with_k_ones(n, k):\n    # Count the number of binary representations of numbers from 1 to n that have exactly k digits of 1\n    count = 0\n    for i in range(1, n + 1):\n        if bin(i).count('1') == k:\n            count += 1\n    return count\n\ndef find_n(m, k):\n    # Use binary search to find the smallest positive integer n such that the number of numbers from n + 1 to 2 * n that have exactly k digits of 1 is equal to m\n    left = 1\n    right = 10 ** 18\n    while left < right:\n        mid = (left + right) // 2\n        if count_numbers_with_k_ones(2 * mid, k) - count_numbers_with_k_ones(mid, k) < m:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\n# Read input\nm, k = map(int, input().split())\n\n# Find and print the required number n\nn = find_n(m, k)\nprint(n)"}
{"solution": "n = int(input())\nlevel = input()\n\n# Find all the platforms\nplatforms = [i for i in range(n) if level[i] == '*']\n\n# Check if there are at least 5 platforms\nif len(platforms) < 5:\n    print('no')\nelse:\n    # Check if there is a sequence of 5 platforms with equal intervals\n    for i in range(len(platforms) - 4):\n        if (platforms[i+4] - platforms[i+3] ==\n            platforms[i+3] - platforms[i+2] ==\n            platforms[i+2] - platforms[i+1] ==\n            platforms[i+1] - platforms[i]):\n            print('yes')\n            break\n    else:\n        print('no')"}
{"solution": "def calculate_magic_constant(matrix, n):\n    # Calculate the sum of the first row\n    magic_constant = sum(matrix[0])\n\n    # Calculate the sum of each row and column\n    for i in range(n):\n        row_sum = 0\n        col_sum = 0\n        for j in range(n):\n            row_sum += matrix[i][j]\n            col_sum += matrix[j][i]\n\n        # If the sum of the row or column is not equal to the magic constant, return -1\n        if row_sum != magic_constant or col_sum != magic_constant:\n            return -1\n\n    # Calculate the sum of the main diagonal\n    main_diagonal_sum = 0\n    for i in range(n):\n        main_diagonal_sum += matrix[i][i]\n\n    # If the sum of the main diagonal is not equal to the magic constant, return -1\n    if main_diagonal_sum != magic_constant:\n        return -1\n\n    # Calculate the sum of the secondary diagonal\n    secondary_diagonal_sum = 0\n    for i in range(n):\n        secondary_diagonal_sum += matrix[i][n - i - 1]\n\n    # If the sum of the secondary diagonal is not equal to the magic constant, return -1\n    if secondary_diagonal_sum != magic_constant:\n        return -1\n\n    # Calculate the sum of the numbers in the last row\n    last_row_sum = sum(matrix[n - 1])\n\n    # Calculate the sum of the numbers in the last column\n    last_col_sum = sum(matrix[n - 1][:n - 1])\n\n    # Calculate the sum of the numbers in the main diagonal excluding the last element\n    main_diagonal_sum_excluding_last = sum(matrix[i][i] for i in range(n - 1))\n\n    # Calculate the sum of the numbers in the secondary diagonal excluding the last element\n    secondary_diagonal_sum_excluding_last = sum(matrix[i][n - i - 2] for i in range(n - 1))\n\n    # Calculate the value that should be filled in the empty cell\n    value = magic_constant - (last_row_sum + last_col_sum - matrix[n - 1][n - 1])\n\n    # Check if the value is valid\n    if value < 1 or value > 10**18 or value != magic_constant - (main_diagonal_sum_excluding_last + secondary_diagonal_sum_excluding_last):\n        return -1\n\n    return value\n\n# Read the input\nn = int(input())\nmatrix = []\nfor i in range(n):\n    row = list(map(int, input().split()))\n    matrix.append(row)\n\n# Calculate the value that should be filled in the empty cell\nvalue = calculate_magic_constant(matrix, n)\n\n# Print the output\nprint(value)"}
{"solution": "# Read the input\nn = int(input())\nm = int(input())\nbenches = [int(input()) for _ in range(n)]\n\n# Calculate the minimum possible k\nmin_k = max(benches)\nif m % n == 0:\n    min_k += m // n\nelse:\n    min_k += m // n + 1\n\n# Calculate the maximum possible k\nmax_k = max(benches) + m\n\n# Print the output\nprint(min_k, max_k)"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(n, m):\n    # dp[i][j] is the number of ways to assign tickets to i passengers\n    # such that the last passenger enters from the j-th entrance (0 for front, 1 for back)\n    dp = [[0, 0] for _ in range(m + 1)]\n    dp[0][0] = dp[0][1] = 1\n\n    for i in range(1, m + 1):\n        # The last passenger enters from the front\n        dp[i][0] = (dp[i - 1][0] * (n - i + 1) + dp[i - 1][1] * (i - 1)) % MOD\n\n        # The last passenger enters from the back\n        dp[i][1] = (dp[i - 1][0] * i + dp[i - 1][1] * (n - i + 1)) % MOD\n\n    return sum(dp[m]) % MOD\n\nn, m = map(int, input().split())\nprint(solve(n, m))"}
{"solution": "# Read in the number of friends and pizzas\nn, m = map(int, input().split())\n\n# For each friend, read in their favorite ingredients and store them in a bitmask\nfriends = []\nfor _ in range(n):\n    f_i, *b_i = map(int, input().split())\n    bitmask = 0\n    for b in b_i:\n        bitmask |= 1 << (b - 1)\n    friends.append(bitmask)\n\n# For each pizza, read in its ingredients and store them in a bitmask\npizzas = []\nfor _ in range(m):\n    c_j, r_j, *a_j = map(int, input().split())\n    bitmask = 0\n    for a in a_j:\n        bitmask |= 1 << (a - 1)\n    pizzas.append((bitmask, c_j))\n\n# For each pair of pizzas, count the number of friends who are pleased by that pair\n# and store the result in a 2D array\npleased_friends = [[0] * m for _ in range(m)]\nfor i in range(m):\n    for j in range(i + 1, m):\n        for friend in friends:\n            if (friend & pizzas[i][0]) and (friend & pizzas[j][0]):\n                pleased_friends[i][j] += 1\n\n# Find the pair of pizzas that pleases the maximum number of friends\n# If there are multiple such pairs, choose the one with the minimum total price\nmax_pleased = 0\nmin_price = float('inf')\nbest_pair = (0, 0)\nfor i in range(m):\n    for j in range(i + 1, m):\n        if pleased_friends[i][j] > max_pleased or (pleased_friends[i][j] == max_pleased and pizzas[i][1] + pizzas[j][1] < min_price):\n            max_pleased = pleased_friends[i][j]\n            min_price = pizzas[i][1] + pizzas[j][1]\n            best_pair = (i, j)\n\n# Output the indices of the chosen pizzas\nprint(best_pair[0] + 1, best_pair[1] + 1)"}
{"solution": "def find_numbers(m, s):\n    # Initialize the smallest and largest numbers as strings of length m\n    smallest = ['0'] * m\n    largest = ['0'] * m\n\n    # If the sum is 0 and the length is more than 1, return \"-1 -1\"\n    if s == 0 and m > 1:\n        return \"-1 -1\"\n\n    # Start filling the digits from the most significant digit\n    i = 0\n    while s > 0:\n        # For the largest number, fill the current digit with the minimum of 9 and s\n        largest[i] = str(min(9, s))\n        s -= min(9, s)\n\n        # For the smallest number, fill the current digit with the maximum of 0 and s - (m - i - 1) * 9\n        smallest[i] = str(max(0, s - (m - i - 1) * 9))\n        s -= int(smallest[i])\n\n        i += 1\n\n    # If the most significant digit of the smallest number is 0, remove it\n    if smallest[0] == '0':\n        smallest = smallest[1:]\n\n    # Join the digits to form the numbers\n    smallest = ''.join(smallest)\n    largest = ''.join(largest)\n\n    # Reverse the smallest number to get the correct order of digits\n    smallest = smallest[::-1]\n\n    return smallest + ' ' + largest\n\n# Get the input\nm, s = map(int, input().split())\n\n# Print the output\nprint(find_numbers(m, s))"}
{"solution": "MOD = 998244353\n\ndef solve(l, r, k):\n    dp = [[0] * (1 << 10) for _ in range(20)]\n    dp[0] = [1] * (1 << 10)\n\n    for i in range(1, 20):\n        for mask in range(1 << 10):\n            for digit in range(10):\n                if (mask >> digit) & 1:\n                    dp[i][mask] += dp[i - 1][mask ^ (1 << digit)]\n                    dp[i][mask] %= MOD\n\n    def f(n):\n        if n == 0:\n            return 0\n        digits = [int(d) for d in str(n)]\n        res = 0\n        for i in range(1, len(digits)):\n            for mask in range(1 << 10):\n                if bin(mask).count('1') <= k:\n                    res += dp[i][mask]\n                    res %= MOD\n        mask = 0\n        for i in range(len(digits)):\n            for digit in range(digits[i]):\n                if (mask >> digit) & 1:\n                    continue\n                if bin(mask | (1 << digit)).count('1') > k:\n                    continue\n                res += dp[len(digits) - i - 1][mask | (1 << digit)]\n                res %= MOD\n            if (mask >> digits[i]) & 1:\n                break\n            mask |= (1 << digits[i])\n        else:\n            res += n\n            res %= MOD\n        return res\n\n    return (f(r) - f(l - 1)) % MOD\n\nl, r, k = map(int, input().split())\nprint(solve(l, r, k))"}
{"solution": "def can_distribute_pencils(n, k, d, pencils):\n    pencils.sort()\n    i = 0\n    while i < n:\n        count = 1\n        while i + count < n and pencils[i + count] - pencils[i] <= d:\n            count += 1\n        if count < k:\n            return False\n        i += count\n    return True\n\nn, k, d = map(int, input().split())\npencils = list(map(int, input().split()))\nprint(\"YES\" if can_distribute_pencils(n, k, d, pencils) else \"NO\")"}
{"solution": "def count_dead_light_bulbs(garland):\n    colors = {'R': 0, 'B': 0, 'Y': 0, 'G': 0}\n    for i in range(len(garland)):\n        if garland[i] == '!':\n            if i % 4 == 0:\n                if garland[i+1] != 'R':\n                    colors['R'] += 1\n                elif garland[i+2] != 'B':\n                    colors['B'] += 1\n                elif garland[i+3] != 'G':\n                    colors['G'] += 1\n                else:\n                    colors['Y'] += 1\n            elif i % 4 == 1:\n                if garland[i-1] != 'R':\n                    colors['R'] += 1\n                elif garland[i+1] != 'Y':\n                    colors['Y'] += 1\n                elif garland[i+2] != 'G':\n                    colors['G'] += 1\n                else:\n                    colors['B'] += 1\n            elif i % 4 == 2:\n                if garland[i-2] != 'R':\n                    colors['R'] += 1\n                elif garland[i-1] != 'Y':\n                    colors['Y'] += 1\n                elif garland[i+1] != 'B':\n                    colors['B'] += 1\n                else:\n                    colors['G'] += 1\n            elif i % 4 == 3:\n                if garland[i-3] != 'R':\n                    colors['R'] += 1\n                elif garland[i-2] != 'Y':\n                    colors['Y'] += 1\n                elif garland[i-1] != 'B':\n                    colors['B'] += 1\n                else:\n                    colors['G'] += 1\n    return colors['R'], colors['B'], colors['Y'], colors['G']\n\ngarland = input()\nprint(*count_dead_light_bulbs(garland))"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef main():\n    N, M = map(int, sys.stdin.readline().split())\n    graph = defaultdict(list)\n    for _ in range(M):\n        s, t = map(int, sys.stdin.readline().split())\n        graph[s].append(t)\n\n    dp = [0] * (N + 1)\n    dp[N] = 0\n    for i in range(N - 1, 0, -1):\n        total = 0\n        for j in graph[i]:\n            total += dp[j]\n        dp[i] = total / len(graph[i]) + 1\n\n    min_e = dp[1]\n    for j in graph[1]:\n        if j == N:\n            continue\n        new_e = (dp[1] * len(graph[1]) - 1) / (len(graph[1]) - 1) + 1 + dp[j]\n        min_e = min(min_e, new_e)\n\n    print(min_e)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Get the input number\nn = int(input())\n\n# If the number already ends with 0, print it as it is\nif n % 10 == 0:\n    print(n)\nelse:\n    # Calculate the remainder of the number when divided by 10\n    remainder = n % 10\n\n    # If the remainder is less than or equal to 5, round down to the nearest integer ending with 0\n    if remainder <= 5:\n        print(n - remainder)\n    # If the remainder is greater than 5, round up to the nearest integer ending with 0\n    else:\n        print(n + (10 - remainder))"}
{"solution": "def find_mixed_keys(s, t):\n    key_pairs = {}\n    for i in range(len(s)):\n        if s[i] != t[i]:\n            if s[i] in key_pairs:\n                if key_pairs[s[i]] != t[i]:\n                    return -1\n            else:\n                key_pairs[s[i]] = t[i]\n    return len(key_pairs), key_pairs\n\ns = input()\nt = input()\nresult = find_mixed_keys(s, t)\nif result == -1:\n    print(-1)\nelse:\n    print(result[0])\n    for key, value in result[1].items():\n        print(key, value)"}
{"solution": "def earliest_login(first_name, last_name):\n    # Iterate over the length of the shorter name\n    for i in range(1, min(len(first_name), len(last_name)) + 1):\n        # If the first i characters of the first name are alphabetically earlier than the first i characters of the last name\n        if first_name[:i] < last_name[:i]:\n            # Return the concatenation of the first i characters of the first name and the first character of the last name\n            return first_name[:i] + last_name[0]\n    # If the first name is alphabetically not earlier than the last name, return the first name followed by the first character of the last name\n    return first_name + last_name[0]\n\n# Get the input\nfirst_name, last_name = input().split()\n# Print the output\nprint(earliest_login(first_name, last_name))"}
{"solution": "def draw_brackets(sequence):\n    n = len(sequence)\n    height = n // 2\n    canvas = [[' '] * (2 * n - 1) for _ in range(height)]\n\n    def draw(start, end, row):\n        if start > end:\n            return\n        mid = (start + end) // 2\n        if sequence[mid] == '[':\n            canvas[row][start] = '+'\n            canvas[row][end] = '+'\n            canvas[row][mid] = '-'\n            for i in range(row + 1, height):\n                canvas[i][start] = '|'\n                canvas[i][end] = '|'\n            draw(start + 1, mid - 1, row + 1)\n            draw(mid + 1, end - 1, row + 1)\n        else:\n            canvas[row][start] = '+'\n            canvas[row][end] = '+'\n            canvas[row][mid] = '-'\n            for i in range(row + 1, height):\n                canvas[i][start] = '|'\n                canvas[i][end] = '|'\n            draw(start + 1, mid - 1, row)\n            draw(mid + 1, end - 1, row)\n\n    draw(0, 2 * height - 1, 0)\n    return [''.join(row) for row in canvas]\n\nn = int(input())\nsequence = input()\nresult = draw_brackets(sequence)\nfor row in result:\n    print(row)"}
{"solution": "def golden_value(number):\n    q = (1 + 5 ** 0.5) / 2\n    value = 0\n    for i, digit in enumerate(reversed(number)):\n        value += int(digit) * q ** i\n    return value\n\nnumber1 = input()\nnumber2 = input()\n\nvalue1 = golden_value(number1)\nvalue2 = golden_value(number2)\n\nif value1 > value2:\n    print(\">\")\nelif value1 < value2:\n    print(\"<\")\nelse:\n    print(\"=\")"}
{"solution": "# Define the dictionary of Infinity Gems\ninfinity_gems = {\n    'purple': 'Power',\n    'green': 'Time',\n    'blue': 'Space',\n    'orange': 'Soul',\n    'red': 'Reality',\n    'yellow': 'Mind'\n}\n\n# Get the number of Gems in the Infinity Gauntlet\nn = int(input())\n\n# Get the colors of the Gems in the Infinity Gauntlet\ngems_in_gauntlet = [input() for _ in range(n)]\n\n# Determine the absent Gems\nabsent_gems = [gem_name for gem_color, gem_name in infinity_gems.items() if gem_color not in gems_in_gauntlet]\n\n# Print the number of absent Gems\nprint(len(absent_gems))\n\n# Print the names of the absent Gems\nfor gem in absent_gems:\n    print(gem)"}
{"solution": "def find_meeting_round(n, a, b):\n    round = 1\n    while n > 1:\n        if (a <= n // 2 and b > n // 2) or (a > n // 2 and b <= n // 2):\n            return round if round != 1 else \"Final!\"\n        a = (a + 1) // 2\n        b = (b + 1) // 2\n        n //= 2\n        round += 1\n\nn, a, b = map(int, input().split())\nprint(find_meeting_round(n, a, b))"}
{"solution": "def min_changes(n, p, b):\n    # Create a list to store the visited positions for each skewer\n    visited = [set() for _ in range(n)]\n\n    # Simulate Pavel's plan for 2n seconds\n    for _ in range(2 * n):\n        for i in range(n):\n            # Add the current position to the visited set\n            visited[i].add(p[i])\n\n            # Reverse the skewer if necessary\n            if b[i] == 1:\n                p[i] = n - p[i] + 1\n\n            # Move the skewer to the next position\n            p[i] = p[p[i] - 1]\n\n    # Count the minimum number of changes needed\n    changes = 0\n    for i in range(n):\n        if len(visited[i]) < 2 * n:\n            changes += 2 * n - len(visited[i])\n\n    return changes\n\n# Read the input\nn = int(input())\np = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Print the minimum number of changes needed\nprint(min_changes(n, p, b))"}
{"solution": "# Read input\nv1, v2 = map(int, input().split())\nt, d = map(int, input().split())\n\n# Initialize maximum distance\nmax_distance = v1 * t\n\n# Initialize current speed\ncurrent_speed = v1\n\n# Iterate through each second of the time period\nfor _ in range(1, t):\n    # Calculate the maximum possible speed for this second\n    if current_speed < v2:\n        current_speed = min(current_speed + d, v2)\n    else:\n        current_speed = max(current_speed - d, v2)\n\n    # Add the current speed to the maximum distance\n    max_distance += current_speed\n\n# Print the maximum possible length of the path section\nprint(max_distance)"}
{"solution": "import sys\nfrom itertools import permutations\n\ndef solve(n, m, w, l, v):\n    # Generate all possible orders of the camels\n    for order in permutations(range(n)):\n        # Initialize the left and right positions of the camels\n        left = [0] * n\n        right = [0] * n\n        right[0] = left[0] + w[order[0]]\n\n        # Calculate the positions of the camels\n        for i in range(1, n):\n            left[i] = max(left[i-1], right[i-1])\n            right[i] = left[i] + w[order[i]]\n\n        # Check if the bridge will collapse\n        for i in range(m):\n            if any(left[j] < l[i] < right[j] for j in range(n-1)):\n                break\n            if sum(w[j] for j in range(n) if left[j] <= l[i] <= right[j]) > v[i]:\n                break\n        else:\n            # If the bridge does not collapse, return the minimum possible distance\n            return right[-1] - left[0]\n\n    # If the bridge will collapse, return -1\n    return -1\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    w = list(map(int, sys.stdin.readline().split()))\n    lv = [list(map(int, sys.stdin.readline().split())) for _ in range(m)]\n    l, v = zip(*lv)\n    print(solve(n, m, w, l, v))\n\nif __name__ == '__main__':\n    main()"}
{"solution": "def last_digit_factorial(n):\n    if n == 0:\n        return 1\n    last_digits = [1, 1, 2, 6, 4, 0, 0, 0, 0, 0]\n    return last_digits[n % 10]\n\ndef last_digit_division(a, b):\n    if a > b:\n        return 0\n    if a == b:\n        return 1\n    return (last_digit_division(a, b - 1) * last_digit_factorial(b)) % 10\n\na, b = map(int, input().split())\nprint(last_digit_division(a, b))"}
{"solution": "def min_jumps(n, d, lilies):\n    jumps = [float('inf')] * n\n    jumps[0] = 0\n\n    for i in range(1, n):\n        if lilies[i] == '1':\n            for j in range(max(0, i-d), i):\n                if lilies[j] == '1':\n                    jumps[i] = min(jumps[i], jumps[j] + 1)\n\n    return jumps[n-1] if jumps[n-1] != float('inf') else -1\n\nn, d = map(int, input().split())\nlilies = input()\nprint(min_jumps(n, d, lilies))"}
{"solution": "def is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\nn = int(input())\nfor m in range(1, 1001):\n    if not is_prime(n * m + 1):\n        print(m)\n        break"}
{"solution": "# Initialize variables for the cost of a house, a car, and a computer\nhouse_cost = 1234567\ncar_cost = 123456\ncomputer_cost = 1234\n\n# Get Kolya's initial game-coin score\nn = int(input())\n\n# Iterate through all possible numbers of houses Kolya could have bought\nfor houses in range(n // house_cost + 1):\n    # For each number of houses, iterate through all possible numbers of cars Kolya could have bought\n    for cars in range((n - houses * house_cost) // car_cost + 1):\n        # For each number of houses and cars, calculate the remaining game-coin score\n        remaining = n - houses * house_cost - cars * car_cost\n        # Check if it's a multiple of the computer cost\n        if remaining % computer_cost == 0:\n            # If it is, output \"YES\" and stop the program\n            print(\"YES\")\n            exit(0)\n\n# If no combination is found after checking all possibilities, output \"NO\"\nprint(\"NO\")"}
{"solution": "def read_input():\n    n = int(input())\n    x1, x2 = map(int, input().split())\n    lines = [tuple(map(int, input().split())) for _ in range(n)]\n    return n, x1, x2, lines\n\ndef calculate_intersection(line1, line2):\n    k1, b1 = line1\n    k2, b2 = line2\n    if k1 == k2:\n        return None\n    x = (b2 - b1) / (k1 - k2)\n    return x\n\ndef check_intersection(x, x1, x2):\n    return x1 < x < x2\n\ndef solve(n, x1, x2, lines):\n    lines.sort(key=lambda line: line[0])\n    for i in range(n - 1):\n        x = calculate_intersection(lines[i], lines[i + 1])\n        if x is not None and check_intersection(x, x1, x2):\n            return \"Yes\"\n    return \"No\"\n\ndef main():\n    n, x1, x2, lines = read_input()\n    result = solve(n, x1, x2, lines)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def count_split_weights(n):\n    # Initialize the count of different weights\n    count = 0\n\n    # Initialize the first element of the split\n    first_element = n\n\n    # While the first element is greater than 0\n    while first_element > 0:\n        # Calculate the remaining sum after subtracting the first element\n        remaining_sum = n - first_element\n\n        # Initialize the count of ways to split the remaining sum\n        # with elements equal to the first element\n        split_count = 1\n\n        # While the remaining sum is greater than or equal to the first element\n        while remaining_sum >= first_element:\n            # Subtract the first element from the remaining sum\n            remaining_sum -= first_element\n\n            # Increment the split count\n            split_count += 1\n\n        # Add the split count to the total count\n        count += split_count\n\n        # Decrease the first element\n        first_element -= 1\n\n    # Return the total count\n    return count\n\n# Read the input\nn = int(input())\n\n# Print the output\nprint(count_split_weights(n))"}
{"solution": "# Read the input\nn, k = map(int, input().split())\n\n# Calculate the minimum possible number of good apartments\n# This will be 1 if there is more than one inhabited apartment, 0 otherwise\nmin_good = 1 if k > 1 else 0\n\n# Calculate the maximum possible number of good apartments\n# This will be k if all inhabited apartments are at the ends of the row,\n# n - k if all inhabited apartments are in the middle of the row,\n# and n - 1 if there is one inhabited apartment at one of the ends of the row\nif k == 0 or k == n:\n    max_good = 0\nelif k == 1 or k == n - 1:\n    max_good = n - 1\nelse:\n    max_good = min(k, n - k)\n\n# Print the result\nprint(min_good, max_good)"}
{"solution": "def max_games(n):\n    # Find the highest power of 2 less than or equal to n\n    power = 0\n    while 2 ** (power + 1) <= n:\n        power += 1\n\n    # If n is a power of 2, the winner plays power games\n    if 2 ** power == n:\n        return power\n\n    # Otherwise, the winner plays power + 1 games\n    else:\n        return power + 1\n\n# Read the input\nn = int(input())\n\n# Print the output\nprint(max_games(n))"}
{"solution": "def max_vk_occurrences(s):\n    count = 0\n    i = 0\n    while i < len(s) - 1:\n        if s[i] == 'V' and s[i + 1] == 'K':\n            count += 1\n            i += 2\n        elif s[i] == 'V' and s[i + 1] == 'V':\n            if i < len(s) - 2 and s[i + 2] == 'K':\n                count += 1\n                i += 2\n            else:\n                i += 1\n        else:\n            i += 1\n    if i == len(s) - 1 and s[i] == 'V' and count > 0:\n        count -= 1\n    return count\n\ns = input()\nprint(max_vk_occurrences(s))"}
{"solution": "import math\n\ndef min_segments(n):\n    # Calculate the square root of n\n    sqrt_n = int(math.sqrt(n))\n\n    # Calculate the number of full rows and columns of squares\n    full_rows = full_cols = sqrt_n\n\n    # Calculate the number of remaining squares\n    remaining_squares = n - full_rows * full_cols\n\n    # Calculate the number of additional rows and columns needed\n    additional_rows = additional_cols = 0\n    if remaining_squares > 0:\n        additional_rows = 1\n        additional_cols = 1\n        if remaining_squares > full_rows:\n            additional_cols = 2\n\n    # Calculate the total number of segments needed\n    total_segments = full_rows + full_cols + additional_rows + additional_cols\n\n    return total_segments\n\n# Read the input\nn = int(input())\n\n# Calculate the minimum number of segments needed\nresult = min_segments(n)\n\n# Print the result\nprint(result)"}
{"solution": "# Get the initial weights of Limak and Bob\na, b = map(int, input().split())\n\n# Initialize the number of years\nyears = 0\n\n# Simulate the weight gain of Limak and Bob over time\nwhile a <= b:\n    a *= 3\n    b *= 2\n    years += 1\n\n# Print the number of years it took for Limak to become strictly larger than Bob\nprint(years)"}
{"solution": "def solve(h, n):\n    # Initialize the number of visited nodes\n    visited = 0\n\n    # Initialize the current node as the root\n    current = 1\n\n    # Initialize the command index\n    command_index = 0\n\n    # Initialize the commands string\n    commands = \"LR\" * (2 ** h)\n\n    # Initialize the parent nodes list\n    parents = [0] * (2 ** h + 1)\n\n    # Initialize the visited nodes set\n    visited_nodes = set()\n\n    # Loop until the exit is reached\n    while current != n:\n        # Get the command\n        command = commands[command_index]\n\n        # Calculate the destination node\n        destination = current * 2 if command == 'L' else current * 2 + 1\n\n        # If the destination node is not visited\n        if destination not in visited_nodes:\n            # Add the current node to the visited nodes set\n            visited_nodes.add(current)\n\n            # Increment the number of visited nodes\n            visited += 1\n\n            # Set the parent of the destination node\n            parents[destination] = current\n\n            # Move to the destination node\n            current = destination\n        else:\n            # If the current node is a leaf node\n            if current >= 2 ** h:\n                # Move to the parent of the current node\n                current = parents[current]\n            else:\n                # Skip the current command\n                command_index += 1\n\n    # Return the number of visited nodes\n    return visited\n\n# Get the input\nh, n = map(int, input().split())\n\n# Print the output\nprint(solve(h, n))"}
{"solution": "import math\n\ndef find_pairs(x):\n    pairs = []\n    for n in range(1, int(math.sqrt(x)) + 1):\n        if x % n == 0:\n            m = x // n\n            if n <= m and (m - n) % 2 == 0:\n                pairs.append((n, m))\n    return pairs\n\nx = int(input())\npairs = find_pairs(x)\nk = len(pairs)\nprint(k)\nfor pair in pairs:\n    print(*pair)"}
{"solution": "def is_valid_sequence(sequence):\n    months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    sequence_length = len(sequence)\n\n    for start_index in range(12):\n        is_valid = True\n        for offset in range(sequence_length):\n            if sequence[offset] != months[(start_index + offset) % 12]:\n                is_valid = False\n                break\n        if is_valid:\n            return True\n\n    return False\n\ndef main():\n    n = int(input())\n    sequence = list(map(int, input().split()))\n\n    if is_valid_sequence(sequence):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_fractions(n):\n    # Find all divisors of n that are greater than 1 and less than n\n    divisors = [i for i in range(2, n) if n % i == 0]\n\n    # Initialize an empty list to store the fractions\n    fractions = []\n\n    # Initialize the sum of the fractions\n    fraction_sum = 0\n\n    # Iterate over the divisors\n    for b in divisors:\n        # Calculate the corresponding a\n        a = n // b - 1\n\n        # If a is positive, add the fraction to the list and update the sum\n        if a > 0:\n            fractions.append((a, b))\n            fraction_sum += a / b\n\n    # Check if the sum of the fractions is equal to 1 - 1/n\n    if fraction_sum == 1 - 1 / n:\n        return \"YES\", fractions\n    else:\n        return \"NO\", []\n\n# Read the input\nn = int(input())\n\n# Find the sequence of fractions\nresult, fractions = find_fractions(n)\n\n# Print the output\nprint(result)\nif result == \"YES\":\n    print(len(fractions))\n    for a, b in fractions:\n        print(a, b)"}
{"solution": "def min_unattractiveness(n, a, b, h):\n    # Calculate the total area of the fence\n    total_area = sum(h)\n\n    # If Vasya doesn't have enough paint for the fence, return -1\n    if a + b < total_area:\n        return -1\n\n    # Initialize the minimum unattractiveness value to infinity\n    min_unattractiveness = float('inf')\n\n    # Iterate through all possible ways to paint the fence\n    for i in range(2**n):\n        # Initialize the current unattractiveness value to 0\n        current_unattractiveness = 0\n\n        # Initialize the previous board color to -1\n        prev_color = -1\n\n        # Initialize the red and green paint areas to 0\n        red_area = 0\n        green_area = 0\n\n        # Iterate through each board\n        for j in range(n):\n            # If the current board is painted red\n            if i & (1 << j):\n                # Add the board's height to the red paint area\n                red_area += h[j]\n\n                # If the previous board is painted green, add the board's height to the current unattractiveness value\n                if prev_color == 0:\n                    current_unattractiveness += h[j]\n\n                # Set the previous board color to red\n                prev_color = 1\n\n            # If the current board is painted green\n            else:\n                # Add the board's height to the green paint area\n                green_area += h[j]\n\n                # If the previous board is painted red, add the board's height to the current unattractiveness value\n                if prev_color == 1:\n                    current_unattractiveness += h[j]\n\n                # Set the previous board color to green\n                prev_color = 0\n\n        # If Vasya has enough paint for the current red and green paint areas, update the minimum unattractiveness value\n        if red_area <= a and green_area <= b:\n            min_unattractiveness = min(min_unattractiveness, current_unattractiveness)\n\n    # If the minimum unattractiveness value is still infinity, return -1\n    if min_unattractiveness == float('inf'):\n        return -1\n\n    # Return the minimum unattractiveness value\n    return min_unattractiveness\n\n# Read the input\nn = int(input())\na, b = map(int, input().split())\nh = list(map(int, input().split()))\n\n# Print the minimum unattractiveness value\nprint(min_unattractiveness(n, a, b, h))"}
{"solution": "def find_triangle_points(n, m, k):\n    # Check if it's possible to find such points\n    if n * m < 2 * k:\n        return \"NO\"\n\n    # Try to find the points\n    for x1 in range(n + 1):\n        for y1 in range(m + 1):\n            for x2 in range(x1, n + 1):\n                for y2 in range(m + 1):\n                    # Calculate the area of the triangle\n                    area = abs(x1 * y2 - x2 * y1) / 2\n                    if area == n * m / k:\n                        # Calculate the third point\n                        x3 = k * (y2 - y1)\n                        y3 = k * (x1 - x2)\n                        if 0 <= x3 <= n and 0 <= y3 <= m:\n                            return \"YES\\n{} {}\\n{} {}\\n{} {}\".format(x1, y1, x2, y2, x3, y3)\n\n    # No solution found\n    return \"NO\"\n\n# Read the input\nn, m, k = map(int, input().split())\n\n# Print the result\nprint(find_triangle_points(n, m, k))"}
{"solution": "# Get the input\nn, k = map(int, input().split())\n\n# Check if Sasha wins\nif n > k:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "# Get the number of exercises\nn = int(input())\n\n# Get the list of repetitions for each exercise\nrepetitions = list(map(int, input().split()))\n\n# Initialize the counters for each muscle group\nchest = 0\nbiceps = 0\nback = 0\n\n# Iterate over the exercises\nfor i in range(n):\n    # Determine which muscle group is being exercised\n    if i % 3 == 0:\n        chest += repetitions[i]\n    elif i % 3 == 1:\n        biceps += repetitions[i]\n    else:\n        back += repetitions[i]\n\n# Determine which muscle group got the most exercise\nif chest > biceps and chest > back:\n    print(\"chest\")\nelif biceps > chest and biceps > back:\n    print(\"biceps\")\nelse:\n    print(\"back\")"}
{"solution": "# Read the number of lab works\nn = int(input())\n\n# Read the grades for each lab work\ngrades = list(map(int, input().split()))\n\n# Calculate the current average grade\navg = sum(grades) / n\n\n# Calculate the number of lab works that need to be redone\n# to raise the average to 5 (rounded up)\nnum_to_redo = 0\nwhile avg < 4.5:\n    # Replace the lowest grade with a 5\n    min_grade_index = grades.index(min(grades))\n    grades[min_grade_index] = 5\n\n    # Recalculate the average\n    avg = sum(grades) / n\n\n    # Increment the number of lab works redone\n    num_to_redo += 1\n\n# Print the result\nprint(num_to_redo)"}
{"solution": "def solve(u, v):\n    if u > v or (u & 1) != (v & 1):\n        return -1\n    if u == 0:\n        return [0]\n    if u == v:\n        return [u]\n    if v > u * 2:\n        return -1\n    if (v - u) & u == 0:\n        return [u, v - u]\n    return [u, (v - u) & u, u ^ ((v - u) & u)]\n\nu, v = map(int, input().split())\nresult = solve(u, v)\nif result == -1:\n    print(-1)\nelse:\n    print(len(result))\n    print(' '.join(map(str, result)))"}
{"solution": "def min_digits_1(n):\n    # Initialize the count of digits 1\n    count = 0\n\n    # While n is greater than 0\n    while n > 0:\n        # If n is odd, subtract 1 from it and add the number of digits in 1 to the count\n        if n % 2 == 1:\n            count += len(str(n))\n            n -= 1\n        # If n is even, divide it by 2\n        else:\n            n //= 2\n\n    # Return the count of digits 1\n    return count\n\n# Read the input\nn = int(input())\n\n# Print the expected minimal number of digits 1\nprint(min_digits_1(n))"}
{"solution": "def can_reach_treasure(x1, y1, x2, y2, x, y):\n    # If the potion doesn't move the captain, he can't reach the treasure\n    if x == 0 and y == 0:\n        return False\n\n    # If the treasure is at the same position as the captain, he can reach it\n    if x1 == x2 and y1 == y2:\n        return True\n\n    # If the potion moves the captain in the same direction as the treasure, he can reach it\n    if (x2 - x1) * x > 0 and (y2 - y1) * y > 0:\n        return True\n\n    # If the potion moves the captain in opposite directions to the treasure, he can't reach it\n    if (x2 - x1) * x < 0 and (y2 - y1) * y < 0:\n        return False\n\n    # If the potion moves the captain in the same direction as the x-coordinate of the treasure,\n    # and the y-coordinate of the treasure is a multiple of y, he can reach it\n    if (x2 - x1) * x > 0 and (y2 - y1) % y == 0:\n        return True\n\n    # If the potion moves the captain in the same direction as the y-coordinate of the treasure,\n    # and the x-coordinate of the treasure is a multiple of x, he can reach it\n    if (x2 - x1) % x == 0 and (y2 - y1) * y > 0:\n        return True\n\n    # In all other cases, the captain can't reach the treasure\n    return False\n\n# Get the input\nx1, y1, x2, y2 = map(int, input().split())\nx, y = map(int, input().split())\n\n# Print the output\nif can_reach_treasure(x1, y1, x2, y2, x, y):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "from itertools import permutations\nfrom collections import Counter\nimport math\n\ndef calculate_variants(n):\n    # Count the occurrences of each digit in n\n    digit_count = Counter(str(n))\n\n    # Generate all unique permutations of the digits in n\n    unique_digits = set(str(n))\n    perms = set()\n    for r in range(1, len(unique_digits) + 1):\n        perms.update(permutations(unique_digits, r))\n\n    # Filter out permutations that start with 0\n    perms = [p for p in perms if p[0] != '0']\n\n    # Calculate the number of possible variants for each permutation\n    variants = 0\n    for p in perms:\n        # Calculate the number of ways to arrange the digits in p\n        # using the multinomial theorem\n        denom = 1\n        for count in Counter(p).values():\n            denom *= math.factorial(count)\n        variants += math.factorial(len(p)) // denom\n\n    return variants\n\n# Read input\nn = int(input())\n\n# Calculate and print output\nprint(calculate_variants(n))"}
{"solution": "# Read the input\na = int(input())\nb = int(input())\nc = int(input())\nd = int(input())\ne = int(input())\nf = int(input())\n\n# Calculate the maximum number of suits of the first type that can be composed\nfirst_type_suits = min(a, d)\n\n# Calculate the maximum number of suits of the second type that can be composed\nsecond_type_suits = min(b, c, d)\n\n# Calculate the maximum possible cost of a set of suits\nmax_cost = first_type_suits * e + second_type_suits * f\n\n# Print the result\nprint(max_cost)"}
{"solution": "def power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1:\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\ndef find_solutions(a, b, p, x):\n    inv = power(a, p - 2, p)\n    count = 0\n    curr = b\n    for i in range(1, x + 1):\n        if curr == 1:\n            count += 1\n        curr = (curr * inv) % p\n        if curr == b:\n            break\n    return count\n\na, b, p, x = map(int, input().split())\nprint(find_solutions(a, b, p, x))"}
{"solution": "# Read the input\nk_2, k_3, k_5, k_6 = map(int, input().split())\n\n# Calculate the number of 256 that can be formed\nmin_256 = min(k_2 // 3, k_5)\nk_2 -= min_256 * 3\nk_5 -= min_256\n\n# Calculate the number of 32 that can be formed\nmin_32 = min(k_2, k_3)\nk_2 -= min_32\nk_3 -= min_32\n\n# Calculate the total sum\ntotal_sum = min_256 * 256 + min_32 * 32\n\n# Print the result\nprint(total_sum)"}
{"solution": "def bender_happiness(n, x, y, c):\n    # Initialize the grid with all cells off\n    grid = [[0] * n for _ in range(n)]\n\n    # Switch on the initial cell\n    grid[x - 1][y - 1] = 1\n\n    # Initialize the count of switched on cells\n    count = 1\n\n    # Initialize the time\n    time = 0\n\n    # While the count of switched on cells is less than c\n    while count < c:\n        # Create a copy of the grid\n        new_grid = [row[:] for row in grid]\n\n        # Iterate over each cell in the grid\n        for i in range(n):\n            for j in range(n):\n                # If the cell is off but has a side-adjacent cell that is on\n                if grid[i][j] == 0 and (\n                    (i > 0 and grid[i - 1][j] == 1) or\n                    (i < n - 1 and grid[i + 1][j] == 1) or\n                    (j > 0 and grid[i][j - 1] == 1) or\n                    (j < n - 1 and grid[i][j + 1] == 1)\n                ):\n                    # Switch on the cell\n                    new_grid[i][j] = 1\n\n                    # Increment the count of switched on cells\n                    count += 1\n\n        # Update the grid\n        grid = new_grid\n\n        # Increment the time\n        time += 1\n\n    # Return the time\n    return time\n\n# Read the input\nn, x, y, c = map(int, input().split())\n\n# Print the output\nprint(bender_happiness(n, x, y, c))"}
{"solution": "# Read the input\nl, r = map(int, input().split())\n\n# Calculate the maximum value of a ^ b\nmax_value = 0\nfor i in range(64, -1, -1):\n    if (l >> i) ^ (r >> i) > max_value >> i:\n        max_value |= 1 << i\n\n# Print the result\nprint(max_value)"}
{"solution": "def min_height(n, k):\n    left, right = 0, k\n    while left < right:\n        mid = (left + right) // 2\n        if sum((mid + 1) * ((i // 2) * (mid - (i // 2)) for i in range(1, 2 * n + 1, 2))) >= k:\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\nn, k = map(int, input().split())\nprint(min_height(n, k))"}
{"solution": "# Get the input values\nx, y, z, t1, t2, t3 = map(int, input().split())\n\n# Calculate the time it takes to use the stairs\nstairs_time = abs(x - y) * t1\n\n# Calculate the time it takes to use the elevator\nelevator_time = abs(z - x) * t2 + abs(z - y) * t2 + 2 * t3\n\n# Compare the times and print the result\nif elevator_time <= stairs_time:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "# Read the input\nn, m = map(int, input().split())\n\n# Calculate the midpoint of the range\nmid = (n + 1) // 2\n\n# If Misha's number is less than or equal to the midpoint, Andrew should choose the midpoint\nif m <= mid:\n    print(mid)\n# If Misha's number is greater than the midpoint, Andrew should choose the midpoint minus one\nelse:\n    print(mid - 1)"}
{"solution": "# Read the number of lessons\nn = int(input())\n\n# Read the schedule for the lessons\nschedule = list(map(int, input().split()))\n\n# Initialize the number of pairs Alena stays at the university\npairs_at_university = 0\n\n# Initialize the number of consecutive free pairs\nconsecutive_free_pairs = 0\n\n# Iterate over the schedule\nfor i in range(n):\n    # If there is a class\n    if schedule[i] == 1:\n        # Alena stays at the university\n        pairs_at_university += 1\n        # Reset the number of consecutive free pairs\n        consecutive_free_pairs = 0\n    # If there is no class\n    else:\n        # Increment the number of consecutive free pairs\n        consecutive_free_pairs += 1\n        # If there are at least two consecutive free pairs\n        if consecutive_free_pairs >= 2:\n            # Alena goes home\n            consecutive_free_pairs = 0\n        # Otherwise, Alena stays at the university\n        else:\n            pairs_at_university += 1\n\n# Print the number of pairs Alena stays at the university\nprint(pairs_at_university)"}
{"solution": "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\nbran_candies = 0\ndays = 0\n\nfor i in range(n):\n    bran_candies += min(8, a[i])\n    a[i] -= min(8, a[i])\n    days += 1\n    if bran_candies >= k:\n        print(days)\n        break\n    if i < n - 1 and a[i] > 0:\n        a[i + 1] += a[i]\n\nif bran_candies < k:\n    print(-1)"}
{"solution": "# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Initialize b as a copy of a\nb = a[:]\n\n# Initialize total_walks as 0\ntotal_walks = 0\n\n# Iterate over the days\nfor i in range(n):\n    # If this is the first day\n    if i == 0:\n        # If Polycarp hasn't planned enough walks for today\n        if b[i] < k:\n            # Add enough walks to meet the minimum requirement\n            b[i] = k\n            total_walks += k - a[i]\n    # If this is not the first day\n    else:\n        # If Polycarp hasn't planned enough walks for today\n        if b[i] < b[i-1] + k - 1:\n            # Add enough walks to meet the minimum requirement\n            b[i] = b[i-1] + k - 1\n            total_walks += b[i] - a[i]\n\n# Print the minimum number of additional walks\nprint(total_walks)\n\n# Print the schedule\nprint(' '.join(map(str, b)))"}
{"solution": "# Get the order of the rhombus from the user\nn = int(input(\"Enter the order of the rhombus: \"))\n\n# Calculate the number of cells in the n-th order rhombus using the formula: n^2 + (n-1)^2\nnum_cells = n**2 + (n-1)**2\n\n# Print the result\nprint(\"The number of cells in the rhombus is:\", num_cells)"}
{"solution": "# Get the length of the string\nn = int(input())\n\n# Get the string\ns = input()\n\n# Convert the string to lowercase\ns = s.lower()\n\n# Create a set of all the letters in the alphabet\nalphabet = set('abcdefghijklmnopqrstuvwxyz')\n\n# Check if all the letters in the alphabet are in the string\nif set(s) == alphabet:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "# Read the input\ncurrent_time = input().split(':')\nminutes_to_add = int(input())\n\n# Convert the current time to minutes\ncurrent_minutes = int(current_time[0]) * 60 + int(current_time[1])\n\n# Add the minutes\nnew_minutes = current_minutes + minutes_to_add\n\n# Convert the new time back to hours and minutes\nnew_hours = new_minutes // 60\nnew_minutes = new_minutes % 60\n\n# Handle the case when the hours exceed 24\nnew_hours = new_hours % 24\n\n# Print the result with leading zeros\nprint(f'{new_hours:02d}:{new_minutes:02d}')"}
{"solution": "# Read input\nn, m = map(int, input().split())\nswitches = [list(map(int, input())) for _ in range(n)]\n\n# Function to check if all lamps are on\ndef all_lamps_on(state):\n    for j in range(m):\n        if all(state[i] == 0 or switches[i][j] == 0 for i in range(n)):\n            return False\n    return True\n\n# Check each switch\nfor i in range(n):\n    # Create a state where the i-th switch is ignored\n    state = [1] * n\n    state[i] = 0\n    # Check if all lamps are on\n    if all_lamps_on(state):\n        print(\"YES\")\n        exit()\n\n# If no switch can be ignored, print \"NO\"\nprint(\"NO\")"}
{"solution": "n = int(input())\nupper_sum = 0\nlower_sum = 0\nswaps = 0\n\nfor _ in range(n):\n    x, y = map(int, input().split())\n    upper_sum += x\n    lower_sum += y\n    if x % 2 != y % 2:\n        swaps += 1\n\nif upper_sum % 2 == 0 and lower_sum % 2 == 0:\n    print(0)\nelif upper_sum % 2 != 0 and lower_sum % 2 != 0:\n    if swaps % 2 == 0:\n        print(-1)\n    else:\n        print(1)\nelse:\n    if swaps % 2 == 0:\n        print(1)\n    else:\n        print(-1)"}
{"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nt = int(input())\nfor _ in range(t):\n    a, b = map(int, input().split())\n    area = a**2 - b**2\n    if is_prime(area):\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "n = int(input())\npoints = [list(map(int, input().split())) for _ in range(n)]\n\n# Separate points into left and right of OY axis\nleft_points = [point for point in points if point[0] < 0]\nright_points = [point for point in points if point[0] > 0]\n\n# Check if all points on one side are above or below OY axis\ndef check_side(points):\n    if not points:\n        return True\n    sign = points[0][1] > 0\n    for point in points:\n        if (point[1] > 0) != sign:\n            return False\n    return True\n\n# Check if there is a point that can be removed\nif check_side(left_points) or check_side(right_points):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "import math\n\n# Get the input\nA, B = map(int, input().split())\n\n# Calculate the factorial of A and B\nfactorial_A = math.factorial(A)\nfactorial_B = math.factorial(B)\n\n# Calculate the greatest common divisor of factorial_A and factorial_B\ngcd = math.gcd(factorial_A, factorial_B)\n\n# Print the result\nprint(gcd)"}
{"solution": "def is_composite(num):\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return True\n    return False\n\ndef find_composites(n):\n    a = n + 4\n    while not is_composite(a):\n        a += 1\n    b = a - n\n    return a, b\n\nn = int(input())\na, b = find_composites(n)\nprint(a, b)"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef max_score(n, m, p, edges):\n    graph = defaultdict(list)\n    for a, b, c in edges:\n        graph[a].append((b, c))\n\n    dp = [0] * (n + 1)\n    for t in range(1, n + 1):\n        for u, v, c in edges:\n            dp[v] = max(dp[v], dp[u] + c - (p if v == n and t > 1 else 0))\n\n    return dp[n]\n\ndef main():\n    n, m, p = map(int, sys.stdin.readline().split())\n    edges = [tuple(map(int, sys.stdin.readline().split())) for _ in range(m)]\n    print(max_score(n, m, p, edges))\n\nif __name__ == '__main__':\n    main()"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef min_palindrome_cost():\n    n = int(sys.stdin.readline())\n    strings = []\n    costs = []\n    for _ in range(n):\n        s, c = sys.stdin.readline().split()\n        strings.append(s)\n        costs.append(int(c))\n\n    # Create a dictionary to store the cost of the first character of each string\n    first_char_cost = defaultdict(lambda: float('inf'))\n    for s, c in zip(strings, costs):\n        first_char_cost[s[0]] = min(first_char_cost[s[0]], c)\n\n    # Create a dictionary to store the cost of the last character of each string\n    last_char_cost = defaultdict(lambda: float('inf'))\n    for s, c in zip(strings, costs):\n        last_char_cost[s[-1]] = min(last_char_cost[s[-1]], c)\n\n    # Initialize the minimum cost to infinity\n    min_cost = float('inf')\n\n    # Iterate over all possible middle characters\n    for c in range(26):\n        middle_char = chr(ord('a') + c)\n\n        # If the middle character is not present in any string, skip it\n        if middle_char not in first_char_cost or middle_char not in last_char_cost:\n            continue\n\n        # Calculate the cost of the middle character\n        middle_cost = first_char_cost[middle_char] + last_char_cost[middle_char]\n\n        # If the middle character is the same as the first character of a string and the same as the last character of another string,\n        # we can use these strings to make a palindrome with a lower cost\n        for s, c in zip(strings, costs):\n            if s[0] == middle_char and s[-1] == middle_char:\n                middle_cost = min(middle_cost, c)\n\n        # Update the minimum cost\n        min_cost = min(min_cost, middle_cost)\n\n    # If the minimum cost is still infinity, it means that there is no choice of strings in which Takahashi can make a palindrome\n    if min_cost == float('inf'):\n        return -1\n    else:\n        return min_cost\n\nprint(min_palindrome_cost())"}
{"solution": "def max_xor_sum(n, k):\n    # If k is equal to n, the maximum xor-sum is n\n    if k == n:\n        return n\n\n    # If k is even, the maximum xor-sum is n ^ (n-1) ^ (n-2) ^ ... ^ (n-k+1)\n    # If k is odd, the maximum xor-sum is n ^ (n-1) ^ (n-2) ^ ... ^ (n-k)\n    # This is because the xor of an even number of the same bits is 0,\n    # and the xor of an odd number of the same bits is the same bit.\n    # So, we want to xor as many of the highest bits as possible.\n    if k % 2 == 0:\n        return n ^ (n-1) ^ (n-2) ^ ... ^ (n-k+1)\n    else:\n        return n ^ (n-1) ^ (n-2) ^ ... ^ (n-k)\n\n# Read the input\nn, k = map(int, input().split())\n\n# Print the output\nprint(max_xor_sum(n, k))"}
{"solution": "# Read the number of points\nn = int(input())\n\n# Initialize the maximum x-coordinate and y-coordinate\nmax_x = 0\nmax_y = 0\n\n# Read the coordinates of each point and update the maximum x-coordinate and y-coordinate\nfor _ in range(n):\n    x, y = map(int, input().split())\n    max_x = max(max_x, x)\n    max_y = max(max_y, y)\n\n# Calculate the minimum length of the shorter side of the triangle\nshorter_side = min(max_x, max_y)\n\n# Print the result\nprint(shorter_side)"}
{"solution": "def max_nineteens(s):\n    # Count the number of each character in the string\n    count = {'n': s.count('n'), 'i': s.count('i'), 'e': s.count('e'), 'g': s.count('g'), 't': s.count('t')}\n\n    # The number of 'nineteen's is limited by the number of 'n's and 'e's\n    # Each 'nineteen' requires 3 'n's and 3 'e's, and 2 each of 'i', 'g', and 't'\n    max_nineteens = min(count['n'] // 3, count['e'] // 3)\n\n    # Check if there are enough 'i's, 'g's, and 't's to form 'nineteen's\n    max_nineteens = min(max_nineteens, count['i'] // 2, count['g'] // 2, count['t'] // 2)\n\n    return max_nineteens\n\n# Get the input string\ns = input()\n\n# Print the maximum number of 'nineteen's that can be formed\nprint(max_nineteens(s))"}
{"solution": "def highest_branch(p, y):\n    # Create a list of all branches that are occupied by grasshoppers\n    occupied_branches = set()\n    for x in range(2, p + 1):\n        j = 2\n        while j * x <= y:\n            occupied_branches.add(j * x)\n            j += 1\n\n    # Find the highest branch that is not occupied\n    for branch in range(y, 1, -1):\n        if branch not in occupied_branches:\n            return branch\n\n    # If no suitable branch is found\n    return -1\n\n# Read input\np, y = map(int, input().split())\n\n# Print output\nprint(highest_branch(p, y))"}
{"solution": "# Read the input\nn, m, k = map(int, input().split())\nhouses = list(map(int, input().split()))\n\n# Initialize variables to store the minimum distance and the current distance\nmin_distance = float('inf')\n\n# Iterate through the houses\nfor i in range(1, n + 1):\n    # Check if the price is less than or equal to Zane's budget\n    if houses[i - 1] <= k:\n        # Calculate the distance from the girl's house to the current house\n        distance = abs(m - i) * 10\n        # Update the minimum distance if the current distance is smaller\n        min_distance = min(min_distance, distance)\n\n# Print the minimum distance as the output\nprint(min_distance)"}
{"solution": "def solve():\n    n, m = map(int, input().split())\n    A = [list(map(int, input().split())) for _ in range(n)]\n    B = [list(map(int, input().split())) for _ in range(n)]\n\n    # Sort the rows of both matrices\n    A = [sorted(row) for row in A]\n    B = [sorted(row) for row in B]\n\n    # Check if the sorted matrices are equal\n    if A == B:\n        print(\"YES\")\n        return\n\n    # Check if it's possible to transform A into B\n    for i in range(n):\n        for j in range(m):\n            if A[i][j] != B[i][j]:\n                # Find the index of the element in A\n                x, y = next((i, j) for i in range(n) for j in range(m) if A[i][j] == B[i][j])\n\n                # Check if the submatrix with top left corner at (i, j) and bottom right corner at (x, y) is a square\n                if x - i == y - j:\n                    # Transpose the submatrix\n                    for k in range(i, x + 1):\n                        for l in range(j, y + 1):\n                            A[k][l], A[l][k] = A[l][k], A[k][l]\n\n    # Check if the transformed matrix A is equal to B\n    if A == B:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nsolve()"}
{"solution": "def longest_uncommon_subsequence(a, b):\n    # If the strings are equal, there is no uncommon subsequence\n    if a == b:\n        return -1\n    # Otherwise, the longest uncommon subsequence is the length of the longer string\n    else:\n        return max(len(a), len(b))\n\n# Get the input strings\na = input()\nb = input()\n\n# Print the length of the longest uncommon subsequence\nprint(longest_uncommon_subsequence(a, b))"}
{"solution": "# Get the input\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Calculate the first scream times for Rick and Morty\nrick_first_scream = b\nmorty_first_scream = d\n\n# Calculate the difference between Rick and Morty's scream intervals\ndifference = abs(a - c)\n\n# If Rick and Morty's scream intervals are the same, they will scream at the same time at their first scream time\nif a == c:\n    print(rick_first_scream)\n# If Rick and Morty's scream intervals are not the same, they will scream at the same time if the difference between their first scream times is a multiple of their scream interval difference\nelif (morty_first_scream - rick_first_scream) % difference == 0:\n    # Calculate the number of screams until they scream at the same time\n    screams_until_same_time = (morty_first_scream - rick_first_scream) // difference\n    # Calculate the time of the first scream at the same time\n    print(rick_first_scream + screams_until_same_time * a)\n# If Rick and Morty's scream intervals are not the same and the difference between their first scream times is not a multiple of their scream interval difference, they will never scream at the same time\nelse:\n    print(-1)"}
{"solution": "n = int(input())\n\n# If n is not a multiple of 3, we can split it into three parts\nif n % 3 != 0:\n    # Start with a = 1, b = 2, and c = n - 3\n    a, b, c = 1, 2, n - 3\n    # If c is a multiple of 3, we need to adjust a and b\n    if c % 3 == 0:\n        a, b, c = 2, 1, n - 3\n    print(a, b, c)\nelse:\n    # If n is a multiple of 3, we need to find a different solution\n    # Start with a = 1, b = 4, and c = n - 5\n    a, b, c = 1, 4, n - 5\n    # If c is a multiple of 3, we need to adjust a and b\n    if c % 3 == 0:\n        a, b, c = 4, 1, n - 5\n    print(a, b, c)"}
{"solution": "def find_squares(n, a, b, c, d):\n    # Calculate the sum of the top left square\n    top_left_sum = a + b + b + d\n\n    # Calculate the possible values for the remaining cells\n    possible_values = set(range(1, n + 1)) - {a, b, c, d}\n\n    # Initialize the count of distinct squares\n    count = 0\n\n    # Iterate through all possible values for the remaining cells\n    for i in possible_values:\n        for j in possible_values:\n            # Check if the sum of the remaining square is equal to the top left square\n            if i + j + c + d == top_left_sum:\n                count += 1\n\n    # Return the count of distinct squares\n    return count\n\n# Read the input\nn, a, b, c, d = map(int, input().split())\n\n# Print the output\nprint(find_squares(n, a, b, c, d))"}
{"solution": "# Get the initial weight and height of the snowball\nw, h = map(int, input().split())\n\n# Get the weight and height of the first stone\nu1, d1 = map(int, input().split())\n\n# Get the weight and height of the second stone\nu2, d2 = map(int, input().split())\n\n# Simulate the descent of the snowball\nwhile h > 0:\n    # Increase the weight of the snowball by its current height\n    w += h\n\n    # Check if the snowball hits a stone\n    if h == d1:\n        # Decrease the weight of the snowball by the weight of the stone\n        w = max(0, w - u1)\n    elif h == d2:\n        # Decrease the weight of the snowball by the weight of the stone\n        w = max(0, w - u2)\n\n    # Move the snowball one meter down\n    h -= 1\n\n# Print the final weight of the snowball\nprint(w)"}
{"solution": "# Read input\nm = int(input())\nscores = list(map(int, input().split()))\nx, y = map(int, input().split())\n\n# Initialize variables\nbeginner_group = 0\nintermediate_group = sum(scores)\npassing_rate = m\n\n# Iterate through possible passing rates\nfor k in range(m, 0, -1):\n    # Calculate size of beginner group\n    beginner_group += scores[k - 1]\n    intermediate_group -= scores[k - 1]\n\n    # Check if groups meet size requirements\n    if x <= beginner_group <= y and x <= intermediate_group <= y:\n        passing_rate = k\n        break\n\n# Print output\nprint(passing_rate)"}
{"solution": "def min_coins(n, k, A, B):\n    coins = 0\n    while n > 1:\n        if n % k == 0 and B < A:\n            n //= k\n            coins += B\n        else:\n            n -= 1\n            coins += A\n    return coins\n\nn = int(input())\nk = int(input())\nA = int(input())\nB = int(input())\n\nprint(min_coins(n, k, A, B))"}
{"solution": "import math\n\ndef min_operations(n):\n    # Initialize minimum value and number of operations\n    min_val = n\n    min_ops = 0\n\n    # Loop while n is greater than 1\n    while n > 1:\n        # Initialize flag to check if n is divisible by any integer greater than 1\n        divisible = False\n\n        # Loop through all integers from 2 to the square root of n\n        for i in range(2, int(math.sqrt(n)) + 1):\n            # If n is divisible by i, multiply n by i and increment number of operations\n            if n % i == 0:\n                n *= i\n                min_ops += 1\n                divisible = True\n                break\n\n        # If n is not divisible by any integer greater than 1, take the square root of n\n        if not divisible:\n            n = int(math.sqrt(n))\n            min_ops += 1\n\n        # Update minimum value\n        min_val = min(min_val, n)\n\n    # Return minimum value and number of operations\n    return min_val, min_ops\n\n# Read input\nn = int(input())\n\n# Print output\nmin_val, min_ops = min_operations(n)\nprint(min_val, min_ops)"}
{"solution": "# Read input\nn, k = map(int, input().split())\nr, s, p = map(int, input().split())\nt = input()\n\n# Initialize score and previous hands array\nscore = 0\nprev_hands = [-1] * k\n\n# Iterate over each round\nfor i in range(n):\n    # Determine the machine's hand\n    machine_hand = t[i]\n\n    # Determine the best hand to play based on the machine's hand and previous hands\n    if machine_hand == 'r':\n        best_hand = 'p'\n    elif machine_hand == 's':\n        best_hand = 'r'\n    else:\n        best_hand = 's'\n\n    # Check if the best hand was used in the previous k rounds\n    if i >= k and best_hand == prev_hands[i % k]:\n        # If it was, skip this round\n        continue\n\n    # Update the previous hands array\n    if i >= k:\n        prev_hands[i % k] = best_hand\n\n    # Update the score\n    if best_hand == 'r':\n        score += r\n    elif best_hand == 's':\n        score += s\n    else:\n        score += p\n\n# Print the maximum total score\nprint(score)"}
{"solution": "# Get the input values\na, b, c = map(int, input().split())\n\n# Calculate the maximum possible length of the good string\nmax_length = 0\n\n# If there are no \"ab\" strings, the maximum length is the sum of the lengths of the \"a\" and \"b\" strings\nif c == 0:\n    max_length = a + b\n# If there are \"ab\" strings, the maximum length is the sum of the lengths of all the strings\nelse:\n    # If there are more \"a\" strings than \"b\" strings, we can use all the \"ab\" strings and one extra \"a\" string\n    if a > b:\n        max_length = 2 * c + 1 + 2 * (a - b - 1)\n    # If there are more \"b\" strings than \"a\" strings, we can use all the \"ab\" strings and one extra \"b\" string\n    elif b > a:\n        max_length = 2 * c + 1 + 2 * (b - a - 1)\n    # If there are equal numbers of \"a\" and \"b\" strings, we can use all the \"ab\" strings\n    else:\n        max_length = 2 * c\n\n# Print the maximum possible length\nprint(max_length)"}
{"solution": "def calculate_marks(n, k, p, x, y, marks):\n    # Calculate the sum of marks Vova needs to get for the remaining tests\n    remaining_sum = x - sum(marks)\n\n    # Calculate the number of tests Vova needs to get a mark of y to maintain the median\n    median_tests = (n + 1) // 2 - k\n\n    # If Vova needs to get a mark of y for more tests than remaining, return -1\n    if median_tests * y > remaining_sum:\n        return -1\n\n    # Calculate the marks Vova needs to get for the remaining tests\n    remaining_marks = [y] * median_tests + [1] * (n - k - median_tests)\n\n    # Distribute the remaining sum evenly among the remaining marks\n    remaining_sum -= median_tests * y\n    for i in range(n - k - median_tests):\n        if remaining_sum > p - 1:\n            remaining_marks[median_tests + i] += p - 1\n            remaining_sum -= p - 1\n        else:\n            remaining_marks[median_tests + i] += remaining_sum\n            remaining_sum = 0\n\n    return remaining_marks\n\n# Read input\nn, k, p, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Calculate and print output\noutput = calculate_marks(n, k, p, x, y, marks)\nif output == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, output)))"}
{"solution": "def is_berlanese(word):\n    vowels = set('aeiou')\n    consonants = set('bcdfghjklmnpqrstvwxyz')\n\n    for i in range(len(word)):\n        if word[i] in consonants:\n            if word[i] == 'n':\n                continue\n            elif i == len(word) - 1 or word[i + 1] not in vowels:\n                return 'NO'\n    return 'YES'\n\nword = input()\nprint(is_berlanese(word))"}
{"solution": "def max_dominoes(n, m, edges):\n    # Create an adjacency list to represent the graph\n    graph = [[] for _ in range(n + 1)]\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    # Function to check if it's possible to place dominoes on the graph\n    def is_possible(k):\n        # Create a list to store the number of dots on the halves of dominoes directed towards each vertex\n        dots = [0] * (n + 1)\n\n        # Function to perform DFS and check if it's possible to place dominoes on the graph\n        def dfs(node, parent, dot):\n            dots[node] = dot\n            for neighbor in graph[node]:\n                if neighbor == parent:\n                    continue\n                if dots[neighbor] == 0:\n                    if not dfs(neighbor, node, k - dot):\n                        return False\n                elif dots[neighbor] != k - dot:\n                    return False\n            return True\n\n        # Perform DFS for each connected component of the graph\n        for i in range(1, n + 1):\n            if dots[i] == 0:\n                if not dfs(i, 0, 1):\n                    return False\n        return True\n\n    # Binary search for the maximum number of dominoes that can be placed on the graph\n    left, right = 0, 6\n    while left < right:\n        mid = (left + right + 1) // 2\n        if is_possible(mid):\n            left = mid\n        else:\n            right = mid - 1\n\n    return left * m // 21\n\n# Read input\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Print output\nprint(max_dominoes(n, m, edges))"}
{"solution": "import sys\n\ndef max_points(n, m, a, b):\n    b = set(b)\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = dp[i - 1]\n        if i in b:\n            for j in range(i, 0, -1):\n                if dp[j - 1] >= a[i - 1]:\n                    dp[i] = max(dp[i], dp[j - 1] + a[i - 1])\n        else:\n            dp[i] = max(dp[i - 1] + a[i - 1], dp[i - 2] - a[i - 1])\n    return dp[n]\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n    print(max_points(n, m, a, b))\n\nif __name__ == '__main__':\n    main()"}
{"solution": "# Get the input\nm = list(map(int, input().split()))\nw = list(map(int, input().split()))\nh = list(map(int, input().split()))\n\n# Define the maximum point values for each problem\nmax_points = [500, 1000, 1500, 2000, 2500]\n\n# Calculate the score for each problem\nscores = []\nfor i in range(5):\n    score = max(0.3 * max_points[i], (1 - m[i] / 250) * max_points[i] - 50 * w[i])\n    scores.append(score)\n\n# Calculate the total score\ntotal_score = sum(scores) + 100 * h[0] - 50 * h[1]\n\n# Print the final score\nprint(int(total_score))"}
{"solution": "MOD = 998244353\n\ndef solve(n, m, L, R):\n    dp = [[0] * (R - L + 1) for _ in range(n * m + 1)]\n    dp[0][0] = 1\n\n    for i in range(n * m):\n        for j in range(R - L + 1):\n            dp[i + 1][j] = (dp[i + 1][j] + dp[i][j]) % MOD\n            if j + 1 <= R - L:\n                dp[i + 1][j + 1] = (dp[i + 1][j + 1] + dp[i][j]) % MOD\n            if j - 1 >= 0:\n                dp[i + 1][j - 1] = (dp[i + 1][j - 1] + dp[i][j] * 2) % MOD\n\n    return sum(dp[n * m][j] for j in range(R - L + 1)) % MOD\n\nn, m, L, R = map(int, input().split())\nprint(solve(n, m, L, R))"}
{"solution": "def check_possible(n, m, matrix1, matrix2):\n    for i in range(n):\n        for j in range(m):\n            if matrix1[i][j] > matrix2[i][j]:\n                matrix1[i], matrix2[i] = matrix2[i], matrix1[i]\n\n    for i in range(n):\n        for j in range(m):\n            if i > 0 and matrix1[i][j] <= matrix1[i-1][j]:\n                return False\n            if j > 0 and matrix1[i][j] <= matrix1[i][j-1]:\n                return False\n            if i > 0 and matrix2[i][j] <= matrix2[i-1][j]:\n                return False\n            if j > 0 and matrix2[i][j] <= matrix2[i][j-1]:\n                return False\n    return True\n\nn, m = map(int, input().split())\nmatrix1 = [list(map(int, input().split())) for _ in range(n)]\nmatrix2 = [list(map(int, input().split())) for _ in range(n)]\n\nif check_possible(n, m, matrix1, matrix2):\n    print(\"Possible\")\nelse:\n    print(\"Impossible\")"}
{"solution": "# Read the input\nn = int(input())\na = list(map(int, input().split()))\n\n# Sort the input in descending order\na.sort(reverse=True)\n\n# Initialize the result\nresult = 0\n\n# Initialize the number of occurrences of the current letter\noccurrences = a[0]\n\n# Iterate over the sorted list\nfor i in range(n):\n    # If the current letter can be added to the string\n    if occurrences > 0:\n        # Add it to the string\n        result += occurrences\n        # Decrease the number of occurrences for the next letter\n        occurrences -= 1\n    # If the current letter cannot be added to the string\n    else:\n        # Break the loop\n        break\n\n# Print the result\nprint(result)"}
{"solution": "# Read input\nn, k = map(int, input().split())\nproblems = list(map(int, input().split()))\n\n# Sort the problems in ascending order of difficulty\nproblems.sort()\n\n# Initialize the number of problems Makes needs to solve on other judges\nadditional_problems = 0\n\n# Iterate through the problems\nfor problem in problems:\n    # If Makes cannot solve the current problem\n    if problem > 2 * k:\n        # Calculate the minimum difficulty level he needs to solve a problem on another judge\n        additional_problem = (problem + 1) // 2\n        # Update the number of problems he needs to solve on other judges\n        additional_problems += 1\n        # Update Makes' maximum difficulty level\n        k = additional_problem\n    else:\n        # Update Makes' maximum difficulty level\n        k = problem\n\n# Print the result\nprint(additional_problems)"}
{"solution": "def distribute_diplomas(n, min_1, max_1, min_2, max_2, min_3, max_3):\n    # Start by giving out the maximum possible diplomas of the third degree\n    third_degree = min(max_3, n - min_1 - min_2)\n\n    # Then, give out the maximum possible diplomas of the second degree\n    second_degree = min(max_2, n - min_1 - third_degree)\n\n    # Finally, give out the remaining diplomas of the first degree\n    first_degree = n - second_degree - third_degree\n\n    # If the number of diplomas of the first degree is less than the minimum required,\n    # we need to redistribute some diplomas from the second and third degrees\n    if first_degree < min_1:\n        # First, try to take diplomas from the third degree\n        third_degree -= min(third_degree - min_3, min_1 - first_degree)\n        # Then, take diplomas from the second degree\n        second_degree -= min(second_degree - min_2, min_1 - first_degree)\n        # Update the number of diplomas of the first degree\n        first_degree = n - second_degree - third_degree\n\n    # Return the optimal distribution of diplomas\n    return first_degree, second_degree, third_degree\n\n# Read the input\nn = int(input())\nmin_1, max_1 = map(int, input().split())\nmin_2, max_2 = map(int, input().split())\nmin_3, max_3 = map(int, input().split())\n\n# Distribute the diplomas\nfirst_degree, second_degree, third_degree = distribute_diplomas(n, min_1, max_1, min_2, max_2, min_3, max_3)\n\n# Print the output\nprint(first_degree, second_degree, third_degree)"}
{"solution": "# Read the input\nn = int(input())\nrecords = list(map(int, input().split()))\n\n# Define the moon cycle\nmoon_cycle = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n\n# Check if the records match the end of the moon cycle\nif records == moon_cycle[-n:]:\n    print(\"DOWN\")\n# Check if the records match the start of the moon cycle\nelif records == moon_cycle[:n]:\n    print(\"UP\")\n# If the records do not match either end of the cycle, it's impossible to determine\nelse:\n    print(-1)"}
{"solution": "def is_transformable(s, t):\n    vowels = set('aeiou')\n    for char_s, char_t in zip(s, t):\n        if char_s != char_t:\n            if (char_s in vowels) != (char_t in vowels):\n                return False\n    return True\n\ns = input()\nt = input()\n\nif len(s) != len(t):\n    print(\"No\")\nelse:\n    if is_transformable(s, t):\n        print(\"Yes\")\n    else:\n        print(\"No\")"}
{"solution": "def check_winner(board):\n    # Check if any white pawn is on the row 2\n    if any('W' in row for row in board[1:2]):\n        return 'A'\n    # Check if any black pawn is on the row 7\n    if any('B' in row for row in board[6:7]):\n        return 'B'\n    # Check if any white pawn is blocking a black pawn from reaching the row 8\n    for i in range(2, 8):\n        for j in range(8):\n            if board[i][j] == 'W' and board[i-1][j] == 'B':\n                return 'A'\n    # If none of the above conditions are met, then player B will win\n    return 'B'\n\n# Read the input\nboard = [input() for _ in range(8)]\n\n# Print the winner\nprint(check_winner(board))"}
{"solution": "def max_length(A, B):\n    n, m = len(A), len(B)\n    i, j, sum_A, sum_B = 0, 0, 0, 0\n    max_len = 0\n\n    while i < n and j < m:\n        sum_A += A[i]\n        sum_B += B[j]\n\n        while i < n - 1 and sum_A < sum_B:\n            i += 1\n            sum_A += A[i]\n\n        while j < m - 1 and sum_B < sum_A:\n            j += 1\n            sum_B += B[j]\n\n        if sum_A == sum_B:\n            max_len = max(max_len, i + 1, j + 1)\n            i += 1\n            j += 1\n            sum_A = 0\n            sum_B = 0\n        elif sum_A < sum_B:\n            i += 1\n            sum_A = 0\n        else:\n            j += 1\n            sum_B = 0\n\n    return max_len\n\nn = int(input())\nA = list(map(int, input().split()))\nm = int(input())\nB = list(map(int, input().split()))\n\nprint(max_length(A, B))"}
{"solution": "def is_contest_problem(problem_name):\n    friends = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\n    count = 0\n    for friend in friends:\n        if friend in problem_name:\n            count += problem_name.count(friend)\n    return count == 1\n\nproblem_name = input()\nprint(\"YES\" if is_contest_problem(problem_name) else \"NO\")"}
{"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef min_length(a, b, k):\n    primes = [is_prime(i) for i in range(b + 1)]\n    prime_count = [0] * (b - a + 2)\n    for i in range(a, b + 1):\n        prime_count[i - a] = prime_count[i - a - 1] + primes[i]\n    for l in range(1, b - a + 2):\n        if all(prime_count[i + l - 1] - prime_count[i - 1] >= k for i in range(a, b - l + 2)):\n            return l\n    return -1\n\na, b, k = map(int, input().split())\nprint(min_length(a, b, k))"}
{"solution": "def calculate_min_x(a, h, w):\n    # Calculate the maximum number of photos that can fit in the wall\n    max_photos_h = h // a\n    max_photos_w = w // a\n\n    # Check if it's possible to put at least one photo on the wall\n    if max_photos_h == 0 or max_photos_w == 0:\n        return -1\n\n    # Calculate the minimum value of x\n    min_x_h = (h - max_photos_h * a) / (max_photos_h + 1)\n    min_x_w = (w - max_photos_w * a) / (max_photos_w + 1)\n\n    # Return the maximum of min_x_h and min_x_w\n    return max(min_x_h, min_x_w)\n\n# Read the input\na, h, w = map(int, input().split())\n\n# Calculate and print the minimum value of x\nresult = calculate_min_x(a, h, w)\nprint(result)"}
{"solution": "# Read the number of chapters\nn = int(input())\n\n# Initialize a counter for unread chapters\nunread_chapters = 0\n\n# Iterate through each chapter\nfor i in range(n):\n    # Read the start and end pages of the chapter\n    start, end = map(int, input().split())\n\n    # Read the marked page\n    marked_page = int(input())\n\n    # If the marked page is within the chapter, increment the counter and break the loop\n    if start <= marked_page <= end:\n        unread_chapters = n - i\n        break\n\n# If the loop completes without breaking, all chapters have been read\nelse:\n    unread_chapters = 0\n\n# Print the result\nprint(unread_chapters)"}
{"solution": "def check_substring(banner):\n    target = \"CODEFORCES\"\n    len_target = len(target)\n    len_banner = len(banner)\n\n    # Check if target is a substring of banner\n    if target in banner:\n        return True\n\n    # Check if target can be formed by removing a substring from the beginning or end of banner\n    for i in range(len_target):\n        if banner.startswith(target[i:]):\n            return True\n        if banner.endswith(target[:len_target - i]):\n            return True\n\n    # Check if target can be formed by removing a substring from the middle of banner\n    for i in range(len_banner - len_target + 1):\n        for j in range(i + len_target, len_banner + 1):\n            if banner[:i] + banner[j:] == target:\n                return True\n\n    return False\n\nbanner = input()\nprint(\"YES\" if check_substring(banner) else \"NO\")"}
{"solution": "# Read the input\nn = int(input())\n\n# Calculate the minimum weight\nif n % 2 == 0:\n    # If n is even, the optimal triangulation is to divide the polygon into two triangles along the diagonal\n    min_weight = (n // 2) * (n // 2 + 1) + (n // 2) * (n // 2 + 1) * n\nelse:\n    # If n is odd, the optimal triangulation is to divide the polygon into two triangles along the diagonal that passes through vertex 1\n    min_weight = (n // 2) * (n // 2 + 1) + (n // 2) * (n // 2 + 1) * (n // 2 + 2)\n\n# Print the output\nprint(min_weight)"}
{"solution": "# Get the input number of books\nn = int(input())\n\n# Initialize the total number of digits to 0\ntotal_digits = 0\n\n# Initialize the number of digits in the current range to 1\nnum_digits = 1\n\n# Initialize the current range to 9\ncurrent_range = 9\n\n# While the current range is less than or equal to the input number\nwhile current_range <= n:\n    # Add the number of digits in the current range to the total number of digits\n    total_digits += current_range * num_digits\n\n    # Update the current range to the next range\n    current_range *= 10\n\n    # Increment the number of digits in the current range\n    num_digits += 1\n\n# Add the number of digits in the remaining books to the total number of digits\ntotal_digits += (n - (current_range // 10) + 1) * num_digits\n\n# Print the total number of digits\nprint(total_digits)"}
{"solution": "# Read input\nn, A = map(int, input().split())\ncars = list(map(int, input().split()))\n\n# Initialize data structure to keep track of counts\ncounts = [0] * (10**6 + 1)\ncounts[A] = 0\n\n# Initialize variables to keep track of maximum count and winning color\nmax_count = 0\nwinning_color = -1\n\n# Iterate through cars\nfor car in cars:\n    # Update count for current car\n    counts[car] += 1\n\n    # If current car is not Alice's color, update maximum count and winning color\n    if car != A:\n        if counts[car] >= max_count:\n            max_count = counts[car]\n            winning_color = car\n\n    # If Alice's count is ever greater than maximum count, reset winning color\n    if counts[A] > max_count:\n        winning_color = -1\n\n# Print winning color\nprint(winning_color)"}
{"solution": "# Read input\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculate the total length of the segments\ntotal_length = sum(a)\n\n# Calculate the total length of the gaps between segments\ntotal_gaps = n - 1\n\n# Calculate the total length of the crossword\ntotal_crossword_length = total_length + total_gaps\n\n# Check if the total length of the crossword is equal to the chosen length\nif total_crossword_length == x:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "# Read the input values for n and S\nn, S = map(int, input().split())\n\n# Initialize the number of coins required to 0\nnum_coins = 0\n\n# While S is greater than 0, subtract the largest possible coin value from S\n# and increment the number of coins required\nwhile S > 0:\n    # The largest possible coin value is min(n, S)\n    coin_value = min(n, S)\n    # Subtract the coin value from S\n    S -= coin_value\n    # Increment the number of coins required\n    num_coins += 1\n\n# Print the minimum number of coins required\nprint(num_coins)"}
{"solution": "from collections import Counter\n\ndef min_changes_palindrome(s):\n    n = len(s)\n    counter = Counter(s)\n\n    # Find the middle character\n    mid_char = None\n    for char, count in counter.items():\n        if count % 2 == 1:\n            if mid_char is None:\n                mid_char = char\n            else:\n                # More than one character with odd count, cannot form a palindrome\n                return ''\n\n    # Build the palindrome\n    palindrome = []\n    for char in sorted(counter.keys()):\n        if char != mid_char:\n            palindrome.extend([char] * (counter[char] // 2))\n\n    # Add the middle character if exists\n    if mid_char is not None:\n        palindrome.append(mid_char)\n\n    # Add the remaining characters\n    palindrome.extend(reversed(palindrome))\n\n    return ''.join(palindrome)\n\n# Read the input string\ns = input()\n\n# Get the lexicographically smallest palindrome with the minimal number of changes\nresult = min_changes_palindrome(s)\n\n# Print the result\nprint(result)"}
{"solution": "# Define the weight of each piece\npiece_weights = {\n    'Q': 9,\n    'R': 5,\n    'B': 3,\n    'N': 3,\n    'P': 1,\n    'q': -9,\n    'r': -5,\n    'b': -3,\n    'n': -3,\n    'p': -1,\n    '.': 0\n}\n\n# Initialize the total weight of each player's pieces\nwhite_weight = 0\nblack_weight = 0\n\n# Read the input and calculate the total weight of each player's pieces\nfor i in range(8):\n    row = input()\n    for piece in row:\n        if piece.isupper():\n            white_weight += piece_weights[piece]\n        elif piece.islower():\n            black_weight += piece_weights[piece]\n\n# Determine which player has the larger position weight\nif white_weight > black_weight:\n    print(\"White\")\nelif white_weight < black_weight:\n    print(\"Black\")\nelse:\n    print(\"Draw\")"}
{"solution": "import sys\nfrom collections import deque\n\ndef main():\n    N, M = map(int, sys.stdin.readline().split())\n    S = sys.stdin.readline().strip()\n\n    # Initialize the graph\n    graph = [[] for _ in range(N + 1)]\n    for i in range(N + 1):\n        for j in range(1, M + 1):\n            if i + j <= N and S[i + j] == '0':\n                graph[i].append(i + j)\n\n    # Initialize the distances and previous nodes\n    dist = [float('inf')] * (N + 1)\n    prev = [-1] * (N + 1)\n    dist[0] = 0\n\n    # Breadth-first search\n    queue = deque([0])\n    while queue:\n        u = queue.popleft()\n        for v in graph[u]:\n            if dist[v] > dist[u] + 1:\n                dist[v] = dist[u] + 1\n                prev[v] = u\n                queue.append(v)\n\n    # Reconstruct the path\n    if dist[N] == float('inf'):\n        print(-1)\n        return\n\n    path = []\n    u = N\n    while u != 0:\n        path.append(prev[u] - u)\n        u = prev[u]\n    path.reverse()\n\n    # Print the path\n    print(' '.join(map(str, path)))\n\nif __name__ == '__main__':\n    main()"}
{"solution": "def solve(k, x, y):\n    # If k is even, the parity of x and y should be the same\n    if k % 2 == 0 and x % 2 != y % 2:\n        return -1\n\n    # Calculate the number of steps needed to reach the target\n    steps = max(abs(x), abs(y)) // k\n    if max(abs(x), abs(y)) % k != 0:\n        steps += 1\n\n    # Calculate the coordinates of the intermediate points\n    points = []\n    current_x, current_y = 0, 0\n    for _ in range(steps):\n        # Move diagonally towards the target\n        if current_x < x:\n            current_x += k\n        elif current_x > x:\n            current_x -= k\n        if current_y < y:\n            current_y += k\n        elif current_y > y:\n            current_y -= k\n        points.append((current_x, current_y))\n\n    # If the target is not reached, move directly to the target\n    if (current_x, current_y) != (x, y):\n        points.append((x, y))\n\n    return points\n\nk = int(input())\nx, y = map(int, input().split())\nresult = solve(k, x, y)\nif result == -1:\n    print(-1)\nelse:\n    print(len(result))\n    for point in result:\n        print(*point)"}
{"solution": "def count_ways(n, k):\n    # Calculate the number of ways to distribute chocolates\n    # using binary search\n    left, right = 1, n\n    while left < right:\n        mid = (left + right) // 2\n        if mid * (1 - k ** 4) >= n * (1 - k):\n            right = mid\n        else:\n            left = mid + 1\n    # Check if the number of ways is equal to m\n    if left * (1 - k ** 4) == n * (1 - k):\n        return True\n    return False\n\ndef find_n(m):\n    # Binary search for the smallest possible value of n\n    left, right = 1, m\n    while left < right:\n        mid = (left + right) // 2\n        # Binary search for the smallest possible value of k\n        k_left, k_right = 2, mid\n        while k_left < k_right:\n            k_mid = (k_left + k_right) // 2\n            if count_ways(mid, k_mid):\n                k_right = k_mid\n            else:\n                k_left = k_mid + 1\n        if count_ways(mid, k_left):\n            right = mid\n        else:\n            left = mid + 1\n    # Check if a valid value of n was found\n    if count_ways(left, 2):\n        return left\n    return -1\n\nm = int(input())\nprint(find_n(m))"}
{"solution": "import math\n\ndef circle_intersection_area(x1, y1, r1, x2, y2, r2):\n    # distance between the centers\n    d = math.sqrt((x1 - x2)**2 + (y1 - y2)**2)\n\n    # if the circles do not intersect\n    if d > r1 + r2:\n        return 0\n\n    # if one circle is inside the other\n    if d < abs(r1 - r2):\n        return math.pi * min(r1, r2)**2\n\n    # calculate the angles subtended by the intersection at the centers\n    a1 = math.acos((r1**2 + d**2 - r2**2) / (2 * r1 * d))\n    a2 = math.acos((r2**2 + d**2 - r1**2) / (2 * r2 * d))\n\n    # calculate the area of the circular segments\n    segment1 = 0.5 * r1**2 * (2 * a1 - math.sin(2 * a1))\n    segment2 = 0.5 * r2**2 * (2 * a2 - math.sin(2 * a2))\n\n    # return the area of intersection\n    return segment1 + segment2\n\n# get the input\nx1, y1, r1 = map(int, input().split())\nx2, y2, r2 = map(int, input().split())\n\n# print the area of intersection\nprint(circle_intersection_area(x1, y1, r1, x2, y2, r2))"}
{"solution": "# Get the initial value of n from the user\nn = int(input())\n\n# Keep subtracting n-1 from n until n is equal to 1\nwhile n > 1:\n    n -= n - 1\n\n# Print the minimum value of n\nprint(n)"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    n = int(sys.stdin.readline())\n    parents = list(map(int, sys.stdin.readline().split()))\n    citizens = list(map(int, sys.stdin.readline().split()))\n\n    graph = defaultdict(list)\n    for i, parent in enumerate(parents, 2):\n        graph[parent].append(i)\n\n    def dfs(node):\n        if not graph[node]:\n            return citizens[node - 1]\n        children_citizens = [dfs(child) for child in graph[node]]\n        bandit_turn = max(children_citizens)\n        children_citizens.remove(bandit_turn)\n        citizens[node - 1] += sum(children_citizens)\n        return bandit_turn\n\n    print(dfs(1))\n\nsolve()"}
{"solution": "def find_common_words(n, s, t):\n    count = 0\n    for i in range(n + 1):\n        if i < n and s[i] == t[i]:\n            if i == n - 1 or s[i + 1] == t[i + 1]:\n                count += 1\n        elif i > 0 and s[i - 1] == t[i - 1]:\n            if i == n or s[i] == t[i]:\n                count += 1\n    return count\n\nn = int(input())\ns = input()\nt = input()\nprint(find_common_words(n, s, t))"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef dfs(node, parent, graph, strengths):\n    min_strength = float('inf')\n    for child in graph[node]:\n        if child != parent:\n            child_strength = dfs(child, node, graph, strengths)\n            min_strength = min(min_strength, child_strength)\n    if min_strength == float('inf'):\n        return strengths[node]\n    else:\n        return max(min_strength - 1, strengths[node])\n\ndef main():\n    n = int(sys.stdin.readline())\n    strengths = list(map(int, sys.stdin.readline().split()))\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    print(dfs(0, -1, graph, strengths))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Read the input\nn, m = map(int, input().split())\n\n# Calculate the remaining cats\nremaining_cats = n - m\n\n# If all cats have left, print 0\nif remaining_cats == 0:\n    print(0)\n# If only one cat is left, print 1\nelif remaining_cats == 1:\n    print(1)\n# Otherwise, calculate the maximum possible number of groups\nelse:\n    # Start with the maximum possible number of groups\n    max_groups = remaining_cats\n    # Loop until we find the maximum possible number of groups\n    while max_groups > 0:\n        # If the remaining cats can be divided into max_groups groups with equal size, break the loop\n        if remaining_cats % max_groups == 0:\n            break\n        # Otherwise, decrease the number of groups\n        max_groups -= 1\n    # Print the maximum possible number of groups\n    print(max_groups)"}
{"solution": "# Get the input\nk, r = map(int, input().split())\n\n# Initialize the minimum number of shovels to buy\nmin_shovels = k\n\n# Iterate through all possible values of the coin\nfor i in range(1, r + 1):\n    # Calculate the minimum number of shovels to buy so that Policarp can pay without any change\n    shovels = (10 - i) * k // r\n    # Update the minimum number of shovels if necessary\n    if shovels > 0 and (10 * shovels) % r == 0:\n        min_shovels = min(min_shovels, shovels)\n\n# Print the minimum number of shovels to buy\nprint(min_shovels)"}
{"solution": "def is_rectangle_possible(grid):\n    n = len(grid)\n    m = len(grid[0])\n    x_count = sum(row.count('X') for row in grid)\n\n    # If the number of 'X' is not even, it's impossible to make a rectangle\n    if x_count % 2 != 0:\n        return False\n\n    # If the number of 'X' is half of the total cells, it's possible to make a rectangle\n    if x_count == n * m // 2:\n        return True\n\n    # If the number of 'X' is less than half of the total cells, it's impossible to make a rectangle\n    if x_count < n * m // 2:\n        return False\n\n    # If the number of 'X' is more than half of the total cells, we need to check if it's possible to split the grid into two equal halves\n    for i in range(1, n):\n        if grid[i][0] == 'X' and grid[i - 1][0] == '.':\n            upper_half = [row[:m // 2] for row in grid[:i]]\n            lower_half = [row[m // 2:] for row in grid[i:]]\n            if upper_half == lower_half:\n                return True\n    return False\n\nn, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\nprint(\"YES\" if is_rectangle_possible(grid) else \"NO\")"}
{"solution": "# Read the coordinates of the three points\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\nx3, y3 = map(int, input().split())\n\n# Initialize the minimum number of segments to the maximum possible value\nmin_segments = 3\n\n# Check if all points are on the same line\nif (x1 == x2 == x3) or (y1 == y2 == y3):\n    min_segments = 1\n# Check if two points are on the same line\nelif (x1 == x2) or (y1 == y2) or (x2 == x3) or (y2 == y3) or (x1 == x3) or (y1 == y3):\n    min_segments = 2\n\n# Print the minimum number of segments\nprint(min_segments)"}
{"solution": "k = int(input())\n\nif k % 2 != 0:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    n = k + 2\n    m = k * (k + 1) // 2 + k\n    print(n, m)\n    for i in range(1, k + 1):\n        for j in range(i + 1, k + 1):\n            print(i, j)\n    for i in range(1, k + 1):\n        print(k + 1, i)\n    for i in range(1, k):\n        print(k + 2, i)\n    print(k + 2, k)"}
{"solution": "def count_occurrences(s, t, l, r):\n    substring = s[l-1:r]\n    count = 0\n    for i in range(len(substring) - len(t) + 1):\n        if substring[i:i+len(t)] == t:\n            count += 1\n    return count\n\nn, m, q = map(int, input().split())\ns = input()\nt = input()\nqueries = [list(map(int, input().split())) for _ in range(q)]\n\nfor l, r in queries:\n    print(count_occurrences(s, t, l, r))"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(n, k, d):\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(1, min(i, k) + 1):\n            for l in range(i - j + 1):\n                dp[j][i] = (dp[j][i] + dp[j - 1][l]) % MOD\n                if j >= d:\n                    dp[j][i] = (dp[j][i] + dp[j][l]) % MOD\n\n    return sum(dp[j][n] for j in range(d, k + 1)) % MOD\n\nn, k, d = map(int, input().split())\nprint(solve(n, k, d))"}
{"solution": "# Read the input\nn = int(input())\nrow = input()\n\n# Initialize variables\ngroups = []\ncurrent_group = 0\n\n# Iterate through the row\nfor square in row:\n    if square == 'B':\n        # If the square is black, increment the current group size\n        current_group += 1\n    elif square == 'W' and current_group > 0:\n        # If the square is white and there is a current group, add it to the list of groups and reset the current group size\n        groups.append(current_group)\n        current_group = 0\n\n# If there is a current group at the end of the row, add it to the list of groups\nif current_group > 0:\n    groups.append(current_group)\n\n# Print the output\nprint(len(groups))\nprint(' '.join(map(str, groups)))"}
{"solution": "def process_bracket_sequence():\n    n, m, p = map(int, input().split())\n    sequence = input()\n    operations = input()\n\n    stack = []\n    for i, bracket in enumerate(sequence):\n        if bracket == '(':\n            stack.append(i)\n        else:\n            start = stack.pop()\n            sequence = sequence[:start] + sequence[start+1:i] + sequence[i+1:]\n            i -= 2\n\n    cursor = p - 1\n    for operation in operations:\n        if operation == 'L':\n            cursor -= 1\n        elif operation == 'R':\n            cursor += 1\n        elif operation == 'D':\n            start = stack[stack.index(cursor)]\n            end = stack[stack.index(start) + 1]\n            sequence = sequence[:start] + sequence[end+1:]\n            stack = stack[:stack.index(start)] + stack[stack.index(start)+2:]\n            if cursor > end:\n                cursor -= 2\n            else:\n                cursor = start if start < cursor else start + 1\n\n    print(sequence)\n\nprocess_bracket_sequence()"}
{"solution": "# Read the number of queries\nn = int(input())\n\n# Initialize the lower and upper bounds\nlower_bound = -2 * 10**9\nupper_bound = 2 * 10**9\n\n# Process each query\nfor _ in range(n):\n    query = input().split()\n    sign = query[0]\n    x = int(query[1])\n    answer = query[2]\n\n    # Update the bounds based on the query and answer\n    if sign == '>':\n        if answer == 'Y':\n            lower_bound = max(lower_bound, x + 1)\n        else:\n            upper_bound = min(upper_bound, x)\n    elif sign == '<':\n        if answer == 'Y':\n            upper_bound = min(upper_bound, x - 1)\n        else:\n            lower_bound = max(lower_bound, x)\n    elif sign == '>=':\n        if answer == 'Y':\n            lower_bound = max(lower_bound, x)\n        else:\n            upper_bound = min(upper_bound, x - 1)\n    elif sign == '<=':\n        if answer == 'Y':\n            upper_bound = min(upper_bound, x)\n        else:\n            lower_bound = max(lower_bound, x + 1)\n\n# Check if a valid value exists\nif lower_bound <= upper_bound:\n    print(lower_bound)\nelse:\n    print('Impossible')"}
{"solution": "import math\n\ndef count_periods(a, b):\n    total_length = a + b\n    periods = set()\n\n    # Check all possible periods\n    for k in range(1, total_length + 1):\n        # If the period divides the total length, it's a valid period\n        if total_length % k == 0:\n            periods.add(k)\n\n        # Check if the period divides the difference between a and b\n        if abs(a - b) % k == 0:\n            # Calculate the number of 'A's and 'B's in each block of the string\n            blocks_a = a // k\n            blocks_b = b // k\n\n            # Check if it's possible to arrange the blocks of 'A's and 'B's in a repeating pattern\n            if blocks_a > 0 and blocks_b > 0 and math.gcd(blocks_a, blocks_b) == 1:\n                periods.add(k)\n\n    return len(periods)\n\n# Read the input\na, b = map(int, input().split())\n\n# Print the result\nprint(count_periods(a, b))"}
{"solution": "def generate_names(n, k, notes):\n    names = []\n    for i in range(n - k + 1):\n        if notes[i] == 'NO':\n            if i == 0:\n                names.extend([f'A{i}' for _ in range(k)])\n            else:\n                names.append(names[-1])\n        else:\n            if i == 0:\n                names.extend([f'A{i}' for _ in range(k)])\n            else:\n                names.append(f'A{i}')\n    return names\n\nn, k = map(int, input().split())\nnotes = input().split()\nnames = generate_names(n, k, notes)\nprint(' '.join(names))"}
{"solution": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef count_operations(a, b):\n    if a == b:\n        return 0\n    if a < b:\n        a, b = b, a\n    if a % 2 == 1 and a % 3 == 1 and b % 2 == 1 and b % 3 == 1:\n        return -1\n    if a == 2 * b or b == 2 * a or a == 3 * b or b == 3 * a or a == 5 * b or b == 5 * a:\n        return 1\n    if gcd(a, b) > 1:\n        return -1\n    return 1 + count_operations(a - b, b)\n\na, b = map(int, input().split())\nprint(count_operations(a, b))"}
{"solution": "def min_cost(n, a, b, suits):\n    cost = 0\n    for i in range(n // 2):\n        if suits[i] == suits[n - i - 1]:\n            continue\n        elif suits[i] == 2:\n            suits[i] = suits[n - i - 1]\n            cost += a if suits[i] == 0 else b\n        elif suits[n - i - 1] == 2:\n            suits[n - i - 1] = suits[i]\n            cost += a if suits[n - i - 1] == 0 else b\n        else:\n            return -1\n    if n % 2 == 1 and suits[n // 2] == 2:\n        cost += min(a, b)\n    return cost\n\nn, a, b = map(int, input().split())\nsuits = list(map(int, input().split()))\nprint(min_cost(n, a, b, suits))"}
{"solution": "def print_cube(k):\n    if k % 2 != 0:\n        print(-1)\n        return\n\n    for i in range(k):\n        for j in range(k):\n            if (i + j) % 2 == 0:\n                print('b', end='')\n            else:\n                print('w', end='')\n        print()\n\nk = int(input())\nprint_cube(k)"}
{"solution": "def biggest_lovely_number(n):\n    # Start with the largest possible number\n    result = n\n\n    # Check if the number is divisible by any perfect square\n    i = 2\n    while i * i <= result:\n        if result % (i * i) == 0:\n            # If it is, divide it by the perfect square to get the largest possible lovely number\n            result //= (i * i)\n        else:\n            # If it's not, check the next perfect square\n            i += 1\n\n    return result\n\n# Get the input\nn = int(input())\n\n# Print the result\nprint(biggest_lovely_number(n))"}
{"solution": "# Read the number of chairs\nn = int(input())\n\n# Read the seating arrangement\nseating = input()\n\n# Check if the seating is maximal\nif '11' not in seating and seating.count('1') * 2 < n:\n    print('Yes')\nelse:\n    print('No')"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\na.insert(0, 0)\n\npossible_k = []\nfor k in range(1, n + 1):\n    x = [a[i] - a[i - k] for i in range(k, n + 1)]\n    if len(set(x)) == 1:\n        possible_k.append(k)\n\nprint(len(possible_k))\nprint(' '.join(map(str, possible_k)))"}
{"solution": "def can_form_teams(scores):\n    total_sum = sum(scores)\n    if total_sum % 2 != 0:\n        return False\n\n    target_sum = total_sum // 2\n    for i in range(6):\n        if target_sum - scores[i] in scores:\n            return True\n    return False\n\nscores = list(map(int, input().split()))\nprint(\"YES\" if can_form_teams(scores) else \"NO\")"}
{"solution": "def count_2_3_integers(l, r):\n    # Generate all possible 2-3 integers up to the maximum possible value in the range\n    two_powers = [1]\n    three_powers = [1]\n    while two_powers[-1] <= r:\n        two_powers.append(two_powers[-1] * 2)\n    while three_powers[-1] <= r:\n        three_powers.append(three_powers[-1] * 3)\n\n    # Count the number of integers in the given range\n    count = 0\n    for i in range(len(two_powers)):\n        for j in range(len(three_powers)):\n            num = two_powers[i] * three_powers[j]\n            if l <= num <= r:\n                count += 1\n\n    return count\n\n# Read input\nl, r = map(int, input().split())\n\n# Print output\nprint(count_2_3_integers(l, r))"}
{"solution": "# Read the input\nn, k = map(int, input().split())\n\n# Initialize the number of candies Alya ate and the number of candies in the box\neaten = 0\nbox = 0\n\n# Simulate Alya's actions\nfor i in range(1, n + 1):\n    # If this is not the last action and the number of candies in the box is less than i,\n    # then Alya has to put candies in the box\n    if i < n and box < i:\n        box += i\n    # Otherwise, Alya takes one candy out and eats it\n    else:\n        box -= 1\n        eaten += 1\n\n# Print the result\nprint(eaten)"}
{"solution": "# Read the input\nn = int(input())\nsegments = list(map(int, input().split()))\n\n# Sort the segments in non-decreasing order\nsegments.sort()\n\n# Check if it's possible to form a non-degenerate triangle\nfor i in range(2, n):\n    if segments[i-2] + segments[i-1] > segments[i]:\n        print(\"YES\")\n        break\nelse:\n    print(\"NO\")"}
{"solution": "def is_possible(x, y):\n    # The number of copies must always be even\n    if x % 2 != 0:\n        return False\n\n    # The number of originals can never be less than the number of copies divided by 2\n    if y < x // 2:\n        return False\n\n    # If the number of copies is 0, the number of originals must be 1\n    if x == 0:\n        return y == 1\n\n    # If the number of originals is equal to the number of copies divided by 2,\n    # it's possible to achieve the desired configuration\n    if y == x // 2:\n        return True\n\n    # If the number of originals is greater than the number of copies divided by 2,\n    # it's possible to achieve the desired configuration if the difference between\n    # the number of originals and the number of copies divided by 2 is even\n    return (y - x // 2) % 2 == 0\n\nx, y = map(int, input().split())\nprint(\"Yes\" if is_possible(x, y) else \"No\")"}
{"solution": "# Read input\nn, k = map(int, input().split())\nskills = list(map(int, input().split()))\n\n# Calculate current rating\nrating = sum(skill // 10 for skill in skills)\n\n# Sort skills in ascending order\nskills.sort()\n\n# Use greedy algorithm to maximize rating\nfor i in range(n):\n    # Calculate how many units are needed to increase the skill to the next level\n    units_needed = (skills[i] // 10 + 1) * 10 - skills[i]\n\n    # Use all available units to increase the skill\n    if k >= units_needed:\n        k -= units_needed\n        skills[i] += units_needed\n        rating += 1\n    else:\n        # Use remaining units to increase the skill as much as possible\n        skills[i] += k\n        rating += k // 10\n        break\n\n# Print output\nprint(rating)"}
{"solution": "from itertools import product\n\n# Read in the two lists of digits and their lengths\nn, m = map(int, input().split())\nlist1 = set(map(int, input().split()))\nlist2 = set(map(int, input().split()))\n\n# Initialize the smallest pretty integer to infinity\nsmallest_pretty = float('inf')\n\n# Generate all possible combinations of digits from the two lists\nfor i in range(1, 10):\n    for combination in product(range(10), repeat=i):\n        # Check if the combination is a pretty integer\n        if set(combination).intersection(list1) and set(combination).intersection(list2):\n            # Convert the combination to an integer and update the smallest pretty integer\n            pretty_integer = int(''.join(map(str, combination)))\n            smallest_pretty = min(smallest_pretty, pretty_integer)\n\n# Output the smallest pretty integer\nprint(smallest_pretty)"}
{"solution": "# Get the input\nn, k = map(int, input().split())\n\n# Initialize the time Limak has to solve problems\ntime_available = 240 - k\n\n# Initialize the time Limak has used to solve problems\ntime_used = 0\n\n# Initialize the number of problems Limak can solve\nproblems_solved = 0\n\n# Loop through the problems\nfor i in range(1, n + 1):\n    # Calculate the time it takes to solve the current problem\n    time_to_solve = 5 * i\n\n    # Check if Limak has enough time to solve the current problem\n    if time_available - time_to_solve >= 0:\n        # Update the time Limak has used to solve problems\n        time_used += time_to_solve\n\n        # Update the time Limak has to solve problems\n        time_available -= time_to_solve\n\n        # Increment the number of problems Limak can solve\n        problems_solved += 1\n\n    # If Limak doesn't have enough time to solve the current problem, break the loop\n    else:\n        break\n\n# Print the maximum possible number of problems Limak can solve\nprint(problems_solved)"}
{"solution": "# Read input\nn, x, y = map(int, input().split())\na = list(map(int, input().split()))\n\n# Sort the list of pages in descending order\na.sort(reverse=True)\n\n# Initialize the number of teams that can be printed\nteams = 0\n\n# Use the sheets with two clean sides first\nwhile x > 0 and a and a[-1] <= 2:\n    pages = a.pop()\n    if pages == 1:\n        y -= 1\n        if y < 0:\n            break\n    x -= pages // 2\n    teams += 1\n\n# Use the remaining sheets with one clean side\nwhile y >= 0 and a:\n    pages = a.pop()\n    y -= pages\n    if y < 0:\n        break\n    teams += 1\n\n# Print the result\nprint(teams)"}
{"solution": "import math\n\ndef prime_factors(n):\n    factors = []\n    while n % 2 == 0:\n        factors.append(2)\n        n = n // 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            factors.append(i)\n            n = n // i\n    if n > 2:\n        factors.append(n)\n    return factors\n\ndef unique_fractions(b):\n    factors = prime_factors(b)\n    unique_count = 1\n    i = 0\n    while i < len(factors):\n        count = 1\n        while i + 1 < len(factors) and factors[i] == factors[i + 1]:\n            count += 1\n            i += 1\n        unique_count *= (count + 1)\n        i += 1\n    return unique_count\n\nb = int(input())\nprint(unique_fractions(b))"}
{"solution": "n = int(input())\nbumpers = input()\n\nfall_off = 0\n\nfor i in range(n):\n    position = i\n    while 0 < position < n:\n        if bumpers[position] == '<':\n            position -= 1\n        else:\n            position += 1\n        if position <= 0 or position >= n:\n            fall_off += 1\n            break\n\nprint(fall_off)"}
{"solution": "from collections import Counter\n\n# Get the number of sticks\nn = int(input())\n\n# Get the lengths of the sticks\nsticks = list(map(int, input().split()))\n\n# Count the occurrences of each stick length\nstick_counts = Counter(sticks)\n\n# Sort the stick lengths in descending order\nsorted_sticks = sorted(stick_counts.keys(), reverse=True)\n\n# Initialize the total area\ntotal_area = 0\n\n# Iterate through the sorted stick lengths\nfor stick in sorted_sticks:\n    # If there are at least 4 sticks of the same length\n    if stick_counts[stick] >= 4:\n        # Make rectangles with the longest possible sides\n        total_area += (stick ** 2) * (stick_counts[stick] // 4)\n        # Update the count of the current stick length\n        stick_counts[stick] %= 4\n    # If there are at least 2 sticks of the same length\n    elif stick_counts[stick] >= 2:\n        # Try to make a rectangle with the current sticks\n        # and the next smallest sticks\n        for next_stick in sorted_sticks:\n            if next_stick <= stick and stick_counts[next_stick] >= 2:\n                total_area += (next_stick * stick)\n                stick_counts[stick] -= 2\n                stick_counts[next_stick] -= 2\n                break\n\n# Print the maximum total area of the rectangles\nprint(total_area)"}
{"solution": "# Read the number of inputs\nn = int(input())\n\n# Create a dictionary to map letters to digits\nletter_to_digit = {}\n\n# Create a list to store the numbers after replacement\nnumbers = []\n\n# Read the numbers and replace letters with digits\nfor _ in range(n):\n    number = input()\n    for letter in number:\n        if letter not in letter_to_digit:\n            letter_to_digit[letter] = -1\n    numbers.append(number)\n\n# Sort the letters based on their frequency in the numbers\nsorted_letters = sorted(letter_to_digit.keys(), key=lambda x: sum(number.count(x) for number in numbers), reverse=True)\n\n# Assign digits to letters based on their frequency\ndigit = 0\nfor letter in sorted_letters:\n    if letter_to_digit[letter] == -1:\n        letter_to_digit[letter] = str(digit)\n        digit += 1\n\n# Calculate the sum of the restored numbers\ntotal_sum = 0\nfor number in numbers:\n    restored_number = int(''.join(letter_to_digit[letter] for letter in number))\n    total_sum += restored_number\n\n# Print the minimum possible sum\nprint(total_sum)"}
{"solution": "def max_teams(n, m):\n    # If there are no newbies, no teams can be formed\n    if m == 0:\n        return 0\n\n    # If there are no experienced members, no teams can be formed\n    if n == 0:\n        return 0\n\n    # If the number of newbies is less than or equal to the number of experienced members,\n    # form teams with one experienced member and two newbies\n    if m <= n:\n        return m\n\n    # If the number of newbies is more than twice the number of experienced members,\n    # form teams with two experienced members and one newbie\n    elif m > 2 * n:\n        return n\n\n    # Otherwise, calculate the maximum number of teams that can be formed\n    else:\n        return n + (m - n) // 2\n\n# Read the input\nn, m = map(int, input().split())\n\n# Print the maximum number of teams that can be formed\nprint(max_teams(n, m))"}
{"solution": "def contains_non_overlapping_substrings(s):\n    # Check for \"AB\" and \"BA\" in the string\n    ab_index = s.find(\"AB\")\n    ba_index = s.find(\"BA\")\n\n    # If both substrings are found\n    if ab_index != -1 and ba_index != -1:\n        # Check if they are non-overlapping\n        if abs(ab_index - ba_index) >= 2:\n            return True\n        # If \"AB\" appears before \"BA\"\n        elif ab_index < ba_index:\n            # Check if there is another \"BA\" after the first \"AB\"\n            if s.find(\"BA\", ab_index + 2) != -1:\n                return True\n        # If \"BA\" appears before \"AB\"\n        else:\n            # Check if there is another \"AB\" after the first \"BA\"\n            if s.find(\"AB\", ba_index + 2) != -1:\n                return True\n\n    return False\n\n# Read the input string\ns = input()\n\n# Check if the string contains non-overlapping substrings \"AB\" and \"BA\"\nif contains_non_overlapping_substrings(s):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def solve(n, a, k, b):\n    stack = []\n    i = 0\n    j = 0\n    while i < n and j < k:\n        if a[i] == b[j]:\n            i += 1\n            j += 1\n        elif stack and stack[-1] > b[j]:\n            return \"NO\"\n        elif stack and stack[-1] < b[j]:\n            stack.pop()\n        else:\n            stack.append(a[i])\n            i += 1\n    while j < k:\n        if stack and stack[-1] == b[j]:\n            stack.pop()\n            j += 1\n        else:\n            return \"NO\"\n    return \"YES\"\n\nn = int(input())\na = list(map(int, input().split()))\nk = int(input())\nb = list(map(int, input().split()))\nprint(solve(n, a, k, b))"}
{"solution": "from collections import deque\n\ndef bfs(graph, matchR, matchB, R, B):\n    queue = deque()\n    for i in range(R):\n        if matchR[i] == -1:\n            level[i] = 0\n            queue.append(i)\n        else:\n            level[i] = float('Inf')\n    level[R] = float('Inf')\n    while queue:\n        u = queue.popleft()\n        if u < R:\n            for v in range(B):\n                if graph[u][v] and level[matchB[v]] == float('Inf'):\n                    level[matchB[v]] = level[u] + 1\n                    queue.append(matchB[v])\n    return level[R] != float('Inf')\n\ndef dfs(graph, matchR, matchB, R, B, u):\n    if u < R:\n        for v in range(B):\n            if graph[u][v] and level[matchB[v]] == level[u] + 1:\n                if dfs(graph, matchR, matchB, R, B, matchB[v]):\n                    matchR[u] = v\n                    matchB[v] = u\n                    return True\n        level[u] = float('Inf')\n        return False\n    return True\n\ndef hopcroftKarp(graph, R, B):\n    matchR = [-1] * R\n    matchB = [-1] * B\n    while bfs(graph, matchR, matchB, R, B):\n        for i in range(R):\n            if matchR[i] == -1:\n                dfs(graph, matchR, matchB, R, B, i)\n    return sum(i != -1 for i in matchR)\n\ndef onSegment(p, q, r):\n    if (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and\n        q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1])):\n        return True\n    return False\n\ndef orientation(p, q, r):\n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0\n    elif val > 0:\n        return 1\n    else:\n        return 2\n\ndef doIntersect(p1, q1, p2, q2):\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n    if o1 != o2 and o3 != o4:\n        return True\n    if o1 == 0 and onSegment(p1, p2, q1):\n        return True\n    if o2 == 0 and onSegment(p1, q2, q1):\n        return True\n    if o3 == 0 and onSegment(p2, p1, q2):\n        return True\n    if o4 == 0 and onSegment(p2, q1, q2):\n        return True\n    return False\n\ndef checkIntersection(rebels, bases, matchR, matchB):\n    for i in range(len(matchR)):\n        if matchR[i] != -1:\n            for j in range(i+1, len(matchR)):\n                if matchR[j] != -1:\n                    if doIntersect(rebels[i], bases[matchR[i]], rebels[j], bases[matchB[j]]):\n                        return True\n    return False\n\nR, B = map(int, input().split())\nrebels = [tuple(map(int, input().split())) for _ in range(R)]\nbases = [tuple(map(int, input().split())) for _ in range(B)]\ngraph = [[False] * B for _ in range(R)]\nfor i in range(R):\n    for j in range(B):\n        graph[i][j] = not checkIntersection(rebels, bases, [-1]*R, [-1]*B)\n        if graph[i][j]:\n            matchR[i] = j\n            matchB[j] = i\n            break\nif hopcroftKarp(graph, R, B) == R:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "# Read the input\nn = int(input())\nnumbers = list(map(int, input().split()))\n\n# Initialize the maximum power of 2 and the count of numbers divisible by it\nmax_power = 0\ncount = 0\n\n# Iterate over the numbers\nfor num in numbers:\n    # Calculate the power of 2 that divides the number\n    power = 0\n    while num % 2 == 0:\n        num //= 2\n        power += 1\n    # Update the maximum power and the count\n    if power > max_power:\n        max_power = power\n        count = 1\n    elif power == max_power:\n        count += 1\n\n# Calculate the maximum power of 2\nr = 2 ** max_power\n\n# Print the output\nprint(r, count)"}
{"solution": "def min_clicks(n, m):\n    clicks = 0\n    while m > n:\n        if m % 2 == 1:\n            m += 1\n            clicks += 1\n        m //= 2\n        clicks += 1\n    return clicks + (n - m)\n\nn, m = map(int, input().split())\nprint(min_clicks(n, m))"}
{"solution": "def is_tree(n, segments):\n    # Sort segments by their start points\n    segments.sort(key=lambda x: x[0])\n\n    # Initialize a list to store the end points of the segments\n    end_points = [0] * (2 * n + 1)\n\n    # Initialize a list to store the parent of each segment\n    parent = [i for i in range(n)]\n\n    # Function to find the parent of a segment\n    def find_parent(i):\n        if parent[i] == i:\n            return i\n        parent[i] = find_parent(parent[i])\n        return parent[i]\n\n    # Function to union two segments\n    def union(i, j):\n        parent_i = find_parent(i)\n        parent_j = find_parent(j)\n        if parent_i != parent_j:\n            parent[parent_i] = parent_j\n\n    # Iterate over the segments\n    for i in range(n):\n        l, r = segments[i]\n\n        # If there is a segment that ends after the current segment starts,\n        # then the current segment and the other segment intersect\n        for j in range(l, r + 1):\n            if end_points[j] > 0:\n                union(i, end_points[j] - 1)\n\n        # Update the end points of the current segment\n        end_points[l] = end_points[r] = i + 1\n\n    # Check if there is exactly one connected component\n    return len(set(find_parent(i) for i in range(n))) == 1\n\n# Read input\nn = int(input())\nsegments = [list(map(int, input().split())) for _ in range(n)]\n\n# Print output\nprint(\"YES\" if is_tree(n, segments) else \"NO\")"}
{"solution": "n = int(input())\nrequests = list(map(int, input().split()))\n\nmax_length = 0\ncurrent_length = 0\n\nfor i in range(1, n + 1):\n    if requests[i - 1] > 100 * i:\n        current_length += 1\n    else:\n        max_length = max(max_length, current_length)\n        current_length = 0\n\nmax_length = max(max_length, current_length)\n\nprint(max_length)"}
{"solution": "def check_dissatisfaction(n, k, memory):\n    max_consecutive_missed = 0\n    current_consecutive_missed = 0\n\n    for i in range(n):\n        if memory[i] == 'N':\n            current_consecutive_missed += 1\n        else:\n            max_consecutive_missed = max(max_consecutive_missed, current_consecutive_missed)\n            current_consecutive_missed = 0\n\n    max_consecutive_missed = max(max_consecutive_missed, current_consecutive_missed)\n\n    if max_consecutive_missed == k:\n        return True\n    elif max_consecutive_missed < k:\n        return False\n    else:\n        return '?' in memory\n\nn, k = map(int, input().split())\nmemory = input()\n\nif check_dissatisfaction(n, k, memory):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "# Read input\nN, X, D = map(int, input().split())\n\n# Calculate the last element of the sequence\nlast_element = X + D * (N - 1)\n\n# Calculate the total sum of the sequence\ntotal_sum = (X + last_element) * N // 2\n\n# Calculate the number of possible values of S - T\n# Takahashi can take any number of elements from 0 to N\n# For each number of elements Takahashi takes, there is a unique corresponding sum S\n# Therefore, the number of possible values of S - T is equal to the number of possible sums S\n# The sum S can range from 0 to the total sum of the sequence\n# Therefore, the number of possible values of S - T is equal to the total sum of the sequence plus 1\n\nnum_possible_values = total_sum + 1\n\n# Print the result\nprint(num_possible_values)"}
{"solution": "n = int(input())\ngood_performance = False\n\nfor _ in range(n):\n    name, before, after = input().split()\n    before, after = int(before), int(after)\n\n    if before < 2400 and after >= 2400:\n        good_performance = True\n        break\n\nprint('YES' if good_performance else 'NO')"}
{"solution": "# Read the binary input\ns = input()\n\n# Convert the binary input to an integer\ns = int(s, 2)\n\n# Initialize the count of missed trains\ncount = 0\n\n# Initialize the departure time of the first train\ndeparture_time = 1\n\n# Loop until the departure time is greater than or equal to s\nwhile departure_time < s:\n    # Increment the count of missed trains\n    count += 1\n\n    # Calculate the departure time of the next train\n    departure_time *= 4\n\n# Print the count of missed trains\nprint(count)"}
{"solution": "def min_rows(matrix):\n    n = len(matrix)\n    m = len(matrix[0])\n\n    # Check if the matrix is already symmetric\n    if matrix == matrix[::-1]:\n        return n // 2\n\n    # Check if the matrix can be split into two halves that are symmetric\n    for i in range(n // 2, 0, -1):\n        upper_half = matrix[:i]\n        lower_half = matrix[i:i*2]\n        if upper_half == lower_half[::-1]:\n            return i\n\n    # If no symmetric split is found, return the number of rows in the matrix\n    return n\n\n# Read input\nn, m = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# Calculate the minimum number of rows\nresult = min_rows(matrix)\n\n# Print the result\nprint(result)"}
{"solution": "def max_orders(n, orders):\n    # Sort the orders based on their start times\n    orders.sort(key=lambda x: x[0])\n\n    # Initialize the list of accepted orders\n    accepted_orders = [orders[0]]\n\n    # Iterate through the orders\n    for i in range(1, n):\n        # If the current order does not intersect with the last accepted order, accept it\n        if orders[i][0] >= accepted_orders[-1][1]:\n            accepted_orders.append(orders[i])\n\n    # Return the maximum number of orders that can be accepted\n    return len(accepted_orders)\n\n# Read the input\nn = int(input())\norders = [list(map(int, input().split())) for _ in range(n)]\n\n# Print the output\nprint(max_orders(n, orders))"}
{"solution": "n, k = map(int, input().split())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\ntables, formulas = 0, 0\n\nfor i in range(n):\n    if tables + x[i] > k or formulas + y[i] > k:\n        tables, formulas = x[i], y[i]\n    else:\n        tables += x[i]\n        formulas += y[i]\n\n    if tables > k or formulas > k:\n        print(\"NO\")\n        break\nelse:\n    print(\"YES\")"}
{"solution": "n, k = map(int, input().split())\ncoefficients = [int(input()) if input() != '?' else None for _ in range(n + 1)]\n\n# Calculate the remainder of P(x) when divided by Q(x)\nremainder = sum(coefficients[i] * k**(n - i) for i in range(n + 1) if coefficients[i] is not None)\n\n# If the remainder is 0, the human has already won\nif remainder == 0:\n    print(\"Yes\")\nelse:\n    # Find an index j such that coefficients[j] is None and setting it to a value that makes the remainder 0\n    for j in range(n + 1):\n        if coefficients[j] is None:\n            if (remainder / k**(n - j)) % 1 == 0:\n                print(\"Yes\")\n                break\n    else:\n        print(\"No\")"}
{"solution": "def smallest_starting_number(X_2):\n    # Generate a list of prime numbers up to X_2\n    primes = [True] * (X_2 + 1)\n    p = 2\n    while p * p <= X_2:\n        if primes[p]:\n            for i in range(p * p, X_2 + 1, p):\n                primes[i] = False\n        p += 1\n\n    # Iterate backwards from X_2 to find the smallest possible starting number\n    for X_0 in range(X_2, 2, -1):\n        if not primes[X_0]:\n            # X_0 is not prime, so it's a possible starting number\n            # Check if it's possible to reach X_0 from X_2 in two turns\n            for p in range(2, X_0):\n                if primes[p]:\n                    X_1 = ((X_2 - 1) // p) * p + p\n                    if X_1 < X_0:\n                        # It's possible to reach X_0 from X_2 in two turns\n                        # Check if it's possible to reach X_1 from X_0 in one turn\n                        for q in range(2, X_1):\n                            if primes[q]:\n                                X_0_prime = ((X_1 - 1) // q) * q + q\n                                if X_0_prime < X_0:\n                                    # It's possible to reach X_0 from X_1 in one turn\n                                    # So X_0 is a valid starting number\n                                    return X_0\n    return 3\n\n# Read the input\nX_2 = int(input())\n\n# Print the output\nprint(smallest_starting_number(X_2))"}
{"solution": "def min_p_binary_numbers(n, p):\n    count = 0\n    while n > 0:\n        # Find the largest p-binary number less than or equal to n\n        x = 0\n        while (2 ** x + p) <= n:\n            x += 1\n        x -= 1\n\n        # Subtract the p-binary number from n\n        n -= (2 ** x + p)\n\n        # Increment the count\n        count += 1\n\n    # If n is not zero, it means that it is impossible to represent n as the sum of p-binary numbers\n    if n != 0:\n        return -1\n\n    return count\n\n# Read the input\nn, p = map(int, input().split())\n\n# Print the result\nprint(min_p_binary_numbers(n, p))"}
{"solution": "# Read input\nn, k = map(int, input().split())\ns = input()\n\n# Initialize result string\nresult = ''\n\n# If the first digit is not 1, change it to 1\nif s[0] != '1' and k > 0:\n    result += '1'\n    k -= 1\nelse:\n    result += s[0]\n\n# Change the remaining digits to 0 if possible\nfor i in range(1, n):\n    if s[i] != '0' and k > 0:\n        result += '0'\n        k -= 1\n    else:\n        result += s[i]\n\n# If there are still changes left, change the last digit to 1\nif k > 0:\n    result = result[:-1] + '1'\n\n# Print result\nprint(result)"}
{"solution": "def sieve_of_eratosthenes(n):\n    primes = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (primes[p] == True):\n            for i in range(p * p, n+1, p):\n                primes[i] = False\n        p += 1\n    return [p for p in range(2, n) if primes[p]]\n\ndef count_numbers(v, x, y):\n    return v - v//x - v//y + v//(x*y)\n\ndef find_min_number(cnt_1, cnt_2, x, y):\n    left, right = 1, 10**9\n    while left < right:\n        mid = (left + right) // 2\n        if count_numbers(mid, x, y) < cnt_1 + cnt_2:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\ncnt_1, cnt_2, x, y = map(int, input().split())\nprint(find_min_number(cnt_1, cnt_2, x, y))"}
{"solution": "def bear_position(n, sx, sy, dx, dy, t):\n    # Calculate the number of times the bear moves\n    moves = t // (2 * n)\n\n    # Calculate the remaining time after the moves\n    t %= 2 * n\n\n    # Calculate the new speed of the bear\n    dx += moves * (sx + sy)\n    dy += moves * (sx + sy)\n\n    # Calculate the new position of the bear\n    sx = ((sx + dx - 1 + t) % n) + 1\n    sy = ((sy + dy - 1 + t) % n) + 1\n\n    # Return the new position of the bear\n    return sx, sy\n\n# Get the input\nn, sx, sy, dx, dy, t = map(int, input().split())\n\n# Calculate the final position of the bear\nfinal_position = bear_position(n, sx, sy, dx, dy, t)\n\n# Print the final position of the bear\nprint(*final_position)"}
{"solution": "def find_nice_word(s):\n    # Create a set of all English alphabet letters\n    alphabet = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n\n    # If the length of the string is less than 26, return -1\n    if len(s) < 26:\n        return -1\n\n    # Create a set to store the letters in the current substring\n    substring = set()\n\n    # Create a dictionary to store the count of each letter in the current substring\n    count = {}\n\n    # Initialize the left and right pointers of the sliding window\n    left = 0\n    right = 0\n\n    # Iterate through the string using the sliding window approach\n    while right < len(s):\n        # If the current character is a question mark, add all possible letters to the substring\n        if s[right] == '?':\n            substring |= alphabet\n            for letter in alphabet:\n                count[letter] = count.get(letter, 0) + 1\n        # If the current character is a letter, add it to the substring and increment its count\n        else:\n            substring.add(s[right])\n            count[s[right]] = count.get(s[right], 0) + 1\n\n        # If the size of the substring is 26, check if it contains all the letters of the alphabet\n        if right - left + 1 == 26:\n            # If it does, replace the question marks with the missing letters and return the resulting word\n            if substring == alphabet:\n                word = list(s)\n                missing_letters = alphabet - set(substring)\n                for i in range(left, right + 1):\n                    if word[i] == '?':\n                        word[i] = missing_letters.pop()\n                return ''.join(word)\n            # If it doesn't, move the left pointer of the sliding window to the right\n            else:\n                if word[left] == '?':\n                    for letter in alphabet:\n                        count[letter] -= 1\n                        if count[letter] == 0:\n                            del count[letter]\n                else:\n                    count[word[left]] -= 1\n                    if count[word[left]] == 0:\n                        del count[word[left]]\n                substring.remove(word[left])\n                left += 1\n\n        # Move the right pointer of the sliding window to the right\n        right += 1\n\n    # If no nice word is found, return -1\n    return -1"}
{"solution": "n = int(input())\nweights = list(map(int, input().split()))\n\ncount_100 = weights.count(100)\ncount_200 = weights.count(200)\n\nif count_100 % 2 == 0 and count_100 <= count_200:\n    print(\"YES\")\nelif count_100 % 2 == 1 and count_100 <= count_200 - 1 and count_200 % 2 == 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def min_time(n, m, building):\n    time = 0\n    pos = 0\n    for floor in building:\n        if '1' in floor:\n            time += 2 * floor[pos:].index('1')\n            pos = floor.rindex('1')\n            time += floor[pos:].count('1')\n    return time\n\nn, m = map(int, input().split())\nbuilding = [input() for _ in range(n)][::-1]\nprint(min_time(n, m, building))"}
{"solution": "import sys\n\ndef min_cost_to_catch_mouse(n, costs, next_rooms):\n    # Initialize a list to store the minimum cost to catch the mouse in each room\n    min_costs = [sys.maxsize] * n\n\n    # Iterate over each room\n    for i in range(n):\n        # If the mouse can be caught in the current room, the minimum cost is the cost of setting a trap in that room\n        if next_rooms[i] == i:\n            min_costs[i] = costs[i]\n        # Otherwise, the minimum cost is the cost of setting a trap in the current room plus the minimum cost to catch the mouse in the next room\n        else:\n            min_costs[i] = costs[i] + min_costs[next_rooms[i] - 1]\n\n    # Return the minimum cost to catch the mouse\n    return min(min_costs)\n\n# Read the input\nn = int(input())\ncosts = list(map(int, input().split()))\nnext_rooms = list(map(int, input().split()))\n\n# Print the minimum cost to catch the mouse\nprint(min_cost_to_catch_mouse(n, costs, next_rooms))"}
{"solution": "# Get the input\nn, a, b = map(int, input().split())\n\n# Calculate the final position using modular arithmetic\nfinal_position = (a + b - 1) % n\n\n# If the final position is 0, it means Vasya is at the last entrance\nif final_position == 0:\n    final_position = n\n\n# Print the result\nprint(final_position)"}
{"solution": "def min_arithmetic_progressions(n, a):\n    count = 0\n    i = 0\n    while i < n:\n        if i + 1 < n and a[i + 1] != -1 and a[i] != -1 and a[i + 1] - a[i] != a[i + 2] - a[i + 1]:\n            count += 1\n            i += 1\n        elif i + 1 < n and a[i] == -1 and a[i + 1] != -1 and a[i + 2] != -1 and (a[i + 2] - a[i + 1]) % 2 == 0:\n            a[i] = a[i + 1] - (a[i + 2] - a[i + 1])\n        elif i + 2 < n and a[i] != -1 and a[i + 1] == -1 and a[i + 2] != -1:\n            a[i + 1] = a[i] + (a[i + 2] - a[i]) // 2\n        elif i + 2 < n and a[i] == -1 and a[i + 1] == -1 and a[i + 2] != -1:\n            a[i] = a[i + 2] - 2 * (a[i + 2] - a[i + 1])\n            a[i + 1] = a[i + 2] - (a[i + 2] - a[i + 1])\n        i += 1\n    return count + 1\n\nn = int(input())\na = list(map(int, input().split()))\nprint(min_arithmetic_progressions(n, a))"}
{"solution": "def max_beauty(n, k, s):\n    # Initialize variables to keep track of the maximum beauty and the current beauty\n    max_beauty = 0\n    current_beauty = 1\n\n    # Iterate over the string\n    for i in range(1, n):\n        # If the current character is the same as the previous character, increment the current beauty\n        if s[i] == s[i - 1]:\n            current_beauty += 1\n        # If the current character is different from the previous character, reset the current beauty to 1\n        else:\n            # If we can change the previous character to match the current character, do so\n            if k > 0:\n                k -= 1\n                current_beauty += 1\n            # Otherwise, update the maximum beauty with the previous beauty\n            else:\n                max_beauty = max(max_beauty, current_beauty)\n                current_beauty = 1\n\n    # Update the maximum beauty with the current beauty\n    max_beauty = max(max_beauty, current_beauty)\n\n    # If we can change the remaining characters to make a longer substring, do so\n    max_beauty = max(max_beauty, min(n, k + 1))\n\n    return max_beauty\n\n# Read the input\nn, k = map(int, input().split())\ns = input()\n\n# Print the maximum beauty\nprint(max_beauty(n, k, s))"}
{"solution": "# Read the input\nn = int(input())\nseats = list(map(int, input().split()))\n\n# Initialize the coalition with Alice's party\ncoalition = [1]\ncoalition_seats = seats[0]\n\n# Sort the other parties by the number of seats in descending order\nother_parties = sorted(range(2, n + 1), key=lambda i: seats[i], reverse=True)\n\n# Iterate over the other parties\nfor party in other_parties:\n    # Check if adding the party to the coalition satisfies both conditions\n    if coalition_seats + seats[party] > n // 2 and seats[0] >= 2 * seats[party]:\n        # Add the party to the coalition\n        coalition.append(party)\n        coalition_seats += seats[party]\n\n# Print the result\nif len(coalition) == 1 and coalition_seats > n // 2:\n    print(1)\n    print(1)\nelif len(coalition) > 1:\n    print(len(coalition))\n    print(' '.join(map(str, coalition)))\nelse:\n    print(0)"}
{"solution": "# Read the input\nn = int(input())\n\n# Initialize the total reward\ntotal_reward = 0.0\n\n# Calculate the total reward\nfor i in range(n, 0, -1):\n    total_reward += 1.0 / i\n\n# Print the result\nprint(\"{:.10f}\".format(total_reward))"}
{"solution": "# Read the input\nn = int(input())\n\n# Initialize the number of children and the list of candies\nk = 0\ncandies = []\n\n# While there are still candies left\nwhile n > 0:\n    # Increase the number of children\n    k += 1\n    # Give the child the next available candy\n    candies.append(min(k, n))\n    # Decrease the number of candies\n    n -= candies[-1]\n\n# Print the number of children\nprint(k)\n# Print the number of candies for each child\nprint(' '.join(map(str, candies)))"}
{"solution": "# Read the input\nn = int(input())\nm = int(input())\n\n# Calculate 2^n\npower_of_two = 1 << n\n\n# Calculate m mod 2^n\nremainder = m % power_of_two\n\n# Print the result\nprint(remainder)"}
{"solution": "def correct_word(word):\n    vowels = 'aeiouy'\n    i = 0\n    while i < len(word) - 1:\n        if word[i] in vowels and word[i + 1] in vowels:\n            word = word[:i] + word[i + 1:]\n        else:\n            i += 1\n    return word\n\nn = int(input())\ns = input()\nprint(correct_word(s))"}
{"solution": "def solve(n, a, b, seats):\n    # Initialize the count of students that can be seated\n    count = 0\n\n    # Initialize the previous seat as empty\n    prev = '.'\n\n    # Iterate over the seats\n    for seat in seats:\n        # If the seat is empty\n        if seat == '.':\n            # If the previous seat was empty and there are still programmers or athletes left\n            if prev == '.' and (a > 0 or b > 0):\n                # If there are more programmers than athletes, seat a programmer\n                if a > b:\n                    a -= 1\n                # Otherwise, seat an athlete\n                else:\n                    b -= 1\n                # Increment the count of students that can be seated\n                count += 1\n                # Update the previous seat\n                prev = 'student'\n            # If the previous seat was occupied, update the previous seat\n            else:\n                prev = '.'\n        # If the seat is occupied, update the previous seat\n        else:\n            prev = 'jury'\n\n    # Return the count of students that can be seated\n    return count\n\n# Read the input\nn, a, b = map(int, input().split())\nseats = input()\n\n# Print the result\nprint(solve(n, a, b, seats))"}
{"solution": "import math\n\ndef find_pair(r):\n    # The function is H(x, y) = x^2 + 2xy + x + 1 = (x + 1)^2 + 2xy\n    # So, we need to find a square number that is less than or equal to r\n    # and then check if there exists a y such that 2xy equals the difference\n    # between r and the square number\n\n    # Find the square root of r and round it down to the nearest integer\n    sqrt_r = int(math.sqrt(r))\n\n    # Check all possible square numbers less than or equal to r\n    for x in range(1, sqrt_r + 1):\n        square = x * x + 2 * x + 1\n        if square > r:\n            break\n        elif (r - square) % (2 * x) == 0:\n            y = (r - square) // (2 * x)\n            return x, y\n\n    # If no pair is found, return \"NO\"\n    return \"NO\"\n\n# Read the input\nr = int(input())\n\n# Find the pair and print the output\nresult = find_pair(r)\nif result == \"NO\":\n    print(\"NO\")\nelse:\n    print(*result)"}
{"solution": "# Read the input\nn = int(input())\nballoons = list(map(int, input().split()))\n\n# Check if it's possible to divide the balloons\nif n < 3 or sum(balloons) % 2 == 0:\n    print(-1)\nelse:\n    # Sort the balloons in descending order\n    balloons.sort(reverse=True)\n\n    # Initialize the sum of balloons for Grigory\n    grigory_sum = 0\n\n    # Initialize the list of packets for Grigory\n    grigory_packets = []\n\n    # Iterate over the packets\n    for i in range(n):\n        # If adding the current packet to Grigory's packets doesn't violate the conditions, do it\n        if grigory_sum + balloons[i] <= sum(balloons) // 2 and len(grigory_packets) < n // 2:\n            grigory_sum += balloons[i]\n            grigory_packets.append(i + 1)\n\n    # Print the result\n    print(len(grigory_packets))\n    print(' '.join(map(str, grigory_packets)))"}
{"solution": "n = int(input())\n\n# Start from the largest possible digit (9)\ndigit = 9\nwhile digit > 0:\n    # Check if n is divisible by the current digit\n    if n % digit == 0:\n        # If yes, print the digit n/digit times\n        print(n // digit)\n        print(' '.join([str(digit)] * (n // digit)))\n        break\n    digit -= 1"}
{"solution": "def sieve_of_eratosthenes(n):\n    primes = [True] * (n+1)\n    p = 2\n    while p * p <= n:\n        if primes[p] == True:\n            for i in range(p * p, n+1, p):\n                primes[i] = False\n        p += 1\n    return primes\n\ndef find_max_simple_subset(a):\n    n = len(a)\n    max_sum = 2 * 10**6\n    primes = sieve_of_eratosthenes(max_sum)\n    freq = {}\n    for num in a:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    simple_subsets = []\n    for i in range(n):\n        for j in range(i+1, n):\n            if primes[a[i] + a[j]]:\n                simple_subsets.append((a[i], a[j]))\n    max_size = 0\n    max_subset = []\n    for subset in simple_subsets:\n        size = sum(freq[num] for num in subset)\n        if size > max_size:\n            max_size = size\n            max_subset = subset\n    return max_size, max_subset\n\nn = int(input())\na = list(map(int, input().split()))\nmax_size, max_subset = find_max_simple_subset(a)\nprint(max_size)\nprint(*max_subset)"}
{"solution": "def greatest_beautiful_divisor(n):\n    # Find the largest k such that (2^k - 1) * (2^k - 1) <= n\n    k = 1\n    while (2**k - 1) * (2**k - 1) <= n:\n        k += 1\n    k -= 1\n\n    # Calculate the greatest beautiful divisor\n    greatest_divisor = (2**k - 1) * (2**k - 1)\n\n    # Check if n is divisible by the greatest beautiful divisor\n    while n % greatest_divisor != 0:\n        # If not, decrease k and recalculate the greatest beautiful divisor\n        k -= 1\n        greatest_divisor = (2**k - 1) * (2**k - 1)\n\n    return greatest_divisor\n\n# Read the input\nn = int(input())\n\n# Find and print the greatest beautiful divisor\nprint(greatest_beautiful_divisor(n))"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(m, d, a, b):\n    a = list(map(int, str(a)))\n    b = list(map(int, str(b)))\n    n = len(a)\n\n    # dp[i][j][k] is the number of d-magic numbers from 0 to j*10^i that are multiples of m and have k digits\n    dp = [[[0] * (n + 1) for _ in range(2)] for _ in range(n)]\n\n    # Base case: dp[0][0][0] = 1 if d is 0, 0 otherwise\n    dp[0][0][1] = 1 if a[0] == d else 0\n\n    for i in range(n):\n        for j in range(2):\n            for k in range(n + 1):\n                for l in range(10):\n                    if i % 2 == 0 and l == d:\n                        continue\n                    if j == 1 or l < a[i]:\n                        dp[i + 1][j or l < b[i]][k + 1] = (dp[i + 1][j or l < b[i]][k + 1] + dp[i][j][k]) % MOD\n                    if j == 1 or l > b[i]:\n                        continue\n                    if l == d and i % 2 == 0:\n                        dp[i + 1][1][k + 1] = (dp[i + 1][1][k + 1] + dp[i][j][k]) % MOD\n\n    # Return the number of d-magic numbers in the segment [a, b] that are multiples of m\n    return sum(dp[n][1][k] for k in range(n + 1) if k * m % 10 == 0) % MOD\n\nm, d = map(int, input().split())\na = input()\nb = input()\nprint(solve(m, d, a, b))"}
{"solution": "n, m = map(int, input().split())\na = list(map(int, input().split()))\n\nqueue = list(range(n))\nlast_child = -1\n\nwhile queue:\n    child = queue.pop(0)\n    a[child] -= m\n    if a[child] > 0:\n        queue.append(child)\n    else:\n        last_child = child + 1\n\nprint(last_child)"}
{"solution": "# List of available denominations\ndenominations = [100, 20, 10, 5, 1]\n\n# Input the total amount\nn = int(input())\n\n# Initialize the number of bills\nnum_bills = 0\n\n# Iterate over the denominations\nfor denomination in denominations:\n    # While the total amount is greater than or equal to the current denomination\n    while n >= denomination:\n        # Subtract the denomination from the total amount\n        n -= denomination\n        # Increment the number of bills\n        num_bills += 1\n\n# Print the minimum number of bills\nprint(num_bills)"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(n, k):\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(min(i, k) + 1):\n            dp[i][j] = (dp[i - 1][j] * (i - j) + dp[i - 1][j - 1] * (j + 1)) % MOD\n\n    return dp[n][k]\n\nn, k = map(int, input().split())\nprint(solve(n, k))"}
{"solution": "import heapq\n\ndef max_beauty(n, k, b, c):\n    roses = sorted(zip(b, c), key=lambda x: (-x[0], x[1]))\n    heap = []\n    total_beauty = 0\n    count = 0\n    for beauty, color in roses:\n        if count < k:\n            total_beauty += beauty\n            count += 1\n            heapq.heappush(heap, beauty)\n            if len(heap) > 2:\n                heapq.heappop(heap)\n        elif color != roses[count-1][1] and color != roses[count-2][1]:\n            total_beauty -= heapq.heappop(heap)\n            total_beauty += beauty\n            heapq.heappush(heap, beauty)\n    if count < k:\n        return -1\n    return total_beauty\n\nn, k = map(int, input().split())\nb = list(map(int, input().split()))\nc = input()\nprint(max_beauty(n, k, b, c))"}
{"solution": "def continued_fraction_to_fraction(continued_fraction):\n    numerator, denominator = 0, 1\n    for coefficient in reversed(continued_fraction):\n        numerator, denominator = coefficient * denominator + numerator, numerator\n    return numerator, denominator\n\ndef are_fractions_equal(p, q, continued_fraction):\n    numerator, denominator = continued_fraction_to_fraction(continued_fraction)\n    return p * denominator == q * numerator\n\np, q = map(int, input().split())\nn = int(input())\ncontinued_fraction = list(map(int, input().split()))\n\nprint(\"YES\" if are_fractions_equal(p, q, continued_fraction) else \"NO\")"}
{"solution": "def correct_expression(expression):\n    A, B, C = expression.split('+')[0], expression.split('+')[1].split('=')[0], expression.split('=')[1]\n    A_count, B_count, C_count = len(A), len(B), len(C)\n\n    if A_count + B_count == C_count:\n        return expression\n    elif A_count + B_count + 1 == C_count:\n        return A + '+' + B + '=' + C[:-1] + '|'\n    elif A_count + B_count - 1 == C_count:\n        return A + '+' + B[:-1] + '=' + C + '|'\n    elif A_count + B_count + 2 == C_count:\n        return A + '|' + '+' + B + '=' + C[:-2] + '||'\n    elif A_count + B_count - 2 == C_count:\n        return A[:-1] + '+' + B[:-1] + '=' + C + '||'\n    else:\n        return \"Impossible\"\n\nexpression = input()\nprint(correct_expression(expression))"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(n, k):\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(i * i + 1):\n            for l in range(max(0, j - i), j + 1):\n                dp[i][j] = (dp[i][j] + dp[i - 1][l]) % MOD\n\n    return dp[n][k]\n\nn, k = map(int, input().split())\nprint(solve(n, k))"}
{"solution": "def can_reach_point(x, y, d):\n    # Check if the point can be reached by the robot arm\n    # with the given section lengths and modes\n    # Return True if it can be reached, False otherwise\n    pass\n\ndef find_robot_arm_configuration(points):\n    # Find the configuration of the robot arm and the way to bring\n    # the end joint to each point\n    # Return the configuration and the ways to reach each point\n    # as a tuple (m, d, w)\n    # If it's not possible to configure the robot arm, return None\n    pass\n\n# Read the input\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Find the robot arm configuration\nresult = find_robot_arm_configuration(points)\n\n# Print the output\nif result is None:\n    print(-1)\nelse:\n    m, d, w = result\n    print(m)\n    print(' '.join(map(str, d)))\n    for way in w:\n        print(way)"}
{"solution": "import re\n\n# Get the length of the interview\nn = int(input())\n\n# Get the interview string\ns = input()\n\n# Define the filler word pattern\npattern = r'(ogo)+'\n\n# Replace the filler words with asterisks\nresult = re.sub(pattern, '***', s)\n\n# Print the result\nprint(result)"}
{"solution": "import math\n\ndef prime_factors(n):\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef g(x, p):\n    k = 0\n    while x % p**k == 0:\n        k += 1\n    return p**(k-1)\n\ndef f(x, y):\n    factors = prime_factors(x)\n    product = 1\n    for p in factors:\n        product *= g(y, p)\n    return product\n\ndef solve(x, n):\n    mod = 10**9 + 7\n    result = 1\n    for i in range(1, n+1):\n        result = (result * f(x, i)) % mod\n    return result\n\nx, n = map(int, input().split())\nprint(solve(x, n))"}
{"solution": "def s(x):\n    return sum(int(digit) for digit in str(x))\n\ndef f(x, a, b, c):\n    return x - b * s(x) ** a - c\n\ndef binary_search(a, b, c):\n    left, right = 1, 10 ** 9\n    solutions = []\n    while left <= right:\n        mid = (left + right) // 2\n        val = f(mid, a, b, c)\n        if val == 0:\n            solutions.append(mid)\n            left = mid + 1\n        elif val < 0:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return solutions\n\na, b, c = map(int, input().split())\nsolutions = binary_search(a, b, c)\nprint(len(solutions))\nprint(' '.join(map(str, solutions)))"}
{"solution": "def is_solvable(cube):\n    # Check if the cube is already solved\n    if len(set(cube)) == 1:\n        return True\n\n    # Define the possible rotations\n    rotations = [\n        [0, 1, 2, 3, 4, 5, 18, 19, 20, 21, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 22, 23],\n        [0, 1, 2, 3, 12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 16, 17, 18, 19, 20, 21, 22, 23],\n        [0, 1, 2, 3, 16, 17, 18, 19, 8, 9, 10, 11, 12, 13, 14, 15, 20, 21, 22, 23, 4, 5, 6, 7],\n        [0, 1, 2, 3, 4, 5, 6, 7, 20, 21, 22, 23, 16, 17, 18, 19, 12, 13, 14, 15, 8, 9, 10, 11],\n        [0, 9, 2, 11, 4, 5, 6, 7, 8, 17, 10, 19, 12, 13, 14, 15, 16, 1, 20, 3, 22, 21, 2, 23],\n        [0, 1, 10, 3, 4, 5, 14, 7, 8, 9, 18, 11, 12, 13, 22, 15, 16, 17, 6, 19, 20, 21, 2, 23]\n    ]\n\n    # Check each rotation\n    for rotation in rotations:\n        new_cube = [cube[i] for i in rotation]\n        if len(set(new_cube[0:4])) == 1 and len(set(new_cube[4:8])) == 1 and len(set(new_cube[8:12])) == 1 and len(set(new_cube[12:16])) == 1 and len(set(new_cube[16:20])) == 1 and len(set(new_cube[20:24])) == 1:\n            return True\n\n    return False\n\n# Read the input\ncube = list(map(int, input().split()))\n\n# Check if the cube is solvable\nif is_solvable(cube):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def calculate_i(s):\n    i = (s // 50) % 475\n    return i\n\ndef generate_tshirts(i):\n    tshirts = []\n    for _ in range(25):\n        i = (i * 96 + 42) % 475\n        tshirts.append(26 + i)\n    return tshirts\n\ndef min_successful_hacks(p, x, y):\n    if p in generate_tshirts(calculate_i(y)):\n        return (y - x) // 100\n    else:\n        return (y - x + 50) // 100\n\np, x, y = map(int, input().split())\nprint(min_successful_hacks(p, x, y))"}
{"solution": "# Read input\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# Initialize total distance\ntotal_distance = 0\n\n# If Winnie needs to have a meal more than once\nif n > 1:\n    # Sort the distances\n    distances = sorted([a, b, c])\n\n    # Calculate the total distance\n    total_distance = distances[0] * (n - 1) + distances[1]\n\n# Print the result\nprint(total_distance)"}
{"solution": "# Get the input\nx1, x2, x3 = map(int, input().split())\n\n# Sort the coordinates\ncoordinates = sorted([x1, x2, x3])\n\n# Calculate the minimum total distance\nmin_distance = (coordinates[1] - coordinates[0]) + (coordinates[2] - coordinates[1])\n\n# Print the result\nprint(min_distance)"}
{"solution": "from collections import Counter\n\ndef min_operations(n, x, a):\n    # Create a counter to store the frequency of each element in the array\n    counter = Counter(a)\n\n    # If there are already two equal elements, return 0\n    if len(counter) < n:\n        return 0\n\n    # Create a set to store the unique elements in the array after applying the operation\n    unique_elements = set()\n\n    # Iterate over the elements in the array\n    for element in a:\n        # Apply the operation to the element\n        new_element = element & x\n\n        # If the new element is already in the set, return the number of operations performed so far\n        if new_element in unique_elements:\n            return len(unique_elements)\n\n        # Add the new element to the set\n        unique_elements.add(new_element)\n\n    # If it is impossible to make two elements equal, return -1\n    return -1\n\n# Read the input\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Print the result\nprint(min_operations(n, x, a))"}
{"solution": "def is_plus_shape(grid):\n    h = len(grid)\n    w = len(grid[0])\n    center = None\n\n    # Find the center of the '+' shape\n    for i in range(1, h - 1):\n        for j in range(1, w - 1):\n            if grid[i][j] == '*' and grid[i-1][j] == '*' and grid[i+1][j] == '*' and grid[i][j-1] == '*' and grid[i][j+1] == '*':\n                center = (i, j)\n                break\n        if center:\n            break\n\n    # If no center is found, return False\n    if not center:\n        return False\n\n    # Check the cells in each direction from the center\n    for i in range(center[0] - 1, -1, -1):\n        if grid[i][center[1]] != '*':\n            return False\n    for i in range(center[0] + 1, h):\n        if grid[i][center[1]] != '*':\n            return False\n    for j in range(center[1] - 1, -1, -1):\n        if grid[center[0]][j] != '*':\n            return False\n    for j in range(center[1] + 1, w):\n        if grid[center[0]][j] != '*':\n            return False\n\n    # If all checks pass, return True\n    return True\n\n# Read the input\nh, w = map(int, input().split())\ngrid = [input() for _ in range(h)]\n\n# Check if the grid has a single '+' shape and print the result\nif is_plus_shape(grid):\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "def solve(n, a, b):\n    # Check if it is possible to construct a graph with the given constraints\n    if a + b > n + 1 or a * b > n * (n - 1) // 2:\n        print(\"NO\")\n        return\n\n    # Initialize the adjacency matrix with all zeros\n    matrix = [[0] * n for _ in range(n)]\n\n    # Add edges to the graph to create the required number of components in it\n    for i in range(1, a):\n        matrix[i][0] = matrix[0][i] = 1\n\n    # Add edges to the graph to create the required number of components in its complement\n    for i in range(a, a + b - 1):\n        matrix[i][i - a + 1] = matrix[i - a + 1][i] = 1\n\n    # Add remaining edges to the graph to ensure that it is connected\n    for i in range(a + b, n):\n        matrix[i][0] = matrix[0][i] = 1\n\n    # Print the result\n    print(\"YES\")\n    for row in matrix:\n        print(\"\".join(map(str, row)))\n\n# Read the input\nn, a, b = map(int, input().split())\n\n# Solve the problem\nsolve(n, a, b)"}
{"solution": "# Read input\nc, d = map(int, input().split())\nn, m = map(int, input().split())\nk = int(input())\n\n# Calculate the number of people that need to go to the finals from the main rounds\nmain_round_finalists = max(0, n * m - k)\n\n# Calculate the number of main rounds needed\nmain_rounds = (main_round_finalists + n - 1) // n\n\n# Calculate the number of additional rounds needed\nadditional_rounds = max(0, main_rounds * n - main_round_finalists)\n\n# Calculate the minimum number of problems the jury needs to prepare\nmin_problems = main_rounds * c + additional_rounds * d\n\n# Print the result\nprint(min_problems)"}
{"solution": "def find_path(s):\n    # Create a dictionary to store the adjacency list of each letter\n    adj = {c: [] for c in s}\n\n    # Populate the adjacency list\n    for i in range(26):\n        adj[s[i]].append(s[i+1])\n        adj[s[i+1]].append(s[i])\n\n    # Add additional edges to ensure that each letter has 4 neighbors\n    for i in range(13):\n        adj[s[i]].append(s[i+13])\n        adj[s[i+13]].append(s[i])\n\n    # Define a recursive function to find a path\n    def dfs(path, visited):\n        if len(path) == 27:\n            return True\n\n        for neighbor in adj[path[-1]]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                path.append(neighbor)\n                if dfs(path, visited):\n                    return True\n                path.pop()\n                visited.remove(neighbor)\n\n        return False\n\n    # Try to find a path starting from each letter\n    for start in s:\n        path = [start]\n        visited = set(path)\n        if dfs(path, visited):\n            # Convert the path into a grid\n            grid = [path[:13], path[13:]]\n            return grid\n\n    # If no path is found, return \"Impossible\"\n    return \"Impossible\"\n\n# Read the input string\ns = input()\n\n# Find a grid that contains a path whose tiles form the string s\nresult = find_path(s)\n\n# Print the result\nif result == \"Impossible\":\n    print(result)\nelse:\n    for row in result:\n        print(\"\".join(row))"}
{"solution": "import math\n\ndef compare_powers(x, y):\n    # Calculate the logarithmic values\n    log_x = math.log(x)\n    log_y = math.log(y)\n\n    # Compare the values\n    if y * log_x < x * log_y:\n        return '<'\n    elif y * log_x > x * log_y:\n        return '>'\n    else:\n        return '='\n\n# Get the input values\nx, y = map(int, input().split())\n\n# Print the result\nprint(compare_powers(x, y))"}
{"solution": "import math\n\n# Get the input\nr, h = map(int, input().split())\n\n# Calculate the volume of the cupboard\ncupboard_volume = (2 * math.pi * r * h * r) / 2\n\n# Calculate the volume of a balloon\nballoon_volume = (4 / 3) * math.pi * (r / 2) ** 3\n\n# Calculate the maximum number of balloons that can be stored in the cupboard\nmax_balloons = int(cupboard_volume // balloon_volume)\n\n# Print the result\nprint(max_balloons)"}
{"solution": "from collections import Counter\n\n# Get the input numbers\nnumbers = list(map(int, input().split()))\n\n# Count the occurrences of each number\ncounter = Counter(numbers)\n\n# Initialize the minimum sum as the sum of all numbers\nmin_sum = sum(numbers)\n\n# Iterate over the counter items\nfor num, freq in counter.items():\n    # If the frequency is greater than or equal to 2,\n    # calculate the sum of discarding two or three of that number\n    if freq >= 2:\n        min_sum = min(min_sum, sum(numbers) - min(3, freq) * num)\n\n# Print the minimum sum\nprint(min_sum)"}
{"solution": "# Read input\nn, a = map(int, input().split())\ncheckpoints = list(map(int, input().split()))\n\n# Sort checkpoints based on their distance from Vasya's starting position\ncheckpoints.sort(key=lambda x: abs(x - a))\n\n# Initialize total distance to 0\ntotal_distance = 0\n\n# Iterate over checkpoints, starting from the closest one\nfor i in range(n - 1):\n    # Add the distance to the current checkpoint to the total distance\n    total_distance += abs(checkpoints[i] - checkpoints[i + 1])\n\n# Print the minimum possible value\nprint(total_distance)"}
{"solution": "def sum_of_digits(n):\n    return sum(int(digit) for digit in str(n))\n\ndef find_root(n):\n    left, right = 1, n\n    while left <= right:\n        mid = (left + right) // 2\n        value = mid**2 + sum_of_digits(mid) * mid - n\n        if value == 0:\n            return mid\n        elif value < 0:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\nn = int(input())\nprint(find_root(n))"}
{"solution": "from datetime import datetime, timedelta\n\n# Get the current time and sleep duration from the user\ncurrent_time = input()\nsleep_duration = input()\n\n# Convert the time strings to datetime objects\ncurrent_time = datetime.strptime(current_time, '%H:%M')\nsleep_duration = datetime.strptime(sleep_duration, '%H:%M')\n\n# Calculate the time George went to bed\nbed_time = current_time - timedelta(hours=sleep_duration.hour, minutes=sleep_duration.minute)\n\n# Format the bed time as a string\nbed_time = bed_time.strftime('%H:%M')\n\n# Print the bed time\nprint(bed_time)"}
{"solution": "# Read the input\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize variables to keep track of the maximum mean and the length of the longest subsegment\nmax_mean = float('-inf')\nmax_length = 0\n\n# Initialize variables to keep track of the current sum and the length of the current subsegment\ncurrent_sum = 0\ncurrent_length = 0\n\n# Initialize variables to keep track of the start and end indices of the longest subsegment\nstart = 0\nend = 0\n\n# Iterate over the array\nfor i in range(n):\n    # Add the current element to the current sum\n    current_sum += a[i]\n    current_length += 1\n\n    # If the current mean is greater than the maximum mean, update the maximum mean and the length of the longest subsegment\n    if current_sum / current_length > max_mean:\n        max_mean = current_sum / current_length\n        max_length = current_length\n        start = i - current_length + 1\n        end = i\n\n    # If the current mean is equal to the maximum mean, update the length of the longest subsegment if the current subsegment is longer\n    elif current_sum / current_length == max_mean:\n        if current_length > max_length:\n            max_length = current_length\n            start = i - current_length + 1\n            end = i\n\n    # If the current sum is less than 0, reset the current sum and the length of the current subsegment\n    elif current_sum < 0:\n        current_sum = 0\n        current_length = 0\n\n# Print the length of the longest subsegment\nprint(max_length)"}
{"solution": "MOD = 998244353\n\ndef solve(n, m, k):\n    dp = [[0] * (k + 1) for _ in range(n)]\n    dp[0][0] = m\n    for i in range(1, n):\n        for j in range(k + 1):\n            dp[i][j] = dp[i - 1][j] * (m - 1) % MOD\n            if j > 0:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD\n    return sum(dp[n - 1]) % MOD\n\nn, m, k = map(int, input().split())\nprint(solve(n, m, k))"}
{"solution": "def is_magic_number(n):\n    n = str(n)\n    i = 0\n    while i < len(n):\n        if n[i] == '1':\n            if i + 2 < len(n) and n[i:i+3] == '144':\n                i += 3\n            elif i + 1 < len(n) and n[i:i+2] == '14':\n                i += 2\n            else:\n                i += 1\n        else:\n            return 'NO'\n    return 'YES'\n\nn = int(input())\nprint(is_magic_number(n))"}
{"solution": "def min_moves(n, m, i, j, a, b):\n    # Calculate the distance to each corner\n    dist_to_corners = [\n        (i - 1) // a + (j - 1) // b,\n        (n - i) // a + (j - 1) // b,\n        (n - i) // a + (m - j) // b,\n        (i - 1) // a + (m - j) // b\n    ]\n\n    # Check if it's possible to reach a corner\n    if all((n - i) % a != 0 or (j - 1) % b != 0 for _ in range(4)):\n        return \"Poor Inna and pony!\"\n\n    # Return the minimum number of moves\n    return min(dist_to_corners)\n\n# Read the input\nn, m, i, j, a, b = map(int, input().split())\n\n# Print the result\nprint(min_moves(n, m, i, j, a, b))"}
{"solution": "# Get the length of the string and the string itself\nn = int(input())\ns = input()\n\n# Initialize a stack and a counter for removed characters\nstack = []\nremoved = 0\n\n# Iterate over the string\nfor i in range(n):\n    # While the stack is not empty and the current character is the successor of the last character in the stack\n    while stack and ord(s[i]) == ord(stack[-1]) - 1:\n        # Remove the last character from the stack\n        stack.pop()\n        # Increment the counter for removed characters\n        removed += 1\n    # Add the current character to the stack\n    stack.append(s[i])\n\n# Print the maximum possible number of characters that can be removed\nprint(removed)"}
{"solution": "import sys\n\ndef min_bills(denominations, k, target):\n    dp = [float('inf')] * (target + 1)\n    dp[0] = 0\n\n    for coin in denominations:\n        for i in range(coin, target + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    for i in range(1, target + 1):\n        if dp[i] > k:\n            dp[i] = float('inf')\n\n    return dp[target] if dp[target] != float('inf') else -1\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    denominations = list(map(int, sys.stdin.readline().split()))\n    q = int(sys.stdin.readline())\n\n    for _ in range(q):\n        target = int(sys.stdin.readline())\n        result = min_bills(denominations, k, target)\n        print(result)\n\nif __name__ == '__main__':\n    main()"}
{"solution": "def min_time(s, x1, x2, t1, t2, p, d):\n    # Calculate the time it takes for Igor to reach x1\n    time_to_x1 = abs(x1 - p) / t1\n\n    # Calculate the time it takes for the tram to reach x1\n    if d == 1:\n        time_to_x1_tram = (s - p) / t1\n    else:\n        time_to_x1_tram = p / t1\n\n    # Calculate the time it takes for Igor to reach x2 from x1\n    time_x1_to_x2 = abs(x2 - x1) / t2\n\n    # If Igor can reach x1 before the tram, he should walk to x2\n    if time_to_x1 < time_to_x1_tram:\n        return time_x1_to_x2\n\n    # Otherwise, Igor should wait for the tram at x1 and then take it to x2\n    else:\n        # Calculate the time it takes for the tram to reach x2\n        if d == 1:\n            time_to_x2_tram = (s - x2) / t1\n        else:\n            time_to_x2_tram = x2 / t1\n\n        # Calculate the time it takes for Igor to reach the tram stop closest to x2\n        if d == 1:\n            time_to_tram_stop = (s - x1) / t2\n        else:\n            time_to_tram_stop = x1 / t2\n\n        # Return the minimum time it takes for Igor to reach x2\n        return max(time_to_x1_tram, time_to_tram_stop) + time_to_x2_tram\n\n# Read the input\ns, x1, x2 = map(int, input().split())\nt1, t2 = map(int, input().split())\np, d = map(int, input().split())\n\n# Print the minimum time it takes for Igor to reach x2\nprint(min_time(s, x1, x2, t1, t2, p, d))"}
{"solution": "# Get the input\nn, x = map(int, input().split())\n\n# Initialize the counter\ncount = 0\n\n# Iterate through all possible row and column numbers\nfor i in range(1, n + 1):\n    for j in range(1, n + 1):\n        # Check if the product equals x\n        if i * j == x:\n            # Increment the counter\n            count += 1\n\n# Print the result\nprint(count)"}
{"solution": "n, k = map(int, input().split())\npassword = []\n\n# Create a list of all possible lowercase Latin letters\nletters = [chr(i) for i in range(ord('a'), ord('z')+1)]\n\n# Iterate through the list of letters, adding distinct letters to the password\n# until the desired length is reached\nfor i in range(n):\n    if i < k:\n        password.append(letters[i])\n    else:\n        # Ensure that no two consecutive symbols are the same\n        if password[i-1] != letters[i % k]:\n            password.append(letters[i % k])\n        else:\n            password.append(letters[(i % k) + 1])\n\n# Print the password\nprint(''.join(password))"}
{"solution": "# Get the number of particles\nn = int(input())\n\n# Get the directions of the particles\ndirections = input()\n\n# Get the positions of the particles\npositions = list(map(int, input().split()))\n\n# Initialize the minimum time to collision as infinity\nmin_time = float('inf')\n\n# Iterate over the particles\nfor i in range(n - 1):\n    # If the particles are moving towards each other\n    if directions[i] == 'R' and directions[i + 1] == 'L':\n        # Calculate the time to collision\n        time = (positions[i + 1] - positions[i]) // 2\n        # Update the minimum time to collision\n        min_time = min(min_time, time)\n\n# If there was a collision\nif min_time != float('inf'):\n    # Print the time to collision\n    print(min_time)\nelse:\n    # Print -1 if there was no collision\n    print(-1)"}
{"solution": "def max_area(n, a, b, seals):\n    # Sort seals by their area in descending order\n    seals.sort(key=lambda x: x[0]*x[1], reverse=True)\n\n    # Initialize maximum area\n    max_area = 0\n\n    # Iterate over all pairs of seals\n    for i in range(n):\n        for j in range(i+1, n):\n            # Get the dimensions of the current pair of seals\n            x1, y1 = seals[i]\n            x2, y2 = seals[j]\n\n            # Check if the seals can be placed without overlapping\n            if (x1 <= a and x2 <= a and y1 <= b and y2 <= b) or \\\n               (x1 <= b and x2 <= b and y1 <= a and y2 <= a):\n                # Update maximum area\n                max_area = max(max_area, x1*y1 + x2*y2)\n\n    return max_area\n\n# Read input\nn, a, b = map(int, input().split())\nseals = [list(map(int, input().split())) for _ in range(n)]\n\n# Print output\nprint(max_area(n, a, b, seals))"}
{"solution": "n = int(input())\npoints = [list(map(int, input().split())) for _ in range(4*n + 1)]\n\nx_counts = {}\ny_counts = {}\n\nfor x, y in points:\n    x_counts[x] = x_counts.get(x, 0) + 1\n    y_counts[y] = y_counts.get(y, 0) + 1\n\nfor x, y in points:\n    if x_counts[x] == 1 and y_counts[y] == 1:\n        print(x, y)\n        break"}
{"solution": "def max_product(n):\n    if n < 10:\n        return n\n\n    product = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    for i in range(10, n + 1):\n        num = i\n        j = 9\n        while num > 0:\n            digit = num % 10\n            num //= 10\n            while j > digit and product[j] <= product[digit]:\n                j -= 1\n            product[j] = product[digit]\n        product[0] *= i % 10\n\n    return product[0]\n\nn = int(input())\nprint(max_product(n))"}
{"solution": "# Get the number of students\nn = int(input())\n\n# Get the votes for Elodreip from each student\nvotes = list(map(int, input().split()))\n\n# Find the maximum number of votes Elodreip gets from a student\nmax_votes = max(votes)\n\n# Initialize the smallest winning number for Awruk\nk = max_votes\n\n# Keep increasing k until Awruk gets strictly more votes than Elodreip\nwhile True:\n    # Calculate the total votes Awruk gets with the current k\n    awruk_votes = sum(k - vote for vote in votes)\n\n    # Calculate the total votes Elodreip gets with the current k\n    elodreip_votes = sum(votes)\n\n    # Check if Awruk wins with the current k\n    if awruk_votes > elodreip_votes:\n        break\n\n    # If not, increase k by 1\n    k += 1\n\n# Print the smallest winning number for Awruk\nprint(k)"}
{"solution": "def count_operations(colors):\n    operations = 0\n    while True:\n        deleted = False\n        new_colors = ''\n        i = 0\n        while i < len(colors):\n            if i == 0 and colors[i] != colors[i+1]:\n                deleted = True\n                i += 1\n            elif i == len(colors) - 1 and colors[i] != colors[i-1]:\n                deleted = True\n                i += 1\n            elif colors[i] != colors[i-1] or colors[i] != colors[i+1]:\n                deleted = True\n                i += 1\n            else:\n                new_colors += colors[i]\n                i += 1\n        if not deleted:\n            break\n        colors = new_colors\n        operations += 1\n    return operations\n\ncolors = input()\nprint(count_operations(colors))"}
{"solution": "from itertools import combinations\n\n# Get the number of elements in the array\nn = int(input())\n\n# Get the elements of the array\na = list(map(int, input().split()))\n\n# Sort the array\na.sort()\n\n# Find the minimum possible product of three distinct numbers\nmin_product = a[0] * a[1] * a[2]\n\n# Initialize a counter for the minimum products\ncount = 0\n\n# Iterate through all possible combinations of three distinct indices\nfor i, j, k in combinations(range(n), 3):\n    # If the product of the numbers at these indices is equal to the minimum product\n    if a[i] * a[j] * a[k] == min_product:\n        # Increment the counter\n        count += 1\n\n# Print the result\nprint(count)"}
{"solution": "# Get the number of Shiro's friends\nn = int(input())\n\n# Calculate the minimum number of straight cuts needed\ncuts = n\n\n# Print the result\nprint(cuts)"}
{"solution": "def max_bank_account(n):\n    if n < 0:\n        # If the number is negative, we want to make it less negative\n        # So we should delete the digit that makes it more negative\n        str_n = str(n)\n        delete_last = int(str_n[:-1])\n        delete_second_last = int(str_n[:-2] + str_n[-1])\n        return max(delete_last, delete_second_last)\n    else:\n        # If the number is positive or zero, we don't need to delete any digit\n        return n\n\nn = int(input())\nprint(max_bank_account(n))"}
{"solution": "# Define the spinner positions and their relationships\npositions = ['v', '<', '^', '>']\n\n# Get the input\nstart, end = input().split()\nn = int(input())\n\n# Determine the direction of rotation\nif start == end:\n    print('undefined')\nelif positions.index(end) == (positions.index(start) + n) % 4:\n    print('cw')\nelif positions.index(end) == (positions.index(start) - n) % 4:\n    print('ccw')"}
{"solution": "def count_standing_dominoes(n, s):\n    # Create a list to store the direction of each domino\n    # -1 means the domino is falling to the left\n    # 1 means the domino is falling to the right\n    # 0 means the domino is standing vertically\n    dominoes = [0] * n\n\n    # Set the initial direction of each domino\n    for i in range(n):\n        if s[i] == 'L':\n            dominoes[i] = -1\n        elif s[i] == 'R':\n            dominoes[i] = 1\n\n    # Simulate the process\n    while True:\n        # Create a copy of the current state of the dominoes\n        prev_dominoes = dominoes[:]\n\n        # Update the state of each domino\n        for i in range(n):\n            if dominoes[i] == -1 and i > 0 and dominoes[i-1] == 0:\n                dominoes[i-1] = -1\n            elif dominoes[i] == 1 and i < n-1 and dominoes[i+1] == 0:\n                dominoes[i+1] = 1\n\n        # Check if the state of the dominoes has changed\n        if dominoes == prev_dominoes:\n            break\n\n    # Count the number of dominoes that remain standing vertically\n    count = 0\n    for i in range(n):\n        if dominoes[i] == 0:\n            count += 1\n\n    return count\n\n# Read the input\nn = int(input())\ns = input()\n\n# Print the output\nprint(count_standing_dominoes(n, s))"}
{"solution": "def solve(n, m, leaders):\n    a = [0] * n\n    for i in range(m - 1, 0, -1):\n        a[leaders[i] - 1] = (leaders[i - 1] - leaders[i]) % n\n        if a[leaders[i] - 1] == 0:\n            return [-1]\n    a[leaders[0] - 1] = (leaders[-1] - leaders[0]) % n\n    if a[leaders[0] - 1] == 0:\n        return [-1]\n    return a\n\nn, m = map(int, input().split())\nleaders = list(map(int, input().split()))\nprint(*solve(n, m, leaders))"}
{"solution": "def max_number(a, k):\n    a = list(str(a))\n    n = len(a)\n    for i in range(n):\n        if k <= 0:\n            break\n        max_idx = i\n        for j in range(i+1, min(n, i+k+1)):\n            if a[j] > a[max_idx]:\n                max_idx = j\n        k -= max_idx - i\n        a[i:max_idx+1] = [a[max_idx]] + a[i:max_idx]\n    return int(''.join(a))\n\na, k = map(int, input().split())\nprint(max_number(a, k))"}
{"solution": "def is_arithmetic(seq):\n    return seq[1] - seq[0] == seq[2] - seq[1] == seq[3] - seq[2]\n\ndef is_geometric(seq):\n    return seq[1] / seq[0] == seq[2] / seq[1] == seq[3] / seq[2]\n\ndef next_element(seq):\n    if is_arithmetic(seq):\n        return seq[-1] + (seq[1] - seq[0])\n    elif is_geometric(seq):\n        return seq[-1] * (seq[1] / seq[0])\n    else:\n        return 42\n\nsequence = list(map(int, input().split()))\nnext_num = next_element(sequence)\n\nif next_num == 42 or next_num != int(next_num):\n    print(42)\nelse:\n    print(int(next_num))"}
{"solution": "# Read the input\nn = int(input())\ncolors = list(map(int, input().split()))\n\n# Initialize variables to keep track of the maximum distance and the last occurrence of each color\nmax_distance = 0\nlast_occurrence = {}\n\n# Iterate through the houses\nfor i in range(n):\n    # If the color of the current house has been seen before, update the maximum distance\n    if colors[i] in last_occurrence:\n        max_distance = max(max_distance, i - last_occurrence[colors[i]])\n    # Update the last occurrence of the current color\n    last_occurrence[colors[i]] = i\n\n# Handle the case where the first and last houses have the same color\nif colors[0] != colors[-1]:\n    max_distance = max(max_distance, n - last_occurrence[colors[0]])\n\n# Print the maximum distance\nprint(max_distance)"}
{"solution": "# Read the input\nn, m, k = map(int, input().split())\n\n# Calculate the lane number\nlane = (k - 1) // (2 * m) + 1\n\n# Calculate the desk number\ndesk = ((k - 1) % (2 * m)) // 2 + 1\n\n# Calculate the side of the desk\nside = 'L' if k % 2 == 1 else 'R'\n\n# Print the output\nprint(lane, desk, side)"}
{"solution": "# Read the input\nn = int(input())\ns = input()\n\n# Count the number of red, green, and blue cards\nred_count = s.count('R')\ngreen_count = s.count('G')\nblue_count = s.count('B')\n\n# Use modular arithmetic to determine the final color\nfinal_color = (red_count % 2) * 'R' + (green_count % 2) * 'G' + (blue_count % 2) * 'B'\n\n# Print the result\nprint(''.join(sorted(final_color)))"}
