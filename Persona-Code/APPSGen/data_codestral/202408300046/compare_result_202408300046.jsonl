{"solution": "def find_max_accordion_length(s):\n    # Find the indices of the first and last occurrences of '[' and ']'\n    first_open = s.find('[')\n    last_close = s.rfind(']')\n\n    # If '[' or ']' is not found or '[' is after ']', return -1\n    if first_open == -1 or last_close == -1 or first_open > last_close:\n        return -1\n\n    # Extract the substring between the first '[' and the last ']'\n    s = s[first_open:last_close+1]\n\n    # Find the indices of the first and last occurrences of ':'\n    first_colon = s.find(':')\n    last_colon = s.rfind(':')\n\n    # If ':' is not found or ':' is not found twice or the first ':' is after the last ':', return -1\n    if first_colon == -1 or last_colon == -1 or first_colon == last_colon:\n        return -1\n\n    # Extract the substring between the first and last ':'\n    s = s[first_colon:last_colon+1]\n\n    # Count the number of '|' characters in the substring\n    pipe_count = s.count('|')\n\n    # Return the length of the accordion\n    return 2 + 2 + pipe_count\n\n# Read the input string\ns = input()\n\n# Print the maximum possible length of the resulting accordion\nprint(find_max_accordion_length(s))"}
{"solution": "def max_sum_digits(x):\n    # Convert the number to string\n    x = str(x)\n\n    # Initialize the result\n    result = ''\n\n    # Iterate over the digits\n    for i in range(len(x)):\n        # Find the maximum digit that can be placed at this position\n        max_digit = max(x[i:])\n\n        # If the maximum digit is not '9', break the loop\n        if max_digit != '9':\n            break\n\n        # Append the maximum digit to the result\n        result += '9'\n\n    # If the maximum digit is not '9', replace the current digit with the maximum digit\n    if max_digit != '9':\n        result += str(int(max_digit) - 1)\n\n        # Append the remaining digits as '9'\n        result += '9' * (len(x) - i - 1)\n    else:\n        # If the maximum digit is '9', the result is the number itself\n        result = x\n\n    # Return the result as an integer\n    return int(result)\n\n# Get the input\nx = int(input())\n\n# Print the result\nprint(max_sum_digits(x))"}
{"solution": "def next_lucky_year(n):\n    while True:\n        n += 1\n        if str(n).count('0') >= len(str(n)) - 1:\n            return n - int(input_year)\n\ninput_year = int(input())\nprint(next_lucky_year(input_year))"}
{"solution": "def max_painted_sections(n, q, painters):\n    # Create a list to store the painted sections\n    painted = [0] * n\n\n    # Sort the painters based on their start point\n    painters.sort(key=lambda x: x[0])\n\n    # Hire the first painter\n    for i in range(painters[0][0] - 1, painters[0][1]):\n        painted[i] = 1\n\n    # Hire the painter that paints the most unpainted sections\n    for _ in range(q - 3):\n        max_unpainted = 0\n        max_painter = None\n        for painter in painters[1:]:\n            unpainted = sum(painted[painter[0] - 1:painter[1]])\n            if unpainted < max_unpainted:\n                max_unpainted = unpainted\n                max_painter = painter\n        if max_painter is not None:\n            for i in range(max_painter[0] - 1, max_painter[1]):\n                painted[i] = 1\n\n    # Return the number of painted sections\n    return sum(painted)\n\n# Read the input\nn, q = map(int, input().split())\npainters = [list(map(int, input().split())) for _ in range(q)]\n\n# Print the output\nprint(max_painted_sections(n, q, painters))"}
{"solution": "def is_lucky(time):\n    return '7' in time\n\ndef format_time(time):\n    return '{:02d}:{:02d}'.format(time // 60, time % 60)\n\ndef solve(x, hh, mm):\n    total_minutes = hh * 60 + mm\n    for y in range(0, 10000):\n        if is_lucky(format_time((total_minutes - y * x) % (24 * 60))):\n            return y\n\nx = int(input())\nhh, mm = map(int, input().split())\nprint(solve(x, hh, mm))"}
{"solution": "# Get the input\nn, pos, l, r = map(int, input().split())\n\n# Calculate the minimum number of seconds required\nif pos < l:\n    # If the cursor is to the left of the segment, move it to the left end of the segment and close tabs to the right\n    seconds = l - pos + r - l\nelif pos > r:\n    # If the cursor is to the right of the segment, move it to the right end of the segment and close tabs to the left\n    seconds = pos - r + r - l\nelse:\n    # If the cursor is within the segment, close tabs to the left and right of the segment\n    seconds = max(pos - l, r - pos)\n\n# Print the result\nprint(seconds)"}
{"solution": "import sys\n\ndef min_blows(n, x, d, h):\n    dp = [float('inf')] * (x + 1)\n    dp[0] = 0\n\n    for i in range(1, x + 1):\n        for j in range(n):\n            if d[j] >= i:\n                dp[i] = min(dp[i], dp[max(0, i - d[j])] + 1)\n            else:\n                next_heads = i - d[j] + h[j]\n                if next_heads < i:\n                    dp[i] = min(dp[i], dp[next_heads] + 1)\n\n    return dp[x] if dp[x] != float('inf') else -1\n\ndef main():\n    t = int(sys.stdin.readline())\n\n    for _ in range(t):\n        n, x = map(int, sys.stdin.readline().split())\n        d, h = [], []\n\n        for _ in range(n):\n            di, hi = map(int, sys.stdin.readline().split())\n            d.append(di)\n            h.append(hi)\n\n        print(min_blows(n, x, d, h))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def barn_empty_day(n, m):\n    day = 0\n    grains_in_barn = n\n    while grains_in_barn > 0:\n        day += 1\n        grains_in_barn += m\n        if grains_in_barn > n:\n            grains_in_barn = n\n        grains_in_barn -= day\n    return day\n\nn, m = map(int, input().split())\nprint(barn_empty_day(n, m))"}
{"solution": "def min_tiles_to_draw(hand):\n    suits = {'m': [], 'p': [], 's': []}\n    for tile in hand:\n        suits[tile[1]].append(int(tile[0]))\n\n    for suit in suits.values():\n        suit.sort()\n        if len(suit) >= 3:\n            if suit[0] + 1 == suit[1] and suit[1] + 1 == suit[2]:\n                return 0\n            elif suit.count(suit[0]) >= 3 or suit.count(suit[1]) >= 3:\n                return 0\n\n    return 1\n\nhand = input().split()\nprint(min_tiles_to_draw(hand))"}
{"solution": "def find_sofa(d, n, m, sofas, cnt):\n    left, right, top, bottom = cnt\n    count = [0] * 4\n    for i in range(d):\n        x1, y1, x2, y2 = sofas[i]\n        for j in range(d):\n            if i == j:\n                continue\n            x3, y3, x4, y4 = sofas[j]\n            if x1 < x3 and y1 == y3 and y2 == y4:\n                count[0] += 1\n            if x1 > x3 and y1 == y3 and y2 == y4:\n                count[1] += 1\n            if y1 < y3 and x1 == x3 and x2 == x4:\n                count[2] += 1\n            if y1 > y3 and x1 == x3 and x2 == x4:\n                count[3] += 1\n        if count == [left, right, top, bottom]:\n            return i + 1\n        count = [0] * 4\n    return -1\n\nd = int(input())\nn, m = map(int, input().split())\nsofas = [list(map(int, input().split())) for _ in range(d)]\ncnt = list(map(int, input().split()))\nprint(find_sofa(d, n, m, sofas, cnt))"}
{"solution": "# Read the input\nn = int(input())\n\n# Calculate the minimum possible number of days off\n# This is when all the days off are at the end of the year\nmin_days_off = n % 7\n\n# Calculate the maximum possible number of days off\n# This is when all the days off are at the beginning of the year\nmax_days_off = 7 - (n % 7)\n# If the number of days is less than 7, the maximum days off is the number of days\nif n < 7:\n    max_days_off = n\n\n# Print the result\nprint(min_days_off, max_days_off)"}
{"solution": "# Read the input\nn, a, b, p, q = map(int, input().split())\n\n# Calculate the number of tiles divisible by a, b and both a and b\ndiv_a = n // a\ndiv_b = n // b\ndiv_ab = n // (a * b)\n\n# Calculate the maximum number of chocolates Joty can get\nmax_chocolates = (div_a - div_ab) * p + (div_b - div_ab) * q + div_ab * max(p, q)\n\n# Print the result\nprint(max_chocolates)"}
{"solution": "n = int(input())\ntrophies = list(input())\n\n# Initialize variables to keep track of the maximum length of a subsegment of golden trophies\nmax_length = 0\ncurrent_length = 0\n\n# Initialize variables to keep track of the indices of silver trophies\nsilver_indices = []\n\n# Iterate over the trophies\nfor i in range(n):\n    if trophies[i] == 'G':\n        # If the current trophy is golden, increment the current length\n        current_length += 1\n    else:\n        # If the current trophy is silver, add its index to the list of silver indices\n        silver_indices.append(i)\n        # Reset the current length\n        current_length = 0\n    # Update the maximum length\n    max_length = max(max_length, current_length)\n\n# If there are no silver trophies, print the maximum length and exit\nif not silver_indices:\n    print(max_length)\n    exit()\n\n# Initialize variables to keep track of the maximum possible length of a subsegment of golden trophies\nmax_possible_length = max_length\ncurrent_length = 0\n\n# Iterate over the trophies\nfor i in range(n):\n    if trophies[i] == 'G':\n        # If the current trophy is golden, increment the current length\n        current_length += 1\n    else:\n        # If the current trophy is silver, calculate the length of the subsegment of golden trophies that would be created by swapping this trophy with a golden one\n        if i > 0 and trophies[i-1] == 'G':\n            left_length = current_length\n        else:\n            left_length = 0\n        if i < n-1 and trophies[i+1] == 'G':\n            right_length = current_length\n        else:\n            right_length = 0\n        # Update the maximum possible length\n        max_possible_length = max(max_possible_length, left_length + right_length + 1)\n        # Reset the current length\n        current_length = 0\n\n# Print the maximum possible length\nprint(max_possible_length)"}
{"solution": "from collections import deque\nimport sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef main():\n    n, k = map(int, read_input().split())\n    main_courses = set(map(int, read_input().split()))\n    dependencies = [set(map(int, read_input().split()[1:])) for _ in range(n)]\n\n    in_degree = [0] * (n + 1)\n    for i in range(1, n + 1):\n        for j in dependencies[i - 1]:\n            in_degree[j] += 1\n\n    queue = deque([i for i in range(1, n + 1) if in_degree[i] == 0 and i in main_courses])\n    order = []\n\n    while queue:\n        course = queue.popleft()\n        order.append(course)\n\n        for dependent in range(1, n + 1):\n            if course in dependencies[dependent - 1]:\n                in_degree[dependent] -= 1\n                if in_degree[dependent] == 0 and dependent in main_courses:\n                    queue.append(dependent)\n\n    if len(order) < k:\n        print(-1)\n    else:\n        print(len(order))\n        print(' '.join(map(str, order)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\nfrom collections import deque\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    p = list(map(int, sys.stdin.readline().split()))\n\n    stack = deque()\n    b = []\n    i = 0\n    for num in range(1, n + 1):\n        if i < k and p[i] == num:\n            stack.append(p[i])\n            i += 1\n        elif stack and stack[-1] == num:\n            b.append(stack.pop())\n        elif i < k:\n            stack.append(p[i])\n            i += 1\n        else:\n            print(-1)\n            return\n\n    while stack:\n        b.append(stack.pop())\n\n    print(*b)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Get the input\na, b, c = map(int, input().split())\n\n# Check if the difference is 0\nif c == 0:\n    # If the difference is 0, the sequence is constant\n    # Check if the first element is equal to Vasya's favorite number\n    if a == b:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    # If the difference is not 0, the sequence is an arithmetic progression\n    # Check if Vasya's favorite number is in the sequence\n    if (b - a) % c == 0 and (b - a) // c >= 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "# Read the input\ncnt_1 = int(input())\ncnt_2 = int(input())\ncnt_3 = int(input())\ncnt_4 = int(input())\n\n# Check if it is possible to form a regular bracket sequence\nif cnt_1 > 0 and cnt_4 > 0:\n    if cnt_1 > cnt_4:\n        cnt_1 -= cnt_4\n        cnt_4 = 0\n        if cnt_1 > cnt_2 + cnt_3:\n            print(0)\n        else:\n            print(1)\n    else:\n        cnt_4 -= cnt_1\n        cnt_1 = 0\n        if cnt_4 > cnt_2 + cnt_3:\n            print(0)\n        else:\n            print(1)\nelse:\n    print(1)"}
{"solution": "# Get the input\nn, k, t = map(int, input().split())\n\n# Calculate the number of standing spectators\nif t <= k:\n    # During the first k seconds, t spectators are standing\n    standing = t\nelif t <= n:\n    # After the first k seconds and before the n-th second, k spectators are standing\n    standing = k\nelse:\n    # After the n-th second, the number of standing spectators decreases linearly\n    standing = max(0, 2*n - t + 1 - k)\n\n# Print the result\nprint(standing)"}
{"solution": "s = input()\nt = ''\nu = ''\n\nwhile s:\n    if s[0] <= s[-1]:\n        t += s[0]\n        s = s[1:]\n    else:\n        t += s[-1]\n        s = s[:-1]\n\nwhile t:\n    u += t[-1]\n    t = t[:-1]\n\nprint(u)"}
{"solution": "def check_records():\n    T = int(input())\n    for _ in range(T):\n        n = int(input())\n        records = [list(map(int, input().split())) for _ in range(n)]\n        valid = True\n        for i in range(1, n):\n            if records[i][0] < records[i-1][0] or records[i][1] < records[i-1][1] or records[i][1] > records[i][0] or records[i][1] < records[i-1][1] or records[i][0] - records[i-1][0] < records[i][1] - records[i-1][1]:\n                valid = False\n                break\n        print(\"YES\" if valid else \"NO\")\n\ncheck_records()"}
{"solution": "def next_palindrome_time(time):\n    hours, minutes = map(int, time.split(':'))\n    while True:\n        minutes += 1\n        if minutes == 60:\n            minutes = 0\n            hours = (hours + 1) % 24\n        time = '{:02d}:{:02d}'.format(hours, minutes)\n        if time == time[::-1]:\n            return time\n\ndef minutes_to_sleep(current_time):\n    next_palindrome = next_palindrome_time(current_time)\n    current_minutes = int(current_time[:2]) * 60 + int(current_time[3:])\n    next_minutes = int(next_palindrome[:2]) * 60 + int(next_palindrome[3:])\n    return (next_minutes - current_minutes) % (24 * 60)\n\ncurrent_time = input()\nprint(minutes_to_sleep(current_time))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nmin_index = a.index(1)\nmax_index = a.index(n)\n\n# Swap the minimum and maximum elements if they are adjacent\nif abs(min_index - max_index) == 1:\n    print(n - 1)\nelse:\n    # Calculate the maximum distance between the minimum and maximum elements\n    distance = max(max_index, n - 1 - min_index)\n    print(distance)"}
{"solution": "# Get the input string\ns = input()\n\n# Calculate the length of the string\nn = len(s)\n\n# Check if the string is s-palindrome\nis_s_palindrome = True\nfor i in range(n // 2):\n    if s[i] != s[n - i - 1]:\n        is_s_palindrome = False\n        break\n\n# Print the result\nif is_s_palindrome:\n    print(\"TAK\")\nelse:\n    print(\"NIE\")"}
{"solution": "from collections import Counter\n\ndef max_permutation(a, b):\n    a_counter = Counter(str(a))\n    b_counter = Counter(str(b))\n    result = []\n\n    for digit in str(a):\n        while a_counter[digit] > 0 and b_counter[digit] > 0:\n            result.append(digit)\n            a_counter[digit] -= 1\n            b_counter[digit] -= 1\n\n    for digit in sorted(b_counter.keys(), reverse=True):\n        while b_counter[digit] > 0:\n            result.append(digit)\n            b_counter[digit] -= 1\n\n    while len(result) < len(str(a)):\n        for digit in sorted(a_counter.keys(), reverse=True):\n            while a_counter[digit] > 0:\n                result.append(digit)\n                a_counter[digit] -= 1\n\n    return int(''.join(result))\n\na = int(input())\nb = int(input())\nprint(max_permutation(a, b))"}
{"solution": "def check_win(board, player):\n    for i in range(10):\n        for j in range(10):\n            if i < 6 and board[i][j] == board[i+1][j] == board[i+2][j] == board[i+3][j] == board[i+4][j] == player:\n                return True\n            if j < 6 and board[i][j] == board[i][j+1] == board[i][j+2] == board[i][j+3] == board[i][j+4] == player:\n                return True\n            if i < 6 and j < 6 and board[i][j] == board[i+1][j+1] == board[i+2][j+2] == board[i+3][j+3] == board[i+4][j+4] == player:\n                return True\n            if i < 6 and j > 3 and board[i][j] == board[i+1][j-1] == board[i+2][j-2] == board[i+3][j-3] == board[i+4][j-4] == player:\n                return True\n    return False\n\ndef can_win(board):\n    for i in range(10):\n        for j in range(10):\n            if board[i][j] == '.':\n                board[i][j] = 'X'\n                if check_win(board, 'X'):\n                    return True\n                board[i][j] = '.'\n    return False\n\nboard = [list(input()) for _ in range(10)]\nprint('YES' if can_win(board) else 'NO')"}
{"solution": "n, k = map(int, input().split())\n\n# Check if it's possible to create the matrix\nif k > n * n or k < n:\n    print(-1)\nelse:\n    # Create an empty n x n matrix\n    matrix = [[0] * n for _ in range(n)]\n\n    # Fill the matrix\n    for i in range(n):\n        for j in range(i, n):\n            if k >= n - i:\n                matrix[i][j] = matrix[j][i] = 1\n                k -= n - i\n            if k == 0:\n                break\n\n    # Print the matrix\n    for row in matrix:\n        print(' '.join(map(str, row)))"}
{"solution": "# Get the input\nx, y, z = map(float, input().split())\n\n# Calculate all the expressions\nexpressions = [\n    x ** y ** z,\n    x ** z ** y,\n    (x ** y) ** z,\n    (x ** z) ** y,\n    y ** x ** z,\n    y ** z ** x,\n    (y ** x) ** z,\n    (y ** z) ** x,\n    z ** x ** y,\n    z ** y ** x,\n    (z ** x) ** y,\n    (z ** y) ** x\n]\n\n# Find the maximum value and its index\nmax_value = max(expressions)\nmax_index = expressions.index(max_value) + 1\n\n# Print the corresponding expression\nif max_index == 1:\n    print(\"x^y^z\")\nelif max_index == 2:\n    print(\"x^z^y\")\nelif max_index == 3:\n    print(\"(x^y)^z\")\nelif max_index == 4:\n    print(\"(x^z)^y\")\nelif max_index == 5:\n    print(\"y^x^z\")\nelif max_index == 6:\n    print(\"y^z^x\")\nelif max_index == 7:\n    print(\"(y^x)^z\")\nelif max_index == 8:\n    print(\"(y^z)^x\")\nelif max_index == 9:\n    print(\"z^x^y\")\nelif max_index == 10:\n    print(\"z^y^x\")\nelif max_index == 11:\n    print(\"(z^x)^y\")\nelif max_index == 12:\n    print(\"(z^y)^x\")"}
{"solution": "n = int(input())\ns = input()\n\n# Initialize the minimum number of operations as the length of the string\nmin_operations = n\n\n# Iterate over all possible lengths of the prefix\nfor i in range(1, n // 2 + 1):\n    # Check if the prefix repeats to form the string\n    if s[:i] * (n // i) == s[:n // i * i]:\n        # Calculate the number of operations required\n        operations = i + 1 if n % i > 0 else i\n        # Update the minimum number of operations\n        min_operations = min(min_operations, operations)\n\nprint(min_operations)"}
{"solution": "n = int(input())\nfiles = [input().split() for _ in range(n)]\n\nexamples = [file[0] for file in files if file[1] == '1']\nregular = [file[0] for file in files if file[1] == '0']\n\nscript = []\n\n# Rename examples\nfor i, example in enumerate(examples, 1):\n    script.append(f\"move {example} {i}\")\n\n# Rename regular tests\nfor i, reg in enumerate(regular, len(examples) + 1):\n    script.append(f\"move {reg} {i}\")\n\nprint(len(script))\nfor line in script:\n    print(line)"}
{"solution": "# Get the input ticket number\nticket = input()\n\n# Calculate the sum of the first three digits\nsum_first_half = sum(int(digit) for digit in ticket[:3])\n\n# Calculate the sum of the last three digits\nsum_second_half = sum(int(digit) for digit in ticket[3:])\n\n# Calculate the difference between the two sums\ndifference = abs(sum_first_half - sum_second_half)\n\n# If the difference is less than or equal to 9, then we can make the ticket lucky by replacing one digit\n# If the difference is greater than 9, then we need to replace two digits\nif difference <= 9:\n    print(1)\nelse:\n    print(2)"}
{"solution": "def order(x, m):\n    n = 1\n    while pow(x, n, m) != 1:\n        n += 1\n    return n\nm, x = map(int, input().split())\nprint(order(x, m))"}
{"solution": "MOD = 10**6 + 3\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1:\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\ndef nCr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * power(den, p - 2, p)) % p\n\ndef solve(n, k):\n    p = 2**n\n    num = p\n    den = p\n    for i in range(2, k + 1):\n        num = (num * (p - i + 1)) % MOD\n        den = (den * nCr(p, i, MOD)) % MOD\n    return num, den\n\nn, k = map(int, input().split())\nnum, den = solve(n, k)\nprint(num, den)"}
{"solution": "n = int(input())\nx, y = 0, 20000\n\nfor _ in range(n):\n    t, dir = input().split()\n    t = int(t)\n\n    if dir == \"North\":\n        y -= t\n    elif dir == \"South\":\n        y += t\n    elif dir == \"West\":\n        x -= t\n    elif dir == \"East\":\n        x += t\n\n    if y < 0 or y > 40000:\n        print(\"NO\")\n        exit()\n\n    if y == 0 and dir != \"North\":\n        print(\"NO\")\n        exit()\n\n    if y == 40000 and dir != \"South\":\n        print(\"NO\")\n        exit()\n\nif y == 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def solve(a1, b1, a2, b2, L, R):\n    if a1 == a2:\n        if b1 == b2 and L <= b1 <= R:\n            return R - L + 1\n        else:\n            return 0\n    else:\n        diff = b2 - b1\n        if diff % gcd(a1, a2) != 0:\n            return 0\n        else:\n            a1 //= gcd(a1, a2)\n            a2 //= gcd(a1, a2)\n            diff //= gcd(a1, a2)\n            k = (L - b1) // a1\n            l = (L - b2 + diff) // a2\n            if k > l:\n                k, l = l, k\n            count = 0\n            while k * a1 + b1 <= R:\n                if k * a1 + b1 == l * a2 + b2:\n                    count += 1\n                k += 1\n                l += 1\n            return count\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\na1, b1, a2, b2, L, R = map(int, input().split())\nprint(solve(a1, b1, a2, b2, L, R))"}
{"solution": "# Get the input\nn, a, b = map(int, input().split())\n\n# Calculate the maximum possible number x\nx = min(a, b, n)\n\n# Print the result\nprint(x)"}
{"solution": "def check_flag(flag):\n    n = len(flag)\n    m = len(flag[0])\n    if n % 3 != 0:\n        return False\n    part_size = n // 3\n    parts = [flag[i:i + part_size] for i in range(0, n, part_size)]\n    for part in parts:\n        for row in part:\n            if row.count(row[0]) != m:\n                return False\n    colors = set(flag[0][0] for flag in parts)\n    return len(colors) == 3\n\nn, m = map(int, input().split())\nflag = [input() for _ in range(n)]\nprint(\"YES\" if check_flag(flag) else \"NO\")"}
{"solution": "def find_position(n):\n    if n == 0:\n        return 0, 0\n\n    # The spiral can be divided into rings.\n    # Each ring has 6 segments, and each segment has length equal to the ring number.\n    # First, find the ring number.\n    ring = 1\n    while 6 * ring * (ring - 1) + 1 <= n:\n        ring += 1\n\n    # Now, find the segment and the position in the segment.\n    segment = (n - 6 * (ring - 1) * (ring - 2) - 1) // ring\n    position = (n - 6 * (ring - 1) * (ring - 2) - 1) % ring\n\n    # Calculate the coordinates.\n    if segment == 0:\n        x = ring - 1\n        y = -position\n    elif segment == 1:\n        x = ring - 1 - position\n        y = position - ring\n    elif segment == 2:\n        x = -position\n        y = ring\n    elif segment == 3:\n        x = -ring\n        y = ring - position\n    elif segment == 4:\n        x = position - ring\n        y = -position\n    else:\n        x = ring\n        y = position\n\n    return x, y\n\nn = int(input())\nx, y = find_position(n)\nprint(x, y)"}
{"solution": "# Get the input\na, b, c = map(int, input().split())\n\n# Check if it's possible to deal exactly c damage\nfor i in range(c // a + 1):\n    for j in range(c // b + 1):\n        if a * i + b * j == c:\n            print('Yes')\n            exit()\n\n# If no combination was found, print 'No'\nprint('No')"}
{"solution": "def check_tracks(n, L, kefa_barriers, sasha_barriers):\n    kefa_distances = [kefa_barriers[0]] + [kefa_barriers[i] - kefa_barriers[i-1] for i in range(1, n)] + [L - kefa_barriers[-1]]\n    sasha_distances = [sasha_barriers[0]] + [sasha_barriers[i] - sasha_barriers[i-1] for i in range(1, n)] + [L - sasha_barriers[-1]]\n\n    for _ in range(n):\n        if kefa_distances == sasha_distances:\n            return \"YES\"\n        sasha_distances = sasha_distances[1:] + [sasha_distances[0]]\n\n    return \"NO\"\n\nn, L = map(int, input().split())\nkefa_barriers = list(map(int, input().split()))\nsasha_barriers = list(map(int, input().split()))\n\nprint(check_tracks(n, L, kefa_barriers, sasha_barriers))"}
{"solution": "def longest_non_palindrome_substring(s):\n    n = len(s)\n    max_length = 0\n\n    for i in range(n):\n        for j in range(i+1, n+1):\n            substring = s[i:j]\n            if substring != substring[::-1]:\n                max_length = max(max_length, len(substring))\n\n    return max_length\n\ns = input()\nprint(longest_non_palindrome_substring(s))"}
{"solution": "n = int(input())\nratings = []\nfor _ in range(n):\n    a, b = map(int, input().split())\n    ratings.append((a, b))\n\nrated = False\nunrated = False\n\nfor i in range(n):\n    if ratings[i][0] != ratings[i][1]:\n        rated = True\n    if i > 0 and ratings[i][0] < ratings[i-1][0] and ratings[i][1] > ratings[i-1][1]:\n        unrated = True\n\nif rated and unrated:\n    print(\"maybe\")\nelif rated:\n    print(\"rated\")\nelse:\n    print(\"unrated\")"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Initialize the list to store the distances\ndistances = [0] * n\n\n# Initialize the variables to store the last zero index and the distance to it\nlast_zero = float('-inf')\ndist = float('inf')\n\n# Iterate over the array from left to right\nfor i in range(n):\n    # If the current element is zero, update the last zero index and reset the distance\n    if a[i] == 0:\n        last_zero = i\n        dist = 0\n    # Otherwise, update the distance to the last zero index\n    else:\n        dist += 1\n    # Store the distance in the distances list\n    distances[i] = dist\n\n# Reset the distance and the last zero index\ndist = float('inf')\nlast_zero = float('inf')\n\n# Iterate over the array from right to left\nfor i in range(n-1, -1, -1):\n    # If the current element is zero, update the last zero index and reset the distance\n    if a[i] == 0:\n        last_zero = i\n        dist = 0\n    # Otherwise, update the distance to the last zero index\n    else:\n        dist += 1\n    # Update the distance in the distances list if it is smaller than the current distance\n    distances[i] = min(distances[i], dist)\n\n# Print the distances\nprint(*distances)"}
{"solution": "def solve(n, s):\n    m = len(s)\n    dp = [[0] * m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if i == 0:\n                dp[i][j] = 1 if s[j] == '0' else 0\n            else:\n                dp[i][j] = dp[i - 1][j]\n                if j == 0:\n                    dp[i][j] += 1 if s[j] == '1' else 0\n                else:\n                    dp[i][j] += dp[i - 1][j - 1] if s[j] == '1' else 0\n    return sum(dp[n - 1])\n\nn = int(input())\ns = input()\nprint(solve(n, s))"}
{"solution": "import math\n\ndef find_min_angle_vectors(n, vectors):\n    angles = []\n    for i in range(n):\n        angle = math.atan2(vectors[i][1], vectors[i][0])\n        angles.append((angle, i))\n    angles.sort()\n\n    min_angle = float('inf')\n    min_pair = (0, 0)\n    for i in range(n):\n        angle_diff = min(abs(angles[(i+1)%n][0] - angles[i][0]), 2*math.pi - abs(angles[(i+1)%n][0] - angles[i][0]))\n        if angle_diff < min_angle:\n            min_angle = angle_diff\n            min_pair = (angles[i][1], angles[(i+1)%n][1])\n    return min_pair\n\nn = int(input())\nvectors = []\nfor _ in range(n):\n    x, y = map(int, input().split())\n    vectors.append((x, y))\n\nmin_pair = find_min_angle_vectors(n, vectors)\nprint(min_pair[0]+1, min_pair[1]+1)"}
{"solution": "def min_time(d, k, a, b, t):\n    time = 0\n    while d > 0:\n        if d > k:\n            time += a * k\n            d -= k\n        else:\n            time += a * d\n            d = 0\n        if d > 0:\n            time += t\n    return min(time, b * d)\n\nd, k, a, b, t = map(int, input().split())\nprint(min_time(d, k, a, b, t))"}
{"solution": "def max_gcd_sequence(n, k):\n    # Check if it's possible to create the sequence\n    if k > n or (n - k + 1) < k:\n        return [-1]\n\n    # Initialize the sequence with the first k-1 numbers\n    sequence = list(range(1, k))\n\n    # Add the remaining sum to the last number of the sequence\n    sequence.append(n - sum(sequence))\n\n    return sequence\n\n# Get the input\nn, k = map(int, input().split())\n\n# Print the output\nprint(*max_gcd_sequence(n, k))"}
{"solution": "def count_pairs(n, m):\n    count = 0\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if (i + j) % 5 == 0:\n                count += 1\n    return count\n\nn, m = map(int, input().split())\nprint(count_pairs(n, m))"}
{"solution": "def max_beauty(n, x, a):\n    max_ending_here = max_so_far = 0\n    for i in range(n):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n\n    max_ending_here = max_so_far_x = 0\n    for i in range(n):\n        max_ending_here = max(a[i] * x, max_ending_here * x + a[i] * x)\n        max_so_far_x = max(max_so_far_x, max_ending_here)\n\n    return max(max_so_far, max_so_far_x)\n\nn, x = map(int, input().split())\na = list(map(int, input().split()))\nprint(max_beauty(n, x, a))"}
{"solution": "def count_elements(n, m, x):\n    count = 0\n    for i in range(1, n + 1):\n        count += min(m, x // i)\n    return count\n\ndef find_kth_largest(n, m, k):\n    left, right = 1, n * m\n    while left < right:\n        mid = (left + right) // 2\n        if count_elements(n, m, mid) < k:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\nn, m, k = map(int, input().split())\nprint(find_kth_largest(n, m, k))"}
{"solution": "def find_kth_digit(k):\n    if k < 10:\n        return k\n\n    count = 9\n    length = 1\n    while k > count * length:\n        k -= count * length\n        length += 1\n        count *= 10\n\n    start_number = 10 ** (length - 1)\n    number = start_number + (k - 1) // length\n    position = (k - 1) % length\n\n    return int(str(number)[position])\n\nk = int(input())\nprint(find_kth_digit(k))"}
{"solution": "# Read input\nn, m, r = map(int, input().split())\ns = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Find the minimum price to buy\nmin_buy = min(s)\n\n# Calculate the maximum number of shares that can be bought\nmax_shares = r // min_buy\n\n# Find the maximum price to sell\nmax_sell = max(b)\n\n# Calculate the maximum number of bourles that can be held after the evening\nmax_bourles = r + max_shares * (max_sell - min_buy)\n\n# Print the result\nprint(max_bourles)"}
{"solution": "def find_error(t):\n    n = len(t)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0 and t[:i] * (n // i) == t:\n            return t[:i]\n    return None\n\nt = input()\ns = find_error(t)\nif s is None:\n    print('NO')\nelse:\n    print('YES')\n    print(s)"}
{"solution": "import math\n\ndef find_teams(n):\n    # Check if n is a valid number of games\n    if n % 2 != 0:\n        return [-1]\n\n    # Find the largest power of 2 that is less than or equal to n\n    power = math.floor(math.log2(n))\n\n    # Calculate the number of teams that would yield exactly n games\n    teams = 2 ** (power + 1)\n\n    # Check if n games can be played with teams\n    if n == teams - 1:\n        return [teams]\n\n    # Calculate the number of teams that would yield exactly n games in a round robin tournament\n    round_robin_teams = math.floor(math.sqrt(2 * n + 0.25) + 0.5)\n\n    # Check if n games can be played with round_robin_teams\n    if round_robin_teams * (round_robin_teams - 1) == 2 * n:\n        return [round_robin_teams]\n\n    # If n games cannot be played, return -1\n    return [-1]\n\n# Read the input\nn = int(input())\n\n# Find all possible numbers of teams that will yield exactly n games\nteams = find_teams(n)\n\n# Print the output\nfor team in teams:\n    print(team)"}
{"solution": "from collections import Counter\n\n# Get the number of characters in the string\nn = int(input())\n\n# Get the string\ns = input()\n\n# Get the beauty values\nbeauty = list(map(int, input().split()))\n\n# Count the occurrences of each character\ncounts = Counter(s)\n\n# Initialize the maximum possible beauty\nmax_beauty = 0\n\n# Iterate over the characters and their counts\nfor char, count in counts.items():\n    # If the count is even, we can use half of the characters for the antipalindromic string\n    if count % 2 == 0:\n        # Sort the beauty values for this character\n        char_beauty = sorted([beauty[i] for i in range(n) if s[i] == char])\n        # Take the highest half of the beauty values\n        max_beauty += sum(char_beauty[count//2:])\n    # If the count is odd, we need to use one less character for the antipalindromic string\n    else:\n        # Sort the beauty values for this character\n        char_beauty = sorted([beauty[i] for i in range(n) if s[i] == char])\n        # Take the highest half of the beauty values, excluding the middle one\n        max_beauty += sum(char_beauty[count//2:])\n\n# Print the maximum possible beauty\nprint(max_beauty)"}
{"solution": "w, m = map(int, input().split())\n\n# Check if the item can be weighted\nif m > w - 1:\n    # If the mass of the item is greater than the difference between the weight and 1,\n    # then it can be weighted if the sum of the item's mass and 1 is a multiple of w\n    if (m + 1) % w == 0:\n        print('YES')\n    else:\n        print('NO')\nelse:\n    # If the mass of the item is less than or equal to the difference between the weight and 1,\n    # then it can be weighted directly\n    print('YES')"}
{"solution": "def solve(n, k):\n    if n < k or (n & (n - 1)) == 0:\n        return \"No\"\n\n    result = []\n    while n:\n        if n & 1:\n            result.append(0)\n            k -= 1\n        n >>= 1\n        if n:\n            result.append(1)\n            k -= 1\n\n    if k < 0:\n        return \"No\"\n\n    result.extend([result[-1]] * k)\n    result.reverse()\n    return \"Yes\\n\" + \" \".join(map(str, result))\n\nn, k = map(int, input().split())\nprint(solve(n, k))"}
{"solution": "import heapq\n\ndef champagne_tower(n, t):\n    tower = [[0.0] * i for i in range(1, n + 1)]\n    tower[0][0] = t\n\n    for i in range(n - 1):\n        for j in range(i + 1):\n            excess = max(tower[i][j] - 1, 0)\n            if excess > 0:\n                tower[i][j] = 1\n                tower[i + 1][j] += excess / 2\n                tower[i + 1][j + 1] += excess / 2\n\n    return sum(x == 1 for row in tower for x in row)\n\nn, t = map(int, input().split())\nprint(champagne_tower(n, t))"}
{"solution": "# Get the number of remaining vertices\nn = int(input())\n\n# Initialize an empty list to store the remaining vertices\nvertices = []\n\n# Get the remaining vertices\nfor i in range(n):\n    x, y = map(int, input().split())\n    vertices.append((x, y))\n\n# If there is only one vertex, it is not enough to determine the area\nif n == 1:\n    print(-1)\nelse:\n    # Sort the vertices by x-coordinate and then by y-coordinate\n    vertices.sort(key=lambda x: (x[0], x[1]))\n\n    # The area of the rectangle is the product of the lengths of the sides\n    # The lengths of the sides are the differences between the x-coordinates and y-coordinates of the opposite vertices\n    area = abs(vertices[0][0] - vertices[-1][0]) * abs(vertices[0][1] - vertices[-1][1])\n\n    print(area)"}
{"solution": "# Get the input\nn = int(input())\na = int(input())\nb = int(input())\n\n# Calculate the number of bars needed for each side\nbars_for_a = 2 * 2 * n // a\nbars_for_b = 2 * n // b\n\n# Print the minimal number of wooden bars needed\nprint(max(bars_for_a, bars_for_b))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\ns = input()\n\n# Create a list of indices where swapping is allowed\nallowed_swaps = [i for i in range(n - 1) if s[i] == '1']\n\n# Create a list of tuples where each tuple contains the value and its index\nval_index = sorted((a[i], i) for i in range(n))\n\n# Create a list of indices based on the sorted values\nsorted_indices = [index for val, index in val_index]\n\n# Check if it is possible to sort the array\nfor i in range(n - 1):\n    if sorted_indices[i] > sorted_indices[i + 1] and i not in allowed_swaps:\n        print('NO')\n        break\nelse:\n    print('YES')"}
{"solution": "def calculate_time(seat):\n    row = int(seat[:-1])\n    column = seat[-1]\n\n    # Calculate the base time for the row\n    base_time = (row - 1) * 6\n\n    # Calculate the additional time for the column\n    if column in ['f', 'e', 'd']:\n        base_time += 4 - ord(column) + ord('a')\n    else:\n        base_time += 2\n\n    # Calculate the time for the attendants to move\n    move_time = (row - 1) // 2\n\n    # Calculate the total time\n    total_time = base_time + move_time\n\n    return total_time\n\n# Get the input\nseat = input()\n\n# Calculate the time\ntime = calculate_time(seat)\n\n# Print the output\nprint(time)"}
{"solution": "# Get input\nn, bx = map(int, input().split())\nx = list(map(int, input().split()))\nm, by = map(int, input().split())\ny = list(map(int, input().split()))\n\n# Convert to base 10\nx_dec = sum(x[i] * bx**(n - i - 1) for i in range(n))\ny_dec = sum(y[i] * by**(m - i - 1) for i in range(m))\n\n# Compare\nif x_dec < y_dec:\n    print(\"<\")\nelif x_dec > y_dec:\n    print(\">\")\nelse:\n    print(\"=\")"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Check if there is a zero in the list\nif 0 in a:\n    print(\"BitAryo\")\n# If all numbers are equal, the first player loses\nelif len(set(a)) == 1:\n    print(\"BitAryo\")\n# If there are two distinct numbers, the first player can win\nelif len(set(a)) == 2:\n    # If the smaller number is 1, the first player loses\n    if min(a) == 1:\n        print(\"BitAryo\")\n    else:\n        print(\"BitLGM\")\n# If there are three distinct numbers, the first player can win\nelse:\n    print(\"BitLGM\")"}
{"solution": "import sys\nfrom math import gcd\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef main():\n    n, k = map(int, read_input().split())\n    a = list(map(int, read_input().split()))\n\n    g = [0] * (n + 1)\n    g[n] = a[n - 1]\n    for i in range(n - 1, 0, -1):\n        g[i] = gcd(g[i + 1], a[i - 1])\n\n    count = 0\n    for i in range(n):\n        if (g[i + 1] if i > 0 else g[i + 2]) * (g[n - i] if i < n - 1 else g[n - i - 1]) % k == 0:\n            count += 1\n\n    print(count)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Read the input\nn, k = map(int, input().split())\ns = input()\n\n# Count the occurrences of each color\ncolor_count = {}\nfor color in s:\n    if color in color_count:\n        color_count[color] += 1\n    else:\n        color_count[color] = 1\n\n# Check if it's possible to distribute the balloons\nfor count in color_count.values():\n    if count > k:\n        print(\"NO\")\n        exit()\nprint(\"YES\")"}
{"solution": "n = int(input())\nnums = list(map(int, input().split()))\n\nmin_val = min(nums)\nmin_indices = [i for i, x in enumerate(nums) if x == min_val]\n\nmin_dist = float('inf')\nfor i in range(1, len(min_indices)):\n    min_dist = min(min_dist, min_indices[i] - min_indices[i-1])\n\nprint(min_dist)"}
{"solution": "def gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_multiples(n, m):\n    return n // m\n\nt, w, b = map(int, input().split())\nlcm_wb = lcm(w, b)\nmultiples = count_multiples(t, lcm_wb)\nprobability = multiples / t\n\nfrom fractions import Fraction\nprint(Fraction(probability).limit_denominator())"}
{"solution": "x, y, z = map(int, input().split())\n\nif x > y + z or y > x + z:\n    print(\"+\" if x > y else \"-\")\nelif x < y or y < x:\n    print(\"+\" if y < x else \"-\")\nelse:\n    print(\"?\" if z > 0 else \"0\")"}
{"solution": "def min_steps(n, operations, x, y):\n    pos = [0, 0]\n    for op in operations:\n        if op == 'U':\n            pos[1] += 1\n        elif op == 'D':\n            pos[1] -= 1\n        elif op == 'L':\n            pos[0] -= 1\n        elif op == 'R':\n            pos[0] += 1\n\n    if pos == [x, y]:\n        return 0\n\n    min_len = float('inf')\n    for i in range(n):\n        for j in range(i, n):\n            temp_pos = pos.copy()\n            for k in range(i, j + 1):\n                if operations[k] == 'U':\n                    temp_pos[1] -= 1\n                elif operations[k] == 'D':\n                    temp_pos[1] += 1\n                elif operations[k] == 'L':\n                    temp_pos[0] += 1\n                elif operations[k] == 'R':\n                    temp_pos[0] -= 1\n\n            if temp_pos == [x, y]:\n                min_len = min(min_len, j - i + 1)\n\n    return min_len if min_len != float('inf') else -1\n\nn = int(input())\noperations = input()\nx, y = map(int, input().split())\nprint(min_steps(n, operations, x, y))"}
{"solution": "from collections import defaultdict\n\ndef solve():\n    T = int(input())\n    for _ in range(T):\n        n, x = map(int, input().split())\n        s = input()\n        balance = 0\n        count = defaultdict(int)\n        count[0] = 1\n        ans = 0\n        for i in range(n):\n            balance += 1 if s[i] == '1' else -1\n            if balance - x in count:\n                ans += count[balance - x]\n            count[balance] += 1\n        if balance == x:\n            ans += 1\n        if balance == 0 and x == 0:\n            ans = -1\n        print(ans)\n\nsolve()"}
{"solution": "# Get the input\nn, k = map(int, input().split())\n\n# Convert the number to string\nn = str(n)\n\n# Find the index of the k-th digit from the right\nindex = len(n) - k\n\n# Count the number of digits to be deleted\ncount = 0\nwhile index < len(n) and n[index] != '0':\n    count += 1\n    index += 1\n\n# Print the result\nprint(count)"}
{"solution": "def solve(n, m, k, x, y):\n    total_students = n * m\n    full_cycles = k // total_students\n    remaining_questions = k % total_students\n\n    max_questions = full_cycles\n    min_questions = full_cycles\n\n    if remaining_questions > 0:\n        max_questions += 1\n        remaining_questions -= 1\n\n    sergei_questions = 0\n    current_student = 0\n    direction = 1\n\n    while remaining_questions > 0:\n        if current_student == (x - 1) * m + (y - 1):\n            sergei_questions += 1\n\n        current_student += direction\n\n        if current_student == total_students:\n            current_student = total_students - 1\n            direction = -1\n        elif current_student == -1:\n            current_student = 0\n            direction = 1\n\n        remaining_questions -= 1\n\n    return max_questions, min_questions, sergei_questions\n\nn, m, k, x, y = map(int, input().split())\nmax_questions, min_questions, sergei_questions = solve(n, m, k, x, y)\nprint(max_questions, min_questions, sergei_questions)"}
{"solution": "def max_beauty(n, ribbon):\n    length = len(ribbon)\n    dp = [[0] * length for _ in range(length)]\n    for i in range(length):\n        dp[i][i] = 1\n    for l in range(2, length + 1):\n        for i in range(length - l + 1):\n            j = i + l - 1\n            dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            if ribbon[i] == ribbon[j]:\n                dp[i][j] = max(dp[i][j], dp[i + 1][j - 1] + 2)\n                if l > 2 and ribbon[i + 1:j] == ribbon[i + 1:j][::-1]:\n                    dp[i][j] = max(dp[i][j], l)\n    return dp[0][-1]\n\nn = int(input())\nribbons = [input() for _ in range(3)]\nbeauties = [max_beauty(n, ribbon) for ribbon in ribbons]\nmax_beauty = max(beauties)\nwinners = [\"Kuro\", \"Shiro\", \"Katie\"]\nif beauties.count(max_beauty) == 1:\n    print(winners[beauties.index(max_beauty)])\nelse:\n    print(\"Draw\")"}
{"solution": "# Get the input\nc, v0, v1, a, l = map(int, input().split())\n\n# Initialize the days and the pages read\ndays = 1\npages_read = v0\n\n# While the total pages read is less than the book length\nwhile pages_read < c:\n    # Calculate the new reading speed\n    new_speed = min(v0 + (days - 1) * a, v1)\n\n    # Calculate the pages read today\n    pages_read += max(new_speed - l, 0)\n\n    # Increment the days\n    days += 1\n\n# Print the number of days\nprint(days)"}
{"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += 2\n    return True\n\ndef solve(n):\n    if is_prime(n):\n        return [n]\n    if is_prime(n - 2):\n        return [2, n - 2]\n    return [2, 2, n - 4]\n\nn = int(input())\nsolution = solve(n)\nprint(len(solution))\nprint(' '.join(map(str, solution)))"}
{"solution": "def find_bomb_position(depot):\n    n = len(depot)\n    m = len(depot[0])\n    row_walls = [0] * n\n    col_walls = [0] * m\n\n    for i in range(n):\n        for j in range(m):\n            if depot[i][j] == '*':\n                row_walls[i] += 1\n                col_walls[j] += 1\n\n    for i in range(n):\n        for j in range(m):\n            if row_walls[i] + col_walls[j] - (1 if depot[i][j] == '*' else 0) == 0:\n                return i + 1, j + 1\n\n    return None\n\ndef main():\n    n, m = map(int, input().split())\n    depot = [input() for _ in range(n)]\n\n    bomb_position = find_bomb_position(depot)\n\n    if bomb_position is None:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(*bomb_position)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Get the input\nn, m, a, b = map(int, input().split())\n\n# Calculate the remainder of n divided by m\nremainder = n % m\n\n# If remainder is 0, no need to build or demolish any box\nif remainder == 0:\n    print(0)\n# If building a box is cheaper than demolishing boxes\nelif a <= b:\n    # Calculate the number of boxes to build\n    boxes_to_build = m - remainder\n    print(boxes_to_build * a)\n# If demolishing a box is cheaper than building boxes\nelse:\n    # Calculate the number of boxes to demolish\n    boxes_to_demolish = remainder\n    print(boxes_to_demolish * b)"}
{"solution": "n = int(input())\nnumbers = list(map(int, input().split()))\n\n# Separate the numbers into odd and even\nodd_numbers = [num for num in numbers if num % 2 != 0]\neven_numbers = [num for num in numbers if num % 2 == 0]\n\n# If there is at least one odd number, the maximum odd subsequence is the maximum odd number\nif odd_numbers:\n    print(max(odd_numbers))\n# If there are no odd numbers, the maximum odd subsequence is the sum of the maximum two even numbers\nelse:\n    even_numbers.sort(reverse=True)\n    print(sum(even_numbers[:2]))"}
{"solution": "MOD = 10**9 + 7\n\ndef solve():\n    n, T = map(int, input().split())\n    songs = [list(map(int, input().split())) for _ in range(n)]\n\n    dp = [[[0] * 4 for _ in range(T + 1)] for _ in range(n + 1)]\n    dp[0][0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(T + 1):\n            for k in range(4):\n                if j >= songs[i - 1][0]:\n                    for l in range(4):\n                        if l != songs[i - 1][1] and l != k:\n                            dp[i][j][songs[i - 1][1]] = (dp[i][j][songs[i - 1][1]] + dp[i - 1][j - songs[i - 1][0]][l]) % MOD\n\n    return sum(dp[n][T]) % MOD\n\nprint(solve())"}
{"solution": "import math\n\ndef calculate_expected_length(m):\n    MOD = 10**9 + 7\n    phi = [i for i in range(m + 1)]\n    for i in range(2, m + 1):\n        if phi[i] == i:\n            for j in range(i, m + 1, i):\n                phi[j] -= phi[j] // i\n    inv = [0] * (m + 1)\n    inv[1] = 1\n    for i in range(2, m + 1):\n        inv[i] = (MOD - MOD // i * inv[MOD % i] % MOD) % MOD\n    numerator = 0\n    denominator = 1\n    for i in range(1, m + 1):\n        numerator = (numerator + phi[i]) % MOD\n        denominator = (denominator * i) % MOD\n    return (numerator * pow(denominator, MOD - 2, MOD)) % MOD\n\nm = int(input())\nresult = calculate_expected_length(m)\nprint(result)"}
{"solution": "def gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\nl, r, x, y = map(int, input().split())\n\ncount = 0\nfor a in range(x, r + 1):\n    for b in range(a, r + 1):\n        if gcd(a, b) == x and lcm(a, b) == y and l <= a and a <= r and l <= b and b <= r:\n            count += 1\n\nprint(count)"}
{"solution": "import math\n\ndef smallest_k(a, b):\n    gcd = math.gcd(a, b)\n    lcm = a * b // gcd\n    k = 0\n    while True:\n        if (a + k) % gcd != 0 or (b + k) % gcd != 0:\n            k += 1\n        else:\n            break\n    return k\n\na, b = map(int, input().split())\nprint(smallest_k(a, b))"}
{"solution": "# Get the input\nn, k = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Calculate the current average\navg = sum(marks) / n\n\n# Calculate the number of marks needed to be added\n# to make the average equal to k\n# If the current average is already greater than or equal to k,\n# no additional marks are needed\nif avg >= k:\n    print(0)\nelse:\n    # Calculate the total sum of marks needed after adding additional marks\n    total_sum = k * (n + 1)\n    # Calculate the sum of the current marks\n    current_sum = sum(marks)\n    # Calculate the number of additional marks needed\n    additional_marks = total_sum - current_sum\n    # Print the result\n    print(int(additional_marks))"}
{"solution": "n = int(input())\nnumbers = list(map(int, input().split()))\n\npositive_count = 0\nnegative_count = 0\nzero_count = 0\n\nfor num in numbers:\n    if num > 0:\n        positive_count += 1\n    elif num < 0:\n        negative_count += 1\n    else:\n        zero_count += 1\n\nif positive_count >= (n + 1) // 2:\n    for i in range(1, 1001):\n        if all(num % i >= 0 for num in numbers):\n            print(i)\n            break\nelif negative_count >= (n + 1) // 2:\n    for i in range(-1, -1001, -1):\n        if all(num % i >= 0 for num in numbers):\n            print(i)\n            break\nelse:\n    print(0)"}
{"solution": "def count_pairs(n):\n    # The maximum possible number of nines at the end of the sum\n    max_nines = n // 2\n\n    # The number of pairs that end with max_nines\n    count = 0\n\n    # The sum of the costs of the two shovels should end with max_nines * '9'\n    target = int('9' * max_nines)\n\n    # Iterate over all possible costs of the first shovel\n    for i in range(1, n):\n        # The cost of the second shovel should be the target minus the cost of the first shovel\n        j = target - i\n        # Check if the second shovel exists and its cost is less than or equal to n\n        if j > i and j <= n:\n            count += 1\n\n    return count\n\n# Read the input\nn = int(input())\n\n# Print the output\nprint(count_pairs(n))"}
{"solution": "def solve(a, b, c, d):\n    if a * b == c * d:\n        return 0, a, b, c, d\n    if a * b < c * d:\n        a, b, c, d = c, d, a, b\n    if a % 2 == 0 and a * b // 2 == c * d:\n        return 1, a // 2, b, c, d\n    if a % 3 == 0 and a * b // 3 == c * d:\n        return 1, a // 3 * 2, b, c, d\n    if b % 2 == 0 and a * b // 2 == c * d:\n        return 1, a, b // 2, c, d\n    if b % 3 == 0 and a * b // 3 == c * d:\n        return 1, a, b // 3 * 2, c, d\n    if a > c:\n        res = solve(a // 2, b, c, d)\n        if res[0] != -1:\n            return res[0] + 1, res[1] * 2, res[2], res[3], res[4]\n    if b > d:\n        res = solve(a, b // 2, c, d)\n        if res[0] != -1:\n            return res[0] + 1, res[1], res[2] * 2, res[3], res[4]\n    return -1, -1, -1, -1, -1\n\na, b = map(int, input().split())\nc, d = map(int, input().split())\nres = solve(a, b, c, d)\nif res[0] == -1:\n    print(-1)\nelse:\n    print(res[0])\n    print(res[1], res[2])\n    print(res[3], res[4])"}
{"solution": "# Read the input\nx_p, y_p, x_v, y_v = map(int, input().split())\n\n# Calculate the sum of coordinates for both players\nsum_p = x_p + y_p\nsum_v = x_v + y_v\n\n# If the sum of coordinates for Polycarp is less than or equal to the sum of coordinates for Vasiliy,\n# then Polycarp will win. Otherwise, Vasiliy will win.\nif sum_p <= sum_v:\n    print(\"Polycarp\")\nelse:\n    print(\"Vasiliy\")"}
{"solution": "# Define the number of days in each month\ndays_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n# Get the input\nm, d = map(int, input().split())\n\n# Calculate the number of days in the month\nnum_days = days_in_month[m - 1]\n\n# Calculate the number of columns in the table\n# The first day of the month is represented by d columns\n# The remaining days are represented by (num_days - (8 - d)) // 7 columns\n# If there are remaining days after filling the full columns, add one more column\nnum_columns = (num_days - (8 - d)) // 7 + (1 if num_days % 7 >= 8 - d else 0)\n\n# Print the result\nprint(num_columns)"}
{"solution": "def count_binary_zeros(n):\n    binary = bin(n)[2:]\n    return binary.count('0')\n\ndef count_years(a, b):\n    count = 0\n    for year in range(a, b + 1):\n        if count_binary_zeros(year) == 1:\n            count += 1\n    return count\n\na, b = map(int, input().split())\nprint(count_years(a, b))"}
{"solution": "# Read the input integer N\nN = int(input())\n\n# Initialize the number of layers required to 0\nlayers = 0\n\n# Initialize a list to store the frequency of each endpoint\nfreq = [0] * (N + 1)\n\n# Count the frequency of each endpoint\nfor i in range(N + 1):\n    for j in range(i, N + 1):\n        freq[i] += 1\n        freq[j] += 1\n\n# Sort the frequency list in descending order\nfreq.sort(reverse=True)\n\n# Greedily assign the endpoints to layers\nfor f in freq:\n    if f > 0:\n        layers += 1\n        f -= 1\n        for i in range(N + 1):\n            if freq[i] > 0:\n                freq[i] -= 1\n\n# Print the minimum number of layers required\nprint(layers)"}
{"solution": "import sys\nfrom math import factorial\n\ndef solve(n, k, S, a):\n    dp = [[0] * (S + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(S + 1):\n            dp[i][j] = dp[i - 1][j]\n            if a[i - 1] <= j:\n                dp[i][j] += dp[i - 1][j - a[i - 1]]\n            if k > 0 and a[i - 1] <= 20 and factorial(a[i - 1]) <= j:\n                dp[i][j] += dp[i - 1][j - factorial(a[i - 1])]\n\n    return dp[n][S]\n\ndef main():\n    n, k, S = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    print(solve(n, k, S, a))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def solve(n, k, a):\n    for i in range(n):\n        if a[i] == 0:\n            continue\n        power = 0\n        while (k ** power) <= a[i]:\n            if (k ** power) == a[i]:\n                a[i] = 0\n                break\n            power += 1\n        if a[i] != 0:\n            return False\n    return True\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        n, k = map(int, input().split())\n        a = list(map(int, input().split()))\n        if solve(n, k, a):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "MOD = 1073741824\n\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count\n\na, b, c = map(int, input().split())\n\ntotal = 0\nfor i in range(1, a + 1):\n    for j in range(1, b + 1):\n        for k in range(1, c + 1):\n            total = (total + count_divisors(i * j * k)) % MOD\n\nprint(total)"}
{"solution": "def get_state(puzzle):\n    return ''.join(puzzle)\n\ndef get_neighbors(state):\n    neighbors = []\n    index = state.index('X')\n    if index not in [0, 1]:\n        neighbors.append(state[:index-2] + 'X' + state[index-1] + state[index-2] + state[index+1:])\n    if index not in [2, 3]:\n        neighbors.append(state[:index] + state[index+1] + 'X' + state[index+2:])\n    if index not in [0, 2]:\n        neighbors.append(state[:index-1] + state[index] + state[index+1] + 'X' + state[index+2:])\n    if index not in [1, 3]:\n        neighbors.append(state[:index-1] + 'X' + state[index-1] + state[index] + state[index+1:])\n    return neighbors\n\ndef bfs(start):\n    visited = set()\n    queue = [start]\n    while queue:\n        state = queue.pop(0)\n        if state in visited:\n            continue\n        visited.add(state)\n        for neighbor in get_neighbors(state):\n            queue.append(neighbor)\n    return visited\n\nbessie_puzzle = []\nfor _ in range(2):\n    bessie_puzzle.extend(input())\nelsie_puzzle = []\nfor _ in range(2):\n    elsie_puzzle.extend(input())\n\nbessie_states = bfs(get_state(bessie_puzzle))\nelsie_states = bfs(get_state(elsie_puzzle))\n\nif any(state in bessie_states for state in elsie_states):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "# Get the input\nn = int(input())\nk = input()\n\n# Initialize the result\nresult = 0\n\n# Convert k to decimal\nfor i in range(len(k)):\n    result += int(k[i]) * (n ** i)\n\n# Print the result\nprint(result)"}
{"solution": "n = int(input())\narr = list(map(int, input().split()))\n\n# Check if array is unimodal\nincreasing = True\ndecreasing = True\n\n# Check if array is increasing\nfor i in range(1, n):\n    if arr[i] < arr[i-1]:\n        increasing = False\n        break\n\n# Check if array is decreasing\nfor i in range(n-1, 0, -1):\n    if arr[i] < arr[i-1]:\n        decreasing = False\n        break\n\n# Check if array is unimodal\nunimodal = increasing or decreasing\nfor i in range(1, n):\n    if arr[i] == arr[i-1]:\n        continue\n    elif arr[i] < arr[i-1] and increasing:\n        increasing = False\n    elif arr[i] > arr[i-1] and not increasing:\n        unimodal = False\n        break\n\nprint(\"YES\" if unimodal else \"NO\")"}
{"solution": "def f(x):\n    return x // 2 if x % 2 == 0 else x - 1\n\ndef path(x):\n    p = [x]\n    while x != 1:\n        x = f(x)\n        p.append(x)\n    return p\n\ndef max_y(n, k):\n    count = [0] * (n + 1)\n    for x in range(1, n + 1):\n        for y in path(x):\n            count[y] += 1\n    for y in range(n, 0, -1):\n        if count[y] >= k:\n            return y\n\nn, k = map(int, input().split())\nprint(max_y(n, k))"}
{"solution": "def billiard_table(n, m, x, y, vx, vy):\n    # Check if the ball is already in a pocket\n    if (x == 0 and vy < 0) or (x == n and vy > 0) or (y == 0 and vx < 0) or (y == m and vx > 0):\n        return (x, y)\n\n    # Calculate the time to hit the vertical and horizontal walls\n    if vx == 0:\n        tx = float('inf')\n    elif vx > 0:\n        tx = (n - x) / vx\n    else:\n        tx = (x - 0) / -vx\n\n    if vy == 0:\n        ty = float('inf')\n    elif vy > 0:\n        ty = (m - y) / vy\n    else:\n        ty = (y - 0) / -vy\n\n    # Calculate the new position of the ball\n    if tx < ty:\n        x += vx * tx\n        y += vy * tx\n        vx = -vx\n    else:\n        x += vx * ty\n        y += vy * ty\n        vy = -vy\n\n    # Recursively call the function with the new position and velocity\n    return billiard_table(n, m, x, y, vx, vy)\n\n# Read the input\nn, m, x, y, vx, vy = map(int, input().split())\n\n# Call the function and print the output\nresult = billiard_table(n, m, x, y, vx, vy)\nif result == (x, y):\n    print(x, y)\nelse:\n    print(-1)"}
{"solution": "# Get the input\nboard_dimensions = list(map(int, input().split()))\npainting1_dimensions = list(map(int, input().split()))\npainting2_dimensions = list(map(int, input().split()))\n\n# Sort the dimensions to ensure that the larger one is always first\nboard_dimensions.sort()\npainting1_dimensions.sort()\npainting2_dimensions.sort()\n\n# Check if the paintings can be placed on the board\nif (painting1_dimensions[0] + painting2_dimensions[0] <= board_dimensions[0] and max(painting1_dimensions[1], painting2_dimensions[1]) <= board_dimensions[1]) or \\\n   (painting1_dimensions[1] + painting2_dimensions[0] <= board_dimensions[1] and max(painting1_dimensions[0], painting2_dimensions[1]) <= board_dimensions[0]) or \\\n   (painting1_dimensions[0] + painting2_dimensions[1] <= board_dimensions[0] and max(painting1_dimensions[1], painting2_dimensions[0]) <= board_dimensions[1]) or \\\n   (painting1_dimensions[1] + painting2_dimensions[1] <= board_dimensions[1] and max(painting1_dimensions[0], painting2_dimensions[0]) <= board_dimensions[0]):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def solve():\n    b1, q, l, m = map(int, input().split())\n    bad_numbers = set(map(int, input().split()))\n\n    if b1 == 0:\n        if 0 in bad_numbers:\n            print(0)\n        else:\n            print(1 if abs(b1) <= l else 0)\n        return\n\n    if q == 1:\n        print('inf' if abs(b1) <= l and b1 not in bad_numbers else 0)\n        return\n\n    if q == -1:\n        print(2 if abs(b1) <= l and b1 not in bad_numbers and -b1 not in bad_numbers else 1 if abs(b1) <= l and b1 not in bad_numbers else 0)\n        return\n\n    count = 0\n    current = b1\n    while abs(current) <= l:\n        if current not in bad_numbers:\n            count += 1\n        current *= q\n\n    print(count)\n\nsolve()"}
{"solution": "def find_frame(grid):\n    n, m = len(grid), len(grid[0])\n    min_size = float('inf')\n    min_frame = None\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'w':\n                size = min(i, j, n-i-1, m-j-1)\n                if size < min_size:\n                    min_size = size\n                    min_frame = (i, j, size)\n\n    if min_frame is None:\n        return -1\n\n    i, j, size = min_frame\n    for k in range(j, j+size+1):\n        grid[i][k] = '+'\n        grid[i+size][k] = '+'\n    for k in range(i, i+size+1):\n        grid[k][j] = '+'\n        grid[k][j+size] = '+'\n\n    return grid\n\nn, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\nresult = find_frame(grid)\n\nif result == -1:\n    print(-1)\nelse:\n    for row in result:\n        print(row)"}
{"solution": "n = int(input())\na = int(input())\nb = int(input())\n\nfor x in range(n // a + 1):\n    for y in range(n // b + 1):\n        if x * a + y * b == n:\n            print('YES')\n            print(x, y)\n            exit()\nprint('NO')"}
{"solution": "# Define the number names\nnumbers = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\ntens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n\n# Get the input\ns = int(input())\n\n# If the number is less than 20, print the number name\nif s < 20:\n    print(numbers[s])\n# If the number is greater than or equal to 20, print the tens name and the ones name\nelse:\n    # If the ones digit is 0, print only the tens name\n    if s % 10 == 0:\n        print(tens[s // 10])\n    # If the ones digit is not 0, print the tens name and the ones name separated by a hyphen\n    else:\n        print(tens[s // 10] + \"-\" + numbers[s % 10])"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nmax_erased = 0\nfor i in range(1, n - 1):\n    if a[i - 1] + 1 < a[i + 1] - 1:\n        max_erased = max(max_erased, a[i + 1] - a[i - 1] - 2)\n\nprint(max_erased)"}
{"solution": "n = int(input())\nproblems = list(map(int, input().split()))\n\ntotal_problems = sum(problems)\nhalf_problems = total_problems // 2\nif total_problems % 2 == 0:\n    half_problems -= 1\n\nsolved_problems = 0\nfor i in range(n):\n    solved_problems += problems[i]\n    if solved_problems > half_problems:\n        print(i + 1)\n        break"}
{"solution": "from collections import deque\n\ndef get_neighbors(x, y, n):\n    neighbors = []\n    # Knight moves\n    for dx, dy in [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]:\n        nx, ny = x + dx, y + dy\n        if 0 <= nx < n and 0 <= ny < n:\n            neighbors.append((nx, ny))\n    # Bishop moves\n    for dx, dy in [(-1, -1), (-1, 1), (1, -1), (1, 1)]:\n        nx, ny = x + dx, y + dy\n        while 0 <= nx < n and 0 <= ny < n:\n            neighbors.append((nx, ny))\n            nx += dx\n            ny += dy\n    # Rook moves\n    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        nx, ny = x + dx, y + dy\n        while 0 <= nx < n and 0 <= ny < n:\n            neighbors.append((nx, ny))\n            nx += dx\n            ny += dy\n    return neighbors\n\ndef solve(n, board):\n    dist = [[float('inf')] * n for _ in range(n)]\n    replacements = [[float('inf')] * n for _ in range(n)]\n    dist[0][0] = 0\n    replacements[0][0] = 0\n    q = deque([(0, 0, 0, 0)])  # x, y, steps, replacements\n    while q:\n        x, y, steps, repl = q.popleft()\n        for nx, ny in get_neighbors(x, y, n):\n            if board[nx][ny] == board[x][y] + 1:\n                if steps + 1 < dist[nx][ny] or (steps + 1 == dist[nx][ny] and repl < replacements[nx][ny]):\n                    dist[nx][ny] = steps + 1\n                    replacements[nx][ny] = repl\n                    q.appendleft((nx, ny, steps + 1, repl))\n            elif steps + 1 < dist[nx][ny] or (steps + 1 == dist[nx][ny] and repl + 1 < replacements[nx][ny]):\n                dist[nx][ny] = steps + 1\n                replacements[nx][ny] = repl + 1\n                q.append((nx, ny, steps + 1, repl + 1))\n    return dist[n - 1][n - 1], replacements[n - 1][n - 1]\n\nn = int(input())\nboard = [list(map(int, input().split())) for _ in range(n)]\nprint(*solve(n, board))"}
{"solution": "def min_time(n, m, k, a, b):\n    # Calculate the apartment numbers for the first and last apartments in each entrance\n    first_apts = [i*m*k + 1 for i in range(n)]\n    last_apts = [(i+1)*m*k for i in range(n)]\n\n    # Calculate the time it takes to go from apartment a to apartment b by going clockwise\n    clockwise_time = min((b - a) % (n*m*k), (a - b) % (n*m*k)) * 5\n    clockwise_time += min((b - a) // (m*k), (a - b) // (m*k)) * 15\n\n    # Calculate the time it takes to go from apartment a to apartment b by going counter-clockwise\n    counter_clockwise_time = n*m*k - clockwise_time\n\n    # Calculate the time it takes to go from apartment a to the first apartment of its entrance\n    time_to_first = (a - 1) % (m*k) * 5\n    time_to_first += min((a - 1) // (m*k), (n - 1 - (a - 1) // (m*k))) * 15\n\n    # Calculate the time it takes to go from the first apartment of the entrance of apartment b to apartment b\n    time_from_first = (b - 1) % (m*k) * 5\n    time_from_first += min((b - 1) // (m*k), (n - 1 - (b - 1) // (m*k))) * 15\n\n    # Calculate the time it takes to go from apartment a to apartment b using the elevator\n    elevator_time = 10 + abs(a - b) // (k)\n\n    # Return the minimum time\n    return min(clockwise_time, counter_clockwise_time, time_to_first + time_from_first, elevator_time)\n\n# Read the input\nn, m, k = map(int, input().split())\na, b = map(int, input().split())\n\n# Print the result\nprint(min_time(n, m, k, a, b))"}
{"solution": "def divisible_by_64(s):\n    # Count the number of zeros in the string\n    count_zeros = s.count('0')\n\n    # If there are less than 6 zeros, it's impossible to get a number divisible by 64\n    if count_zeros < 6:\n        return 'no'\n\n    # Count the number of ones in the string\n    count_ones = s.count('1')\n\n    # If there are no ones, it's impossible to get a number divisible by 64\n    if count_ones == 0:\n        return 'no'\n\n    # If there are at least 6 zeros and at least one one, it's possible to get a number divisible by 64\n    return 'yes'\n\n# Read the input string\ns = input()\n\n# Print the result\nprint(divisible_by_64(s))"}
{"solution": "def solve(s):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    i = 0\n    result = ''\n    for char in s:\n        if char == alphabet[i]:\n            result += char\n            i += 1\n        elif char < alphabet[i]:\n            result += char\n        else:\n            while i < 26 and char > alphabet[i]:\n                i += 1\n            if i < 26:\n                result += alphabet[i]\n                i += 1\n        if i == 26:\n            break\n    return result if i == 26 else '-1'\n\ns = input()\nprint(solve(s))"}
{"solution": "def calculate_max_expected_value(n, m, r, k):\n    total_cells = n * m\n    total_scoop_positions = (n - r + 1) * (m - r + 1)\n    max_caught_fish_per_scoop = r * r\n\n    if k >= max_caught_fish_per_scoop:\n        return max_caught_fish_per_scoop\n\n    return k * (k / max_caught_fish_per_scoop) * (total_scoop_positions / total_cells)\n\nn, m, r, k = map(int, input().split())\nprint(calculate_max_expected_value(n, m, r, k))"}
{"solution": "# Read the number of elements\nn = int(input())\n\n# Read the elements of the array\na = list(map(int, input().split()))\n\n# Initialize the count of negative numbers\nneg_count = 0\n\n# Initialize the index of the smallest non-negative number\nsmallest_non_neg = float('inf')\n\n# Iterate over the array\nfor i in range(n):\n    # If the number is negative, increment the count\n    if a[i] < 0:\n        neg_count += 1\n    # If the number is non-negative, update the smallest non-negative number\n    elif a[i] < smallest_non_neg:\n        smallest_non_neg = a[i]\n\n# If the count of negative numbers is odd\nif neg_count % 2 == 1:\n    # If there is a non-negative number\n    if smallest_non_neg != float('inf'):\n        # Replace the smallest non-negative number with its negative counterpart\n        a[a.index(smallest_non_neg)] = -smallest_non_neg - 1\n    else:\n        # Replace the last number with its negative counterpart\n        a[-1] = -a[-1] - 1\n\n# Replace all other numbers with their negative counterparts\nfor i in range(n):\n    a[i] = -a[i] - 1\n\n# Print the array\nprint(*a)"}
{"solution": "import math\n\ndef find_kth_divisor(n, k):\n    divisors = set()\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n        if len(divisors) >= k:\n            return sorted(list(divisors))[k - 1]\n    if len(divisors) < k:\n        return -1\n\nn, k = map(int, input().split())\nprint(find_kth_divisor(n, k))"}
{"solution": "from itertools import permutations\n\ndef get_possible_numbers(cubes):\n    numbers = set()\n    for cube in cubes:\n        for _ in range(4):\n            cube = cube[1:] + cube[:1]\n            for _ in range(4):\n                cube = cube[3:] + cube[:3]\n                numbers.add(int(''.join(map(str, cube))))\n    return numbers\n\ndef find_max_number(n, cubes):\n    numbers = get_possible_numbers(cubes)\n    max_number = 0\n    for i in range(1, 1000):\n        for perm in permutations(numbers, i):\n            if sum(perm) == i * (i + 1) // 2:\n                max_number = i\n                break\n        if max_number == i:\n            break\n    return max_number\n\nn = int(input())\ncubes = [list(map(int, input().split())) for _ in range(n)]\nprint(find_max_number(n, cubes))"}
{"solution": "def k_rounding(n, k):\n    # Calculate the multiplier to reach the k-rounding\n    multiplier = 10 ** k\n    # Calculate the k-rounding\n    k_rounded = ((n + multiplier - 1) // multiplier) * multiplier\n    return k_rounded\n\n# Read the input\nn, k = map(int, input().split())\n# Print the k-rounding of n\nprint(k_rounding(n, k))"}
{"solution": "n, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\nB = [[0] * m for _ in range(n)]\n\noperations = []\n\nfor i in range(n - 1):\n    for j in range(m - 1):\n        if A[i][j] == 1 and B[i][j] == 0:\n            operations.append((i + 1, j + 1))\n            for x in range(i, i + 2):\n                for y in range(j, j + 2):\n                    B[x][y] = 1\n\nif A == B:\n    print(len(operations))\n    for op in operations:\n        print(*op)\nelse:\n    print(-1)"}
{"solution": "def calculate_probabilities(r, s, p):\n    total = r + s + p\n    dp = [[[0.0 for _ in range(p+1)] for _ in range(s+1)] for _ in range(r+1)]\n    dp[r][s][p] = 1.0\n\n    for t in range(total, 0, -1):\n        for i in range(r+1):\n            for j in range(s+1):\n                for k in range(p+1):\n                    if i > 0 and j > 0:\n                        dp[i][j][k] += dp[i-1][j-1][k] * i * j / t / (t-1)\n                    if i > 0 and k > 0:\n                        dp[i][j][k] += dp[i-1][j][k-1] * i * k / t / (t-1)\n                    if j > 0 and k > 0:\n                        dp[i][j][k] += dp[i][j-1][k-1] * j * k / t / (t-1)\n\n    return dp[r][0][0], dp[0][s][0], dp[0][0][p]\n\nr, s, p = map(int, input().split())\nprob_r, prob_s, prob_p = calculate_probabilities(r, s, p)\nprint(prob_r, prob_s, prob_p)"}
{"solution": "# Get the input\nl1, r1, l2, r2, k = map(int, input().split())\n\n# Calculate the overlapping time\noverlap = min(r1, r2) - max(l1, l2)\n\n# If Sonya is prinking during the overlapping time, subtract that minute\nif k >= max(l1, l2) and k <= min(r1, r2):\n    overlap -= 1\n\n# If there is no overlapping time, print 0\nif overlap < 0:\n    print(0)\nelse:\n    print(overlap)"}
{"solution": "import sys\nfrom bisect import bisect_left, bisect_right\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    horizontal_lines = []\n    vertical_lines = []\n\n    for _ in range(n):\n        a, b, c = map(int, sys.stdin.readline().split())\n        horizontal_lines.append((c, a, b))\n\n    for _ in range(m):\n        d, e, f = map(int, sys.stdin.readline().split())\n        vertical_lines.append((d, e, f))\n\n    horizontal_lines.sort()\n    vertical_lines.sort()\n\n    horizontal_lines_x = [line[0] for line in horizontal_lines]\n    vertical_lines_x = [line[0] for line in vertical_lines]\n\n    min_x = max(min(horizontal_lines_x + vertical_lines_x), -10**9)\n    max_x = min(max(horizontal_lines_x + vertical_lines_x), 10**9)\n\n    total_area = 0\n    prev_x = 0\n\n    for x in range(min_x, max_x + 1):\n        horizontal_line_indices = [bisect_left(horizontal_lines, (x,)) for x in (prev_x, x)]\n        vertical_line_indices = [bisect_left(vertical_lines, (x,)) for x in (prev_x, x)]\n\n        horizontal_line_ranges = []\n        vertical_line_ranges = []\n\n        for i in range(2):\n            for j in range(horizontal_line_indices[i], n):\n                if horizontal_lines[j][0] != x:\n                    break\n                horizontal_line_ranges.append((horizontal_lines[j][1], horizontal_lines[j][2]))\n\n            for j in range(vertical_line_indices[i], m):\n                if vertical_lines[j][0] != x:\n                    break\n                vertical_line_ranges.append((vertical_lines[j][1], vertical_lines[j][2]))\n\n        horizontal_line_ranges.sort()\n        vertical_line_ranges.sort()\n\n        merged_ranges = []\n        current_range = None\n\n        for start, end in horizontal_line_ranges + vertical_line_ranges:\n            if current_range is None or start > current_range[1]:\n                if current_range is not None:\n                    merged_ranges.append(current_range)\n                current_range = (start, end)\n            else:\n                current_range = (current_range[0], max(current_range[1], end))\n\n        if current_range is not None:\n            merged_ranges.append(current_range)\n\n        total_area += sum(end - start for start, end in merged_ranges)\n        prev_x = x\n\n    print(total_area)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Get the input\nt, s, x = map(int, input().split())\n\n# Calculate the barking times\nbark_times = [t]\ni = 1\nwhile bark_times[-1] < x:\n    bark_times.append(t + i * s)\n    bark_times.append(t + i * s + 1)\n    i += 1\n\n# Check if the pineapple will bark at time x\nif x in bark_times:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n = int(input())\nsegments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r, i+1))\nsegments.sort()\n\nfor i in range(n-1):\n    if segments[i][1] >= segments[i+1][1]:\n        print(segments[i+1][2], segments[i][2])\n        exit()\nprint(-1, -1)"}
{"solution": "n = int(input())\ns = list(input())\n\ncounts = {'A': 0, 'C': 0, 'G': 0, 'T': 0}\nfor nucleotide in s:\n    if nucleotide != '?':\n        counts[nucleotide] += 1\n\nif n % 4 != 0 or max(counts.values()) > n // 4:\n    print(\"===\")\nelse:\n    for i in range(n):\n        if s[i] == '?':\n            for nucleotide in 'ACGT':\n                if counts[nucleotide] < n // 4:\n                    s[i] = nucleotide\n                    counts[nucleotide] += 1\n                    break\n    print(''.join(s))"}
{"solution": "def check_win(board, player):\n    for i in range(4):\n        if all(board[i][j] == player for j in range(4)) or all(board[j][i] == player for j in range(4)):\n            return True\n    if all(board[i][i] == player for i in range(4)) or all(board[i][3-i] == player for i in range(4)):\n        return True\n    return False\n\ndef can_win(board):\n    for i in range(4):\n        for j in range(4):\n            if board[i][j] == '.':\n                board[i][j] = 'x'\n                if check_win(board, 'x'):\n                    return True\n                board[i][j] = '.'\n    return False\n\nboard = [list(input()) for _ in range(4)]\nprint('YES' if can_win(board) else 'NO')"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\ntotal_sum = sum(a)\nprefix_sum = 0\n\nfor i in range(n):\n    if prefix_sum == total_sum - prefix_sum - a[i]:\n        print(\"YES\")\n        exit()\n    prefix_sum += a[i]\n\nprint(\"NO\")"}
{"solution": "n, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Sort b in descending order\nb.sort(reverse=True)\n\n# Replace zeros in a with elements from b\ni = 0\nj = 0\nwhile i < n and j < k:\n    if a[i] == 0:\n        a[i] = b[j]\n        j += 1\n    i += 1\n\n# Check if the resulting sequence is not increasing\nfor i in range(1, n):\n    if a[i] >= a[i - 1]:\n        print(\"No\")\n        exit()\n\nprint(\"Yes\")"}
{"solution": "# Read input\nx, y, z = map(int, input().split())\na, b, c = map(int, input().split())\n\n# Check if Andrew can eat enough green grapes\nif x > a:\n    print(\"NO\")\nelse:\n    # Subtract the green grapes Andrew will eat from the total\n    a -= x\n    # Check if Dmitry can eat enough non-black grapes\n    if y > a + b:\n        print(\"NO\")\n    else:\n        # Subtract the non-black grapes Dmitry will eat from the total\n        y -= min(y, a)\n        a -= min(y, a)\n        # Check if Michal can eat enough remaining grapes\n        if z > a + b + c:\n            print(\"NO\")\n        else:\n            print(\"YES\")"}
{"solution": "# Read the input\ntraffic_lights = [list(map(int, input().split())) for _ in range(4)]\n\n# Check for accidents\nfor i in range(4):\n    for j in range(4):\n        if i != j and traffic_lights[i][3] == 1 and traffic_lights[j][(i-j)%4] == 1:\n            print(\"YES\")\n            exit()\n\n# If no accidents are possible\nprint(\"NO\")"}
{"solution": "def same_finger_movements(n, num):\n    # Define the finger movements for each digit\n    movements = {\n        '1': [(0, 0)],\n        '2': [(0, 1), (0, 0)],\n        '3': [(0, 1), (0, 1)],\n        '4': [(0, 1), (1, 1)],\n        '5': [(1, 0), (0, 0)],\n        '6': [(1, 0), (1, 1)],\n        '7': [(1, 0), (2, 0)],\n        '8': [(1, 1), (0, 0)],\n        '9': [(1, 1), (1, 1)],\n        '0': [(1, 1), (2, 1)]\n    }\n\n    # Calculate the finger movements for the input number\n    num_movements = []\n    for i in range(n):\n        num_movements.extend(movements[num[i]])\n\n    # Check if there is any other number with the same finger movements\n    for digit in movements:\n        if digit != num[0]:\n            other_movements = movements[digit]\n            for i in range(1, n):\n                other_movements.extend(movements[num[i]])\n            if num_movements == other_movements:\n                return False\n\n    return True\n\n# Read the input\nn = int(input())\nnum = input()\n\n# Print the output\nif same_finger_movements(n, num):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import heapq\n\ndef max_sold_products(n, f, k, l):\n    # Create a list of tuples, each containing the difference in sales and the number of products\n    diff_sales = [(l[i] - k[i], k[i], l[i]) for i in range(n)]\n    # Sort the list in descending order based on the difference in sales\n    diff_sales.sort(reverse=True)\n\n    # Create a max heap to store the number of products\n    max_heap = []\n    total_sold = 0\n\n    # Iterate over the days\n    for i in range(n):\n        # If it's a sell-out day, double the number of products and add it to the max heap\n        if i < f:\n            heapq.heappush(max_heap, 2 * diff_sales[i][1])\n        # Add the number of products to the total sold\n        total_sold += min(diff_sales[i][1], diff_sales[i][2])\n\n        # If the number of products sold exceeds the number of products available,\n        # replace the largest number of products with the current number of products\n        if len(max_heap) > 0 and max_heap[0] < diff_sales[i][1]:\n            heapq.heapreplace(max_heap, diff_sales[i][1])\n\n    # Add the products from the sell-out days to the total sold\n    total_sold += sum(heapq.nlargest(f, max_heap))\n\n    return total_sold\n\n# Read the input\nn, f = map(int, input().split())\nk = []\nl = []\nfor i in range(n):\n    ki, li = map(int, input().split())\n    k.append(ki)\n    l.append(li)\n\n# Print the output\nprint(max_sold_products(n, f, k, l))"}
{"solution": "# Read input\nn, k = map(int, input().split())\n\n# Calculate the maximum messiness\n# The maximum messiness is achieved when the largest cow is in the first stall\n# and the smallest cow is in the last stall\n# After k swaps, the largest k cows will be in the first k stalls\n# and the smallest k cows will be in the last k stalls\n# The number of pairs (i, j) such that i < j and p_i > p_j is the number of inversions\n# in the permutation of the first k cows and the last k cows\n# The number of inversions in a permutation of length k is k * (k - 1) / 2\nmax_messiness = k * min(n, k) * (min(n, k) - 1) // 2\n\n# Print output\nprint(max_messiness)"}
{"solution": "# Get the input\nN, M, K, L = map(int, input().split())\n\n# Calculate the minimum number of coins one friend can gift\nif M * (N - K) >= L * M:\n    # Each friend can gift one coin to Ivan\n    print(1)\nelif N - K >= M and L <= M:\n    # Each friend can gift a coin that Ivan doesn't have yet\n    print(L // M)\nelse:\n    # It's impossible to satisfy all three conditions\n    print(-1)"}
{"solution": "n, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\n\ndef count_black(i, j, k):\n    count = 0\n    for x in range(i, i+k):\n        for y in range(j, j+k):\n            if grid[x][y] == 'W':\n                count += 1\n    return count\n\nmin_paint = float('inf')\nfor k in range(1, min(n, m) + 1):\n    for i in range(n - k + 1):\n        for j in range(m - k + 1):\n            min_paint = min(min_paint, count_black(i, j, k))\n\nprint(min_paint if min_paint != float('inf') else -1)"}
{"solution": "n = int(input())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\ndiff = sum(y) - sum(x)\n\nif diff < 0 or any(i < 0 for i in [y[j] - x[j] for j in range(n)]):\n    print(\"No\")\nelse:\n    print(\"Yes\")"}
{"solution": "n = int(input())\nangles = list(map(int, input().split()))\n\ntotal_sum = sum(angles)\nmin_diff = total_sum\ncurrent_sum = 0\n\nfor i in range(n):\n    current_sum += angles[i]\n    min_diff = min(min_diff, abs(total_sum - 2 * current_sum))\n\nprint(min_diff)"}
{"solution": "MOD = 10**9 + 7\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1:\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\ndef find_ways(n, m):\n    return power(2, n * m - n, MOD)\n\nn, m = map(int, input().split())\nprint(find_ways(n, m))"}
{"solution": "import math\n\ndef find_pythagorean_triple(n):\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            j = n // i\n            if (i + j) % 2 == 1 and i < j:\n                return (j * j - i * i) // 2, (j * j + i * i) // 2\n    return -1\n\nn = int(input())\nresult = find_pythagorean_triple(n)\nif result == -1:\n    print(-1)\nelse:\n    print(*result)"}
{"solution": "n, k = map(int, input().split())\nremainders = set()\n\nfor i in range(1, k + 1):\n    remainder = n % i\n    if remainder in remainders:\n        print(\"No\")\n        break\n    remainders.add(remainder)\nelse:\n    print(\"Yes\")"}
{"solution": "# Read the input\na = raw_input().strip('0')\nb = raw_input().strip('0')\n\n# Compare the lengths of the numbers\nif len(a) < len(b):\n    print(\"<\")\nelif len(a) > len(b):\n    print(\">\")\nelse:\n    # If the lengths are equal, compare the numbers\n    if a < b:\n        print(\"<\")\n    elif a > b:\n        print(\">\")\n    else:\n        print(\"=\")"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(n, p, colors):\n    dp = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        if colors[i] != -1:\n            dp[i][i][colors[i]] = 1\n        else:\n            dp[i][i][0] = dp[i][i][1] = 1\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if colors[i] != -1 and colors[j] != -1 and colors[i] != colors[j]:\n                dp[i][j][colors[i]] += dp[i + 1][j][1 - colors[i]]\n                dp[i][j][colors[i]] %= MOD\n                dp[i][j][colors[j]] += dp[i][j - 1][1 - colors[j]]\n                dp[i][j][colors[j]] %= MOD\n            elif colors[i] != -1:\n                dp[i][j][colors[i]] += dp[i + 1][j][1 - colors[i]]\n                dp[i][j][colors[i]] %= MOD\n            elif colors[j] != -1:\n                dp[i][j][colors[j]] += dp[i][j - 1][1 - colors[j]]\n                dp[i][j][colors[j]] %= MOD\n            else:\n                for k in range(i + 1, j):\n                    dp[i][j][0] += dp[i][k][1] * dp[k][j][0]\n                    dp[i][j][0] %= MOD\n                    dp[i][j][1] += dp[i][k][0] * dp[k][j][1]\n                    dp[i][j][1] %= MOD\n    return sum(dp[0][n - 1]) % MOD\n\nn, p = map(int, input().split())\ncolors = list(map(int, input().split()))\nprint(solve(n, p, colors))"}
{"solution": "def min_cost(n, a, b, c):\n    # Calculate the number of copybooks Alyona needs to buy\n    k = (4 - n % 4) % 4\n\n    # Calculate the cost of buying k copybooks using the cheapest packs\n    cost = 0\n    while k >= 3:\n        if 3*c <= a + b:\n            cost += c\n            k -= 3\n        else:\n            break\n    while k >= 2:\n        if 2*b <= a:\n            cost += b\n            k -= 2\n        else:\n            break\n    while k > 0:\n        cost += a\n        k -= 1\n\n    return cost\n\n# Read the input\nn, a, b, c = map(int, input().split())\n\n# Print the minimum cost\nprint(min_cost(n, a, b, c))"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef dfs(node, visited, recStack, graph):\n    visited[node] = True\n    recStack[node] = True\n\n    for neighbour in graph[node]:\n        if not visited[neighbour] and dfs(neighbour, visited, recStack, graph):\n            return True\n        elif recStack[neighbour]:\n            return True\n\n    recStack[node] = False\n    return False\n\ndef isCyclic(graph):\n    visited = [False] * len(graph)\n    recStack = [False] * len(graph)\n\n    for node in range(len(graph)):\n        if not visited[node] and dfs(node, visited, recStack, graph):\n            return True\n    return False\n\ndef solve(n, m, edges):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n\n    for u, v in edges:\n        graph[u].remove(v)\n        if not isCyclic(graph):\n            return True\n        graph[u].append(v)\n\n    return False\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    edges = [tuple(map(int, sys.stdin.readline().split())) for _ in range(m)]\n\n    if solve(n, m, edges):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    antennas = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    antennas.sort()\n\n    dp = [0] + [float('inf')] * m\n    for x, s in antennas:\n        for i in range(x - s, x + s + 1):\n            if i < 1:\n                continue\n            if i > m:\n                break\n            dp[i] = min(dp[i], dp[max(0, i - s - 1)] + max(0, x - i + s))\n\n    print(dp[m])\n\nif __name__ == '__main__':\n    main()"}
{"solution": "# Read the input\nW = int(input())\nitems = list(map(int, input().split()))\n\n# Initialize the maximum possible weight of a good subset\nmax_weight = 0\n\n# Iterate over all possible weights from 1 to 8\nfor weight in range(1, 9):\n    # Calculate the maximum number of items with the current weight that can be included in the good subset\n    num_items = min(items[weight - 1], W // weight)\n    # Update the maximum possible weight of a good subset\n    max_weight += num_items * weight\n    # Update the remaining weight\n    W -= num_items * weight\n\n# Print the maximum possible weight of a good subset\nprint(max_weight)"}
{"solution": "import sys\n\ndef min_cost(n, L, costs):\n    volumes = [2**i - 1 for i in range(1, n+1)]\n    dp = [float('inf')] * (L+1)\n    dp[0] = 0\n\n    for i in range(n):\n        for j in range(volumes[i], L+1):\n            dp[j] = min(dp[j], dp[j - volumes[i]] + costs[i])\n\n    return dp[L]\n\ndef main():\n    n, L = map(int, sys.stdin.readline().split())\n    costs = list(map(int, sys.stdin.readline().split()))\n    print(min_cost(n, L, costs))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Read the number of elements\nn = int(input())\n\n# Read the elements of the array\narr = list(map(int, input().split()))\n\n# Sort the array\narr.sort()\n\n# Initialize the mex value\nmex = 1\n\n# Iterate over the sorted array\nfor i in range(n):\n    # If the current element is equal to mex, increment mex\n    if arr[i] == mex:\n        mex += 1\n\n# Print the maximum possible value of mex\nprint(mex)"}
{"solution": "n = int(input())\nticket = input()\ndigits = [int(d) for d in ticket]\n\ndef is_lucky(digits):\n    total_sum = sum(digits)\n    if total_sum % 2 != 0:\n        return False\n    target_sum = total_sum // 2\n    current_sum = 0\n    for i in range(len(digits)):\n        current_sum += digits[i]\n        if current_sum == target_sum:\n            return is_lucky(digits[i+1:]) or (i+1 == len(digits) - 1)\n    return False\n\nif is_lucky(digits):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "# Get the user name\nuser_name = input()\n\n# Count the number of distinct characters\ndistinct_chars = len(set(user_name))\n\n# Determine the gender\nif distinct_chars % 2 == 0:\n    print(\"IGNORE HIM!\")\nelse:\n    print(\"CHAT WITH HER!\")"}
{"solution": "# Get the input\nn, k = map(int, input().split())\ntabs = list(map(int, input().split()))\n\n# Initialize the maximum difference\nmax_diff = 0\n\n# Iterate over all possible starting points\nfor b in range(1, n + 1):\n    # Initialize the counts of test and social network tabs\n    e, s = 0, 0\n\n    # Iterate over all tabs\n    for i in range(n):\n        # If the tab is not closed\n        if (i + 1 - b) % k != 0:\n            # If the tab contains information for the test\n            if tabs[i] == 1:\n                e += 1\n            # If the tab is a social network tab\n            else:\n                s += 1\n\n    # Update the maximum difference\n    max_diff = max(max_diff, abs(e - s))\n\n# Print the maximum difference\nprint(max_diff)"}
{"solution": "# Get the input\nn, c0, c1 = map(int, input().split())\n\n# Initialize the total cost\ntotal_cost = 0\n\n# Initialize the current code\ncode = '0'\n\n# Loop through the number of letters in the alphabet\nfor i in range(n):\n    # Add the current code's cost to the total cost\n    total_cost += code.count('0') * c0 + code.count('1') * c1\n\n    # Generate the next code\n    if '0' in code:\n        code = code.replace('0', '1', 1)\n    else:\n        code = '0' + code\n\n# Print the total cost\nprint(total_cost)"}
{"solution": "def will_meet(n, a, x, b, y):\n    # Create a list to represent the stations\n    stations = list(range(1, n+1)) * 2\n\n    # Initialize Daniel's and Vlad's positions\n    daniel_pos = a - 1\n    vlad_pos = b - 1 + n if b < a else b - 1\n\n    # Move Daniel and Vlad simultaneously\n    while daniel_pos != x - 1 and vlad_pos != y - 1 + n:\n        # Check if they are at the same station\n        if stations[daniel_pos] == stations[vlad_pos]:\n            return True\n\n        # Move Daniel and Vlad to their next stations\n        daniel_pos = (daniel_pos + 1) % (n * 2)\n        vlad_pos = (vlad_pos - 1) % (n * 2)\n\n    # Check if they are at the same station at the end\n    return stations[daniel_pos] == stations[vlad_pos]\n\n# Read the input\nn, a, x, b, y = map(int, input().split())\n\n# Check if Daniel and Vlad will meet\nif will_meet(n, a, x, b, y):\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "def unlucky_years(x, y, l, r):\n    unlucky = set()\n    a, b = 0, 0\n    while x**a <= r:\n        while y**b <= r:\n            if l <= x**a + y**b <= r:\n                unlucky.add(x**a + y**b)\n            b += 1\n        a += 1\n        b = 0\n\n    golden_age = 0\n    current_age = 0\n    for year in range(l, r+1):\n        if year not in unlucky:\n            current_age += 1\n            golden_age = max(golden_age, current_age)\n        else:\n            current_age = 0\n\n    return golden_age\n\nx, y, l, r = map(int, input().split())\nprint(unlucky_years(x, y, l, r))"}
{"solution": "def max_divisor(n):\n    for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1\n\ndef min_tax(n):\n    if n == 2:\n        return 1\n    if n % 2 == 0:\n        return 2\n    if max_divisor(n) > 2:\n        return 2\n    return 3\n\nn = int(input())\nprint(min_tax(n))"}
{"solution": "def check_consonants(word):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = 0\n    prev_consonant = None\n    result = []\n\n    for char in word:\n        if char not in vowels:\n            count += 1\n            if prev_consonant is not None and prev_consonant != char:\n                if count == 3:\n                    result.append(' ')\n                    count = 1\n                elif count > 3:\n                    result[-1] = ' '\n                    result.append(char)\n                    count = 1\n            prev_consonant = char\n        else:\n            count = 0\n            prev_consonant = None\n        result.append(char)\n\n    return ''.join(result)\n\nword = input()\nprint(check_consonants(word))"}
{"solution": "import sys\n\ndef main():\n    n, m, k = map(int, sys.stdin.readline().split())\n    x, s = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n    c = list(map(int, sys.stdin.readline().split()))\n    d = list(map(int, sys.stdin.readline().split()))\n\n    min_time = x * n\n\n    # Try all possible combinations of spells\n    for i in range(m):\n        for j in range(k):\n            if b[i] + d[j] > s:\n                continue\n            potions = c[j]\n            time = a[i] * (n - potions)\n            min_time = min(min_time, time)\n\n    # Try all spells of the first type\n    for i in range(m):\n        if b[i] > s:\n            continue\n        time = a[i] * n\n        min_time = min(min_time, time)\n\n    # Try all spells of the second type\n    for j in range(k):\n        if d[j] > s:\n            continue\n        potions = c[j]\n        time = x * (n - potions)\n        min_time = min(min_time, time)\n\n    print(min_time)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef max_points(n, k, M, t):\n    t.sort()\n    dp = [0] * (M + 1)\n    for i in range(1, k + 1):\n        for j in range(M, t[i - 1] - 1, -1):\n            dp[j] = max(dp[j], dp[j - t[i - 1]] + 1)\n    max_tasks = dp[M] // k\n    max_points = max_tasks * (k + 1) + dp[M - max_tasks * k]\n    return max_points\n\nn, k, M = map(int, sys.stdin.readline().split())\nt = list(map(int, sys.stdin.readline().split()))\nprint(max_points(n, k, M, t))"}
{"solution": "MOD = 998244353\n\ndef solve(n):\n    # dp[i][j] represents the number of perfectly balanced striped binary search trees\n    # with i nodes and j as the maximum key\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n\n    # Base case: when there are no nodes, there is only one tree (empty tree)\n    for j in range(n + 1):\n        dp[0][j] = 1\n\n    # Iterate over the number of nodes\n    for i in range(1, n + 1):\n        # Iterate over the maximum key\n        for j in range(i, n + 1):\n            # If the maximum key is even, we can add a left subtree with keys from 1 to j - 1\n            if j % 2 == 0:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD\n            # If the maximum key is odd, we can add a right subtree with keys from j + 1 to n\n            if j % 2 == 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MOD\n\n    # The answer is the number of trees with n nodes and maximum key n\n    return dp[n][n]\n\n# Read the input\nn = int(input())\n\n# Print the output\nprint(solve(n))"}
{"solution": "def find_position(n, m, k):\n    # Lara moves down first\n    if k < n:\n        return k + 1, 1\n    k -= n\n\n    # Then she moves in a snake fashion\n    for i in range(n - 1, 0, -2):\n        # Move right\n        if k < m - 1:\n            return i, k + 1\n        k -= m - 1\n\n        # Move up\n        if k < 1:\n            return i - k, m\n        k -= 1\n\n        # Move left\n        if k < m - 1:\n            return i - 1, m - k\n        k -= m - 1\n\n    # If Lara hasn't moved k times yet, she is at (1, 2)\n    return 1, 2\n\nn, m, k = map(int, input().split())\nrow, col = find_position(n, m, k)\nprint(row, col)"}
{"solution": "import math\n\ndef find_min_max_pair(X):\n    # If X is 1, then a and b should both be 1\n    if X == 1:\n        return 1, 1\n\n    # Initialize a and b as X and 1 respectively\n    a, b = X, 1\n\n    # Iterate from sqrt(X) to 1\n    for i in range(int(math.sqrt(X)), 0, -1):\n        # If X is divisible by i\n        if X % i == 0:\n            # Update a and b\n            a = X // i\n            b = i\n            # Break the loop as we found the pair\n            break\n\n    # Return the pair\n    return a, b\n\n# Read the input\nX = int(input())\n\n# Find the pair\na, b = find_min_max_pair(X)\n\n# Print the output\nprint(a, b)"}
{"solution": "# Get the input\na = int(input())\nb = int(input())\nc = int(input())\n\n# Calculate the maximum number of lemons that can be used\nlemons = min(a, b // 2, c // 4)\n\n# Calculate the maximum total number of fruits that can be used\ntotal_fruits = lemons + 2 * lemons + 4 * lemons\n\n# Print the result\nprint(total_fruits)"}
{"solution": "# Read the input\nn = int(input())\nratings = list(map(int, input().split()))\n\n# Sort the ratings\nratings.sort()\n\n# Check if it's possible to divide the players\nfor i in range(n):\n    if ratings[i] >= ratings[n + i]:\n        print(\"NO\")\n        exit()\n\n# If it's possible, print \"YES\"\nprint(\"YES\")"}
{"solution": "from math import gcd\n\n# Get the number of elements in the array\nn = int(input())\n\n# Get the elements of the array\narr = list(map(int, input().split()))\n\n# Initialize the count of moves\nmoves = 0\n\n# Initialize the new array\nnew_arr = []\n\n# Iterate over the array\nfor i in range(n):\n    # Add the current element to the new array\n    new_arr.append(arr[i])\n\n    # If the current element is not the last element\n    if i < n - 1:\n        # If the current element and the next element are not co-prime\n        if gcd(arr[i], arr[i + 1]) != 1:\n            # Add 1 to the count of moves\n            moves += 1\n\n            # Find the smallest co-prime number to the current element\n            j = 2\n            while gcd(arr[i], j) != 1:\n                j += 1\n\n            # Add the co-prime number to the new array\n            new_arr.append(j)\n\n# Print the least number of elements needed to add to the array a to make it co-prime\nprint(moves)\n\n# Print the elements of the array a after adding k elements to it\nprint(' '.join(map(str, new_arr)))"}
{"solution": "import math\n\n# Read input\nn, k = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Calculate the total sum of the elements\ntotal_sum = sum(A)\n\n# Calculate the maximum possible positive integer that divides every element of A\nmax_divisor = 1\nfor i in range(1, int(math.sqrt(total_sum)) + 1):\n    if total_sum % i == 0:\n        # Check if i divides every element of A\n        if all(a % i == 0 for a in A):\n            max_divisor = max(max_divisor, i)\n        # Check if total_sum // i divides every element of A\n        if all(a % (total_sum // i) == 0 for a in A):\n            max_divisor = max(max_divisor, total_sum // i)\n\n# Print the result\nprint(max_divisor)"}
{"solution": "def cat_furrier_transform(x):\n    operations = []\n    for i in range(30, -1, -1):\n        if x & (1 << i):\n            operations.append(i)\n            x ^= (1 << (i + 1)) - 1\n    return operations\n\nx = int(input())\noperations = cat_furrier_transform(x)\nprint(len(operations) * 2)\nprint(' '.join(map(str, operations)))"}
{"solution": "# Get the input\nn, k = map(int, input().split())\nbuckets = list(map(int, input().split()))\n\n# Find the maximum length that can be watered by a single bucket\nmax_length = max(buckets)\n\n# Calculate the minimum number of hours required to water the garden\nmin_hours = k // max_length\nif k % max_length != 0:\n    min_hours += 1\n\n# Print the result\nprint(min_hours)"}
{"solution": "n, k = map(int, input().split())\nline = input()\n\ngrasshopper_pos = line.index('G')\ninsect_pos = line.index('T')\n\nif (grasshopper_pos - insect_pos) % k == 0 and all(line[i] != '#' for i in range(min(grasshopper_pos, insect_pos), max(grasshopper_pos, insect_pos), k)):\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "def calculate_intersection():\n    y1, y2, yw, xb, yb, r = map(int, input().split())\n\n    # Calculate the slope and y-intercept of the line of the ball's trajectory\n    m = (yw - yb) / xb\n    b = yb - m * xb\n\n    # Calculate the discriminant of the quadratic equation\n    a = 1 + m**2\n    c = b**2 - r**2\n    discriminant = (y1 - b)**2 - c / a\n\n    if discriminant < 0:\n        print(-1)\n        return\n\n    # Calculate the x-coordinate of the intersection point\n    x1 = (y1 - b) / (1 + m**2)\n\n    if y2 - b < 0:\n        print(-1)\n        return\n\n    x2 = (y2 - b) / (1 + m**2)\n\n    # Check if the intersection point is within the range of the goal\n    if x1 <= x2:\n        print(-1)\n        return\n\n    # Calculate the x-coordinate of the point of aiming\n    xw = (x1 + x2) / 2\n    print(xw)\n\ncalculate_intersection()"}
{"solution": "# Get the input\nb, d, s = map(int, input().split())\n\n# Calculate the total number of meals\ntotal_meals = b + d + s\n\n# Calculate the minimum number of meals Vasiliy could have missed\n# This is the total number of meals minus the maximum number of meals he could have had\n# The maximum number of meals he could have had is the minimum number of each type of meal plus one\nmin_missed_meals = total_meals - (min(b, d, s) + 1)\n\n# Print the result\nprint(min_missed_meals)"}
{"solution": "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    x, y = 0, 0\n    dx, dy = 0, 0\n    visited = set()\n\n    for i in range(n):\n        if a[i] in visited:\n            print(\"NO\")\n            return\n        visited.add(a[i])\n\n        if i == 0:\n            continue\n\n        if a[i] == a[i-1] + 1:\n            dy += 1\n        elif a[i] == a[i-1] - 1:\n            dy -= 1\n        elif a[i] == a[i-1] + y:\n            dx += 1\n        elif a[i] == a[i-1] - y:\n            dx -= 1\n        else:\n            print(\"NO\")\n            return\n\n        x = max(x, dx)\n        y = max(y, dy)\n\n    if x * y < n:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    print(x, y)\n\nsolve()"}
{"solution": "def min_removals(a, b):\n    i = j = 0\n    m, n = len(a), len(b)\n    while i < m and j < n:\n        if a[i] == b[j]:\n            i += 1\n        j += 1\n    return a[:i]\n\na = input()\nb = input()\nprint(min_removals(a, b) or '-')"}
{"solution": "# Read the number of operations\nn = int(input())\n\n# Read the operations\noperations = input()\n\n# Initialize the number of stones in the pile\nstones = 0\n\n# Initialize the minimum number of stones in the pile\nmin_stones = 0\n\n# Iterate over the operations\nfor op in operations:\n    # If Vasya took a stone\n    if op == '-':\n        # Decrease the number of stones in the pile\n        stones -= 1\n    # If Vasya added a stone\n    else:\n        # Increase the number of stones in the pile\n        stones += 1\n    # Update the minimum number of stones in the pile\n    min_stones = min(min_stones, stones)\n\n# Print the minimum number of stones in the pile\nprint(-min_stones)"}
{"solution": "# Get the input\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# Calculate the maximum number of liters Kolya can drink\n# First, calculate how many plastic bottles Kolya can buy\nplastic_bottles = n // a\n\n# Then, calculate how many glass bottles Kolya can buy and return\n# Kolya can buy a glass bottle and return it as long as the price difference is greater than or equal to the return price\nglass_bottles = 0\nif b - c > a:\n    glass_bottles = n // (b - c)\n\n# Kolya can drink all the plastic bottles and the kefir from the glass bottles\ntotal_liters = plastic_bottles + glass_bottles\n\n# Print the result\nprint(total_liters)"}
{"solution": "def card_war(n, k1, deck1, k2, deck2):\n    seen = set()\n    while deck1 and deck2:\n        if (tuple(deck1), tuple(deck2)) in seen:\n            return -1, -1\n        seen.add((tuple(deck1), tuple(deck2)))\n        card1 = deck1.pop(0)\n        card2 = deck2.pop(0)\n        if card1 > card2:\n            deck1.append(card2)\n            deck1.append(card1)\n        else:\n            deck2.append(card1)\n            deck2.append(card2)\n    return len(seen), 1 if deck1 else 2\n\nn = int(input())\nk1 = int(input())\ndeck1 = list(map(int, input().split()))\nk2 = int(input())\ndeck2 = list(map(int, input().split()))\n\nfights, winner = card_war(n, k1, deck1, k2, deck2)\nif fights == -1:\n    print(-1)\nelse:\n    print(fights, winner)"}
{"solution": "import re\n\npassword = input()\n\nif len(password) < 5:\n    print(\"Too weak\")\nelif not re.search(\"[a-z]\", password):\n    print(\"Too weak\")\nelif not re.search(\"[A-Z]\", password):\n    print(\"Too weak\")\nelif not re.search(\"[0-9]\", password):\n    print(\"Too weak\")\nelse:\n    print(\"Correct\")"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Count the number of students with each academic performance in both groups\ncount_a = [0] * 6\ncount_b = [0] * 6\nfor i in range(n):\n    count_a[a[i]] += 1\n    count_b[b[i]] += 1\n\n# Calculate the difference in the number of students with each academic performance\ndiff = [0] * 6\nfor i in range(1, 6):\n    diff[i] = abs(count_a[i] - count_b[i])\n\n# Check if it is possible to redistribute students\nif any(diff[i] % 2 != 0 for i in range(1, 6)):\n    print(-1)\nelse:\n    # Calculate the minimum number of exchanges\n    exchanges = sum(diff[i] // 2 for i in range(1, 6))\n    print(exchanges)"}
{"solution": "def is_valid(n, m, h, v):\n    # Create a graph where each junction is a node\n    graph = [[] for _ in range(n * m)]\n\n    # Add edges based on the street directions\n    for i in range(n):\n        for j in range(m - 1):\n            if h[i] == '>':\n                graph[i * m + j].append(i * m + j + 1)\n            else:\n                graph[i * m + j + 1].append(i * m + j)\n\n    for i in range(n - 1):\n        for j in range(m):\n            if v[j] == 'v':\n                graph[i * m + j].append((i + 1) * m + j)\n            else:\n                graph[(i + 1) * m + j].append(i * m + j)\n\n    # Check if there is a path from every node to every other node\n    for start in range(n * m):\n        visited = [False] * (n * m)\n        stack = [start]\n        visited[start] = True\n\n        while stack:\n            node = stack.pop()\n\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    stack.append(neighbor)\n\n        # If any node is not reachable, return False\n        if not all(visited):\n            return False\n\n    # If all nodes are reachable, return True\n    return True\n\n# Read input\nn, m = map(int, input().split())\nh = input()\nv = input()\n\n# Print output\nprint(\"YES\" if is_valid(n, m, h, v) else \"NO\")"}
{"solution": "def solve(n, a):\n    if n == 1:\n        return 'YES\\n' + str(a[0])\n    if a[0] == 0:\n        return 'YES\\n' + '(' + '0->' + solve(n - 1, a[1:]) + ')'\n    else:\n        for i in range(1, n):\n            if a[i] == 0:\n                return 'YES\\n' + '(' + solve(i, a[:i]) + '->' + solve(n - i, a[i:]) + ')'\n        return 'NO'\n\nn = int(input())\na = list(map(int, input().split()))\nprint(solve(n, a))"}
{"solution": "def solve(a, b):\n    while a != 0 and b != 0:\n        if a >= 2 * b:\n            a = a - 2 * b\n        elif b >= 2 * a:\n            b = b - 2 * a\n        else:\n            break\n    return a, b\n\na, b = map(int, input().split())\nresult = solve(a, b)\nprint(result[0], result[1])"}
{"solution": "def solve(k, a, b):\n    # Calculate the number of multiples of k in the range [1, b]\n    count_b = b // k\n\n    # Calculate the number of multiples of k in the range [1, a-1]\n    count_a = (a - 1) // k\n\n    # The number of k-divisible numbers on the segment [a, b] is the difference between the two counts\n    return count_b - count_a\n\n# Read the input\nk, a, b = map(int, input().split())\n\n# Print the result\nprint(solve(k, a, b))"}
{"solution": "k = int(input())\n\nnum = 1\nlength = 1\n\nwhile k > length:\n    k -= length\n    num += 1\n    length = len(str(num))\n\nnum = str(num)\nprint(num[k - 1])"}
{"solution": "n = int(input())\ns = input()\n\n# Count the number of 8s in the string\ncount_8 = s.count('8')\n\n# If there are no 8s, Vasya cannot win\nif count_8 == 0:\n    print('NO')\nelse:\n    # If the first 8 is not at the beginning of the string\n    # and there are at least (n - 11) // 2 + 1 8s, Vasya can win\n    if s.index('8') != 0 and count_8 >= (n - 11) // 2 + 1:\n        print('YES')\n    else:\n        print('NO')"}
{"solution": "MOD = 10**9 + 7\n\ndef factorial(n):\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = (fact[i - 1] * i) % MOD\n    return fact\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1:\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\ndef find_permutations(n, x, pos):\n    fact = factorial(n)\n    if pos > x - 1:\n        return (fact[n - 1] * power(fact[x - 1], MOD - 2, MOD) * power(fact[n - x], MOD - 2, MOD)) % MOD\n    else:\n        return (fact[n - 1] * power(fact[x - 1], MOD - 2, MOD) * power(fact[n - x - 1], MOD - 2, MOD)) % MOD\n\nn, x, pos = map(int, input().split())\nprint(find_permutations(n, x, pos))"}
{"solution": "def decode_string(s, k):\n    n = len(s)\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            if s[i - 1].isalpha():\n                if j > 0:\n                    dp[i][j] = dp[i - 1][j - 1]\n            elif s[i - 1] == '?':\n                if j > 0:\n                    dp[i][j] = dp[i - 1][j - 1]\n                dp[i][j] |= dp[i - 1][j]\n            else:\n                if j > 0:\n                    dp[i][j] = dp[i - 1][j - 1]\n                for l in range(2, j + 1):\n                    dp[i][j] |= dp[i - 1][j - l + 1]\n    if dp[n][k] == 0:\n        return \"Impossible\"\n    else:\n        res = []\n        i, j = n, k\n        while i > 0 and j > 0:\n            if s[i - 1].isalpha():\n                res.append(s[i - 1])\n                i -= 1\n                j -= 1\n            elif s[i - 1] == '?':\n                if j > 0 and dp[i - 1][j - 1] == 1:\n                    res.append(s[i - 2])\n                    i -= 2\n                    j -= 1\n                else:\n                    i -= 1\n            else:\n                l = 1\n                while j - l >= 0 and dp[i - 1][j - l] == 0:\n                    l += 1\n                res.append(s[i - 2] * l)\n                i -= 2\n                j -= l\n        return ''.join(res[::-1])\n\ns = input()\nk = int(input())\nprint(decode_string(s, k))"}
{"solution": "# Get the input\nx = int(input())\n\n# Calculate the number of 90 degree turns\nturns = (x % 360 + 360) // 90\n\n# Calculate the minimum number of 90 degree clockwise turns\nmin_turns = min(turns, 4 - turns)\n\n# Print the output\nprint(min_turns)"}
{"solution": "# Get the input\na, b, c = map(int, input().split())\nx, y, z = map(int, input().split())\n\n# Check if it's possible to get the required number of spheres\nif a >= x and b >= y and c >= z:\n    print(\"Yes\")\nelif a + b >= x + y and a + c >= x + z and b + c >= y + z:\n    print(\"Yes\")\nelif a + b + c >= x + y + z and (a + b - x - y >= 0 or a + c - x - z >= 0 or b + c - y - z >= 0):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "def solve(n, k, m):\n    dp = [[0] * k for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(k):\n            for d in range(10):\n                dp[i][(j * 10 + d) % k] = (dp[i][(j * 10 + d) % k] + dp[i - 1][j]) % m\n    return dp[n][0]\n\nn, k, m = map(int, input().split())\nprint(solve(n, k, m))"}
{"solution": "# Get the input\nl, r, a = map(int, input().split())\n\n# Calculate the maximum possible size of the team\nteam_size = 2 * min(l, r) + 2 * min(a, abs(l - r))\n\n# Print the result\nprint(team_size)"}
{"solution": "def min_moves(n, k):\n    # Initial move to throw the stone to the rightmost manhole\n    moves = n - k\n    # Move to open the rightmost manhole\n    moves += 1\n    # Move to go to the leftmost manhole\n    moves += k - 1\n    # Throw stones from the leftmost manhole to the right, opening each manhole\n    moves += 2 * (n - 1)\n    return moves\n\nn, k = map(int, input().split())\nprint(min_moves(n, k))"}
{"solution": "n, m = map(int, input().split())\n\n# Calculate the maximum number of blocks that can be used by students using two-block pieces\nmax_two_blocks = 2 * n\n\n# Calculate the maximum number of blocks that can be used by students using three-block pieces\nmax_three_blocks = 3 * m\n\n# Initialize the height of the tallest tower\nheight = 0\n\n# If there are students using two-block pieces\nif n > 0:\n    # Start from the maximum number of blocks that can be used by students using two-block pieces\n    # and decrement by 2 in each iteration\n    for i in range(max_two_blocks, 0, -2):\n        # If the current number of blocks is not a multiple of 3,\n        # it means that it can be used by a student using two-block pieces\n        if i % 3 != 0:\n            # Update the height of the tallest tower\n            height = max(height, i)\n            # Break the loop since we only need to find the minimum height necessary\n            # for the tallest of the students' towers\n            break\n\n# If there are students using three-block pieces\nif m > 0:\n    # Start from the maximum number of blocks that can be used by students using three-block pieces\n    # and decrement by 3 in each iteration\n    for i in range(max_three_blocks, 0, -3):\n        # If the current number of blocks is not a multiple of 2,\n        # it means that it can be used by a student using three-block pieces\n        if i % 2 != 0:\n            # Update the height of the tallest tower\n            height = max(height, i)\n            # Break the loop since we only need to find the minimum height necessary\n            # for the tallest of the students' towers\n            break\n\n# Print the minimum possible height of the tallest tower\nprint(height)"}
{"solution": "n = int(input())\ncards = [int(input()) for _ in range(n)]\n\nfrom collections import Counter\ncounter = Counter(cards)\n\npetya_card = None\nvasya_card = None\n\nfor card, count in counter.items():\n    if count == n // 2:\n        if petya_card is None:\n            petya_card = card\n        elif vasya_card is None:\n            vasya_card = card\n            break\n\nif petya_card is not None and vasya_card is not None:\n    print(\"YES\")\n    print(petya_card, vasya_card)\nelse:\n    print(\"NO\")"}
{"solution": "# Read input\nn, k = map(int, input().split())\ngroups = list(map(int, input().split()))\n\n# Sort groups in descending order\ngroups.sort(reverse=True)\n\n# Check if it's possible to arrange soldiers\npossible = True\nfor group in groups:\n    # Calculate number of rows needed for this group\n    rows = (group + 7) // 8\n    if rows > n:\n        possible = False\n        break\n    # Subtract used rows\n    n -= rows\n\n# Print result\nif possible:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n = int(input())\nsticks = list(map(int, input().split()))\n\nmin_cost = float('inf')\nt = 0\n\nfor i in range(1, 101):\n    cost = 0\n    for stick in sticks:\n        cost += min(abs(stick - i), abs(stick - i - 1), abs(stick - i + 1))\n    if cost < min_cost:\n        min_cost = cost\n        t = i\n\nprint(t, min_cost)"}
{"solution": "# Read the input\nn, m = map(int, input().split())\nsky_map = [input() for _ in range(n)]\n\n# Find the boundaries of the stars\nmin_row, max_row, min_col, max_col = n, 0, m, 0\nfor i in range(n):\n    for j in range(m):\n        if sky_map[i][j] == '*':\n            min_row = min(min_row, i)\n            max_row = max(max_row, i)\n            min_col = min(min_col, j)\n            max_col = max(max_col, j)\n\n# Calculate the side length of the square\nside_length = max(max_row - min_row + 1, max_col - min_col + 1)\n\n# Print the result\nprint(side_length)"}
{"solution": "MOD = 10**9 + 7\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\n\ndef solve(n, k, a):\n    zeros = a.count(0)\n    ones = n - zeros\n    if zeros == 0 or ones == 0:\n        return 1\n    if k >= n * (n - 1) // 2:\n        return 0\n    fact = [1]\n    for i in range(1, n + 1):\n        fact.append(fact[-1] * i % MOD)\n    inv_fact = [inv(fact[-1])]\n    for i in range(n, 0, -1):\n        inv_fact.append(inv_fact[-1] * i % MOD)\n    inv_fact.reverse()\n    def C(n, k):\n        return fact[n] * inv_fact[k] * inv_fact[n - k] % MOD\n    def S(n, k):\n        if k > n:\n            return 0\n        return C(n, k) * fact[k] % MOD\n    ans = 0\n    for i in range(zeros, n + 1):\n        ans = (ans + S(n - 1, i - 1) * S(i, zeros) % MOD)\n    return ans * inv(S(n, zeros)) % MOD\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nprint(solve(n, k, a))"}
{"solution": "def min_seconds(x, y):\n    seconds = 0\n    while x > y:\n        if x % 2 == 0:\n            x //= 2\n        else:\n            x -= 1\n        seconds += 1\n    return seconds\n\nx, y = map(int, input().split())\nprint(min_seconds(x, y))"}
{"solution": "# Get the input\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Calculate the determinant\ndet = a * d - b * c\n\n# If the determinant is not zero, the matrix is not degenerate\nif det != 0:\n    print(0)\nelse:\n    # Calculate the norm of the matrix A\n    norm_A = max(abs(a), abs(b), abs(c), abs(d))\n\n    # Calculate the minimum possible value of ||A - B||\n    # If a and d are not both zero, we can make one of them zero\n    if a != 0 or d != 0:\n        norm_B = max(abs(b), abs(c))\n    # If a and d are both zero, we can make b and c both zero\n    else:\n        norm_B = max(abs(a), abs(d))\n\n    print(abs(norm_A - norm_B))"}
{"solution": "n, a, b = map(int, input().split())\ngroups = list(map(int, input().split()))\n\ndenied = 0\none_seaters = a\ntwo_seaters = b\nsingle_in_two_seater = 0\n\nfor group in groups:\n    if group == 1:\n        if one_seaters > 0:\n            one_seaters -= 1\n        elif two_seaters > 0:\n            two_seaters -= 1\n        elif single_in_two_seater > 0:\n            single_in_two_seater -= 1\n        else:\n            denied += 1\n    else:\n        if two_seaters > 0:\n            two_seaters -= 1\n        else:\n            denied += 2\n    if group == 1 and two_seaters > 0:\n        single_in_two_seater += 1\n\nprint(denied)"}
{"solution": "# Get the input\nA, B, C, N = map(int, input().split())\n\n# Check if the data is valid\nif A + B - C > N or A + C > N or B + C > N or A + B - C < 0 or A + C < 0 or B + C < 0:\n    print(-1)\nelse:\n    # Calculate the number of students who didn't pass the exam\n    not_passed = N - (A + B - C)\n    # Check if at least one student stayed home\n    if not_passed > 0:\n        print(not_passed)\n    else:\n        print(-1)"}
{"solution": "MOD = 10**9 + 7\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1:\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\ndef inverse(n, p):\n    return power(n, p - 2, p)\n\ndef solve(x, k):\n    if k == 0:\n        return x\n    else:\n        return (solve(x, k - 1) * 2 % MOD * inverse(2, MOD) + solve(x, k - 1) * 2 % MOD * inverse(2, MOD)) % MOD\n\nx, k = map(int, input().split())\nprint(solve(x, k))"}
{"solution": "MOD = 998244353\n\ndef solve():\n    n = int(input())\n    dp = [[0] * (n + 1) for _ in range(n)]\n    l = [0] * n\n    r = [0] * n\n\n    for i in range(n):\n        l[i], r[i] = map(int, input().split())\n\n    for i in range(l[0], r[0] + 1):\n        dp[0][i] = 1\n\n    for i in range(1, n):\n        for j in range(l[i], r[i] + 1):\n            for k in range(j, r[i - 1] + 1):\n                dp[i][j] = (dp[i][j] + dp[i - 1][k]) % MOD\n\n    ans = 0\n    for i in range(l[n - 1], r[n - 1] + 1):\n        ans = (ans + dp[n - 1][i]) % MOD\n\n    total = 1\n    for i in range(1, n):\n        total = (total * (r[i] - l[i] + 1)) % MOD\n\n    return (ans * pow(total, MOD - 2, MOD)) % MOD\n\nprint(solve())"}
{"solution": "# Get the length of the stick from the user\nn = int(input())\n\n# Initialize the count of ways to split the stick\ncount = 0\n\n# Iterate through all possible lengths of the first part of the stick\nfor i in range(1, n // 3 + 1):\n    # Calculate the length of the remaining part of the stick\n    remaining = n - i\n\n    # Check if the remaining length can be divided into two equal parts\n    if remaining % 2 == 0:\n        # Calculate the length of each equal part\n        half = remaining // 2\n\n        # Check if the length of the first part is not equal to the length of each equal part\n        if i != half:\n            # Add the number of ways to divide each equal part into two parts each to the total count\n            count += 1\n\n# Print the total count of ways to split the stick\nprint(count)"}
{"solution": "# Read input\nn, s = map(int, input().split())\nkegs = list(map(int, input().split()))\n\n# Sort the kegs in non-decreasing order\nkegs.sort()\n\n# Calculate the total volume of kvass\ntotal_volume = sum(kegs)\n\n# Check if it's possible to pour s liters of kvass\nif total_volume < s:\n    print(-1)\nelse:\n    # Calculate the minimum possible volume in the least keg\n    min_volume = (total_volume - s) // (n - 1)\n    # Update the minimum possible volume in the least keg\n    kegs[-1] = min(kegs[-1], kegs[0] + min_volume)\n    print(kegs[-1])"}
{"solution": "# Get the input\nh1, h2 = map(int, input().split())\na, b = map(int, input().split())\n\n# Calculate the distance the caterpillar needs to cover each day\nday_distance = 12 * a - 12 * b\n\n# Calculate the distance the caterpillar needs to cover to get the apple\ntotal_distance = h2 - h1\n\n# If the caterpillar can't get the apple, print -1\nif day_distance <= 0 and total_distance > day_distance:\n    print(-1)\nelse:\n    # Calculate the number of days the caterpillar needs to get the apple\n    days = total_distance // day_distance\n    if total_distance % day_distance != 0:\n        days += 1\n    print(days)"}
{"solution": "# Get the input\nC, Hr, Hb, Wr, Wb = map(int, input().split())\n\n# Calculate the maximum number of red candies Om Nom can eat\nmax_red_candies = min(C // Wr, C // Hr)\n\n# Calculate the maximum number of blue candies Om Nom can eat\nmax_blue_candies = min(C // Wb, C // Hb)\n\n# Calculate the maximum number of joy units Om Nom can get\nmax_joy = max_red_candies * Hr + max_blue_candies * Hb\n\n# Print the result\nprint(max_joy)"}
{"solution": "# Get the start and end coordinates\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\n\n# Calculate the absolute difference between the coordinates\ndx = abs(x1 - x2)\ndy = abs(y1 - y2)\n\n# The minimal number of steps is the maximum of dx and dy\nmin_steps = max(dx, dy)\n\n# Print the result\nprint(min_steps)"}
{"solution": "n = int(input())\nemployees = input()\n\n# Initialize two stacks for depublicans and remocrats\ndepublicans = []\nremocrats = []\n\n# Iterate over the employees\nfor i in range(n):\n    # If the employee is a depublican\n    if employees[i] == 'D':\n        # If there are no remocrats left to vote\n        if not remocrats:\n            # The depublican votes\n            depublicans.append(i)\n        # If there are remocrats left to vote\n        else:\n            # The depublican denies the right to vote to the last remocrat\n            remocrats.pop()\n    # If the employee is a remocrat\n    else:\n        # If there are no depublicans left to vote\n        if not depublicans:\n            # The remocrat votes\n            remocrats.append(i)\n        # If there are depublicans left to vote\n        else:\n            # The remocrat denies the right to vote to the last depublican\n            depublicans.pop()\n\n# Print the outcome of the vote\nprint('D' if depublicans else 'R')"}
{"solution": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\na, b, x, y = map(int, input().split())\n\n# Reduce the aspect ratio to its simplest form\ng = gcd(x, y)\nx //= g\ny //= g\n\n# Calculate the maximum possible width and height\nmax_width = b * x\nmax_height = a * y\n\n# If the maximum possible width is less than the actual width,\n# then the aspect ratio constraint is more restrictive than the width constraint\nif max_width < a:\n    a = max_width\n# Similarly, if the maximum possible height is less than the actual height,\n# then the aspect ratio constraint is more restrictive than the height constraint\nelif max_height < b:\n    b = max_height\n\n# Now, the number of possible screen resolutions is the number of multiples of the aspect ratio\n# that are less than or equal to the maximum possible width and height\nprint(min(a // x, b // y))"}
{"solution": "def factorial_trailing_zeros(n, b):\n    count = 0\n    while n > 0:\n        n //= b\n        count += n\n    return count\n\nn, b = map(int, input().split())\nprint(factorial_trailing_zeros(n, b))"}
{"solution": "def frog_jumps(m, a, b):\n    if a == b:\n        return m + 1\n    elif a > b:\n        return (m + 1) * (m + 2) // 2\n    else:\n        total = 0\n        k = m // (a - b)\n        total += (k * (2 * a + (k - 1) * (a - b))) // 2\n        m -= k * (a - b)\n        if m < a:\n            total += m + 1\n        else:\n            total += frog_jumps(m, b, a)\n        return total\n\nm, a, b = map(int, input().split())\nprint(frog_jumps(m, a, b))"}
{"solution": "n = int(input())\nseq = list(map(int, input().split()))\n\n# Check if the first and last elements are odd\nif seq[0] % 2 == 0 or seq[-1] % 2 == 0:\n    print(\"No\")\nelse:\n    # Count the number of odd elements\n    odd_count = sum(1 for num in seq if num % 2 != 0)\n\n    # If the number of odd elements is even, it's not possible to divide the sequence\n    if odd_count % 2 == 0:\n        print(\"No\")\n    else:\n        print(\"Yes\")"}
{"solution": "# Get the coordinates of the two known trees\nx1, y1, x2, y2 = map(int, input().split())\n\n# Check if the two known trees are on the same horizontal or vertical line\nif x1 == x2 or y1 == y2:\n    # Calculate the coordinates of the two unknown trees\n    x3, y3 = x2, y1\n    x4, y4 = x1, y2\nelse:\n    # Check if the two known trees are on the same diagonal\n    if abs(x1 - x2) == abs(y1 - y2):\n        # Calculate the coordinates of the two unknown trees\n        x3, y3 = x1, y2\n        x4, y4 = x2, y1\n    else:\n        # If the two known trees are not on the same line or diagonal, there is no solution\n        x3, y3, x4, y4 = -1, -1, -1, -1\n\n# Print the coordinates of the two unknown trees\nprint(x3, y3, x4, y4)"}
{"solution": "MOD = 10**9 + 7\n\ndef matrix_multiply(A, B):\n    C = [[0, 0], [0, 0]]\n    for i in range(2):\n        for j in range(2):\n            for k in range(2):\n                C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % MOD\n    return C\n\ndef matrix_power(M, n):\n    result = [[1, 0], [0, 1]]\n    while n > 0:\n        if n % 2 == 1:\n            result = matrix_multiply(result, M)\n        M = matrix_multiply(M, M)\n        n //= 2\n    return result\n\nx, y = map(int, input().split())\nn = int(input())\n\nif n == 1:\n    print(x % MOD)\nelif n == 2:\n    print(y % MOD)\nelse:\n    M = [[1, 1], [1, 0]]\n    M_power_n_minus_2 = matrix_power(M, n - 2)\n    f_n = (x * M_power_n_minus_2[0][0] + y * M_power_n_minus_2[0][1]) % MOD\n    print(f_n)"}
{"solution": "n = int(input())\narr = list(map(int, input().split()))\n\n# Check if all elements are zero\nif all(x == 0 for x in arr):\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    # Initialize variables\n    start = 0\n    end = 0\n    sum_arr = 0\n    result = []\n\n    # Iterate through the array\n    while end < n:\n        # Add current element to sum\n        sum_arr += arr[end]\n\n        # If sum is not zero, add subarray to result\n        if sum_arr != 0:\n            result.append((start + 1, end + 1))\n            start = end + 1\n            sum_arr = 0\n\n        # Move to next element\n        end += 1\n\n    # Print number of subarrays\n    print(len(result))\n\n    # Print subarrays\n    for subarray in result:\n        print(*subarray)"}
{"solution": "MOD = 1000000009\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1:\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\ndef min_score(n, m, k):\n    score = m\n    doubles = 0\n    while m >= k:\n        doubles += m // k\n        m = m % k\n    score += power(2, doubles, MOD) - 1\n    return score % MOD\n\nn, m, k = map(int, input().split())\nprint(min_score(n, m, k))"}
{"solution": "def is_divisible_by_eight(n):\n    if n == '0':\n        return True\n    elif len(n) == 1:\n        return int(n) % 8 == 0\n    else:\n        for i in range(len(n)):\n            if int(n[i]) % 8 == 0:\n                return True\n            for j in range(i+1, len(n)):\n                if int(n[i:j+1]) % 8 == 0:\n                    return True\n        return False\n\nn = input()\nif is_divisible_by_eight(n):\n    print('YES')\n    if n == '0':\n        print(n)\n    else:\n        for i in range(len(n)):\n            if int(n[i]) % 8 == 0:\n                print(n[i])\n                break\n            for j in range(i+1, len(n)):\n                if int(n[i:j+1]) % 8 == 0:\n                    print(n[i:j+1])\n                    break\nelse:\n    print('NO')"}
{"solution": "def find_floor(n, m, memory):\n    # Sort the memory by flat number\n    memory.sort(key=lambda x: x[0])\n\n    # Initialize the number of flats per floor\n    flats_per_floor = None\n\n    # Iterate over the memory\n    for i in range(m):\n        # Calculate the number of flats per floor for this memory entry\n        current_flats_per_floor = memory[i][0] // memory[i][1]\n\n        # If this is the first memory entry, set the number of flats per floor\n        if flats_per_floor is None:\n            flats_per_floor = current_flats_per_floor\n\n        # If this is not the first memory entry and the number of flats per floor is not equal to the previous one, return -1\n        elif flats_per_floor != current_flats_per_floor:\n            return -1\n\n    # If we have reached this point, it means that the number of flats per floor is unique\n    # Calculate the floor for the n-th flat\n    return (n - 1) // flats_per_floor + 1\n\n# Read the input\nn, m = map(int, input().split())\nmemory = [list(map(int, input().split())) for _ in range(m)]\n\n# Print the output\nprint(find_floor(n, m, memory))"}
{"solution": "def count_bishwocks(board):\n    count = 0\n    for i in range(len(board) - 1):\n        for j in range(len(board[0]) - 1):\n            if board[i][j] == '0' and board[i][j + 1] == '0' and board[i + 1][j] == '0':\n                count += 1\n            if board[i][j] == '0' and board[i + 1][j] == '0' and board[i + 1][j + 1] == '0':\n                count += 1\n    return count\n\nboard = [input() for _ in range(2)]\nprint(count_bishwocks(board))"}
{"solution": "n = int(input())\ns = input()\n\n# Initialize variables\nmax_pretty_set = 0\ncurrent_pretty_set = 0\nlast_uppercase = -1\nseen_lowercase = set()\n\n# Iterate over the string\nfor i in range(n):\n    if s[i].islower():\n        # If the character is lowercase\n        if s[i] not in seen_lowercase and (last_uppercase == -1 or last_uppercase < i):\n            # If the character is not in the seen_lowercase set and there are no uppercase letters before it\n            current_pretty_set += 1\n            seen_lowercase.add(s[i])\n        else:\n            # If the character is in the seen_lowercase set or there are uppercase letters before it\n            max_pretty_set = max(max_pretty_set, current_pretty_set)\n            current_pretty_set = 1\n            seen_lowercase = set(s[i])\n    else:\n        # If the character is uppercase\n        last_uppercase = i\n        max_pretty_set = max(max_pretty_set, current_pretty_set)\n        current_pretty_set = 0\n        seen_lowercase = set()\n\n# Update the maximum pretty set\nmax_pretty_set = max(max_pretty_set, current_pretty_set)\n\n# Print the result\nprint(max_pretty_set)"}
{"solution": "# Read the number of elements\nn = int(input())\n\n# Read the elements of the sequence\na = list(map(int, input().split()))\n\n# Calculate the sum of all elements\ntotal_sum = sum(a)\n\n# Initialize the maximum possible value of B - C\nmax_diff = 0\n\n# Iterate over all possible subsets of the sequence\nfor i in range(1 << n):\n    # Calculate the sum of the current subset\n    subset_sum = 0\n    for j in range(n):\n        if i & (1 << j):\n            subset_sum += a[j]\n    # Calculate the difference between the sum of the current subset and the sum of the rest of the sequence\n    diff = abs(subset_sum - (total_sum - subset_sum))\n    # Update the maximum possible value of B - C\n    max_diff = max(max_diff, diff)\n\n# Print the maximum possible value of B - C\nprint(max_diff)"}
{"solution": "# Read input\na, b, f, k = map(int, input().split())\n\n# Calculate the distance the bus can travel with a full tank\ndistance_per_tank = b\n\n# Calculate the distance the bus needs to travel for one journey\ndistance_per_journey = 2 * a\n\n# Calculate the number of refuels needed for one journey\nrefuels_per_journey = 0\nif distance_per_journey > distance_per_tank:\n    refuels_per_journey = 1\n    if f > distance_per_tank or f < a - distance_per_tank:\n        refuels_per_journey = 2\n\n# Calculate the total number of refuels needed for k journeys\ntotal_refuels = refuels_per_journey * k\n\n# Check if it is possible to make k journeys\nif total_refuels > k:\n    print(-1)\nelse:\n    print(total_refuels)"}
{"solution": "n, p, q = map(int, input().split())\ns = input()\n\ndef split_string(s, p, q):\n    result = []\n    i = 0\n    while i < len(s):\n        if i + p <= len(s):\n            result.append(s[i:i+p])\n            i += p\n        elif i + q <= len(s):\n            result.append(s[i:i+q])\n            i += q\n        else:\n            return None\n    return result\n\nsplit = split_string(s, p, q)\nif split is None:\n    print(-1)\nelse:\n    print(len(split))\n    for part in split:\n        print(part)"}
{"solution": "def solve():\n    n, m, s, d = map(int, input().split())\n    obstacles = sorted(map(int, input().split()))\n\n    position = 0\n    for obstacle in obstacles:\n        if obstacle - position < s:\n            print(\"IMPOSSIBLE\")\n            return\n        else:\n            print(\"RUN\", obstacle - s - position)\n            position = obstacle\n            if position + d >= m:\n                break\n            else:\n                print(\"JUMP\", d)\n                position += d\n    if position < m:\n        print(\"RUN\", m - position)\n\nsolve()"}
{"solution": "def count_pairs(s, x):\n    # If sum is odd and xor is even, or sum is even and xor is odd, then no solution exists\n    if (s % 2 != x % 2):\n        return 0\n\n    # If sum and xor are equal, then only one solution exists (a = b = sum/2)\n    if (s == x):\n        return 1\n\n    # Find the difference between the two numbers\n    diff = (s - x) // 2\n\n    # Find the common bits in the two numbers\n    common = s - 2 * diff\n\n    # Find the number of set bits in the common part\n    set_bits = bin(common).count('1')\n\n    # The number of solutions is 2^(set_bits-1)\n    return 2**(set_bits-1)\n\n# Read the input\ns, x = map(int, input().split())\n\n# Print the number of solutions\nprint(count_pairs(s, x))"}
{"solution": "n, k = map(int, input().split())\n\n# Calculate the minimum number of actions needed\nl = (n + 2 * k) // (2 * k + 1)\n\n# Print the minimum number of actions needed\nprint(l)\n\n# Print the number of the skewer that is to be turned over at the corresponding step\nfor i in range(k + 1, n + 1, 2 * k + 1):\n    print(i)"}
{"solution": "def min_operations(n):\n    # Convert the number to string for easy manipulation\n    n = str(n)\n\n    # Initialize the minimum operations to infinity\n    min_ops = float('inf')\n\n    # Iterate over all possible lengths of the square root\n    for i in range(1, len(n) // 2 + 2):\n        # Iterate over all possible starting indices of the square root\n        for j in range(len(n) - i + 1):\n            # Extract the square root candidate\n            sqrt = int(n[j:j + i])\n\n            # Check if the square root is an integer\n            if sqrt * sqrt == int(n[j:]):\n                # Update the minimum operations\n                min_ops = min(min_ops, len(n) - len(str(sqrt * sqrt)))\n\n    # Return the minimum operations or -1 if it is impossible\n    return min_ops if min_ops < float('inf') else -1\n\n# Read the input\nn = int(input())\n\n# Print the output\nprint(min_operations(n))"}
{"solution": "import sys\n\nMOD = 10**9 + 7\n\ndef factorial(n):\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = (fact[i - 1] * i) % MOD\n    return fact\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1:\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\ndef find_f_max(n):\n    fact = factorial(n)\n    inv = [0] * (n + 1)\n    inv[n] = power(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        inv[i - 1] = (inv[i] * i) % MOD\n\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n\n    return (fact[n] * inv[count]) % MOD\n\nn = int(sys.stdin.readline())\nprint(find_f_max(n))"}
{"solution": "# Get the input string\ns = input()\n\n# Define the vowels\nvowels = ['A', 'E', 'I', 'O', 'U', 'Y']\n\n# Initialize the maximum jump length and the current position\nmax_jump = 0\ncurrent_pos = 0\n\n# Iterate over the string\nwhile current_pos < len(s):\n    # Find the next vowel\n    next_vowel_pos = float('inf')\n    for vowel in vowels:\n        try:\n            next_vowel_pos = min(next_vowel_pos, s.index(vowel, current_pos))\n        except ValueError:\n            pass\n\n    # If there are no more vowels, break the loop\n    if next_vowel_pos == float('inf'):\n        break\n\n    # Update the maximum jump length\n    max_jump = max(max_jump, next_vowel_pos - current_pos)\n\n    # Update the current position\n    current_pos = next_vowel_pos\n\n# Print the result\nprint(max_jump)"}
{"solution": "# Get the input\na1, a2, a3, a4 = map(int, input().split())\n\n# Calculate the total sum of candies\ntotal_sum = a1 + a2 + a3 + a4\n\n# Check if the total sum is odd, if so, it's impossible to distribute the candies equally\nif total_sum % 2 != 0:\n    print(\"NO\")\nelse:\n    # Check if it's possible to distribute the candies equally\n    if (a1 + a2 == total_sum // 2) or (a1 + a3 == total_sum // 2) or (a1 + a4 == total_sum // 2) or (a2 + a3 == total_sum // 2) or (a2 + a4 == total_sum // 2) or (a3 + a4 == total_sum // 2):\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "# Get the number of slices\nn = int(input())\n\n# Get the sizes of the slices\nsizes = list(map(int, input().split()))\n\n# Initialize the scores of Alice and Bob\nalice_score = 0\nbob_score = 0\n\n# Initialize the decider (1 for Alice, 0 for Bob)\ndecider = 0\n\n# Iterate over the slices\nfor size in sizes:\n    # If the decider is Alice\n    if decider:\n        # Alice takes the slice if it's larger than Bob's next slice or if Bob has no next slice\n        if sizes.index(size) == n - 1 or size > sizes[sizes.index(size) + 1]:\n            alice_score += size\n        else:\n            bob_score += size\n    # If the decider is Bob\n    else:\n        # Bob takes the slice if it's larger than or equal to Alice's next slice or if Alice has no next slice\n        if sizes.index(size) == n - 1 or size >= sizes[sizes.index(size) + 1]:\n            bob_score += size\n        else:\n            alice_score += size\n    # Switch the decider\n    decider = 1 - decider\n\n# Print the scores\nprint(alice_score, bob_score)"}
{"solution": "from collections import defaultdict\n\ndef min_variables(n, a):\n    dp = defaultdict(set)\n    dp[0] = {0}\n\n    for i in range(n):\n        new_dp = defaultdict(set)\n        for j in dp:\n            for k in dp[j]:\n                new_dp[j].add(k)\n                new_dp[j | (1 << i)].add(k + a[i])\n        dp = new_dp\n\n    for i in range(1, n + 1):\n        if len(dp[1 << i]) > 0:\n            return i\n\n    return -1\n\nn = int(input())\na = list(map(int, input().split()))\nprint(min_variables(n, a))"}
{"solution": "n = int(input())\npiles = list(map(int, input().split()))\n\n# If there is a pile with more than one stone, Alice can remove half of the piles\n# and leave the other half with one stone each. Then, Bob will be forced to remove\n# the last stone from a pile on his turn, and Alice can mirror Bob's moves.\n# Therefore, Alice can win.\nif max(piles) > 1:\n    print(\"Alice\")\nelse:\n    print(\"Bob\")"}
{"solution": "n = int(input())\nnums = list(map(int, input().split()))\nnums.sort()\n\nif n == 1:\n    print(\"YES\")\nelif n == 2:\n    if (nums[1] - nums[0]) % 2 == 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    diff1 = nums[1] - nums[0]\n    diff2 = nums[2] - nums[1]\n    if diff1 == diff2:\n        if all(nums[i] - nums[i - 1] == diff1 for i in range(2, n)):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n    else:\n        print(\"NO\")"}
{"solution": "n = int(input())\ns = input()\n\nmax_len = 0\nfor i in range(n):\n    for j in range(i+max_len, n):\n        sub = s[i:j+1]\n        if s.count(sub) >= 2:\n            max_len = max(max_len, len(sub))\n\nprint(max_len)"}
{"solution": "# Get the input\nn, a = map(int, input().split())\n\n# Calculate the minimum time Vasya needs to reach house a\nif a <= n // 2:\n    # If house a is on the left side of the street\n    time = a\nelse:\n    # If house a is on the right side of the street\n    time = n - a + 1\n\n# Print the result\nprint(time)"}
{"solution": "def check_possible(n, m, colors, k):\n    # Create a frequency map of the desired colors\n    freq_map = {}\n    for i in range(m):\n        freq_map[i+1] = k[i]\n\n    # Initialize variables to keep track of the current frequency and the start of the interval\n    curr_freq = {}\n    start = 0\n\n    # Iterate over the colors\n    for end in range(n):\n        # Add the current color to the current frequency map\n        if colors[end] in curr_freq:\n            curr_freq[colors[end]] += 1\n        else:\n            curr_freq[colors[end]] = 1\n\n        # If the current frequency map is equal to the desired frequency map, return True\n        if curr_freq == freq_map:\n            return True\n\n        # If the size of the current interval is greater than the desired size, remove the first color from the current frequency map\n        if end - start + 1 > sum(k):\n            curr_freq[colors[start]] -= 1\n            if curr_freq[colors[start]] == 0:\n                del curr_freq[colors[start]]\n            start += 1\n\n    # If no interval was found, return False\n    return False\n\n# Read the input\nn, m = map(int, input().split())\ncolors = list(map(int, input().split()))\nk = list(map(int, input().split()))\n\n# Check if it is possible to select an interval with the desired color counts\nif check_possible(n, m, colors, k):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n = int(input())\nmishka_wins = 0\nchris_wins = 0\n\nfor _ in range(n):\n    mishka, chris = map(int, input().split())\n    if mishka > chris:\n        mishka_wins += 1\n    elif chris > mishka:\n        chris_wins += 1\n\nif mishka_wins > chris_wins:\n    print(\"Mishka\")\nelif chris_wins > mishka_wins:\n    print(\"Chris\")\nelse:\n    print(\"Friendship is magic!^^\")"}
{"solution": "def is_valid(grid, n, m):\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '*':\n                continue\n            count = 0\n            for x in range(max(0, i-1), min(n, i+2)):\n                for y in range(max(0, j-1), min(m, j+2)):\n                    if grid[x][y] == '*':\n                        count += 1\n            if grid[i][j] == '.' and count != 0:\n                return False\n            elif grid[i][j] != '.' and int(grid[i][j]) != count:\n                return False\n    return True\n\nn, m = map(int, input().split())\ngrid = [list(input()) for _ in range(n)]\n\nif is_valid(grid, n, m):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def min_candies(n):\n    k = 1\n    while True:\n        vasya = 0\n        petya = 0\n        candies = n\n        while candies > 0:\n            vasya += min(k, candies)\n            candies -= min(k, candies)\n            if candies > 0:\n                petya += candies // 10\n                candies = candies - candies // 10\n        if vasya >= n // 2:\n            return k\n        k += 1\n\nn = int(input())\nprint(min_candies(n))"}
{"solution": "def check_necklace(s):\n    pearls = [i for i, x in enumerate(s) if x == 'o']\n    n = len(pearls)\n    diff = [pearls[(i+1)%n] - pearls[i] - 1 for i in range(n)]\n    return 'YES' if len(set(diff)) == 1 else 'NO'\n\ns = input()\nprint(check_necklace(s))"}
{"solution": "# Get the input\nn, m, k = map(int, input().split())\n\n# Calculate the maximum number of pillows Frodo can have\n# First, distribute one pillow to each hobbit\npillows_per_hobbit = 1\nremaining_pillows = m - n\n\n# If there are remaining pillows, distribute them to Frodo\n# but make sure no one is hurt\nif remaining_pillows > 0:\n    # Frodo can take at most the number of pillows that the hobbit\n    # on his left and the hobbit on his right have\n    pillows_for_frodo = min(k - 1, n - k)\n    # Update the remaining pillows\n    remaining_pillows -= pillows_for_frodo\n    # If there are still remaining pillows, distribute them equally\n    # to the hobbits on Frodo's left and right\n    if remaining_pillows > 0:\n        pillows_per_hobbit += remaining_pillows // 2\n\n# Frodo's pillows are the pillows he has initially plus the additional pillows\nfrodo_pillows = pillows_per_hobbit + pillows_for_frodo\n\n# Print the result\nprint(frodo_pillows)"}
{"solution": "import math\n\ndef max_cost_subarray(n, m, k, a):\n    max_cost = 0\n    curr_sum = 0\n    min_sum = 0\n    min_sum_index = -1\n    prefix_sum = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + a[i - 1]\n\n    for i in range(n):\n        curr_sum += a[i]\n\n        if i - min_sum_index >= m:\n            min_sum = min(min_sum, prefix_sum[i] - prefix_sum[min_sum_index + 1])\n            min_sum_index = min_sum_index + 1\n            while min_sum_index < i and prefix_sum[i] - prefix_sum[min_sum_index + 1] < min_sum:\n                min_sum_index += 1\n\n        cost = curr_sum - k * math.ceil((i - min_sum_index + 1) / m)\n        max_cost = max(max_cost, cost)\n\n    return max_cost\n\nn, m, k = map(int, input().split())\na = list(map(int, input().split()))\n\nprint(max_cost_subarray(n, m, k, a))"}
{"solution": "def main():\n    n, m = map(int, input().split())\n\n    # If n or m is 0, then the longest polyline is a square\n    if n == 0 or m == 0:\n        print(f\"{n} {m}\")\n        print(f\"{n} {n+m}\")\n        print(f\"{n+m} {n+m}\")\n        print(f\"{n+m} {n}\")\n    # If n and m are both even, then the longest polyline is a rectangle\n    elif n % 2 == 0 and m % 2 == 0:\n        print(f\"{n} {m}\")\n        print(f\"{n} {0}\")\n        print(f\"{0} {0}\")\n        print(f\"{0} {m}\")\n    # If n is even and m is odd, then the longest polyline is a zigzag\n    elif n % 2 == 0:\n        print(f\"{n} {m}\")\n        print(f\"{n} {0}\")\n        print(f\"{0} {1}\")\n        print(f\"{n} {1}\")\n    # If n is odd and m is even, then the longest polyline is a zigzag\n    elif m % 2 == 0:\n        print(f\"{n} {m}\")\n        print(f\"{1} {m}\")\n        print(f\"{1} {0}\")\n        print(f\"{n} {0}\")\n    # If n and m are both odd, then the longest polyline is a zigzag\n    else:\n        print(f\"{n} {m}\")\n        print(f\"{0} {m}\")\n        print(f\"{1} {m-1}\")\n        print(f\"{n} {0}\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from collections import Counter\n\ndef smallest_number(shuffled, substring):\n    count = Counter(shuffled)\n    sub_count = Counter(substring)\n    prefix = ''\n    suffix = ''\n\n    for char in shuffled:\n        if count[char] > sub_count[char]:\n            prefix += char\n            count[char] -= 1\n        else:\n            break\n\n    for char in reversed(shuffled):\n        if count[char] > sub_count[char]:\n            suffix = char + suffix\n            count[char] -= 1\n        else:\n            break\n\n    return prefix + substring + suffix\n\nshuffled = input()\nsubstring = input()\nprint(smallest_number(shuffled, substring))"}
{"solution": "n, m, min_val, max_val = map(int, input().split())\ntemperatures = list(map(int, input().split()))\n\n# Check if the minimum and maximum temperatures are in the list of temperatures\nif min_val not in temperatures or max_val not in temperatures:\n    print('Incorrect')\nelse:\n    # Check if the number of temperatures that are equal to min_val or max_val is greater than or equal to n - m\n    if temperatures.count(min_val) + temperatures.count(max_val) >= n - m:\n        print('Correct')\n    else:\n        print('Incorrect')"}
{"solution": "# Read the input value of m\nm = int(input())\n\n# Initialize a variable to store the count of n\ncount = 0\n\n# Initialize a variable to store the current power of 5\npower_of_5 = 5\n\n# Loop until the current power of 5 is less than or equal to m\nwhile power_of_5 <= m:\n\n    # Add the number of times m can be divided by the current power of 5 to the count\n    count += m // power_of_5\n\n    # Multiply the current power of 5 by 5 to get the next power of 5\n    power_of_5 *= 5\n\n# Print the count of n\nprint(count)\n\n# Print the values of n in increasing order\nfor i in range(1, count + 1):\n    print(5 * i, end=' ')"}
{"solution": "import heapq\nimport sys\n\ndef dijkstra(graph, start):\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n\n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node].items():\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n\n    return distances\n\ndef find_farthest_special_node(graph, special_nodes):\n    n = len(graph)\n    distances = [dijkstra(graph, node) for node in special_nodes]\n    max_distances = [0] * n\n\n    for i in range(n):\n        for j in range(len(special_nodes)):\n            max_distances[i] = max(max_distances[i], distances[j][i])\n\n    return [max_distances[node] for node in special_nodes]\n\ndef main():\n    n, m, k = map(int, sys.stdin.readline().split())\n    special_nodes = list(map(int, sys.stdin.readline().split()))\n    graph = {i: {} for i in range(1, n + 1)}\n\n    for _ in range(m):\n        u, v, w = map(int, sys.stdin.readline().split())\n        graph[u][v] = graph[v][u] = min(graph[u].get(v, float('infinity')), w)\n\n    print(*find_farthest_special_node(graph, special_nodes))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Get the number of movements and the final position of the ball\nn = int(input())\nx = int(input())\n\n# Calculate the initial position of the ball\nif n % 2 == 0:\n    # If n is even, the final position is the same as the initial position\n    # for the shells 0 and 2. For the shell 1, the initial position is the\n    # opposite of the final position.\n    if x == 1:\n        print(2)\n    else:\n        print(x)\nelse:\n    # If n is odd, the final position is the shell to the right of the\n    # initial position for the shells 0 and 1. For the shell 2, the initial\n    # position is the same as the final position.\n    if x == 0:\n        print(1)\n    elif x == 1:\n        print(0)\n    else:\n        print(x)"}
{"solution": "def is_square(rectangles):\n    x_coords = set()\n    y_coords = set()\n    for rect in rectangles:\n        x_coords.add(rect[0])\n        x_coords.add(rect[2])\n        y_coords.add(rect[1])\n        y_coords.add(rect[3])\n\n    x_coords = sorted(list(x_coords))\n    y_coords = sorted(list(y_coords))\n\n    if len(x_coords) != len(y_coords) or len(x_coords) != 2:\n        return False\n\n    for rect in rectangles:\n        if rect[0] != x_coords[0] or rect[2] != x_coords[1] or rect[1] != y_coords[0] or rect[3] != y_coords[1]:\n            return False\n\n    return True\n\nn = int(input())\nrectangles = []\nfor _ in range(n):\n    rect = list(map(int, input().split()))\n    rectangles.append(rect)\n\nprint(\"YES\" if is_square(rectangles) else \"NO\")"}
{"solution": "def sum_of_digits(n):\n    return sum(int(digit) for digit in str(n))\n\ndef count_really_big_numbers(n, s):\n    count = 0\n    for i in range(1, n + 1):\n        if i - sum_of_digits(i) >= s:\n            count += 1\n    return count\n\nn, s = map(int, input().split())\nprint(count_really_big_numbers(n, s))"}
{"solution": "def check_collinear(points):\n    if len(points) <= 2:\n        return True\n\n    x0, y0 = points[0]\n    x1, y1 = points[1]\n\n    for x, y in points[2:]:\n        if (x - x0) * (y1 - y0) != (y - y0) * (x1 - x0):\n            return False\n\n    return True\n\ndef check_possible(points):\n    n = len(points)\n\n    if n <= 2:\n        return True\n\n    for i in range(n):\n        for j in range(i+1, n):\n            line1 = [points[i], points[j]]\n            line2 = []\n\n            for k in range(n):\n                if k != i and k != j:\n                    if check_collinear(line1 + [points[k]]):\n                        line1.append(points[k])\n                    else:\n                        line2.append(points[k])\n\n            if check_collinear(line1) and check_collinear(line2):\n                return True\n\n    return False\n\nn = int(input())\npoints = [list(map(int, input().split())) for _ in range(n)]\n\nif check_possible(points):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "MOD = 10**9 + 7\n\ndef fast_power(base, power):\n    result = 1\n    while power > 0:\n        if power % 2 == 1:\n            result = (result * base) % MOD\n        base = (base * base) % MOD\n        power //= 2\n    return result\n\ndef inverse(n):\n    return fast_power(n, MOD - 2)\n\ndef binomial_coefficient(n, k):\n    if k > n:\n        return 0\n    return (factorials[n] * inverse(factorials[k]) * inverse(factorials[n - k])) % MOD\n\na, b, k, t = map(int, input().split())\n\nfactorials = [1]\nfor i in range(1, 2 * k * t + 1):\n    factorials.append((factorials[-1] * i) % MOD)\n\nresult = 0\nfor i in range(max(0, b - a + t), t + 1):\n    result = (result + binomial_coefficient(t, i) * fast_power(2 * k + 1, t - i)) % MOD\n\nprint(result)"}
{"solution": "def solve(n, l, x, y, marks):\n    marks_set = set(marks)\n    if x in marks_set and y in marks_set:\n        return 0, []\n    elif x in marks_set:\n        if y - x in marks_set:\n            return 0, []\n        else:\n            return 1, [y]\n    elif y in marks_set:\n        if y - x in marks_set:\n            return 0, []\n        else:\n            return 1, [x]\n    else:\n        if x in marks_set or y in marks_set or x + y in marks_set or l - x in marks_set or l - y in marks_set:\n            return 1, [x] if x not in marks_set else [y]\n        else:\n            return 2, [x, y]\n\nn, l, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\n\nv, new_marks = solve(n, l, x, y, marks)\nprint(v)\nprint(' '.join(map(str, new_marks)))"}
{"solution": "import sys\nimport math\n\ndef max_volume_cake():\n    n = int(sys.stdin.readline())\n    cakes = []\n    for _ in range(n):\n        r, h = map(int, sys.stdin.readline().split())\n        cakes.append((r, h))\n\n    cakes.sort(key=lambda x: x[0])\n\n    dp = [0] * n\n    dp[0] = math.pi * cakes[0][0]**2 * cakes[0][1]\n\n    for i in range(1, n):\n        dp[i] = dp[i-1]\n        for j in range(i):\n            if cakes[j][0] < cakes[i][0] and cakes[j][1] < cakes[i][1]:\n                dp[i] = max(dp[i], dp[j] + math.pi * cakes[i][0]**2 * cakes[i][1])\n\n    return dp[-1]\n\nprint(max_volume_cake())"}
{"solution": "import sys\n\ndef min_slices(n, k, h):\n    h.sort()\n    min_height = h[0]\n    slices = 0\n    removed_cubes = 0\n\n    for i in range(n):\n        if h[i] > min_height:\n            cubes_to_remove = h[i] - min_height\n            if removed_cubes + cubes_to_remove > k:\n                slices += 1\n                removed_cubes = cubes_to_remove\n            else:\n                removed_cubes += cubes_to_remove\n\n        if i < n - 1 and h[i] < h[i + 1]:\n            min_height = h[i]\n            removed_cubes = 0\n\n    return slices + 1\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    h = list(map(int, sys.stdin.readline().split()))\n    print(min_slices(n, k, h))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Read the input\nn = int(input())\ncards = list(map(int, input().split()))\n\n# Initialize the maximum score\nmax_score = 0\n\n# Iterate over all possible segments\nfor i in range(n):\n    for j in range(i, n):\n        # Calculate the score for the current segment\n        score = sum(cards[:i]) + sum(cards[i+1:j]) + sum(cards[j+1:])\n        # Update the maximum score\n        max_score = max(max_score, score)\n\n# Print the maximum score\nprint(max_score)"}
{"solution": "# Get the input\nk1, k2, k3 = map(int, input().split())\n\n# Check if it is possible to switch on the garlands in such a way that each second after switching the garlands on at least one garland will be lit\nif k1 == 1 or k2 == 1 or k3 == 1 or (k1 % 2 == 0 and k2 % 2 == 0 and k3 % 2 == 0):\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "n = int(input())\ns = input()\n\nstack = []\n\nfor char in s:\n    if stack and stack[-1][0] == char:\n        stack[-1][1] += 1\n    else:\n        stack.append([char, 1])\n\noperations = 0\nwhile stack:\n    if stack[-1][1] == 1:\n        break\n    else:\n        stack[-1][1] -= 1\n        operations += 1\n    if stack[-1][1] == 0:\n        stack.pop()\n    if stack and stack[-1][1] == 1:\n        operations += 1\n        stack.pop()\n\nif stack:\n    operations += 1\n\nprint(operations)"}
{"solution": "# Read the number of boys and their dancing skills\nn = int(input())\nboys = list(map(int, input().split()))\n\n# Read the number of girls and their dancing skills\nm = int(input())\ngirls = list(map(int, input().split()))\n\n# Sort the boys and girls by their dancing skills\nboys.sort()\ngirls.sort()\n\n# Initialize the count of pairs\ncount = 0\n\n# Iterate over the boys and girls\ni = 0\nj = 0\nwhile i < n and j < m:\n    # If the difference in dancing skills is at most 1, form a pair\n    if abs(boys[i] - girls[j]) <= 1:\n        count += 1\n        i += 1\n        j += 1\n    # Otherwise, move the one with lower dancing skills\n    elif boys[i] < girls[j]:\n        i += 1\n    else:\n        j += 1\n\n# Print the maximum possible number of pairs\nprint(count)"}
{"solution": "# Read the input\nteam1_player1 = list(map(int, input().split()))\nteam1_player2 = list(map(int, input().split()))\nteam2_player1 = list(map(int, input().split()))\nteam2_player2 = list(map(int, input().split()))\n\n# Determine the optimal strategy for each team\nif team1_player1[0] > team2_player2[1] and team1_player2[1] > team2_player1[0]:\n    print(\"Team 1\")\nelif team2_player1[0] > team1_player2[1] and team2_player2[1] > team1_player1[0]:\n    print(\"Team 2\")\nelse:\n    print(\"Draw\")"}
{"solution": "import math\nfrom itertools import combinations\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\ndef time_to_eat(point, meals):\n    return max(meal[2] * distance(point, meal[:2]) for meal in meals)\n\ndef find_optimal_point(meals, k):\n    min_time = float('inf')\n    for combo in combinations(meals, k):\n        x = sum(meal[0] / meal[2] for meal in combo) / (k * sum(1 / meal[2] for meal in combo))\n        y = sum(meal[1] / meal[2] for meal in combo) / (k * sum(1 / meal[2] for meal in combo))\n        min_time = min(min_time, time_to_eat((x, y), meals))\n    return min_time\n\nN, K = map(int, input().split())\nmeals = [list(map(int, input().split())) for _ in range(N)]\nprint(find_optimal_point(meals, K))"}
{"solution": "n = int(input())\nticket = input()\n\n# Calculate the sum of the first half and the second half of the ticket\nfirst_half_sum = sum(int(digit) for digit in ticket[:n//2] if digit != '?')\nsecond_half_sum = sum(int(digit) for digit in ticket[n//2:] if digit != '?')\n\n# Calculate the number of erased digits in the first half and the second half\nfirst_half_erased = ticket[:n//2].count('?')\nsecond_half_erased = ticket[n//2:].count('?')\n\n# If the sums are equal and the number of erased digits is even, Bicarp wins\nif first_half_sum == second_half_sum and (first_half_erased + second_half_erased) % 2 == 0:\n    print('Bicarp')\nelse:\n    print('Monocarp')"}
{"solution": "n, t = map(int, input().split())\nbuses = [list(map(int, input().split())) for _ in range(n)]\n\nearliest_bus = float('inf')\nearliest_bus_route = -1\n\nfor i in range(n):\n    s, d = buses[i]\n    if s <= t:\n        bus_time = s + ((t - s) // d) * d\n        if bus_time < earliest_bus:\n            earliest_bus = bus_time\n            earliest_bus_route = i + 1\n\nprint(earliest_bus_route)"}
{"solution": "import sys\nfrom math import comb\n\n# Read input\nm, k = map(int, sys.stdin.readline().split())\n\n# Function to count numbers with exactly k bits set in binary representation\ndef count_bits(n):\n    count = 0\n    for i in range(k, min(n.bit_length(), k + 1)):\n        count += comb(n.bit_length() - 1, i - 1)\n    return count\n\n# Binary search for the required number n\nleft, right = 1, 10**18\nwhile left < right:\n    mid = (left + right) // 2\n    if count_bits(2 * mid) - count_bits(mid) >= m:\n        right = mid\n    else:\n        left = mid + 1\n\n# Print the result\nprint(left)"}
{"solution": "n = int(input())\nlevel = input()\n\n# Find all the indices of platforms\nplatforms = [i for i in range(n) if level[i] == '*']\n\n# Check if there is a sequence of five platforms with equal jumps\nfor i in range(len(platforms) - 4):\n    if (platforms[i+1] - platforms[i] ==\n        platforms[i+2] - platforms[i+1] ==\n        platforms[i+3] - platforms[i+2] ==\n        platforms[i+4] - platforms[i+3]):\n        print('yes')\n        break\nelse:\n    print('no')"}
{"solution": "def calculate_magic_constant(matrix, n):\n    # Calculate the sum of the first row\n    magic_constant = sum(matrix[0])\n\n    # Calculate the sum of the remaining rows\n    for i in range(1, n):\n        if sum(matrix[i]) != magic_constant:\n            return -1\n\n    # Calculate the sum of the columns\n    for i in range(n):\n        column_sum = 0\n        for j in range(n):\n            column_sum += matrix[j][i]\n        if column_sum != magic_constant:\n            return -1\n\n    # Calculate the sum of the main diagonal\n    diagonal_sum = 0\n    for i in range(n):\n        diagonal_sum += matrix[i][i]\n    if diagonal_sum != magic_constant:\n        return -1\n\n    # Calculate the sum of the secondary diagonal\n    diagonal_sum = 0\n    for i in range(n):\n        diagonal_sum += matrix[i][n - i - 1]\n    if diagonal_sum != magic_constant:\n        return -1\n\n    return magic_constant\n\ndef find_missing_number(matrix, n):\n    # Calculate the magic constant\n    magic_constant = calculate_magic_constant(matrix, n)\n    if magic_constant == -1:\n        return -1\n\n    # Find the missing number\n    row_sums = [sum(row) for row in matrix]\n    col_sums = [sum(col) for col in zip(*matrix)]\n    main_diagonal_sum = sum(matrix[i][i] for i in range(n))\n    secondary_diagonal_sum = sum(matrix[i][n - i - 1] for i in range(n))\n\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] == 0:\n                # Calculate the possible value for the missing number\n                possible_value = magic_constant - (row_sums[i] + col_sums[j] - matrix[i][j])\n                if i == j:\n                    possible_value -= matrix[i][j] - main_diagonal_sum\n                if i == n - j - 1:\n                    possible_value -= matrix[i][j] - secondary_diagonal_sum\n                # Check if the possible value is valid\n                if possible_value > 0 and possible_value == magic_constant - row_sums[i] and possible_value == magic_constant - col_sums[j]:\n                    if i == j and possible_value == magic_constant - main_diagonal_sum:\n                        return possible_value\n                    if i == n - j - 1 and possible_value == magic_constant - secondary_diagonal_sum:\n                        return possible_value\n    return -1\n\n# Read the input\nn = int(input())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# Find the missing number\nresult = find_missing_number(matrix, n)\n\n# Print the result\nprint(result)"}
{"solution": "# Read the input\nn = int(input())\nm = int(input())\nbenches = [int(input()) for _ in range(n)]\n\n# Calculate the minimum possible k\nmin_k = max(benches)\nif m % n == 0:\n    min_k += m // n\nelse:\n    min_k += m // n + 1\n\n# Calculate the maximum possible k\nmax_k = max(benches) + m\n\n# Print the output\nprint(min_k, max_k)"}
{"solution": "MOD = 10**9 + 7\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1:\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\ndef find_ways(n, m):\n    if m > n:\n        return 0\n    if m == 1:\n        return n\n    if m == 2:\n        return (n * (n - 1)) % MOD\n    return (find_ways(n, m - 1) * (n - m + 1) * power(2, m - 2, MOD)) % MOD\n\nn, m = map(int, input().split())\nprint(find_ways(n, m))"}
{"solution": "import sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    friends = [0] * n\n    for i in range(n):\n        f_i, *b_i = map(int, sys.stdin.readline().split())\n        for b in b_i:\n            friends[i] |= 1 << (b - 1)\n\n    pizzas = [(0, 0, 0)] * m\n    for i in range(m):\n        c_j, r_j, *a_j = map(int, sys.stdin.readline().split())\n        ingredients = 0\n        for a in a_j:\n            ingredients |= 1 << (a - 1)\n        pizzas[i] = (c_j, ingredients, i + 1)\n\n    pizzas.sort()\n    max_pleased = 0\n    best_pizzas = (-1, -1)\n    for i in range(m - 1):\n        for j in range(i + 1, m):\n            combined = pizzas[i][1] | pizzas[j][1]\n            pleased = sum((friend & combined) == friend for friend in friends)\n            if pleased > max_pleased or (pleased == max_pleased and pizzas[i][0] + pizzas[j][0] < best_pizzas[0] + best_pizzas[1]):\n                max_pleased = pleased\n                best_pizzas = (pizzas[i][2], pizzas[j][2])\n\n    print(*best_pizzas)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_min_max(m, s):\n    if s == 0:\n        if m == 1:\n            return '0 0'\n        else:\n            return '-1 -1'\n    if s > 9 * m:\n        return '-1 -1'\n\n    min_num = ['0'] * m\n    max_num = ['0'] * m\n    s_temp = s\n\n    for i in range(m - 1, -1, -1):\n        if s_temp > 9:\n            max_num[i] = '9'\n            s_temp -= 9\n        else:\n            max_num[i] = str(s_temp)\n            s_temp = 0\n\n    s_temp = s\n    for i in range(m):\n        if s_temp > 9:\n            min_num[i] = '9'\n            s_temp -= 9\n        elif s_temp > 0:\n            min_num[i] = str(s_temp)\n            s_temp = 0\n\n    if min_num[0] == '0':\n        for i in range(1, m):\n            if min_num[i] != '0':\n                min_num[0], min_num[i] = min_num[i], min_num[0]\n                break\n\n    return ''.join(min_num) + ' ' + ''.join(max_num)\n\nm, s = map(int, input().split())\nprint(find_min_max(m, s))"}
{"solution": "MOD = 998244353\n\ndef solve(l, r, k):\n    def f(n):\n        if n == 0:\n            return 0\n        s = str(n)\n        dp = [[0] * (1 << 10) for _ in range(len(s) + 1)]\n        dp[0][0] = 1\n        for i in range(len(s)):\n            for j in range(1 << 10):\n                for d in range(10):\n                    if (j >> d) & 1:\n                        dp[i + 1][j] = (dp[i + 1][j] + dp[i][j]) % MOD\n                    elif (j >> d) < (1 << (k - 1)):\n                        dp[i + 1][j | (1 << d)] = (dp[i + 1][j | (1 << d)] + dp[i][j]) % MOD\n        return sum(dp[-1]) % MOD\n    return (f(r) - f(l - 1)) % MOD\n\nl, r, k = map(int, input().split())\nprint(solve(l, r, k))"}
{"solution": "def solve(n, k, d, a):\n    a.sort()\n    i = 0\n    while i < n:\n        j = i + k - 1\n        if j >= n:\n            return \"NO\"\n        while j > i and a[j] - a[i] > d:\n            j -= 1\n        if j == i:\n            return \"NO\"\n        i = j + 1\n    return \"YES\"\n\nn, k, d = map(int, input().split())\na = list(map(int, input().split()))\nprint(solve(n, k, d, a))"}
{"solution": "# Get the input string\ns = input()\n\n# Initialize the count of dead light bulbs for each color\nkr, kb, ky, kg = 0, 0, 0, 0\n\n# Iterate over the string\nfor i in range(len(s)):\n    # Check the color of the light bulb and increment the corresponding counter if it's dead\n    if s[i] == '!':\n        # Check the previous and next light bulbs to determine the color of the dead one\n        if i > 0 and i < len(s) - 1:\n            if s[i-1] != s[i+1]:\n                if s[i-1] == 'R' or s[i+1] == 'R':\n                    kr += 1\n                elif s[i-1] == 'B' or s[i+1] == 'B':\n                    kb += 1\n                elif s[i-1] == 'Y' or s[i+1] == 'Y':\n                    ky += 1\n                elif s[i-1] == 'G' or s[i+1] == 'G':\n                    kg += 1\n        # If it's the first or last light bulb, we can't determine the color, so we'll increment all counters\n        else:\n            kr += 1\n            kb += 1\n            ky += 1\n            kg += 1\n\n# Print the results\nprint(kr, kb, ky, kg)"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef read_input():\n    return sys.stdin.readline\n\ndef main():\n    n, m = map(int, read_input().split())\n    graph = defaultdict(list)\n    for _ in range(m):\n        s, t = map(int, read_input().split())\n        graph[s].append(t)\n\n    dp = [0] * (n + 1)\n    dp[n] = 0\n    for i in range(n - 1, 0, -1):\n        total = 0\n        for j in graph[i]:\n            total += dp[j]\n        dp[i] = total / len(graph[i]) + 1\n\n    min_expected_passages = float('inf')\n    for j in graph[1]:\n        if j == n:\n            min_expected_passages = min(min_expected_passages, 1)\n        else:\n            min_expected_passages = min(min_expected_passages, 1 + (dp[j] * len(graph[1]) - 1) / (len(graph[1]) - 1))\n\n    print(min_expected_passages)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Get the input number\nn = int(input())\n\n# If the number already ends with 0, print it as it is\nif n % 10 == 0:\n    print(n)\n# If the last digit is less than or equal to 5, round down to the nearest integer ending with 0\nelif n % 10 <= 5:\n    print(n - n % 10)\n# If the last digit is greater than 5, round up to the nearest integer ending with 0\nelse:\n    print(n + 10 - n % 10)"}
{"solution": "def find_swaps(s, t):\n    swaps = []\n    used = set()\n    for i in range(len(s)):\n        if s[i] != t[i] and t[i] not in used:\n            swaps.append((s[i], t[i]))\n            used.add(s[i])\n            used.add(t[i])\n    if len(used) == len(set(s)):\n        return swaps\n    else:\n        return -1\n\ns = input()\nt = input()\nresult = find_swaps(s, t)\nif result == -1:\n    print(-1)\nelse:\n    print(len(result))\n    for swap in result:\n        print(swap[0], swap[1])"}
{"solution": "# Get the input\nfirst_name, last_name = input().split()\n\n# Initialize the login\nlogin = \"\"\n\n# Iterate over the characters in the first name\nfor i in range(len(first_name)):\n    # Add the current character to the login\n    login += first_name[i]\n    # Iterate over the characters in the last name\n    for j in range(len(last_name)):\n        # Create a potential login\n        potential_login = login + last_name[j]\n        # If the potential login is alphabetically earlier than the current login, update the login\n        if potential_login < login:\n            login = potential_login\n\n# Print the login\nprint(login)"}
{"solution": "def draw_brackets(sequence):\n    n = len(sequence)\n    height = n // 2\n    width = 2 * height - 1\n    grid = [[' ' for _ in range(width * n)] for _ in range(2 * height + 1)]\n\n    def draw(start, end, level):\n        if start > end:\n            return\n        mid = (start + end) // 2\n        grid[level][mid * 2] = '+'\n        grid[height * 2 + 1 - level][mid * 2] = '+'\n        for i in range(start, mid):\n            grid[level][i * 2 + 1] = '-'\n            grid[height * 2 + 1 - level][i * 2 + 1] = '-'\n        for i in range(mid + 1, end + 1):\n            grid[level][i * 2 - 1] = '-'\n            grid[height * 2 + 1 - level][i * 2 - 1] = '-'\n        for i in range(level + 1, height * 2 + 1 - level):\n            grid[i][mid * 2] = '|'\n        draw(start, mid - 1, level + 1)\n        draw(mid + 1, end, level + 1)\n\n    draw(0, n // 2 - 1, 1)\n    for line in grid:\n        print(''.join(line))\n\nn = int(input())\nsequence = input()\ndraw_brackets(sequence)"}
{"solution": "def golden_to_decimal(golden_number):\n    decimal_number = 0\n    q = (1 + 5 ** 0.5) / 2\n    for i in range(len(golden_number)):\n        decimal_number += int(golden_number[i]) * q ** (len(golden_number) - 1 - i)\n    return decimal_number\n\ngolden_number1 = input()\ngolden_number2 = input()\n\ndecimal_number1 = golden_to_decimal(golden_number1)\ndecimal_number2 = golden_to_decimal(golden_number2)\n\nif decimal_number1 > decimal_number2:\n    print(\">\")\nelif decimal_number1 < decimal_number2:\n    print(\"<\")\nelse:\n    print(\"=\")"}
{"solution": "# Define the dictionary of gems and their colors\ngems = {\n    'purple': 'Power',\n    'green': 'Time',\n    'blue': 'Space',\n    'orange': 'Soul',\n    'red': 'Reality',\n    'yellow': 'Mind'\n}\n\n# Get the number of gems Thanos has\nn = int(input())\n\n# Get the colors of the gems Thanos has\nthanos_gems = [input() for _ in range(n)]\n\n# Find the names of the absent gems\nabsent_gems = [name for color, name in gems.items() if color not in thanos_gems]\n\n# Print the number of absent gems\nprint(len(absent_gems))\n\n# Print the names of the absent gems\nfor gem in absent_gems:\n    print(gem)"}
{"solution": "def find_meeting_round(n, a, b):\n    round = 1\n    while n > 1:\n        if (a - 1) // 2 == (b - 1) // 2:\n            return round\n        a = (a + 1) // 2\n        b = (b + 1) // 2\n        n //= 2\n        round += 1\n    return \"Final!\"\n\nn, a, b = map(int, input().split())\nprint(find_meeting_round(n, a, b))"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef dfs(node, graph, visited, component):\n    visited[node] = True\n    component.append(node)\n    for neighbor in graph[node]:\n        if not visited[neighbor]:\n            dfs(neighbor, graph, visited, component)\n\ndef solve():\n    n = int(read_input())\n    p = list(map(int, read_input().split()))\n    b = list(map(int, read_input().split()))\n\n    graph = defaultdict(list)\n    for i in range(n):\n        graph[i].append(p[i] - 1)\n        if b[i] == 1:\n            graph[i + n].append(p[n - i - 1] + n - 1)\n        else:\n            graph[i + n].append(p[i] - 1 + n)\n\n    visited = [False] * (2 * n)\n    components = []\n    for i in range(2 * n):\n        if not visited[i]:\n            component = []\n            dfs(i, graph, visited, component)\n            components.append(component)\n\n    odd_components = [component for component in components if len(component) % 2 == 1]\n    return len(odd_components) // 2\n\nprint(solve())"}
{"solution": "# Read input\nv1, v2 = map(int, input().split())\nt, d = map(int, input().split())\n\n# Initialize maximum distance\nmax_distance = v1 * t\n\n# Initialize current speed\ncurrent_speed = v1\n\n# Calculate maximum distance for each second\nfor _ in range(1, t):\n    # Calculate new speed\n    new_speed = current_speed + d if current_speed < v2 else current_speed - d\n    new_speed = min(max(new_speed, 1), 100)\n\n    # Update maximum distance\n    max_distance += new_speed\n\n    # Update current speed\n    current_speed = new_speed\n\n# Print maximum distance\nprint(max_distance)"}
{"solution": "import sys\nfrom itertools import accumulate\n\ndef solve():\n    N, M = map(int, sys.stdin.readline().split())\n    weights = list(map(int, sys.stdin.readline().split()))\n    bridges = [list(map(int, sys.stdin.readline().split())) for _ in range(M)]\n\n    # Sort the weights in descending order\n    weights.sort(reverse=True)\n\n    # Calculate the prefix sum of the weights\n    prefix_sum = list(accumulate(weights))\n\n    # Binary search for the minimum possible distance\n    left, right = 0, 10**16\n    while left < right:\n        mid = (left + right) // 2\n\n        # Check if it's possible to make the camels cross the bridge without it collapsing\n        current_weight = 0\n        current_position = 0\n        for weight in weights:\n            current_weight += weight\n            while current_position < M and bridges[current_position][0] < current_weight:\n                current_position += 1\n            if current_position == M or bridges[current_position][1] < current_weight:\n                break\n            if current_position > 0 and bridges[current_position-1][0] + mid < bridges[current_position][0]:\n                current_weight -= weight\n                current_position -= 1\n\n        if current_position == M:\n            right = mid\n        else:\n            left = mid + 1\n\n    # If it's not possible to make the camels cross the bridge without it collapsing\n    if left == 10**16:\n        return -1\n\n    return left\n\nprint(solve())"}
{"solution": "def last_digit_factorial(n):\n    if n == 0:\n        return 1\n    last_digits = [1, 1, 2, 6, 4, 0, 0, 0, 0, 0]\n    return last_digits[n % 10]\n\ndef last_digit_division(a, b):\n    if a > b:\n        return 0\n    if a == b:\n        return 1\n    a_last_digit = last_digit_factorial(a)\n    b_last_digit = last_digit_factorial(b)\n    inv_b_last_digit = {1: 1, 2: 5, 3: 3, 4: 7, 5: 9, 6: 1, 7: 1, 8: 1, 9: 1, 0: 0}\n    return (b_last_digit * inv_b_last_digit[a_last_digit]) % 10\n\na, b = map(int, input().split())\nprint(last_digit_division(a, b))"}
{"solution": "n, d = map(int, input().split())\ns = input()\n\njumps = 0\ncurrent_position = 0\n\nwhile current_position < n - 1:\n    next_position = current_position + d\n    while next_position > current_position and s[next_position] == '0':\n        next_position -= 1\n    if next_position == current_position:\n        print(-1)\n        break\n    current_position = next_position\n    jumps += 1\n\nif current_position == n - 1:\n    print(jumps)"}
{"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nn = int(input())\nfor m in range(1, 1001):\n    if not is_prime(n * m + 1):\n        print(m)\n        break"}
{"solution": "# Get the input\nn = int(input())\n\n# Define the prices\nhouse_price = 1234567\ncar_price = 123456\ncomputer_price = 1234\n\n# Check all possible numbers of houses\nfor a in range(n // house_price + 1):\n    # Check all possible numbers of cars\n    for b in range((n - a * house_price) // car_price + 1):\n        # Check if the remaining amount can be spent on computers\n        if (n - a * house_price - b * car_price) % computer_price == 0:\n            print(\"YES\")\n            exit(0)\n\n# If no solution is found\nprint(\"NO\")"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef main():\n    n = int(read_input())\n    x1, x2 = map(int, read_input().split())\n    lines = [list(map(int, read_input().split())) for _ in range(n)]\n\n    # Sort lines by slope\n    lines.sort(key=lambda x: x[0])\n\n    # Initialize min and max y values for lines with the same slope\n    min_y = [float('inf')] * n\n    max_y = [float('-inf')] * n\n\n    for i in range(n):\n        k, b = lines[i]\n        y1 = k * x1 + b\n        y2 = k * x2 + b\n        min_y[i] = min(y1, y2)\n        max_y[i] = max(y1, y2)\n\n    # Check if there is an intersection inside the strip\n    for i in range(1, n):\n        if lines[i][0] == lines[i - 1][0]:\n            if min_y[i] < max_y[i - 1] and min_y[i - 1] < max_y[i]:\n                print(\"YES\")\n                return\n        else:\n            x = (lines[i - 1][1] - lines[i][1]) / (lines[i][0] - lines[i - 1][0])\n            if x1 < x < x2:\n                print(\"YES\")\n                return\n\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Read the input\nn = int(input())\n\n# Initialize the count of different weights\ncount = 0\n\n# Initialize the first element of the split\ni = n\n\n# Loop until the first element of the split is 0\nwhile i > 0:\n    # Calculate the remaining sum after subtracting the first element\n    remaining = n - i\n\n    # Calculate the number of ways to split the remaining sum\n    # into non-increasing sequence of positive integers\n    # This is equivalent to finding the number of partitions of the remaining sum\n    # into distinct parts, which is given by the pentagonal number theorem\n    j = 1\n    while (j * (3 * j - 1)) // 2 <= remaining:\n        if ((remaining - (j * (3 * j - 1)) // 2) % j == 0):\n            count += 1\n        j += 1\n\n    # Decrease the first element of the split\n    i -= 1\n\n# Print the result\nprint(count)"}
{"solution": "# Read input\nn, k = map(int, input().split())\n\n# Calculate minimum possible number of good apartments\nmin_good = max(0, k - (n - k))\n\n# Calculate maximum possible number of good apartments\nmax_good = min(k, n - 1)\n\n# Print output\nprint(min_good, max_good)"}
{"solution": "# Read the input\nn = int(input())\n\n# Initialize the number of games the winner can play\ngames = 0\n\n# While there are still players left in the tournament\nwhile n > 1:\n    # The winner can play in one more game\n    games += 1\n\n    # The number of players is halved in each round\n    n //= 2\n\n# Print the result\nprint(games)"}
{"solution": "s = input()\ncount = 0\n\n# Count the number of \"VK\" in the string\nfor i in range(len(s) - 1):\n    if s[i] == 'V' and s[i + 1] == 'K':\n        count += 1\n\n# If the string has less than 2 characters, the maximum number of \"VK\" is the current count\nif len(s) < 2:\n    print(count)\nelse:\n    # Initialize the maximum number of \"VK\" as the current count\n    max_count = count\n\n    # Iterate over the string\n    for i in range(len(s)):\n        # Create a new string by changing one character\n        new_s = s[:i] + ('K' if s[i] == 'V' else 'V') + s[i + 1:]\n\n        # Count the number of \"VK\" in the new string\n        new_count = 0\n        for j in range(len(new_s) - 1):\n            if new_s[j] == 'V' and new_s[j + 1] == 'K':\n                new_count += 1\n\n        # Update the maximum number of \"VK\"\n        max_count = max(max_count, new_count)\n\n    # Print the maximum number of \"VK\"\n    print(max_count)"}
{"solution": "import math\n\ndef min_segments(n):\n    # The first square requires 2 segments\n    if n == 1:\n        return 2\n\n    # The second square requires 1 additional segment\n    if n == 2:\n        return 3\n\n    # For n > 2, each additional square requires 2 additional segments\n    # However, every 2 squares, we can reuse a segment from the previous square\n    # So, the number of new segments needed is 2 * (n - 1) - (n // 2)\n    return 2 * n - 1 - (n // 2)\n\nn = int(input())\nprint(min_segments(n))"}
{"solution": "# Get the initial weights of Limak and Bob\na, b = map(int, input().split())\n\n# Initialize the number of years\nyears = 0\n\n# While Limak's weight is less than or equal to Bob's weight\nwhile a <= b:\n    # Triple Limak's weight\n    a *= 3\n    # Double Bob's weight\n    b *= 2\n    # Increment the number of years\n    years += 1\n\n# Print the number of years\nprint(years)"}
{"solution": "def solve(h, n):\n    visited = set()\n    current = 1\n    commands = \"LR\"\n    command_index = 0\n    while current != n:\n        visited.add(current)\n        next_node = current * 2 if commands[command_index] == 'L' else current * 2 + 1\n        if next_node in visited:\n            command_index = (command_index + 1) % 2\n            if commands[command_index] == 'L':\n                current = current // 2\n        else:\n            current = next_node\n            command_index = (command_index + 1) % 2\n    return len(visited) - 1\n\nh, n = map(int, input().split())\nprint(solve(h, n))"}
{"solution": "def find_pairs(x):\n    pairs = []\n    for n in range(1, int(x**0.5) + 1):\n        if x % n == 0:\n            m = x // n\n            if (n + m - 1) % 2 == 0 and (n + m - 1) // 2 <= min(n, m):\n                pairs.append((n, m))\n    return pairs\n\nx = int(input())\npairs = find_pairs(x)\nprint(len(pairs))\nfor pair in pairs:\n    print(*pair)"}
{"solution": "# Get the input\nn = int(input())\nmonths = list(map(int, input().split()))\n\n# Define the months with 31 days and 30 days\nmonths_31 = [1, 3, 5, 7, 8, 10, 12]\nmonths_30 = [4, 6, 9, 11]\n\n# Define a function to check if a year is leap\ndef is_leap(year):\n    if year % 4 != 0:\n        return False\n    elif year % 100 != 0:\n        return True\n    elif year % 400 != 0:\n        return False\n    return True\n\n# Define a function to check if the sequence is valid\ndef is_valid(seq):\n    # Start from January of year 1\n    year = 1\n    month = 1\n    # Iterate over the sequence\n    for days in seq:\n        # If the number of days is not valid for the current month, return False\n        if (month in months_31 and days != 31) or (month in months_30 and days != 30) or (month == 2 and (days != 28 and (not is_leap(year) or days != 29))):\n            return False\n        # Move to the next month\n        month += 1\n        # If the month is greater than 12, move to the next year and reset the month\n        if month > 12:\n            month = 1\n            year += 1\n    # If all numbers in the sequence are valid, return True\n    return True\n\n# Print the result\nprint(\"YES\" if is_valid(months) else \"NO\")"}
{"solution": "def find_fractions(n):\n    fractions = []\n    for i in range(2, n):\n        if n % i == 0:\n            a = 1\n            b = i\n            while a < b:\n                if (a / b) + sum(fractions) == (1 - (1 / n)):\n                    fractions.append(a / b)\n                    return fractions\n                elif (a / b) + sum(fractions) < (1 - (1 / n)):\n                    fractions.append(a / b)\n                    a += 1\n                else:\n                    break\n    return []\n\nn = int(input())\nfractions = find_fractions(n)\nif fractions:\n    print(\"YES\")\n    print(len(fractions))\n    for fraction in fractions:\n        print(f\"{int(fraction.numerator)} {int(fraction.denominator)}\")\nelse:\n    print(\"NO\")"}
{"solution": "def min_unattractiveness(n, a, b, h):\n    dp = [[0, 0] for _ in range(n)]\n    dp[0][0] = h[0]\n    dp[0][1] = 0\n\n    for i in range(1, n):\n        dp[i][0] = min(dp[i-1][1], dp[i-1][0] + h[i])\n        dp[i][1] = min(dp[i-1][0], dp[i-1][1] + h[i])\n\n    if dp[n-1][0] <= a and dp[n-1][1] <= b:\n        return min(dp[n-1])\n    elif dp[n-1][0] <= a:\n        return dp[n-1][0]\n    elif dp[n-1][1] <= b:\n        return dp[n-1][1]\n    else:\n        return -1\n\nn = int(input())\na, b = map(int, input().split())\nh = list(map(int, input().split()))\n\nprint(min_unattractiveness(n, a, b, h))"}
{"solution": "def find_points(n, m, k):\n    area = (n * m) / k\n    if area < 0.5:\n        return \"NO\"\n    for x1 in range(n + 1):\n        for y1 in range(m + 1):\n            for x2 in range(x1, n + 1):\n                for y2 in range(m + 1):\n                    if abs((x1 * y2 - x2 * y1) / 2) == area:\n                        for x3 in range(x2, n + 1):\n                            y3 = (area * 2 - (x3 - x1) * y1 + (x3 - x2) * y2) / (x1 - x2)\n                            if y3 >= 0 and y3 <= m and y3 == int(y3):\n                                return \"YES\\n{} {}\\n{} {}\\n{} {}\".format(x1, y1, x2, y2, x3, int(y3))\n    return \"NO\"\n\nn, m, k = map(int, input().split())\nprint(find_points(n, m, k))"}
{"solution": "n, k = map(int, input().split())\n\n# If the number of sticks is less than or equal to k, Sasha wins in one move\nif n <= k:\n    print(\"YES\")\n# If the number of sticks is more than k, and the remainder of n divided by k is 0, Sasha loses\nelif n % k == 0:\n    print(\"NO\")\n# Otherwise, Sasha wins\nelse:\n    print(\"YES\")"}
{"solution": "n = int(input())\nexercises = list(map(int, input().split()))\n\nchest = 0\nbiceps = 0\nback = 0\n\nfor i in range(n):\n    if i % 3 == 0:\n        chest += exercises[i]\n    elif i % 3 == 1:\n        biceps += exercises[i]\n    else:\n        back += exercises[i]\n\nif chest > biceps and chest > back:\n    print('chest')\nelif biceps > chest and biceps > back:\n    print('biceps')\nelse:\n    print('back')"}
{"solution": "# Read the number of lab works\nn = int(input())\n\n# Read the grades for the lab works\ngrades = list(map(int, input().split()))\n\n# Calculate the current average\navg = sum(grades) / n\n\n# Calculate the number of lab works that need to be redone\n# to raise the average to 4.5\nnum_to_redo = 0\nfor grade in grades:\n    if grade < 5 and avg < 4.5:\n        num_to_redo += 1\n        avg = (avg * n - grade + 5) / n\n\n# If the average is still less than 4.5, Vasya needs to redo more lab works\n# to raise it to 4.5\nif avg < 4.5:\n    num_to_redo += int(4.5 * n - sum(grades))\n\n# Print the result\nprint(num_to_redo)"}
{"solution": "def solve(u, v):\n    if u == 0:\n        if v == 0:\n            return [0]\n        else:\n            return [-1]\n    if u > v or (u & 1) != (v & 1):\n        return [-1]\n    if u == v:\n        return [u]\n    if u > v // 2:\n        if ((v // 2) & 1) == 1:\n            return [v // 2, v // 2, u - v // 2]\n        else:\n            return [v // 2 - (u - v // 2), u - v // 2, v // 2 - (u - v // 2)]\n    else:\n        return [u, v - 2 * u]\n\nu, v = map(int, input().split())\nresult = solve(u, v)\nif result[0] == -1:\n    print(-1)\nelse:\n    print(len(result))\n    print(' '.join(map(str, result)))"}
{"solution": "def min_digits(n):\n    count = 0\n    while n > 0:\n        if n % 10 == 9:\n            n -= 9\n        else:\n            n -= n % 10\n        count += n % 10\n    return count\n\nn = int(input())\nprint(min_digits(n))"}
{"solution": "# Get the input\nx1, y1, x2, y2 = map(int, input().split())\nx, y = map(int, input().split())\n\n# Check if it is possible to reach the treasure\nif (x2 - x1) % x == 0 and (y2 - y1) % y == 0 and (x2 - x1) // x == (y2 - y1) // y:\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "from collections import Counter\nfrom math import factorial\n\ndef count_variants(n):\n    digits = Counter(str(n))\n    total = factorial(len(str(n)))\n    for digit in digits:\n        if digit != '0':\n            total //= factorial(digits[digit])\n    return total\n\nn = int(input())\nprint(count_variants(n))"}
{"solution": "# Read the input\na = int(input())\nb = int(input())\nc = int(input())\nd = int(input())\ne = int(input())\nf = int(input())\n\n# Calculate the maximum number of suits of the first type that can be composed\nfirst_type_suits = min(a, d)\n\n# Calculate the maximum number of suits of the second type that can be composed\nsecond_type_suits = min(b, c, d)\n\n# Calculate the maximum possible cost of a set of suits\nmax_cost = first_type_suits * e + second_type_suits * f\n\n# Print the result\nprint(max_cost)"}
{"solution": "import sys\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1:\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\ndef find_solution(a, b, p, x):\n    inv = power(a, p - 2, p)\n    b = b * inv % p\n    count = 0\n    for n in range(1, x + 1):\n        if power(a, n * n, p) == b:\n            count += 1\n    return count\n\nif __name__ == \"__main__\":\n    a, b, p, x = map(int, sys.stdin.readline().split())\n    print(find_solution(a, b, p, x))"}
{"solution": "# Get the input\nk_2, k_3, k_5, k_6 = map(int, input().split())\n\n# Calculate the number of 256 that can be formed\nmin_256 = min(k_2, k_5, k_6)\n\n# Calculate the remaining 2's after forming 256\nremaining_2 = k_2 - min_256\n\n# Calculate the number of 32 that can be formed\nmin_32 = min(k_3, remaining_2)\n\n# Calculate the final sum\nfinal_sum = min_256 * 256 + min_32 * 32\n\n# Print the output\nprint(final_sum)"}
{"solution": "def bender_happy(n, x, y, c):\n    # Initialize the grid with all cells off\n    grid = [[0] * n for _ in range(n)]\n    # Switch on the initial cell\n    grid[x-1][y-1] = 1\n    # Initialize the count of switched on cells\n    count = 1\n    # Initialize the time\n    time = 0\n    # While the count of switched on cells is less than c\n    while count < c:\n        # Increment the time\n        time += 1\n        # Create a copy of the grid\n        new_grid = [row[:] for row in grid]\n        # Iterate over each cell in the grid\n        for i in range(n):\n            for j in range(n):\n                # If the cell is off and has a side-adjacent cell that is on\n                if grid[i][j] == 0 and (\n                    (i > 0 and grid[i-1][j] == 1) or\n                    (i < n-1 and grid[i+1][j] == 1) or\n                    (j > 0 and grid[i][j-1] == 1) or\n                    (j < n-1 and grid[i][j+1] == 1)\n                ):\n                    # Switch on the cell\n                    new_grid[i][j] = 1\n                    # Increment the count of switched on cells\n                    count += 1\n        # Update the grid\n        grid = new_grid\n    # Return the time\n    return time\n\n# Read the input\nn, x, y, c = map(int, input().split())\n# Print the output\nprint(bender_happy(n, x, y, c))"}
{"solution": "# Get the input\nl, r = map(int, input().split())\n\n# Calculate the maximum value of a ^ b\nmax_val = 0\nfor a in range(l, r + 1):\n    for b in range(a, r + 1):\n        max_val = max(max_val, a ^ b)\n\n# Print the result\nprint(max_val)"}
{"solution": "def min_height(n, k):\n    left, right = 0, k\n    while left < right:\n        mid = (left + right) // 2\n        if (mid * (mid + 1)) // 2 > k or (mid * (mid + 1) // 2 + mid * (n - mid)) < k:\n            left = mid + 1\n        else:\n            right = mid\n    if left * (left + 1) // 2 + left * (n - left) < k:\n        return left + 1\n    return left\n\nn, k = map(int, input().split())\nprint(min_height(n, k))"}
{"solution": "# Get the input\nx, y, z, t1, t2, t3 = map(int, input().split())\n\n# Calculate the time it takes to use the stairs\nstairs_time = abs(x - y) * t1\n\n# Calculate the time it takes to use the elevator\nelevator_time = abs(z - x) * t2 + t3 + abs(z - y) * t2 + t3\n\n# Check which option is faster\nif elevator_time <= stairs_time:\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "# Read the input\nn, m = map(int, input().split())\n\n# Calculate the optimal value of a\nif m <= (n + 1) // 2:\n    a = m\nelse:\n    a = m - 1\n\n# Print the output\nprint(a)"}
{"solution": "# Get the number of lessons\nn = int(input())\n\n# Get the schedule for the lessons\nschedule = list(map(int, input().split()))\n\n# Initialize the number of pairs Alena stays at the university\npairs_at_university = 0\n\n# Initialize the flag to check if Alena is currently at the university\nat_university = False\n\n# Iterate over the schedule\nfor i in range(n):\n    # If Alena has a pair\n    if schedule[i] == 1:\n        # Increment the number of pairs Alena stays at the university\n        pairs_at_university += 1\n        # Set the flag to True\n        at_university = True\n    # If Alena doesn't have a pair\n    else:\n        # If Alena is currently at the university\n        if at_university:\n            # Increment the number of pairs Alena stays at the university\n            pairs_at_university += 1\n        # If Alena is not currently at the university\n        else:\n            # Check if the next pair is a class\n            if i < n - 1 and schedule[i + 1] == 1:\n                # Increment the number of pairs Alena stays at the university\n                pairs_at_university += 1\n\n# Print the number of pairs Alena stays at the university\nprint(pairs_at_university)"}
{"solution": "# Read input\nn, k = map(int, input().split())\ncandies = list(map(int, input().split()))\n\n# Initialize variables\ndays = 0\nbran_candies = 0\n\n# Iterate over days\nfor i in range(n):\n    # Arya finds candies\n    arya_candies = candies[i]\n\n    # Arya gives Bran candies\n    if arya_candies >= 8:\n        bran_candies += 8\n        arya_candies -= 8\n    else:\n        bran_candies += arya_candies\n        arya_candies = 0\n\n    # Check if Bran has enough candies\n    if bran_candies >= k:\n        days = i + 1\n        break\n\n# Print result\nif days == 0:\n    print(-1)\nelse:\n    print(days)"}
{"solution": "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Initialize the total number of additional walks\ntotal = 0\n\n# Initialize the previous day's walks\nprev = k\n\n# Iterate over the days\nfor i in range(n):\n    # If the current day's walks are less than the minimum required\n    if a[i] < prev + k:\n        # Calculate the number of additional walks needed\n        additional = prev + k - a[i]\n        # Add the additional walks to the total\n        total += additional\n        # Update the current day's walks\n        a[i] += additional\n    # Update the previous day's walks\n    prev = a[i]\n\n# Print the total number of additional walks\nprint(total)\n# Print the schedule\nprint(' '.join(map(str, a)))"}
{"solution": "# Get the input for the order of the rhombus\nn = int(input())\n\n# Calculate the number of cells in the n-th order rhombus\ncells = n * n + (n - 1) * (n - 1)\n\n# Print the result\nprint(cells)"}
{"solution": "# Get the number of characters in the string\nn = int(input())\n\n# Get the string\ns = input()\n\n# Convert the string to lowercase\ns = s.lower()\n\n# Create a set of all the letters in the alphabet\nalphabet = set('abcdefghijklmnopqrstuvwxyz')\n\n# Check if all the letters in the alphabet are in the string\nif set(s) == alphabet:\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "# Get the current time and the number of minutes passed\ncurrent_time = input().split(':')\nminutes_passed = int(input())\n\n# Convert the current time to minutes\ncurrent_time_in_minutes = int(current_time[0]) * 60 + int(current_time[1])\n\n# Add the minutes passed\nnew_time_in_minutes = (current_time_in_minutes + minutes_passed) % (24 * 60)\n\n# Convert the new time to hours and minutes\nnew_time_hours = new_time_in_minutes // 60\nnew_time_minutes = new_time_in_minutes % 60\n\n# Print the new time in the format hh:mm\nprint(f'{new_time_hours:02d}:{new_time_minutes:02d}')"}
{"solution": "def check_switches(n, m, switches):\n    # Create a list to store the lamps that can be turned on by each switch\n    lamps_per_switch = [set() for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if switches[i][j] == '1':\n                lamps_per_switch[i].add(j)\n\n    # Create a set to store all the lamps that can be turned on\n    all_lamps = set(range(m))\n\n    # Check each switch to see if it can be ignored\n    for i in range(n):\n        # Create a set to store all the lamps that can be turned on without the current switch\n        lamps_without_switch = set()\n        for j in range(n):\n            if i != j:\n                lamps_without_switch |= lamps_per_switch[j]\n        # If all the lamps can be turned on without the current switch, then it can be ignored\n        if lamps_without_switch == all_lamps:\n            return \"YES\"\n\n    # If no switch can be ignored, return \"NO\"\n    return \"NO\"\n\n# Read the input\nn, m = map(int, input().split())\nswitches = [input() for _ in range(n)]\n\n# Print the output\nprint(check_switches(n, m, switches))"}
{"solution": "n = int(input())\nupper_sum = 0\nlower_sum = 0\nswaps = 0\n\nfor _ in range(n):\n    x, y = map(int, input().split())\n    upper_sum += x\n    lower_sum += y\n    if x % 2 != y % 2:\n        swaps += 1\n\nif upper_sum % 2 == 0 and lower_sum % 2 == 0:\n    print(0)\nelif upper_sum % 2 != 0 and lower_sum % 2 != 0:\n    if swaps > 0:\n        print(1)\n    else:\n        print(-1)\nelse:\n    print(-1)"}
{"solution": "import math\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    sqrt_n = math.isqrt(n)\n    for i in range(3, sqrt_n + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\nt = int(input())\nfor _ in range(t):\n    a, b = map(int, input().split())\n    area = a**2 - b**2\n    if is_prime(area):\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "n = int(input())\npoints = [list(map(int, input().split())) for _ in range(n)]\n\n# Check the sign of the x-coordinate of the first point\nfirst_sign = points[0][0] > 0\n\n# Iterate over the rest of the points\nfor i in range(1, n):\n    # If the sign of the x-coordinate of the current point is different from the first point,\n    # then there is a point that can be removed to make the remaining points on one side of the OY axis\n    if (points[i][0] > 0) != first_sign:\n        print(\"Yes\")\n        exit()\n\n# If all points have the same sign of the x-coordinate, then there is no point that can be removed\nprint(\"No\")"}
{"solution": "import math\n\n# Get the two input numbers\nA, B = map(int, input().split())\n\n# Calculate the factorials of A and B\nA_factorial = math.factorial(A)\nB_factorial = math.factorial(B)\n\n# Calculate the greatest common divisor of A! and B!\ngcd = math.gcd(A_factorial, B_factorial)\n\n# Print the result\nprint(gcd)"}
{"solution": "def is_composite(n):\n    if n < 4:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False\n\ndef find_composites(n):\n    a = n + 4\n    while not is_composite(a):\n        a += 1\n    return a, a - n\n\nn = int(input())\na, b = find_composites(n)\nprint(a, b)"}
{"solution": "import sys\n\ndef max_score(n, m, p, edges):\n    # Create a graph with n vertices\n    graph = [[] for _ in range(n+1)]\n\n    # Add edges to the graph\n    for a, b, c in edges:\n        graph[a].append((b, c))\n\n    # Initialize the dp array with -1\n    dp = [-1] * (n+1)\n    dp[1] = 0\n\n    # Calculate the maximum score for each vertex\n    for i in range(1, n+1):\n        for j, c in graph[i]:\n            dp[j] = max(dp[j], dp[i] + c)\n\n    # Calculate the maximum score after pressing the button\n    max_score = -1\n    for i in range(1, n+1):\n        max_score = max(max_score, dp[i] - (i-1) * p)\n\n    return max_score\n\n# Read input from standard input\nn, m, p = map(int, sys.stdin.readline().split())\nedges = [tuple(map(int, sys.stdin.readline().split())) for _ in range(m)]\n\n# Calculate and print the maximum score\nresult = max_score(n, m, p, edges)\nprint(result)"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef min_palindrome_cost():\n    n = int(sys.stdin.readline())\n    strings = []\n    costs = []\n    for _ in range(n):\n        s, c = sys.stdin.readline().split()\n        strings.append(s)\n        costs.append(int(c))\n\n    dp = [[float('inf')] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = costs[i]\n\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if strings[i] == strings[j][::-1]:\n                dp[i][j] = min(dp[i][j], costs[i] + costs[j])\n            for k in range(i, j):\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j])\n\n    min_cost = min(dp[i][n - 1] for i in range(n) if strings[i] == strings[n - 1][::-1])\n    return min_cost if min_cost != float('inf') else -1\n\nprint(min_palindrome_cost())"}
{"solution": "def max_xor_sum(n, k):\n    if k == n:\n        return n if n % 4 < 2 else n ^ (n - 1)\n    else:\n        return n if k % 4 < 2 else n ^ (k - 1)\n\nn, k = map(int, input().split())\nprint(max_xor_sum(n, k))"}
{"solution": "n = int(input())\npoints = [list(map(int, input().split())) for _ in range(n)]\n\n# Sort points by x-coordinate\npoints.sort(key=lambda x: x[0])\n\n# Initialize minimum distance\nmin_dist = float('inf')\n\n# Iterate over all possible y-coordinates for the base of the triangle\nfor y in range(1, 2 * 10**9 + 1):\n    # Initialize left and right endpoints of the triangle base\n    left, right = points[0][0], points[-1][0]\n\n    # Iterate over all points\n    for x, y_point in points:\n        # If the point is above the base, update the left endpoint\n        if y_point > y:\n            left = max(left, x)\n        # If the point is below the base, update the right endpoint\n        elif y_point < y:\n            right = min(right, x)\n\n    # Update the minimum distance\n    min_dist = min(min_dist, right - left)\n\nprint(min_dist)"}
{"solution": "def max_nineteens(s):\n    # count the number of each character\n    count = {'n': s.count('n'), 'i': s.count('i'), 'e': s.count('e'), 't': s.count('t')}\n\n    # the number of 'nineteen' is limited by the number of 'n' and 'e'\n    count['nineteen'] = min(count['n'] // 3, count['e'] // 3)\n\n    # the number of 'nineteen' is also limited by the number of 'i' and 't'\n    count['nineteen'] = min(count['nineteen'], count['i'] // 2, count['t'])\n\n    return count['nineteen']\n\n# get the input string\ns = input()\n\n# print the maximum number of \"nineteen\"s that she can get in her string\nprint(max_nineteens(s))"}
{"solution": "import math\n\ndef find_highest_branch(p, y):\n    for i in range(y, 1, -1):\n        for j in range(2, min(i, p) + 1):\n            if i % j == 0:\n                break\n        else:\n            return i\n    return -1\n\np, y = map(int, input().split())\nprint(find_highest_branch(p, y))"}
{"solution": "# Get the input\nn, m, k = map(int, input().split())\nhouses = list(map(int, input().split()))\n\n# Initialize the minimum distance to a large number\nmin_distance = float('inf')\n\n# Iterate over all houses\nfor i in range(n):\n    # If the house is affordable\n    if houses[i] <= k:\n        # Calculate the distance to the girl's house\n        distance = abs(i - m + 1) * 10\n        # Update the minimum distance\n        min_distance = min(min_distance, distance)\n\n# Print the minimum distance\nprint(min_distance)"}
{"solution": "def transpose_square_submatrix(matrix, x, y, k):\n    for i in range(k):\n        for j in range(i+1, k):\n            matrix[x+i][y+j], matrix[x+j][y+i] = matrix[x+j][y+i], matrix[x+i][y+j]\n\ndef transform_matrix(A, B):\n    n, m = len(A), len(A[0])\n    for k in range(min(n, m), 0, -1):\n        for i in range(n-k+1):\n            for j in range(m-k+1):\n                transpose_square_submatrix(A, i, j, k)\n                if A == B:\n                    return True\n                transpose_square_submatrix(A, i, j, k)\n    return False\n\nn, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\nB = [list(map(int, input().split())) for _ in range(n)]\n\nprint(\"YES\" if transform_matrix(A, B) else \"NO\")"}
{"solution": "# Get the input strings\na = input()\nb = input()\n\n# If the strings are equal, there is no uncommon subsequence\nif a == b:\n    print(-1)\n# Otherwise, the longest uncommon subsequence is the length of the longest string\nelse:\n    print(max(len(a), len(b)))"}
{"solution": "# Get the input\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Calculate the first scream times for Rick and Morty\nrick_first_scream = b\nmorty_first_scream = d\n\n# If Rick and Morty scream at the same time in the first attempt, print the time\nif rick_first_scream == morty_first_scream:\n    print(rick_first_scream)\nelse:\n    # Find the first time they scream at the same time\n    while rick_first_scream != morty_first_scream:\n        # If Rick's next scream time is less than Morty's next scream time, update Rick's scream time\n        if rick_first_scream + a < morty_first_scream:\n            rick_first_scream += a\n        # If Morty's next scream time is less than Rick's next scream time, update Morty's scream time\n        elif morty_first_scream + c < rick_first_scream:\n            morty_first_scream += c\n        # If they don't scream at the same time in the next attempt and their scream times are equal, they will never scream at the same time\n        else:\n            print(-1)\n            break\n    # If they scream at the same time, print the time\n    else:\n        print(rick_first_scream)"}
{"solution": "n = int(input())\n\n# If n is not a multiple of 3, we can always split it into three numbers\n# such that none of them is a multiple of 3\nif n % 3 != 0:\n    print(1, 1, n - 2)\nelse:\n    # If n is a multiple of 3, we need to find a different approach\n    # We can always split it into three numbers as 1, 4, and the rest\n    print(1, 4, n - 5)"}
{"solution": "def count_valid_squares(n, a, b, c, d):\n    count = 0\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i + j + a + b == i + j + c + d == i + a + j + b == a + b + c + d:\n                count += 1\n    return count\n\nn, a, b, c, d = map(int, input().split())\nprint(count_valid_squares(n, a, b, c, d))"}
{"solution": "# Get input\nw, h = map(int, input().split())\nu1, d1 = map(int, input().split())\nu2, d2 = map(int, input().split())\n\n# Simulate the snowball's movement\nwhile h > 0:\n    w += h\n    if h == d1:\n        w = max(0, w - u1)\n    if h == d2:\n        w = max(0, w - u2)\n    h -= 1\n\n# Print the final weight\nprint(w)"}
{"solution": "# Get the input\nm = int(input())\nc = list(map(int, input().split()))\nx, y = map(int, input().split())\n\n# Initialize the variables\nbeginners = 0\nintermediates = 0\nk = 0\n\n# Iterate over the scores\nfor i in range(m):\n    # If adding the current group to the beginners group doesn't exceed the limit\n    if beginners + c[i] <= y:\n        beginners += c[i]\n    # If adding the current group to the intermediates group doesn't exceed the limit\n    elif intermediates + c[i] <= y:\n        intermediates += c[i]\n        k = i + 1\n    # If neither of the above conditions is met, it's impossible to split the groups\n    else:\n        k = 0\n        break\n\n# If the size of either group is less than x, it's impossible to split the groups\nif beginners < x or intermediates < x:\n    k = 0\n\n# Print the result\nprint(k)"}
{"solution": "n = int(input())\nk = int(input())\nA = int(input())\nB = int(input())\n\ndef min_coins(n, k, A, B):\n    if n == 1:\n        return 0\n    if n % k == 0:\n        return min(A + min_coins(n - 1, k, A, B), B + min_coins(n // k, k, A, B))\n    else:\n        return A + min_coins(n - 1, k, A, B)\n\nprint(min_coins(n, k, A, B))"}
{"solution": "import math\n\ndef min_operations(n):\n    operations = 0\n    while n % 2 == 0:\n        n = math.isqrt(n)\n        operations += 1\n    while n % 3 == 0:\n        n = n // 3\n        operations += 1\n    while n % 5 == 0:\n        n = n // 5\n        operations += 1\n    while n % 7 == 0:\n        n = n // 7\n        operations += 1\n    if n > 1:\n        operations += 1\n        n = 1\n    return n, operations\n\nn = int(input())\nmin_n, min_operations = min_operations(n)\nprint(min_n, min_operations)"}
{"solution": "# Get input\nn, k = map(int, input().split())\nr, s, p = map(int, input().split())\nt = input()\n\n# Initialize score and last_played list\nscore = 0\nlast_played = [-1] * 3\n\n# Iterate over each round\nfor i in range(n):\n    # Get machine's play\n    machine_play = t[i]\n\n    # If it's within the first k rounds, play optimally\n    if i < k:\n        if machine_play == 'r':\n            score += p\n            last_played[0] = i\n        elif machine_play == 's':\n            score += r\n            last_played[1] = i\n        else:\n            score += s\n            last_played[2] = i\n    # If it's after the first k rounds, play optimally but avoid the hand used k rounds ago\n    else:\n        if machine_play == 'r':\n            if last_played[0] < i - k:\n                score += p\n                last_played[0] = i\n        elif machine_play == 's':\n            if last_played[1] < i - k:\n                score += r\n                last_played[1] = i\n        else:\n            if last_played[2] < i - k:\n                score += s\n                last_played[2] = i\n\n# Print the maximum total score\nprint(score)"}
{"solution": "# Get the input\na, b, c = map(int, input().split())\n\n# Calculate the maximum possible length\nmax_length = 2 * min(a, b) + 2 * c\nif a != b:\n    max_length += 1\n\n# Print the result\nprint(max_length)"}
{"solution": "n, k, p, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Calculate the sum of marks Vova already has\ncurrent_sum = sum(marks)\n\n# Sort the marks in ascending order\nmarks.sort()\n\n# Calculate the median of marks Vova already has\nmedian = marks[k // 2]\n\n# Calculate the minimum mark Vova needs to get for the remaining tests\n# to ensure that the sum of marks does not exceed x\nmin_mark = max(1, (x - current_sum) // (n - k))\n\n# Check if it's possible to achieve the desired result\nif min_mark > p or (min_mark == y and k < n - 1):\n    print(-1)\nelse:\n    # Calculate the number of remaining tests with the minimum mark\n    num_min_marks = (x - current_sum) // min_mark\n\n    # Calculate the number of remaining tests with the maximum mark\n    num_max_marks = n - k - num_min_marks\n\n    # Print the marks Vova should get for the remaining tests\n    print(*([min_mark] * num_min_marks + [p] * num_max_marks))"}
{"solution": "def is_berlanese(word):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    prev_char = word[0]\n    for char in word[1:]:\n        if prev_char not in vowels and prev_char != 'n':\n            if char not in vowels:\n                return False\n        prev_char = char\n    if prev_char not in vowels and prev_char != 'n':\n        return False\n    return True\n\nword = input()\nif is_berlanese(word):\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "import sys\nfrom typing import List\n\nreadline = sys.stdin.readline\n\ndef solve():\n    num_vertices, num_edges = map(int, readline().split())\n    graph = [[] for _ in range(num_vertices)]\n    for _ in range(num_edges):\n        vertex1, vertex2 = map(int, readline().split())\n        vertex1 -= 1\n        vertex2 -= 1\n        graph[vertex1].append(vertex2)\n        graph[vertex2].append(vertex1)\n\n    def dfs(vertex: int, parent: int, color: int) -> bool:\n        colors[vertex] = color\n        for neighbor in graph[vertex]:\n            if neighbor == parent:\n                continue\n            if colors[neighbor] != -1:\n                if colors[neighbor] != color:\n                    return False\n                continue\n            if not dfs(neighbor, vertex, color ^ 1):\n                return False\n        return True\n\n    colors = [-1] * num_vertices\n    for vertex in range(num_vertices):\n        if colors[vertex] != -1:\n            continue\n        if not dfs(vertex, -1, 0):\n            print(0)\n            return\n\n    color_count = [0] * 2\n    for color in colors:\n        color_count[color] += 1\n\n    if color_count[0] > color_count[1]:\n        color_count[0], color_count[1] = color_count[1], color_count[0]\n\n    print(color_count[0] + (color_count[1] - color_count[0]) // 2)\n\nsolve()"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip().split()\n\ndef main():\n    n, m = map(int, read_input())\n    a = list(map(int, read_input()))\n    b = set(map(int, read_input()))\n\n    dp = [0] * (n + 1)\n    dp[0] = 0\n\n    for i in range(1, n + 1):\n        dp[i] = dp[i - 1] + a[i - 1]\n        if i in b:\n            for j in range(i - 1, -1, -1):\n                dp[i] = max(dp[i], dp[j] + a[i - 1] * 2)\n\n    print(dp[n])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Input\nm = list(map(int, input().split()))\nw = list(map(int, input().split()))\nh = list(map(int, input().split()))\n\n# Problem points\npoints = [500, 1000, 1500, 2000, 2500]\n\n# Calculate score\nscore = 0\nfor i in range(5):\n    score += max(0.3 * points[i], (1 - m[i] / 250) * points[i] - 50 * w[i])\n\n# Add hack points\nscore += h[0] * 100 - h[1] * 50\n\n# Print score\nprint(int(score))"}
{"solution": "MOD = 998244353\n\ndef solve(n, m, L, R):\n    if L == R:\n        return 1\n    if L + 1 == R:\n        return (pow(2, n * m, MOD) - 2 * pow(2, (n - 1) * m, MOD) * pow(2, n * (m - 1), MOD) % MOD + MOD) % MOD\n    if (R - L) % 2 == 1:\n        return 0\n    return (pow(2, n * m, MOD) - 2 * pow(2, (n - 1) * m, MOD) * pow(2, n * (m - 1), MOD) % MOD + MOD) % MOD\n\nn, m, L, R = map(int, input().split())\nprint(solve(n, m, L, R))"}
{"solution": "def check_possible(matrix1, matrix2, n, m):\n    for i in range(n):\n        for j in range(m):\n            if (i > 0 and matrix1[i][j] <= matrix1[i-1][j]) or (j > 0 and matrix1[i][j] <= matrix1[i][j-1]):\n                if (i > 0 and matrix2[i][j] <= matrix2[i-1][j]) or (j > 0 and matrix2[i][j] <= matrix2[i][j-1]):\n                    return False\n            elif (i > 0 and matrix2[i][j] <= matrix2[i-1][j]) or (j > 0 and matrix2[i][j] <= matrix2[i][j-1]):\n                if (i > 0 and matrix1[i][j] <= matrix1[i-1][j]) or (j > 0 and matrix1[i][j] <= matrix1[i][j-1]):\n                    return False\n    return True\n\nn, m = map(int, input().split())\nmatrix1 = [list(map(int, input().split())) for _ in range(n)]\nmatrix2 = [list(map(int, input().split())) for _ in range(n)]\n\nprint(\"Possible\" if check_possible(matrix1, matrix2, n, m) else \"Impossible\")"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\na.sort(reverse=True)\n\nmax_length = 0\nfor i in range(n):\n    if a[i] > i:\n        max_length += i + 1\n    else:\n        max_length += a[i]\n\nprint(max_length)"}
{"solution": "n, k = map(int, input().split())\nproblems = list(map(int, input().split()))\nproblems.sort()\n\nextra_problems = 0\nfor problem in problems:\n    if problem > k:\n        if k * 2 < problem:\n            extra_problems += 1\n            k = problem\n        else:\n            k = problem\n\nprint(extra_problems)"}
{"solution": "def distribute_diplomas(n, min_1, max_1, min_2, max_2, min_3, max_3):\n    # Start from the maximum possible number of diplomas of the first degree\n    for first_degree in range(max_1, min_1 - 1, -1):\n        # Calculate the remaining number of diplomas to distribute\n        remaining = n - first_degree\n        # Check if it's possible to distribute the remaining diplomas within the given limits\n        if min_2 <= remaining - max_3 <= max_2:\n            # Calculate the number of diplomas of the second degree\n            second_degree = min(remaining - max_3, max_2)\n            # Calculate the number of diplomas of the third degree\n            third_degree = remaining - second_degree\n            return first_degree, second_degree, third_degree\n    # If no solution is found, return -1 for all degrees\n    return -1, -1, -1\n\n# Read the input\nn = int(input())\nmin_1, max_1 = map(int, input().split())\nmin_2, max_2 = map(int, input().split())\nmin_3, max_3 = map(int, input().split())\n\n# Distribute the diplomas\nfirst_degree, second_degree, third_degree = distribute_diplomas(n, min_1, max_1, min_2, max_2, min_3, max_3)\n\n# Print the output\nprint(first_degree, second_degree, third_degree)"}
{"solution": "# Get the number of days Vitya was watching the moon\nn = int(input())\n\n# Get Vitya's records\nrecords = list(map(int, input().split()))\n\n# Define the moon cycle\nmoon_cycle = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n\n# Check if the records match the end of the moon cycle\nif records == moon_cycle[-n:]:\n    # If the records match the end of the moon cycle, the size will increase\n    print(\"UP\")\n# Check if the records match the beginning of the moon cycle\nelif records == moon_cycle[:n]:\n    # If the records match the beginning of the moon cycle, the size will decrease\n    print(\"DOWN\")\nelse:\n    # If the records don't match either the end or the beginning of the moon cycle, it's impossible to determine\n    print(\"-1\")"}
{"solution": "def is_transformable(s, t):\n    vowels = set('aeiou')\n    if len(s) != len(t):\n        return False\n    for char_s, char_t in zip(s, t):\n        if char_s == char_t:\n            continue\n        if (char_s in vowels) != (char_t in vowels):\n            return False\n    return True\n\ns = input()\nt = input()\n\nif is_transformable(s, t):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "board = [input() for _ in range(8)]\n\n# Check if any white pawn is in the second row\nif any('W' in row for row in board[:2]):\n    print('A')\n# Check if any black pawn is in the seventh row\nelif any('B' in row for row in board[6:]):\n    print('B')\n# Check if any white pawn is in the third row and any black pawn is in the sixth row\nelif any('W' in board[2] for i in range(8)) and any('B' in board[5] for i in range(8)):\n    print('B')\n# If none of the above conditions are met, then player A will win\nelse:\n    print('A')"}
{"solution": "def max_length(A, B):\n    n, m = len(A), len(B)\n    i, j = 0, 0\n    sum_A, sum_B = 0, 0\n    max_len = 0\n\n    while i < n and j < m:\n        sum_A += A[i]\n        sum_B += B[j]\n\n        if sum_A == sum_B:\n            max_len = i + 1\n            sum_A, sum_B = 0, 0\n            i += 1\n            j += 1\n        elif sum_A > sum_B:\n            j += 1\n        else:\n            i += 1\n\n    if sum_A == sum_B:\n        max_len = max(max_len, i)\n\n    return max_len if sum_A == 0 and sum_B == 0 else -1\n\nn = int(input())\nA = list(map(int, input().split()))\nm = int(input())\nB = list(map(int, input().split()))\n\nprint(max_length(A, B))"}
{"solution": "names = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\nproblem_name = input()\ncount = 0\n\nfor name in names:\n    count += problem_name.count(name)\n\nif count == 1:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import math\n\ndef sieve_of_eratosthenes(n):\n    primes = [True for i in range(n+1)]\n    p = 2\n    while(p * p <= n):\n        if (primes[p] == True):\n            for i in range(p * p, n+1, p):\n                primes[i] = False\n        p += 1\n    return primes\n\ndef count_primes(a, b, k):\n    primes = sieve_of_eratosthenes(b)\n    primes_count = [0] * (b - a + 2)\n    for i in range(a, b + 1):\n        if primes[i]:\n            primes_count[i - a] = 1\n    for i in range(a, b):\n        primes_count[i - a] += primes_count[i - a - 1]\n    for l in range(b - a + 1, 0, -1):\n        for i in range(b - a + 1 - l + 1):\n            if primes_count[i + l] - primes_count[i] >= k:\n                return l\n    return -1\n\na, b, k = map(int, input().split())\nprint(count_primes(a, b, k))"}
{"solution": "def calculate_min_distance(a, h, w):\n    # Check if it's possible to put at least one photo\n    if a > h or a > w:\n        return -1\n\n    # Check if it's possible to fill the wall with photos\n    if h % a != 0 or w % a != 0:\n        return -1\n\n    # Calculate the number of photos that can be put on the wall\n    num_photos_h = h // a\n    num_photos_w = w // a\n\n    # Calculate the minimum distance\n    min_distance = min((h - num_photos_h * a) / (num_photos_h + 1), (w - num_photos_w * a) / (num_photos_w + 1))\n\n    return min_distance\n\n# Read the input\na, h, w = map(int, input().split())\n\n# Calculate the minimum distance\nresult = calculate_min_distance(a, h, w)\n\n# Print the result\nprint(result)"}
{"solution": "# Read the number of chapters\nn = int(input())\n\n# Initialize a list to store the chapters\nchapters = []\n\n# Read the chapters\nfor _ in range(n):\n    l, r = map(int, input().split())\n    chapters.append((l, r))\n\n# Read the marked page\nk = int(input())\n\n# Initialize a counter for unread chapters\nunread_chapters = 0\n\n# Iterate over the chapters\nfor l, r in chapters:\n    # If the marked page is after the current chapter, increment the counter\n    if k <= l:\n        unread_chapters += 1\n    # If the marked page is inside the current chapter, break the loop\n    elif l < k <= r:\n        unread_chapters += 1\n        break\n\n# Print the number of unread chapters\nprint(unread_chapters)"}
{"solution": "def check_codeforces(s):\n    codeforces = \"CODEFORCES\"\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            new_s = s[:i] + s[j+1:]\n            if codeforces in new_s:\n                return \"YES\"\n    return \"NO\"\n\ns = input()\nprint(check_codeforces(s))"}
{"solution": "n = int(input())\n\n# Initialize the minimum weight as infinity\nmin_weight = float('inf')\n\n# Iterate over all possible first vertices of the first triangle\nfor i in range(1, n - 1):\n    # Calculate the weight of the first triangle\n    weight_1 = i * (i + 1) * (i + 2)\n\n    # Calculate the weight of the second triangle\n    weight_2 = i * (i + 2) * (i + 3 if i + 3 <= n else i + 3 - n)\n\n    # Update the minimum weight\n    min_weight = min(min_weight, weight_1 + weight_2)\n\n# Print the minimum weight\nprint(min_weight)"}
{"solution": "# Get the input\nn = int(input())\n\n# Initialize the count of digits\ndigits = 0\n\n# Loop through the numbers from 1 to n\nfor i in range(1, n + 1):\n    # Add the number of digits in the current number to the total count\n    digits += len(str(i))\n\n# Print the total count of digits\nprint(digits)"}
{"solution": "# Read input\nn, A = map(int, input().split())\ncars = list(map(int, input().split()))\n\n# Initialize count of Alice's color and a dictionary to store count of other colors\ncount_A = 0\ncount_other = {}\n\n# Iterate over cars\nfor car in cars:\n    # If car is of Alice's color, increment count_A\n    if car == A:\n        count_A += 1\n    # If car is not of Alice's color, increment its count in count_other\n    else:\n        if car not in count_other:\n            count_other[car] = 1\n        else:\n            count_other[car] += 1\n\n# Initialize Bob's color as -1\nB = -1\n\n# Iterate over colors in count_other\nfor color, count in count_other.items():\n    # If count of color is greater than or equal to count_A, update Bob's color\n    if count >= count_A:\n        B = color\n\n# Print Bob's color\nprint(B)"}
{"solution": "# Get the input\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculate the total length of the segments\ntotal_length = sum(a)\n\n# Calculate the total length of the gaps between segments\ngap_length = n - 1\n\n# Check if the total length of the segments and gaps is equal to the length of the crossword\nif total_length + gap_length == x:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n, S = map(int, input().split())\ncoins = 0\nwhile S > 0:\n    if n <= S:\n        S -= n\n    else:\n        n -= 1\n    coins += 1\nprint(coins)"}
{"solution": "from collections import Counter\n\ndef min_changes_palindrome(s):\n    counter = Counter(s)\n    odd_chars = [char for char, count in counter.items() if count % 2]\n    if len(odd_chars) > 1:\n        odd_chars.sort()\n        odd_chars = odd_chars[:-1]\n    for char in odd_chars:\n        counter[char] -= 1\n    left, right = [], []\n    for char in sorted(counter.keys()):\n        left.extend(char * (counter[char] // 2))\n        right.extend(char * (counter[char] // 2))\n    if odd_chars:\n        middle = odd_chars[0]\n    else:\n        middle = ''\n    return ''.join(left + middle + right[::-1])\n\ns = input()\nprint(min_changes_palindrome(s))"}
{"solution": "# Define the weights of the chess pieces\nweights = {'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'P': 1, 'q': -9, 'r': -5, 'b': -3, 'n': -3, 'p': -1}\n\n# Initialize the total weight of the white and black pieces\nwhite_weight = 0\nblack_weight = 0\n\n# Read the input\nfor _ in range(8):\n    row = input()\n    # Calculate the total weight of the white and black pieces in the row\n    for piece in row:\n        if piece != '.':\n            if piece.isupper():\n                white_weight += weights[piece]\n            else:\n                black_weight += weights[piece]\n\n# Print the result\nif white_weight > black_weight:\n    print('White')\nelif white_weight < black_weight:\n    print('Black')\nelse:\n    print('Draw')"}
{"solution": "import sys\n\ndef min_turns(n, m, s):\n    # Initialize dp array to store minimum number of turns required to reach each square\n    dp = [float('inf')] * (n + 1)\n    # Initialize seq array to store the sequence of numbers that leads to each square\n    seq = [[] for _ in range(n + 1)]\n\n    # Base case: Takahashi starts at square 0\n    dp[0] = 0\n\n    # Iterate through each square\n    for i in range(n):\n        # If the current square is a game over square, skip it\n        if s[i] == '1':\n            continue\n\n        # Iterate through each possible number that can come up on the roulette\n        for j in range(1, m + 1):\n            # If moving to the next square is within the board and not a game over square\n            if i + j <= n and s[i + j] == '0':\n                # If moving to the next square requires fewer turns than the current minimum\n                if dp[i] + 1 < dp[i + j]:\n                    # Update the minimum number of turns required to reach the next square\n                    dp[i + j] = dp[i] + 1\n                    # Update the sequence of numbers that leads to the next square\n                    seq[i + j] = seq[i] + [j]\n\n    # If Takahashi cannot reach the final square, return -1\n    if dp[n] == float('inf'):\n        return -1\n\n    # Return the lexicographically smallest sequence among the shortest sequences\n    return ' '.join(map(str, seq[n]))\n\n# Read input from standard input\nn, m = map(int, sys.stdin.readline().split())\ns = sys.stdin.readline().strip()\n\n# Print the result\nprint(min_turns(n, m, s))"}
{"solution": "import sys\n\ndef main():\n    K = int(sys.stdin.readline())\n    X, Y = map(int, sys.stdin.readline().split())\n\n    # If K is odd, the parity of X and Y should be the same\n    if K % 2 != 0 and X % 2 != Y % 2:\n        print(-1)\n        return\n\n    # Calculate the number of steps needed\n    steps = 0\n    if 2 * K <= abs(X) + abs(Y):\n        steps = (abs(X) + abs(Y) + K - 1) // (2 * K)\n    else:\n        steps = 2\n\n    # Calculate the path\n    path = []\n    for i in range(steps, 0, -1):\n        path.append((X * i, Y * i))\n        X, Y = X * (i - 1), Y * (i - 1)\n\n    # Print the result\n    print(steps)\n    for x, y in reversed(path):\n        print(x, y)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef find_n(m):\n    # Iterate over possible values of n\n    for n in range(1, int(math.sqrt(m)) + 1):\n        # Check if n is a divisor of m\n        if m % n == 0:\n            # Calculate the quotient\n            q = m // n\n            # Check if q is a power of n - 1\n            while q % (n - 1) == 0:\n                q //= (n - 1)\n            # If q is 1, then n is a valid value\n            if q == 1:\n                return n\n    # If no valid value of n is found, return -1\n    return -1\n\n# Read the input\nm = int(input())\n# Find the smallest possible value of n\nn = find_n(m)\n# Print the output\nprint(n)"}
{"solution": "import math\n\ndef circle_intersection_area(x1, y1, r1, x2, y2, r2):\n    d = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n\n    if d > r1 + r2:\n        return 0\n    elif d < abs(r1 - r2):\n        return min(math.pi * r1**2, math.pi * r2**2)\n    else:\n        a = (r1**2 - r2**2 + d**2) / (2 * d)\n        h = math.sqrt(r1**2 - a**2)\n        theta1 = 2 * math.asin(h / r1)\n        theta2 = 2 * math.asin(h / r2)\n        A1 = 0.5 * r1**2 * (theta1 - math.sin(theta1))\n        A2 = 0.5 * r2**2 * (theta2 - math.sin(theta2))\n        return A1 + A2\n\nx1, y1, r1 = map(int, input().split())\nx2, y2, r2 = map(int, input().split())\n\nprint(circle_intersection_area(x1, y1, r1, x2, y2, r2))"}
{"solution": "# Get the input\nv = int(input())\n\n# If v is 1, then the minimum value is 1\nif v == 1:\n    print(1)\n# If v is 2, then the minimum value is 1\nelif v == 2:\n    print(1)\n# If v is 3, then the minimum value is 1\nelif v == 3:\n    print(1)\n# If v is greater than 3 and even, then the minimum value is 1\nelif v > 3 and v % 2 == 0:\n    print(1)\n# If v is greater than 3 and odd, then the minimum value is 2\nelse:\n    print(2)"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef read_input():\n    return sys.stdin.readline\n\ndef main():\n    n = int(read_input())\n    parents = list(map(int, read_input().split()))\n    values = list(map(int, read_input().split()))\n\n    graph = defaultdict(list)\n    for i in range(2, n + 1):\n        graph[parents[i - 1]].append(i)\n\n    def dfs(node):\n        if not graph[node]:\n            return values[node - 1]\n        else:\n            children_values = [dfs(child) for child in graph[node]]\n            total_children_value = sum(children_values)\n            max_child_value = max(children_values) if children_values else 0\n            return values[node - 1] + max(0, total_children_value - max_child_value)\n\n    print(dfs(1))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n = int(input())\nS = input()\nT = input()\n\n# Initialize the count of possible words\ncount = 0\n\n# Check if S can be obtained from T by deleting one character\nfor i in range(n):\n    if S == T[:i] + T[i+1:]:\n        count += 1\n        break\n\n# Check if T can be obtained from S by deleting one character\nfor i in range(n):\n    if T == S[:i] + S[i+1:]:\n        count += 1\n        break\n\nprint(count)"}
{"solution": "import sys\nimport heapq\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef dfs(node, parent, graph, values):\n    max_child = 0\n    for child in graph[node]:\n        if child != parent:\n            child_max = dfs(child, node, graph, values)\n            max_child = max(max_child, child_max)\n    if max_child < values[node]:\n        return values[node]\n    else:\n        return max_child + 1\n\ndef main():\n    n = int(read_input())\n    values = list(map(int, read_input().split()))\n    graph = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        u, v = map(int, read_input().split())\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n\n    root = dfs(0, -1, graph, values)\n    queue = [(values[i], i) for i in range(n) if values[i] == root]\n    heapq.heapify(queue)\n    visited = [False] * n\n\n    while queue:\n        value, node = heapq.heappop(queue)\n        if visited[node]:\n            continue\n        visited[node] = True\n        for child in graph[node]:\n            if not visited[child]:\n                values[child] += 1\n                if values[child] > root:\n                    heapq.heappush(queue, (values[child], child))\n        root = value\n\n    print(value)\n\nif __name__ == '__main__':\n    main()"}
{"solution": "# Get the input\nn, m = map(int, input().split())\n\n# Calculate the maximum possible number of groups\nif m == 0:\n    # If no cats have left, there is 1 group\n    groups = 1\nelif m == n:\n    # If all cats have left, there are 0 groups\n    groups = 0\nelif m == 1:\n    # If one cat has left, there are 2 groups\n    groups = 2\nelse:\n    # If more than one cat has left, there are at most 3 groups\n    groups = 3\n\n# Print the result\nprint(groups)"}
{"solution": "# Get the input\nk, r = map(int, input().split())\n\n# Initialize the number of shovels\nshovels = 1\n\n# Keep buying shovels until he can pay without any change\nwhile (shovels * k) % 10 != r:\n    shovels += 1\n\n# Print the result\nprint(shovels)"}
{"solution": "def is_rectangle_possible(grid):\n    n = len(grid)\n    m = len(grid[0])\n    x_count = sum(row.count('X') for row in grid)\n\n    if x_count % 2 != 0:\n        return False\n\n    half_x_count = x_count // 2\n    current_x_count = 0\n    start_row = -1\n\n    for i in range(n):\n        current_x_count += grid[i].count('X')\n        if current_x_count == half_x_count:\n            start_row = i\n            break\n\n    if start_row == -1:\n        return False\n\n    for i in range(start_row + 1, n):\n        if grid[i] != grid[start_row]:\n            return False\n\n    return True\n\nn, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\nprint(\"YES\" if is_rectangle_possible(grid) else \"NO\")"}
{"solution": "# Read the coordinates of the three points\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\nx3, y3 = map(int, input().split())\n\n# Check if the points are collinear\nif (x1 == x2 == x3) or (y1 == y2 == y3):\n    print(1)\n# Check if two points have the same x or y coordinate\nelif (x1 == x2) or (x1 == x3) or (x2 == x3) or (y1 == y2) or (y1 == y3) or (y2 == y3):\n    print(2)\n# If none of the above conditions are met, then the minimum number of segments is 3\nelse:\n    print(3)"}
{"solution": "def create_graph(k):\n    if k % 2 != 0:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    n = 2 * k\n    m = k * k\n    print(n, m)\n\n    # Create a cycle of 2k vertices\n    for i in range(1, n):\n        print(i, i + 1)\n    print(n, 1)\n\n    # Add k edges to create a bridge\n    for i in range(1, k + 1):\n        print(i, i + k)\n\nk = int(input())\ncreate_graph(k)"}
{"solution": "def count_occurrences(s, t, l, r):\n    substring = s[l-1:r]\n    count = 0\n    for i in range(len(substring) - len(t) + 1):\n        if substring[i:i+len(t)] == t:\n            count += 1\n    return count\n\nn, m, q = map(int, input().split())\ns = input()\nt = input()\n\nfor _ in range(q):\n    l, r = map(int, input().split())\n    print(count_occurrences(s, t, l, r))"}
{"solution": "MOD = 1000000007\n\ndef solve(n, k, d):\n    dp = [[0] * (n + 1) for _ in range(k + 1)]\n    dp[0][0] = 1\n    for i in range(1, k + 1):\n        for j in range(n + 1):\n            for l in range(1, min(j, i) + 1):\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - l]) % MOD\n            if i >= d:\n                dp[i][j] = (dp[i][j] + dp[i][j - i]) % MOD\n    return dp[k][n]\n\nn, k, d = map(int, input().split())\nprint(solve(n, k, d))"}
{"solution": "# Get the length of the row\nn = int(input())\n\n# Get the row as a string\nrow = input()\n\n# Initialize an empty list to store the lengths of black squares\nblack_squares = []\n\n# Initialize a counter for the current black square\ncurrent_black = 0\n\n# Iterate over the row\nfor square in row:\n    # If the square is black\n    if square == 'B':\n        # Increment the counter\n        current_black += 1\n    # If the square is white\n    else:\n        # If the counter is not zero, add it to the list and reset the counter\n        if current_black != 0:\n            black_squares.append(current_black)\n            current_black = 0\n\n# If the last square was black, add the counter to the list\nif current_black != 0:\n    black_squares.append(current_black)\n\n# Print the number of groups of black squares\nprint(len(black_squares))\n\n# Print the lengths of the groups of black squares\nprint(' '.join(map(str, black_squares)))"}
{"solution": "def solve_bracket_sequence(n, m, p, sequence, operations):\n    cursor = p - 1\n    bracket_pairs = [-1] * n\n    stack = []\n\n    for i in range(n):\n        if sequence[i] == '(':\n            stack.append(i)\n        else:\n            j = stack.pop()\n            bracket_pairs[i] = j\n            bracket_pairs[j] = i\n\n    for op in operations:\n        if op == 'L':\n            cursor -= 1\n        elif op == 'R':\n            cursor += 1\n        else:\n            j = bracket_pairs[cursor]\n            bracket_pairs[cursor] = -1\n            bracket_pairs[j] = -1\n            if j < cursor:\n                cursor = j\n            else:\n                while cursor < n and bracket_pairs[cursor] == -1:\n                    cursor += 1\n                if cursor == n:\n                    cursor -= 1\n\n    result = []\n    for i in range(n):\n        if bracket_pairs[i] != -1:\n            result.append(sequence[i])\n\n    return ''.join(result)\n\nn, m, p = map(int, input().split())\nsequence = input()\noperations = input()\n\nprint(solve_bracket_sequence(n, m, p, sequence, operations))"}
{"solution": "import sys\n\ndef find_number():\n    n = int(sys.stdin.readline())\n    lower_bound = -2 * 10**9\n    upper_bound = 2 * 10**9\n\n    for _ in range(n):\n        query = sys.stdin.readline().split()\n        sign = query[0]\n        x = int(query[1])\n        answer = query[2]\n\n        if answer == 'Y':\n            if sign == '>':\n                lower_bound = max(lower_bound, x + 1)\n            elif sign == '<':\n                upper_bound = min(upper_bound, x - 1)\n            elif sign == '>=':\n                lower_bound = max(lower_bound, x)\n            elif sign == '<=':\n                upper_bound = min(upper_bound, x)\n        else:\n            if sign == '>':\n                upper_bound = min(upper_bound, x)\n            elif sign == '<':\n                lower_bound = max(lower_bound, x)\n            elif sign == '>=':\n                upper_bound = min(upper_bound, x - 1)\n            elif sign == '<=':\n                lower_bound = max(lower_bound, x + 1)\n\n    if lower_bound <= upper_bound:\n        return lower_bound\n    else:\n        return 'Impossible'\n\nprint(find_number())"}
{"solution": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef count_periods(a, b):\n    total = a + b\n    periods = set()\n    for i in range(1, total + 1):\n        if gcd(i, total) == 1:\n            periods.add(i)\n        if i != total // 2 and total % 2 == 0 and gcd(i, total // 2) == 1:\n            periods.add(total // 2)\n    return len(periods)\n\na, b = map(int, input().split())\nprint(count_periods(a, b))"}
{"solution": "n, k = map(int, input().split())\ns = input().split()\n\nnames = []\nfor i in range(n):\n    if i < k - 1:\n        names.append('A' + 'a' * (i % 10))\n    elif s[i - k + 1] == 'NO':\n        names.append(names[i - 1])\n    else:\n        names.append('A' + 'a' * ((i - 1) % 10))\n\nprint(' '.join(names))"}
{"solution": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef count_steps(a, b):\n    if a < b:\n        a, b = b, a\n    diff = a - b\n    steps = 0\n    while diff > 0:\n        if diff % 2 == 0:\n            diff //= 2\n        elif diff % 3 == 0:\n            diff = 2 * diff // 3\n        elif diff % 5 == 0:\n            diff = 4 * diff // 5\n        else:\n            return -1\n        steps += 1\n    return steps\n\na, b = map(int, input().split())\ng = gcd(a, b)\nif a % g != 0 or b % g != 0:\n    print(-1)\nelse:\n    print(count_steps(a, b))"}
{"solution": "n, a, b = map(int, input().split())\ndancers = list(map(int, input().split()))\n\ncost = 0\nfor i in range(n // 2):\n    if dancers[i] == dancers[n - i - 1]:\n        continue\n    elif dancers[i] == 2 and dancers[n - i - 1] == 2:\n        cost += min(a, b) * 2\n    elif dancers[i] == 2:\n        cost += a if dancers[n - i - 1] == 0 else b\n    elif dancers[n - i - 1] == 2:\n        cost += a if dancers[i] == 0 else b\n    else:\n        cost = -1\n        break\n\nprint(cost)"}
{"solution": "def print_cube(k):\n    if k % 2 == 1:\n        print(-1)\n        return\n\n    for i in range(k):\n        for j in range(k):\n            if (i // 2 + j // 2) % 2 == 0:\n                print(\"w\", end=\"\")\n            else:\n                print(\"b\", end=\"\")\n        print()\n\nk = int(input())\nprint_cube(k)"}
{"solution": "def max_lovely_number(n):\n    i = 2\n    while i * i <= n:\n        if n % (i * i) == 0:\n            while n % (i * i) == 0:\n                n //= i\n        i += 1\n    return n\n\nn = int(input())\nprint(max_lovely_number(n))"}
{"solution": "n = int(input())\nseating = input()\n\n# Check if the first or last seat is occupied\nif seating[0] == '1' or seating[-1] == '1':\n    print(\"No\")\nelse:\n    # Check if there are two adjacent occupied seats\n    if '11' in seating:\n        print(\"No\")\n    else:\n        # Check if there is an empty seat between two occupied seats\n        if '010' in seating:\n            print(\"No\")\n        else:\n            print(\"Yes\")"}
{"solution": "n = int(input())\na = [0] + list(map(int, input().split()))\n\npossible_k = []\nfor k in range(1, n + 1):\n    x = [a[i] - a[i - 1] for i in range(1, k + 1)]\n    if all(a[i] == sum(x[:(i - 1) % k + 1]) for i in range(k + 1, n + 2)):\n        possible_k.append(k)\n\nprint(len(possible_k))\nprint(' '.join(map(str, possible_k)))"}
{"solution": "# Get the input scores\nscores = list(map(int, input().split()))\n\n# Calculate the total sum of scores\ntotal_sum = sum(scores)\n\n# Check if the total sum is odd, if so, it's impossible to divide into two equal teams\nif total_sum % 2 != 0:\n    print(\"NO\")\nelse:\n    # If the total sum is even, try to find a subset of scores that sum up to half of the total sum\n    target_sum = total_sum // 2\n    # Sort the scores in descending order\n    scores.sort(reverse=True)\n    # Use a recursive function to check if a subset of scores sum up to the target sum\n    def check_subset_sum(scores, target_sum, current_sum=0, index=0):\n        if current_sum == target_sum:\n            return True\n        if current_sum > target_sum or index == len(scores):\n            return False\n        return check_subset_sum(scores, target_sum, current_sum + scores[index], index + 1) or check_subset_sum(scores, target_sum, current_sum, index + 1)\n    # Print the result\n    if check_subset_sum(scores, target_sum):\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "def count_2_3_integers(l, r):\n    powers_of_2 = [2**i for i in range(32)]\n    powers_of_3 = [3**i for i in range(21)]\n    two_three_numbers = set()\n\n    for i in powers_of_2:\n        for j in powers_of_3:\n            if i*j <= r:\n                two_three_numbers.add(i*j)\n\n    return sum(1 for i in two_three_numbers if i >= l)\n\nl, r = map(int, input().split())\nprint(count_2_3_integers(l, r))"}
{"solution": "# Read the input\nn, k = map(int, input().split())\n\n# Initialize the number of candies Alya ate\neaten_candies = 0\n\n# Initialize the number of candies in the box\nbox_candies = 0\n\n# Perform the actions\nfor i in range(1, n + 1):\n    # If the box is empty or the number of candies to put is less than or equal to the number of candies in the box\n    if box_candies == 0 or i <= box_candies:\n        # Put i candies into the box\n        box_candies += i\n    else:\n        # Eat one candy from the box\n        box_candies -= 1\n        eaten_candies += 1\n\n# Print the number of candies Alya ate\nprint(eaten_candies)"}
{"solution": "# Read the number of line segments\nn = int(input())\n\n# Read the lengths of line segments\nsegments = list(map(int, input().split()))\n\n# Sort the lengths of line segments\nsegments.sort()\n\n# Check if the sum of the lengths of the two smallest segments is greater than the length of the third smallest segment\nif segments[n - 3] + segments[n - 2] > segments[n - 1]:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "x, y = map(int, input().split())\n\n# If the number of original toys is less than the desired number, it's impossible\nif y < 1:\n    print('No')\n# If the number of copies is greater than the number of original toys, it's impossible\nelif x > y - 1:\n    print('No')\n# If the number of copies is odd and the number of original toys is even, it's impossible\nelif x % 2 == 1 and y % 2 == 0:\n    print('No')\n# Otherwise, it's possible\nelse:\n    print('Yes')"}
{"solution": "import sys\n\ndef calculate_max_rating(n, k, skills):\n    # Sort the skills in ascending order\n    skills.sort()\n\n    # Calculate the current rating\n    current_rating = sum(skill // 10 for skill in skills)\n\n    # Iterate over the skills\n    for i in range(n):\n        # If there are no improvement units left, break the loop\n        if k == 0:\n            break\n\n        # Calculate the number of improvement units needed to increase the skill to the next level\n        units_needed = (skills[i] // 10 + 1) * 10 - skills[i]\n\n        # If the number of improvement units needed is less than or equal to the number of improvement units available,\n        # increase the skill to the next level and decrease the number of improvement units available\n        if units_needed <= k:\n            skills[i] += units_needed\n            k -= units_needed\n            current_rating += 1\n\n    # Return the maximum possible rating\n    return current_rating\n\ndef main():\n    # Read the input\n    n, k = map(int, sys.stdin.readline().split())\n    skills = list(map(int, sys.stdin.readline().split()))\n\n    # Calculate the maximum possible rating\n    max_rating = calculate_max_rating(n, k, skills)\n\n    # Print the result\n    print(max_rating)\n\nif __name__ == '__main__':\n    main()"}
{"solution": "# Read input\nn, m = map(int, input().split())\na = set(map(int, input().split()))\nb = set(map(int, input().split()))\n\n# Check if there is a common digit\ncommon = a & b\nif common:\n    print(min(common))\nelse:\n    # Find the smallest number with one digit from a and one digit from b\n    min_a = min(a)\n    min_b = min(b)\n    print(min(min_a * 10 + min_b, min_b * 10 + min_a))"}
{"solution": "n, k = map(int, input().split())\n\ntotal_time = 240\ntime_spent_on_problems = 0\nproblems_solved = 0\n\nfor i in range(1, n + 1):\n    time_needed_for_problem = 5 * i\n    if time_spent_on_problems + time_needed_for_problem + k <= total_time:\n        time_spent_on_problems += time_needed_for_problem\n        problems_solved += 1\n    else:\n        break\n\nprint(problems_solved)"}
{"solution": "n, x, y = map(int, input().split())\na = list(map(int, input().split()))\n\n# Sort the list of pages in descending order\na.sort(reverse=True)\n\n# Initialize the number of teams that can be printed\nteams = 0\n\n# Iterate over the list of pages\nfor pages in a:\n    # If the number of pages is even\n    if pages % 2 == 0:\n        # If there are enough sheets with two clean sides\n        if x >= pages // 2:\n            x -= pages // 2\n            teams += 1\n    # If the number of pages is odd\n    else:\n        # If there is a sheet with two clean sides\n        if x > 0:\n            x -= 1\n            pages -= 1\n        # If there are enough sheets with one clean side\n        if y >= pages:\n            y -= pages\n            teams += 1\n\n# Print the number of teams that can be printed\nprint(teams)"}
{"solution": "def count_unique_fractions(b):\n    factors = set()\n    i = 1\n    while i * i <= b:\n        if b % i:\n            i += 1\n        else:\n            factors.add(i)\n            factors.add(b // i)\n            i += 1\n    return len(factors)\n\nb = int(input())\nprint(count_unique_fractions(b))"}
{"solution": "# Read the input\nn = int(input())\nbumpers = input()\n\n# Initialize the count of positions where the ball will fall off\ncount = 0\n\n# Iterate over the bumpers\nfor i in range(n):\n    # Initialize the current position of the ball\n    pos = i\n\n    # Simulate the ball's movement\n    while True:\n        # If the ball is at the leftmost position and hits a '<' bumper, it falls off\n        if pos == 0 and bumpers[pos] == '<':\n            count += 1\n            break\n\n        # If the ball is at the rightmost position and hits a '>' bumper, it falls off\n        if pos == n - 1 and bumpers[pos] == '>':\n            count += 1\n            break\n\n        # If the ball hits a '<' bumper, move it to the left\n        if bumpers[pos] == '<':\n            pos -= 1\n\n        # If the ball hits a '>' bumper, move it to the right\n        else:\n            pos += 1\n\n# Print the result\nprint(count)"}
{"solution": "from collections import Counter\n\ndef max_rectangle_area(n, sticks):\n    counter = Counter(sticks)\n    pairs = 0\n    for length, count in counter.items():\n        pairs += count // 2\n\n    return pairs * 2 * (pairs * 2)\n\nn = int(input())\nsticks = list(map(int, input().split()))\nprint(max_rectangle_area(n, sticks))"}
{"solution": "# Read the number of strings\nn = int(input())\n\n# Initialize a dictionary to store the sum of each digit at each position\ndigit_sum = {i: 0 for i in range(10)}\n\n# Initialize a dictionary to store the frequency of each character\nchar_freq = {}\n\n# Read the strings and calculate the sum of each digit at each position\nfor _ in range(n):\n    s = input()\n    for i in range(len(s)):\n        # If the character is not in the dictionary, add it\n        if s[i] not in char_freq:\n            char_freq[s[i]] = 0\n        # Add the digit (position) to the sum of the character\n        digit_sum[char_freq[s[i]]] += 10 ** (len(s) - i - 1)\n        # Increment the frequency of the character\n        char_freq[s[i]] += 1\n\n# Sort the characters by their frequency\nsorted_chars = sorted(char_freq.keys(), key=lambda x: char_freq[x])\n\n# Initialize the total sum and the digit value\ntotal_sum = 0\ndigit_value = 0\n\n# Assign the smallest possible digits to the characters\nfor char in sorted_chars:\n    total_sum += digit_sum[char_freq[char]] * digit_value\n    digit_value += 1\n\n# Print the total sum\nprint(total_sum)"}
{"solution": "# Get the input\nn, m = map(int, input().split())\n\n# Initialize the number of teams\nteams = 0\n\n# While there are enough newbies for A's team\nwhile n > 0 and m >= 2:\n    # Form a team\n    teams += 1\n    # Decrease the number of newbies and experienced members\n    m -= 2\n    n -= 1\n\n# While there are enough experienced members for B's team\nwhile n >= 2 and m > 0:\n    # Form a team\n    teams += 1\n    # Decrease the number of newbies and experienced members\n    m -= 1\n    n -= 2\n\n# Print the result\nprint(teams)"}
{"solution": "def check_string(s):\n    if 'AB' in s and 'BA' in s:\n        ab_index = s.index('AB')\n        ba_index = s.index('BA')\n        if ab_index < ba_index + 2 and ba_index < ab_index + 2:\n            return 'NO'\n        else:\n            return 'YES'\n    elif 'BA' in s and 'AB' in s:\n        ba_index = s.index('BA')\n        ab_index = s.index('AB')\n        if ba_index < ab_index + 2 and ab_index < ba_index + 2:\n            return 'NO'\n        else:\n            return 'YES'\n    else:\n        return 'NO'\n\ns = input()\nprint(check_string(s))"}
{"solution": "def solve_problem():\n    n = int(input())\n    a = list(map(int, input().split()))\n    k = int(input())\n    b = list(map(int, input().split()))\n\n    # Check if the final queue state is possible\n    if sorted(a, reverse=True)[:k] != sorted(b, reverse=True):\n        print(\"NO\")\n        return\n\n    # Simulate the eating process\n    eatings = []\n    while a != b:\n        for i in range(len(a)):\n            # Check if the current monster can eat the monster to its left\n            if i > 0 and a[i] > a[i-1]:\n                a[i] += a[i-1]\n                eatings.append(f\"{i+1} L\")\n                del a[i-1]\n                break\n            # Check if the current monster can eat the monster to its right\n            elif i < len(a) - 1 and a[i] > a[i+1]:\n                a[i] += a[i+1]\n                eatings.append(f\"{i+1} R\")\n                del a[i+1]\n                break\n\n    # Print the result\n    print(\"YES\")\n    for eating in eatings:\n        print(eating)\n\nsolve_problem()"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline\n\ndef write_output(text):\n    return sys.stdout.write(text)\n\ndef calculate_slope(point1, point2):\n    # Calculate the slope between two points\n    return (point1[1] - point2[1]) / (point1[0] - point2[0])\n\ndef check_collinearity(point1, point2, point3):\n    # Check if three points are collinear\n    return (point1[0] - point2[0]) * (point2[1] - point3[1]) == (point2[0] - point3[0]) * (point1[1] - point2[1])\n\ndef main():\n    number_of_red_points, number_of_blue_points = map(int, read_input().split())\n    red_points = []\n    blue_points = []\n\n    for _ in range(number_of_red_points):\n        x, y = map(int, read_input().split())\n        red_points.append((x, y))\n\n    for _ in range(number_of_blue_points):\n        x, y = map(int, read_input().split())\n        blue_points.append((x, y))\n\n    if number_of_red_points != number_of_blue_points:\n        write_output(\"No\\n\")\n        return\n\n    red_points.sort()\n    blue_points.sort()\n\n    slopes = set()\n    for red_point in red_points:\n        for blue_point in blue_points:\n            if red_point != blue_point and not check_collinearity(red_point, blue_point, (0, 0)):\n                slope = calculate_slope(red_point, blue_point)\n                if slope in slopes:\n                    write_output(\"No\\n\")\n                    return\n                slopes.add(slope)\n\n    write_output(\"Yes\\n\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n = int(input())\nnumbers = list(map(int, input().split()))\n\nmax_power = 0\ncount = 0\n\nfor num in numbers:\n    power = 0\n    while num % 2 == 0:\n        num //= 2\n        power += 1\n    if power > max_power:\n        max_power = power\n        count = 1\n    elif power == max_power:\n        count += 1\n\nr = 2 ** max_power\nprint(r, count)"}
{"solution": "# Get the input\nn, m = map(int, input().split())\n\n# Initialize the number of clicks\nclicks = 0\n\n# While n is not equal to m\nwhile n != m:\n    # If m is greater than n and m is even\n    if m > n and m % 2 == 0:\n        # Divide m by 2\n        m //= 2\n        # Increment the number of clicks\n        clicks += 1\n    # Otherwise\n    else:\n        # Decrement m\n        m -= 1\n        # Increment the number of clicks\n        clicks += 1\n\n# Print the number of clicks\nprint(clicks)"}
{"solution": "import sys\n\ndef find(parent, i):\n    if parent[i] == i:\n        return i\n    return find(parent, parent[i])\n\ndef union(parent, rank, x, y):\n    xroot = find(parent, x)\n    yroot = find(parent, y)\n\n    if rank[xroot] < rank[yroot]:\n        parent[xroot] = yroot\n    elif rank[xroot] > rank[yroot]:\n        parent[yroot] = xroot\n    else:\n        parent[yroot] = xroot\n        rank[xroot] += 1\n\ndef is_tree(n, segments):\n    parent = [0]*n\n    rank = [0]*n\n\n    for i in range(n):\n        parent[i] = i\n\n    segments.sort(key=lambda x: x[1])\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if segments[j][0] < segments[i][1]:\n                x = find(parent, i)\n                y = find(parent, j)\n\n                if x == y:\n                    return False\n\n                union(parent, rank, x, y)\n\n    return True\n\ndef main():\n    n = int(sys.stdin.readline())\n    segments = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n\n    if is_tree(n, segments):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n = int(input())\nrequests = list(map(int, input().split()))\n\nmax_length = 0\ncurrent_length = 0\n\nfor i in range(n):\n    if requests[i] > 100 * (i + 1 - current_length):\n        current_length = i + 1\n    else:\n        max_length = max(max_length, current_length - max(0, i - 100 * (i + 1)))\n        current_length = i + 1\n\nmax_length = max(max_length, current_length - max(0, n - 100 * n))\n\nprint(max_length)"}
{"solution": "def check_dissatisfaction(n, k, episodes):\n    max_consecutive_not_watched = 0\n    current_consecutive_not_watched = 0\n    for i in range(n):\n        if episodes[i] == 'N':\n            current_consecutive_not_watched += 1\n            max_consecutive_not_watched = max(max_consecutive_not_watched, current_consecutive_not_watched)\n        elif episodes[i] == 'Y':\n            current_consecutive_not_watched = 0\n    if max_consecutive_not_watched == k:\n        return \"YES\"\n    elif max_consecutive_not_watched < k:\n        if '?' in episodes and episodes.count('?') >= k - max_consecutive_not_watched:\n            return \"YES\"\n    return \"NO\"\n\nn, k = map(int, input().split())\nepisodes = input()\nprint(check_dissatisfaction(n, k, episodes))"}
{"solution": "# Read input\nN, X, D = map(int, input().split())\n\n# Calculate the last element of the sequence\nlast_element = X + D * (N - 1)\n\n# If D is 0, there is only one possible value of S - T\nif D == 0:\n    print(1)\nelse:\n    # Calculate the minimum and maximum possible values of S - T\n    min_diff = min(X, last_element) - max(X, last_element)\n    max_diff = max(X, last_element) - min(X, last_element)\n\n    # Calculate the number of possible values of S - T\n    # It is the number of elements in the range [min_diff, max_diff] that are multiples of D\n    num_possible_values = (max_diff - min_diff) // D + 1\n\n    # Print the result\n    print(num_possible_values)"}
{"solution": "n = int(input())\ngood_performance = False\n\nfor _ in range(n):\n    name, before, after = input().split()\n    before = int(before)\n    after = int(after)\n\n    if before >= 2400 and after > before:\n        good_performance = True\n\nif good_performance:\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "# Get the binary input\ns = input()\n\n# Convert the binary input to decimal\ns = int(s, 2)\n\n# Initialize the counter for missed trains\ncount = 0\n\n# Initialize the time for the first train\ntime = 1\n\n# Loop until the time for the next train is greater than or equal to s\nwhile time < s:\n    # Increment the counter for missed trains\n    count += 1\n    # Calculate the time for the next train\n    time *= 4\n\n# Print the number of missed trains\nprint(count)"}
{"solution": "def find_min_rows(matrix):\n    n = len(matrix)\n    m = len(matrix[0])\n    for i in range(1, n // 2 + 1):\n        if matrix[:i] == matrix[i:2*i][::-1]:\n            return i\n    return n\n\nn, m = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\nprint(find_min_rows(matrix))"}
{"solution": "# Read the number of orders\nn = int(input())\n\n# Create a list to store the orders\norders = []\n\n# Read the orders and store them in the list\nfor _ in range(n):\n    l, r = map(int, input().split())\n    orders.append((l, r))\n\n# Sort the orders by their finish time\norders.sort(key=lambda x: x[1])\n\n# Initialize the count of accepted orders and the finish time of the last accepted order\ncount = 0\nlast_finish = 0\n\n# Iterate over the orders\nfor l, r in orders:\n    # If the current order does not intersect with the last accepted order, accept it\n    if l >= last_finish:\n        count += 1\n        last_finish = r\n\n# Print the maximal number of orders that can be accepted\nprint(count)"}
{"solution": "def solve():\n    n, k = map(int, input().split())\n    x = list(map(int, input().split()))\n    y = list(map(int, input().split()))\n\n    tables = 0\n    formulas = 0\n\n    for i in range(n):\n        if tables + x[i] > k or formulas + y[i] > k:\n            print(\"NO\")\n            return\n\n        if i < n - 1:\n            if tables + x[i] <= k and formulas + y[i] <= k:\n                tables += x[i]\n                formulas += y[i]\n            elif tables + y[i] <= k and formulas + x[i] <= k:\n                tables += y[i]\n                formulas += x[i]\n                x[i], y[i] = y[i], x[i]\n            else:\n                print(\"NO\")\n                return\n        else:\n            tables += x[i]\n            formulas += y[i]\n\n    print(\"YES\")\n\nsolve()"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef main():\n    n, k = map(int, read_input().split())\n    a = [int(read_input()) if read_input() != '?' else None for _ in range(n + 1)]\n\n    # If it's computer's turn and there are no undefined coefficients,\n    # the human has already won.\n    if all(coeff is not None for coeff in a):\n        return 'No'\n\n    # If it's human's turn and there is only one undefined coefficient,\n    # the human can win by setting it to -k.\n    if sum(coeff is None for coeff in a) == 1:\n        return 'Yes'\n\n    # If it's computer's turn and there are two or more undefined coefficients,\n    # the human can't guarantee the victory.\n    return 'No'\n\nprint(main())"}
{"solution": "def smallest_prime_factor(n):\n    spf = [0 for i in range(n+1)]\n    spf[1] = 1\n    for i in range(2, n+1):\n        spf[i] = i\n    for i in range(4, n+1, 2):\n        spf[i] = 2\n    for i in range(3, int(n**0.5)+1):\n        if spf[i] == i:\n            for j in range(i * i, n + 1, i):\n                if spf[j] == j:\n                    spf[j] = i\n    return spf\n\ndef solve(x):\n    spf = smallest_prime_factor(x)\n    p = spf[x]\n    q = x // p\n    if q > p:\n        return p\n    else:\n        return p * q\n\nx = int(input())\nprint(solve(x))"}
{"solution": "n, p = map(int, input().split())\n\n# Check if it is possible to represent n as the sum of any number of p-binary numbers\nif n < p and p > 0:\n    print(-1)\nelse:\n    # Calculate the maximum possible power of 2 that can be used\n    max_power = 0\n    while (1 << max_power) <= n:\n        max_power += 1\n\n    # Initialize the count of p-binary numbers\n    count = 0\n\n    # Start from the maximum possible power and go down\n    for i in range(max_power, -1, -1):\n        # If the current p-binary number is less than or equal to n\n        if (1 << i) + p <= n:\n            # Subtract the current p-binary number from n\n            n -= (1 << i) + p\n            # Increment the count\n            count += 1\n\n    # Print the count\n    print(count)"}
{"solution": "n, k = map(int, input().split())\nS = list(input())\n\n# If the first digit is not '1' and we can change it, change it to '1'\nif S[0] != '1' and k > 0:\n    S[0] = '1'\n    k -= 1\n\n# Change the remaining digits to '0' if possible\nfor i in range(1, n):\n    if S[i] != '0' and k > 0:\n        S[i] = '0'\n        k -= 1\n\nprint(''.join(S))"}
{"solution": "def sieve_of_eratosthenes(n):\n    primes = [True] * (n + 1)\n    p = 2\n    while p * p <= n:\n        if primes[p] == True:\n            for i in range(p * p, n + 1, p):\n                primes[i] = False\n        p += 1\n    return [p for p in range(2, n) if primes[p]]\n\ndef count_numbers(cnt1, cnt2, x, y):\n    primes = sieve_of_eratosthenes(30000)\n    if x not in primes or y not in primes:\n        return -1\n    v = 1\n    while True:\n        if v // x + v // y - v // (x * y) >= cnt1 + cnt2:\n            return v\n        v += 1\n\ncnt1, cnt2, x, y = map(int, input().split())\nprint(count_numbers(cnt1, cnt2, x, y))"}
{"solution": "def bear_move(n, sx, sy, dx, dy, t):\n    x, y = sx, sy\n    for _ in range(t):\n        k = x + y\n        dx += k\n        dy += k\n        x = ((x + dx - 1) % n) + 1\n        y = ((y + dy - 1) % n) + 1\n    return x, y\n\nn, sx, sy, dx, dy, t = map(int, input().split())\nx, y = bear_move(n, sx, sy, dx, dy, t)\nprint(x, y)"}
{"solution": "def solve(s):\n    n = len(s)\n    if n < 26:\n        return -1\n    alphabet = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n    for i in range(n - 26 + 1):\n        substring = s[i:i+26]\n        missing = alphabet - set(substring)\n        if len(missing) <= substring.count('?'):\n            result = list(substring)\n            for j, c in enumerate(result):\n                if c == '?':\n                    result[j] = missing.pop()\n            return ''.join(result).replace('?', 'A')\n    return -1\n\ns = input()\nprint(solve(s))"}
{"solution": "n = int(input())\napples = list(map(int, input().split()))\n\ncount_100 = apples.count(100)\ncount_200 = apples.count(200)\n\nif count_100 % 2 == 0 and (count_100 > 0 or count_200 % 2 == 0):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def min_time(n, m, building):\n    time = 0\n    for i in range(n-1, -1, -1):\n        left_to_right = building[i][0:m+2].find('1')\n        right_to_left = building[i][m+1::-1].find('1')\n        if left_to_right != -1 and right_to_left != -1:\n            time += 2 * min(left_to_right, right_to_left) + max(left_to_right, right_to_left)\n        elif left_to_right != -1:\n            time += left_to_right\n        elif right_to_left != -1:\n            time += right_to_left\n        if i > 0:\n            time += 1\n    return time\n\nn, m = map(int, input().split())\nbuilding = [input() for _ in range(n)]\nprint(min_time(n, m, building))"}
{"solution": "import sys\n\ndef find_min_cost(n, costs, transitions):\n    # Initialize an array to store the minimum cost to catch the mouse for each room\n    min_costs = [sys.maxsize] * n\n\n    # Iterate over each room\n    for i in range(n):\n        # Initialize a variable to store the current room and a set to store the visited rooms\n        current_room = i\n        visited_rooms = set()\n\n        # Iterate until the mouse is caught or an infinite loop is detected\n        while current_room not in visited_rooms:\n            # Add the current room to the set of visited rooms\n            visited_rooms.add(current_room)\n\n            # Update the minimum cost to catch the mouse for the current room\n            min_costs[i] = min(min_costs[i], costs[current_room])\n\n            # Move the mouse to the next room\n            current_room = transitions[current_room] - 1\n\n    # Return the minimum total cost to catch the mouse\n    return sum(min_costs)\n\n# Read the input\nn = int(input())\ncosts = list(map(int, input().split()))\ntransitions = list(map(int, input().split()))\n\n# Print the output\nprint(find_min_cost(n, costs, transitions))"}
{"solution": "# Get the input\nn, a, b = map(int, input().split())\n\n# Calculate the final position\nfinal_position = (a + b - 1) % n\n\n# If final position is 0, it means Vasya is at the last entrance\nif final_position == 0:\n    final_position = n\n\n# Print the result\nprint(final_position)"}
{"solution": "def min_arithmetic_progressions(arr):\n    n = len(arr)\n    dp = [0] * n\n    last = [-1] * n\n\n    for i in range(n):\n        dp[i] = dp[i-1] + 1\n        j = i - 1\n        while j >= 0:\n            if arr[j] != -1 and arr[i] != -1 and (arr[i] - arr[j]) % (i - j) != 0:\n                j = last[(arr[i] - arr[j]) % (i - j) + (10**9)]\n                continue\n            if dp[i] > dp[j] + 1:\n                dp[i] = dp[j] + 1\n                last[(arr[i] - arr[j]) % (i - j) + (10**9)] = j\n            j -= 1\n\n    return dp[n-1]\n\nn = int(input())\narr = list(map(int, input().split()))\nprint(min_arithmetic_progressions(arr))"}
{"solution": "def max_beauty(n, k, s):\n    max_len = 0\n    curr_len = 1\n    for i in range(1, n):\n        if s[i] == s[i-1]:\n            curr_len += 1\n        else:\n            max_len = max(max_len, curr_len)\n            curr_len = 1\n    max_len = max(max_len, curr_len)\n    return min(n, max_len + k)\n\nn, k = map(int, input().split())\ns = input()\nprint(max_beauty(n, k, s))"}
{"solution": "n = int(input())\nseats = list(map(int, input().split()))\n\n# Calculate total seats\ntotal_seats = sum(seats)\n\n# Check if Alice's party has more than half of the seats\nif seats[0] > total_seats / 2:\n    print(1)\n    print(1)\nelse:\n    # Sort the other parties based on the number of seats\n    other_parties = sorted([(seats[i], i + 1) for i in range(1, n)])\n\n    # Try to form a coalition\n    coalition = [1]\n    coalition_seats = seats[0]\n    for party in other_parties:\n        if party[0] * 2 <= seats[0] and coalition_seats + party[0] > total_seats / 2:\n            coalition.append(party[1])\n            coalition_seats += party[0]\n\n    # Print the result\n    if len(coalition) == 1:\n        print(0)\n    else:\n        print(len(coalition))\n        print(' '.join(map(str, coalition)))"}
{"solution": "# Read the input\nn = int(input())\n\n# Initialize the total reward\ntotal_reward = 0.0\n\n# Calculate the total reward in the best possible scenario\nwhile n > 0:\n    total_reward += 1 / n\n    n -= 1\n\n# Print the result\nprint(\"{:.12f}\".format(total_reward))"}
{"solution": "n = int(input())\n\n# The maximum number of children is the maximum number of distinct positive integers that sum up to n\n# This is the same as the number of terms in the arithmetic series 1 + 2 + 3 + ... + k = n\n# We can find k by solving the equation k*(k+1)/2 = n for k\nk = int((2 * n) ** 0.5 - 0.5)\nwhile k * (k + 1) // 2 < n:\n    k += 1\n\n# The last child gets the remaining candies\ncandies = [i for i in range(1, k)]\ncandies.append(n - sum(candies))\n\nprint(k)\nprint(' '.join(map(str, candies)))"}
{"solution": "# Read input\nn = int(input())\nm = int(input())\n\n# Calculate 2^n\npower_of_two = 1 << n\n\n# Calculate m mod 2^n\nresult = m % power_of_two\n\n# Print output\nprint(result)"}
{"solution": "# Get the length of the word\nn = int(input())\n\n# Get the word\ns = input()\n\n# Define the vowels\nvowels = ['a', 'e', 'i', 'o', 'u', 'y']\n\n# Initialize the corrected word as an empty string\ncorrected_word = ''\n\n# Iterate over the word\nfor i in range(n):\n    # If the current character is a vowel and the next character is a vowel\n    if i < n - 1 and s[i] in vowels and s[i + 1] in vowels:\n        # Skip the current character\n        continue\n    # Otherwise, add the current character to the corrected word\n    else:\n        corrected_word += s[i]\n\n# Print the corrected word\nprint(corrected_word)"}
{"solution": "def main():\n    n, a, b = map(int, input().split())\n    seats = input()\n\n    # Initialize the count of students that can be seated\n    count = 0\n\n    # Initialize the previous seat as empty\n    prev_seat = '.'\n\n    # Iterate over the seats\n    for seat in seats:\n        # If the seat is empty\n        if seat == '.':\n            # If the previous seat was also empty\n            if prev_seat == '.':\n                # If there are still student-programmers left\n                if a > 0:\n                    # Seat a student-programmer\n                    a -= 1\n                    count += 1\n                    prev_seat = 'A'\n                # If there are still student-athletes left\n                elif b > 0:\n                    # Seat a student-athlete\n                    b -= 1\n                    count += 1\n                    prev_seat = 'B'\n            # If the previous seat was occupied by a student-programmer\n            elif prev_seat == 'A':\n                # If there are still student-athletes left\n                if b > 0:\n                    # Seat a student-athlete\n                    b -= 1\n                    count += 1\n                    prev_seat = 'B'\n            # If the previous seat was occupied by a student-athlete\n            elif prev_seat == 'B':\n                # If there are still student-programmers left\n                if a > 0:\n                    # Seat a student-programmer\n                    a -= 1\n                    count += 1\n                    prev_seat = 'A'\n        # If the seat is occupied by a jury member\n        else:\n            # The previous seat is now occupied by a jury member\n            prev_seat = '*'\n\n    # Print the count of students that can be seated\n    print(count)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\ndef find_pair(r):\n    for x in range(1, int(math.sqrt(r)) + 1):\n        if (r - x * x - x - 1) % (2 * x) == 0:\n            y = (r - x * x - x - 1) // (2 * x)\n            if y > 0:\n                return x, y\n    return \"NO\"\n\nr = int(input())\nprint(find_pair(r))"}
{"solution": "n = int(input())\nballoons = list(map(int, input().split()))\n\n# If there are only 1 or 2 packets, it's impossible to divide them\nif n <= 2:\n    print(-1)\nelse:\n    # Sort the packets in descending order\n    balloons.sort(reverse=True)\n\n    # Give the packet with the most balloons to Grigory\n    grigory_packets = [balloons[0]]\n    grigory_sum = balloons[0]\n\n    # Try to give the remaining packets to Andrew in a way that the total number of balloons is not equal\n    for i in range(1, n):\n        if grigory_sum > sum(balloons) - grigory_sum:\n            grigory_packets.append(balloons[i])\n            grigory_sum += balloons[i]\n\n    # If the total number of balloons is equal, it's impossible to divide them\n    if grigory_sum == sum(balloons) - grigory_sum:\n        print(-1)\n    else:\n        print(len(grigory_packets))\n        for i in range(len(grigory_packets)):\n            print(balloons.index(grigory_packets[i]) + 1, end=' ')"}
{"solution": "n = int(input())\n\n# Start from the largest possible digit\nfor i in range(9, 0, -1):\n    if n % i == 0:\n        # If n is divisible by i, print i n/i times\n        print(n // i)\n        print(' '.join([str(i)] * (n // i)))\n        break\n    elif n > i:\n        # If n is not divisible by i, but is greater than i,\n        # subtract i from n and continue the loop\n        n -= i\n        print(n // i + 1)\n        print(' '.join([str(i)] + [str(1)] * (n // i)))\n        break"}
{"solution": "def sieve_of_eratosthenes(n):\n    primes = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (primes[p] == True):\n            for i in range(p * p, n+1, p):\n                primes[i] = False\n        p += 1\n    return primes\n\ndef find_max_simple_subset(arr):\n    n = len(arr)\n    primes = sieve_of_eratosthenes(2*10**6)\n    max_size = 0\n    max_subset = []\n    for i in range(1, 1 << n):\n        subset = [arr[j] for j in range(n) if (i & (1 << j))]\n        is_simple = True\n        for x in subset:\n            for y in subset:\n                if x != y and not primes[x + y]:\n                    is_simple = False\n                    break\n            if not is_simple:\n                break\n        if is_simple and len(subset) > max_size:\n            max_size = len(subset)\n            max_subset = subset\n    return max_size, max_subset\n\nn = int(input())\narr = list(map(int, input().split()))\nmax_size, max_subset = find_max_simple_subset(arr)\nprint(max_size)\nprint(' '.join(map(str, max_subset)))"}
{"solution": "def greatest_beautiful_divisor(n):\n    k = 1\n    while (2**k - 1) * (2**(k-1)) <= n:\n        k += 1\n    return (2**(k-1) - 1) * (2**(k-1))\n\nn = int(input())\nprint(greatest_beautiful_divisor(n))"}
{"solution": "MOD = 10**9 + 7\n\ndef count_numbers(m, d, a, b):\n    n = len(str(a))\n    dp = [[0] * 2 for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(2):\n            for k in range(10):\n                if (i % 2 == 0 and k == d) or (i % 2 == 1 and k != d):\n                    dp[i + 1][j or (k > int(b[i])) or (j and k > int(a[i]))] = (dp[i + 1][j or (k > int(b[i])) or (j and k > int(a[i]))] + dp[i][j]) % MOD\n    return dp[n][0] * pow(10, n, MOD) % MOD if m == 1 else dp[n][0] * pow(10, n - len(str(m)), MOD) % MOD * count_numbers(1, d, '0' * (len(str(m)) - 1), str(m - 1)) % MOD\n\nm, d = map(int, input().split())\na = input()\nb = input()\nprint(count_numbers(m, d, a, b))"}
{"solution": "n, m = map(int, input().split())\na = list(map(int, input().split()))\n\nqueue = list(range(1, n + 1))\nlast_child = 0\n\nwhile queue:\n    child = queue.pop(0)\n    a[child - 1] -= m\n    if a[child - 1] > 0:\n        queue.append(child)\n    else:\n        last_child = child\n\nprint(last_child)"}
{"solution": "# Get the input\nn = int(input())\n\n# Initialize the count of bills\ncount = 0\n\n# Denominations of bills\ndenominations = [100, 20, 10, 5, 1]\n\n# Iterate over each denomination\nfor denomination in denominations:\n    # Count the number of bills of current denomination\n    count += n // denomination\n    # Update the remaining amount\n    n %= denomination\n\n# Print the minimum number of bills\nprint(count)"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(n, k):\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(min(i, k) + 1):\n            dp[i][j] = (dp[i - 1][j] + (i - j) * dp[i - 1][j - 1]) % MOD\n    return dp[n][k]\n\nn, k = map(int, input().split())\nprint(solve(n, k))"}
{"solution": "import heapq\n\nn, k = map(int, input().split())\nbeauties = list(map(int, input().split()))\ncolors = input()\n\nroses = {'W': [], 'O': [], 'R': []}\nfor i in range(n):\n    roses[colors[i]].append(beauties[i])\n\nfor color in roses:\n    roses[color].sort(reverse=True)\n\nmax_beauty = -1\n\n# Try to make a bouquet with two colors\nfor color1 in 'WO':\n    for color2 in 'OR':\n        if color1 != color2 and roses[color1] and roses[color2]:\n            beauty = sum(heapq.nlargest(k, roses[color1] + roses[color2]))\n            max_beauty = max(max_beauty, beauty)\n\n# Try to make a bouquet with one color\nfor color in 'WOR':\n    if len(roses[color]) >= k:\n        beauty = sum(roses[color][:k])\n        max_beauty = max(max_beauty, beauty)\n\nprint(max_beauty)"}
{"solution": "def convert_fraction(a):\n    if len(a) == 1:\n        return a[0], 1\n    else:\n        num = a[-1]\n        denom, num = convert_fraction(a[:-1])\n        num, denom = num + denom * a[-2], num\n        return num, denom\n\np, q = map(int, input().split())\nn = int(input())\na = list(map(int, input().split()))\n\nnum, denom = convert_fraction(a[::-1])\n\nif p == num and q == denom:\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "# Get the input expression\nexpression = input()\n\n# Split the expression into parts\nparts = expression.split('+')\na = parts[0].count('|')\nb = parts[1].split('=')[0].count('|')\nc = parts[1].split('=')[1].count('|')\n\n# Check if it's possible to make the expression correct\nif a + b == c:\n    print(expression)\nelif a + b + 1 == c:\n    print(expression.replace('=', '=|', 1))\nelif a + b - 1 == c:\n    print(expression.replace('|=', '=', 1))\nelif a + b + 2 == c:\n    print(expression.replace('=', '=||', 1))\nelif a + b - 2 == c and a > 1:\n    print(expression.replace('||=', '=', 1))\nelse:\n    print('Impossible')"}
{"solution": "MOD = 10**9 + 7\n\ndef solve():\n    n, k = map(int, input().split())\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(i * i):\n            for l in range(i - 1, -1, -1):\n                if j - l * l >= 0:\n                    dp[i][j] = (dp[i][j] + dp[l][j - l * l]) % MOD\n    return dp[n][k]\n\nprint(solve())"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef main():\n    n = int(read_input())\n    points = [tuple(map(int, read_input().split())) for _ in range(n)]\n\n    # Check if it's possible to reach all points\n    if not all(x % 2 == y % 2 for x, y in points):\n        print(-1)\n        return\n\n    # Calculate the maximum distance from the origin\n    max_dist = max(abs(x) + abs(y) for x, y in points)\n\n    # Initialize the robot arm configuration\n    m = 2 * max_dist\n    d = [1] * m\n\n    # Initialize the way to bring the last joint to each point\n    w = [''] * n\n\n    # Configure the robot arm\n    for i, (x, y) in enumerate(points):\n        # Move to the same x-coordinate\n        if x > 0:\n            w[i] += 'R' * x\n        else:\n            w[i] += 'L' * (-x)\n\n        # Move to the same y-coordinate\n        if y > 0:\n            w[i] += 'U' * y\n        else:\n            w[i] += 'D' * (-y)\n\n    # Print the robot arm configuration\n    print(m)\n    print(' '.join(map(str, d)))\n    print('\\n'.join(w))\n\nif __name__ == '__main__':\n    main()"}
{"solution": "n = int(input())\ns = input()\n\n# Replace all filler words with '***'\nwhile 'ogo' in s:\n    s = s.replace('ogo', '***')\n\n# Replace all remaining 'go' with ''\nwhile 'go' in s:\n    s = s.replace('go', '')\n\nprint(s)"}
{"solution": "import math\n\ndef prime_factors(n):\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef g(x, p):\n    k = 0\n    while x % p**(k+1) == 0:\n        k += 1\n    return p**k\n\ndef f(x, y):\n    factors = prime_factors(x)\n    product = 1\n    for p in factors:\n        product *= g(y, p)\n    return product\n\ndef solve(x, n):\n    mod = 10**9 + 7\n    result = 1\n    for i in range(1, n+1):\n        result = (result * f(x, i)) % mod\n    return result\n\nx, n = map(int, input().split())\nprint(solve(x, n))"}
{"solution": "def sum_of_digits(n):\n    return sum(int(digit) for digit in str(n))\n\ndef find_solutions(a, b, c):\n    solutions = []\n    for x in range(1, 10**9):\n        if x == b * sum_of_digits(x)**a + c:\n            solutions.append(x)\n    return solutions\n\na, b, c = map(int, input().split())\nsolutions = find_solutions(a, b, c)\nprint(len(solutions))\nprint(*solutions)"}
{"solution": "def check_solvable(cube):\n    # Check each face of the cube\n    for i in range(6):\n        # Create a set of the colors on the current face\n        face = set(cube[i*4:i*4+4])\n        # If the set has only one color, the face is solved\n        if len(face) == 1:\n            # Remove the solved face from the cube\n            remaining_cube = cube[:i*4] + cube[i*4+4:]\n            # Check if the remaining cube is solved\n            if len(set(remaining_cube)) == 1:\n                return True\n    return False\n\n# Read the input\ncube = list(map(int, input().split()))\n\n# Check if the cube is solvable\nif check_solvable(cube):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def solve(p, x, y):\n    s = y\n    i = (s // 50) % 475\n    t_shirts = set()\n    for _ in range(25):\n        i = (i * 96 + 42) % 475\n        t_shirts.add(26 + i)\n    hacks = 0\n    while p not in t_shirts or s < x:\n        s += 100\n        hacks += 1\n        i = (s // 50) % 475\n        t_shirts = set()\n        for _ in range(25):\n            i = (i * 96 + 42) % 475\n            t_shirts.add(26 + i)\n    return hacks\n\np, x, y = map(int, input().split())\nprint(solve(p, x, y))"}
{"solution": "# Get the input\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# If Winnie only needs to have a meal once, the distance is 0\nif n == 1:\n    print(0)\nelse:\n    # Initialize the minimum distance as the distance to the farthest house\n    min_distance = max(a, b, c)\n\n    # Calculate the distance for the case where Winnie alternates between Rabbit and the other two friends\n    distance1 = (n - 1) * min(a, c) + b\n\n    # Calculate the distance for the case where Winnie alternates between Owl and the other two friends\n    distance2 = (n - 1) * min(a, b) + c\n\n    # Calculate the distance for the case where Winnie alternates between Eeyore and the other two friends\n    distance3 = (n - 1) * min(b, c) + a\n\n    # The minimum distance is the smallest of the three calculated distances\n    min_distance = min(distance1, distance2, distance3)\n\n    # Print the minimum distance\n    print(min_distance)"}
{"solution": "# Get the input\nx1, x2, x3 = map(int, input().split())\n\n# Sort the coordinates\ncoordinates = sorted([x1, x2, x3])\n\n# Calculate the minimum total distance\nmin_distance = coordinates[1] - coordinates[0] + coordinates[2] - coordinates[1]\n\n# Print the result\nprint(min_distance)"}
{"solution": "from collections import defaultdict\n\ndef solve():\n    n, x = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    # Count the frequency of each element in the array\n    freq = defaultdict(int)\n    for i in range(n):\n        freq[a[i]] += 1\n\n    # Check if there are already two equal elements\n    if any(v > 1 for v in freq.values()):\n        print(0)\n        return\n\n    # Try to apply the operation to each element\n    for i in range(n):\n        new_val = a[i] & x\n        if new_val != a[i] and freq[new_val] > 0:\n            print(1)\n            return\n        freq[a[i]] -= 1\n        freq[new_val] += 1\n\n    # If it is impossible to make two elements equal\n    print(-1)\n\nsolve()"}
{"solution": "def is_plus_shape(grid, h, w):\n    # Find the center of the '+' shape\n    center = None\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == '*':\n                if center is None:\n                    center = (i, j)\n                else:\n                    # More than one '*' found, so it's not a '+' shape\n                    return False\n\n    if center is None:\n        # No '*' found, so it's not a '+' shape\n        return False\n\n    # Check if there is a valid '+' shape around the center\n    for i in range(h):\n        if i != center[0] and grid[i][center[1]] == '*':\n            return False\n    for j in range(w):\n        if j != center[1] and grid[center[0]][j] == '*':\n            return False\n\n    return True\n\n# Read input\nh, w = map(int, input().split())\ngrid = [input() for _ in range(h)]\n\n# Print output\nprint('YES' if is_plus_shape(grid, h, w) else 'NO')"}
{"solution": "def solve(n, a, b):\n    if a + b > n + 1 or a * b > n * (n - 1) // 2:\n        return None\n    graph = [[0] * n for _ in range(n)]\n    for i in range(1, a):\n        graph[i][i - 1] = graph[i - 1][i] = 1\n    for i in range(a, n):\n        for j in range(i + 1, n):\n            if b > 1:\n                graph[i][j] = graph[j][i] = 1\n                b -= 1\n    return graph\n\ndef main():\n    n, a, b = map(int, input().split())\n    graph = solve(n, a, b)\n    if graph is None:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        for row in graph:\n            print(\"\".join(map(str, row)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Read input\nc, d = map(int, input().split())\nn, m = map(int, input().split())\nk = int(input())\n\n# Calculate the number of people that need to go to the finals from the main rounds\nmain_round_finalists = n * m\n\n# Calculate the number of people that need to go to the finals from the additional rounds\nadditional_round_finalists = max(0, main_round_finalists - k)\n\n# Calculate the number of additional rounds needed\nadditional_rounds = (additional_round_finalists + d - 1) // d\n\n# Calculate the total number of problems needed\ntotal_problems = c * m + d * additional_rounds\n\n# Print the result\nprint(total_problems)"}
{"solution": "def find_path(s):\n    grid = [[' ']*13 for _ in range(2)]\n    letters = list(s)\n    last_index = {letter: i for i, letter in enumerate(letters)}\n    adjacents = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n\n    def is_valid(x, y):\n        return 0 <= x < 2 and 0 <= y < 13\n\n    def dfs(x, y, idx):\n        if idx == 27:\n            return True\n        for dx, dy in adjacents:\n            nx, ny = x + dx, y + dy\n            if is_valid(nx, ny) and grid[nx][ny] == ' ':\n                grid[nx][ny] = letters[idx]\n                if dfs(nx, ny, idx + 1):\n                    return True\n                grid[nx][ny] = ' '\n        return False\n\n    for i in range(27):\n        if last_index[letters[i]] - i > 6:\n            grid[0][0] = letters[i]\n            if dfs(0, 0, i + 1):\n                return grid\n    return \"Impossible\"\n\ns = input()\nresult = find_path(s)\nif result == \"Impossible\":\n    print(result)\nelse:\n    for row in result:\n        print(''.join(row))"}
{"solution": "import math\n\ndef compare_powers(x, y):\n    if x == y:\n        return '='\n    elif x == 1:\n        return '<' if y != 1 else '='\n    elif y == 1:\n        return '>'\n    elif x == 2 and y == 4:\n        return '<'\n    elif x == 4 and y == 2:\n        return '>'\n    elif x > y:\n        if x / y > math.log(2):\n            return '>'\n        else:\n            return '=' if x ** (1 / y) == y ** (1 / x) else '>' if x ** (1 / y) > y ** (1 / x) else '<'\n    else:\n        if y / x > math.log(2):\n            return '<'\n        else:\n            return '=' if x ** (1 / y) == y ** (1 / x) else '>' if x ** (1 / y) > y ** (1 / x) else '<'\n\nx, y = map(int, input().split())\nprint(compare_powers(x, y))"}
{"solution": "import math\n\n# Get the input\nr, h = map(int, input().split())\n\n# Calculate the maximum number of balloons that can fit in the cupboard\n# The number of balloons that can fit in the semicircle part\nsemicircle_balloons = math.floor(r / (r / 2))\n\n# The number of balloons that can fit in the rectangular part\nrectangle_balloons = math.floor((h + r) / (r / 2))\n\n# The total number of balloons that can fit in the cupboard is the minimum of the two values\ntotal_balloons = min(semicircle_balloons, rectangle_balloons)\n\n# Print the result\nprint(total_balloons)"}
{"solution": "from collections import Counter\n\n# Get the input and convert it to a list of integers\nnumbers = list(map(int, input().split()))\n\n# Count the occurrences of each number\ncounts = Counter(numbers)\n\n# Initialize the total sum\ntotal_sum = sum(numbers)\n\n# For each number, check if it occurs more than once\nfor number, count in counts.items():\n    # If it occurs three times, subtract three times the number from the total sum\n    if count >= 3:\n        total_sum -= 3 * number\n    # If it occurs twice, subtract twice the number from the total sum\n    elif count == 2:\n        total_sum -= 2 * number\n\n# Print the minimum possible sum of numbers written on remaining cards\nprint(total_sum)"}
{"solution": "# Read input\nn, a = map(int, input().split())\ncheckpoints = list(map(int, input().split()))\n\n# Sort the checkpoints\ncheckpoints.sort()\n\n# Initialize minimum distance\nmin_distance = float('inf')\n\n# Calculate the minimum distance\nfor i in range(n):\n    # If Vasya starts at a checkpoint, he can skip it\n    if checkpoints[i] == a:\n        continue\n    # Calculate the distance if Vasya visits the checkpoints in order\n    distance = abs(checkpoints[i] - a) + abs(checkpoints[i] - checkpoints[-1])\n    min_distance = min(min_distance, distance)\n    # Calculate the distance if Vasya visits the checkpoints in reverse order\n    distance = abs(checkpoints[i] - a) + abs(checkpoints[i] - checkpoints[0])\n    min_distance = min(min_distance, distance)\n\n# Print the minimum distance\nprint(min_distance)"}
{"solution": "def sum_of_digits(n):\n    return sum(int(digit) for digit in str(n))\n\ndef find_root(n):\n    x = 1\n    while True:\n        if x**2 + sum_of_digits(x)*x - n == 0:\n            return x\n        if x**2 + sum_of_digits(x)*x > n:\n            return -1\n        x += 1\n\nn = int(input())\nprint(find_root(n))"}
{"solution": "from datetime import datetime, timedelta\n\n# Get the current time and sleep duration as input\ncurrent_time = datetime.strptime(input(), \"%H:%M\")\nsleep_duration = datetime.strptime(input(), \"%H:%M\")\n\n# Calculate the time George went to bed\nbed_time = current_time - timedelta(hours=sleep_duration.hour, minutes=sleep_duration.minute)\n\n# Print the time George went to bed in the format \"hh:mm\"\nprint(bed_time.strftime(\"%H:%M\"))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nmax_mean = a[0]\nmax_len = 1\ncurr_sum = a[0]\ncurr_len = 1\n\nfor i in range(1, n):\n    if a[i] >= max_mean:\n        if a[i] > max_mean:\n            curr_len = 1\n            curr_sum = a[i]\n        else:\n            curr_len += 1\n            curr_sum += a[i]\n        if curr_sum / curr_len > max_mean:\n            max_mean = curr_sum / curr_len\n            max_len = curr_len\n    else:\n        curr_len = 1\n        curr_sum = a[i]\n\nprint(max_len)"}
{"solution": "MOD = 998244353\n\ndef main():\n    n, m, k = map(int, input().split())\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[1][0] = m\n    for i in range(2, n + 1):\n        for j in range(k + 1):\n            dp[i][j] = dp[i - 1][j] * (m - 1) % MOD\n            if j > 0:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD\n    print(dp[n][k])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_magic_number(n):\n    while n > 0:\n        if n % 100 == 14:\n            n //= 100\n        elif n % 10 == 1:\n            n //= 10\n        elif n == 144:\n            return True\n        else:\n            return False\n    return True\n\nn = int(input())\nprint(\"YES\" if is_magic_number(n) else \"NO\")"}
{"solution": "def min_moves(n, m, i, j, a, b):\n    moves = float('inf')\n\n    # Check if it's possible to reach any corner\n    if (i - a <= 0 or i + a > n) and (j - b <= 0 or j + b > m):\n        return \"Poor Inna and pony!\"\n\n    # Check the number of moves needed to reach each corner\n    if i - a > 0 and j - b > 0:\n        moves = min(moves, 1 + min((i - a - 1) // a, (j - b - 1) // b))\n    if i - a > 0 and j + b <= m:\n        moves = min(moves, 1 + min((i - a - 1) // a, (j + b - m) // b))\n    if i + a <= n and j - b > 0:\n        moves = min(moves, 1 + min((i + a - n) // a, (j - b - 1) // b))\n    if i + a <= n and j + b <= m:\n        moves = min(moves, 1 + min((i + a - n) // a, (j + b - m) // b))\n\n    return moves if moves != float('inf') else \"Poor Inna and pony!\"\n\nn, m, i, j, a, b = map(int, input().split())\nprint(min_moves(n, m, i, j, a, b))"}
{"solution": "def solve(s):\n    n = len(s)\n    dp = [0] * n\n    for i in range(1, n - 1):\n        if ord(s[i - 1]) + 1 == ord(s[i]) or ord(s[i + 1]) + 1 == ord(s[i]):\n            dp[i] = max(dp[i - 1], 1 + dp[i - 2])\n        else:\n            dp[i] = dp[i - 1]\n    return dp[-2]\n\nn = int(input())\ns = input()\nprint(solve(s))"}
{"solution": "def min_bills(denominations, k, amount):\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    for coin in denominations:\n        for x in range(coin, amount + 1):\n            dp[x] = min(dp[x], dp[x - coin] + 1)\n    for x in range(1, amount + 1):\n        if dp[x] > k:\n            dp[x] = float('inf')\n    return dp[amount] if dp[amount] != float('inf') else -1\n\nn, k = map(int, input().split())\ndenominations = list(map(int, input().split()))\nq = int(input())\nrequests = [int(input()) for _ in range(q)]\n\nfor request in requests:\n    print(min_bills(denominations, k, request))"}
{"solution": "def min_time(s, x1, x2, t1, t2, p, d):\n    # Calculate the time Igor needs to reach the tram\n    if d == 1:\n        # Tram is moving towards x2\n        if p <= x1:\n            # Igor needs to wait for the tram\n            wait_time = (x1 - p) / t1\n        else:\n            # Igor needs to go back to meet the tram\n            wait_time = (p + s - x1) / t1\n    else:\n        # Tram is moving towards x1\n        if p >= x1:\n            # Igor needs to wait for the tram\n            wait_time = (p - x1) / t1\n        else:\n            # Igor needs to go back to meet the tram\n            wait_time = (x1 - p + s) / t1\n\n    # Calculate the time Igor needs to reach x2 from the tram\n    if d == 1:\n        # Tram is moving towards x2\n        if p <= x2:\n            # Igor can go directly to x2\n            travel_time = (x2 - p) / t2\n        else:\n            # Igor needs to go to s and then to x2\n            travel_time = (s - p + x2) / t2\n    else:\n        # Tram is moving towards x1\n        if p >= x2:\n            # Igor can go directly to x2\n            travel_time = (p - x2) / t2\n        else:\n            # Igor needs to go to 0 and then to x2\n            travel_time = (p + x2) / t2\n\n    # Return the total time\n    return wait_time + travel_time\n\n# Read the input\ns, x1, x2 = map(int, input().split())\nt1, t2 = map(int, input().split())\np, d = map(int, input().split())\n\n# Print the minimum time\nprint(min_time(s, x1, x2, t1, t2, p, d))"}
{"solution": "# Get the input\nn, x = map(int, input().split())\n\n# Initialize the count\ncount = 0\n\n# Iterate over the rows\nfor i in range(1, n + 1):\n    # If x is divisible by i, then check if x / i is within the range\n    if x % i == 0 and x // i <= n:\n        # If yes, then increment the count\n        count += 1\n\n# Print the count\nprint(count)"}
{"solution": "n, k = map(int, input().split())\npassword = ''\n\n# Add first k distinct lowercase letters to the password\nfor i in range(k):\n    password += chr(ord('a') + i)\n\n# Add remaining letters to the password\nfor i in range(n - k):\n    password += password[i % k]\n\n# Shift the password to ensure no two consecutive symbols are the same\npassword = password[1:] + password[0]\n\nprint(password)"}
{"solution": "# Read the input\nn = int(input())\ndirections = input()\npositions = list(map(int, input().split()))\n\n# Initialize the minimum time to infinity\nmin_time = float('inf')\n\n# Iterate over the particles\nfor i in range(n - 1):\n    # If the particles are moving towards each other\n    if directions[i] == 'R' and directions[i + 1] == 'L':\n        # Calculate the time to collision\n        time = (positions[i + 1] - positions[i]) // 2\n        # Update the minimum time\n        min_time = min(min_time, time)\n\n# Print the result\nif min_time == float('inf'):\n    print(-1)\nelse:\n    print(min_time)"}
{"solution": "def max_area(n, a, b, seals):\n    seals = [(min(x, y), max(x, y)) for x, y in seals]  # normalize seals\n    seals.sort(key=lambda x: x[0] * x[1], reverse=True)  # sort seals by area\n\n    def can_place(s1, s2):\n        return (s1[0] + s2[0] <= a and max(s1[1], s2[1]) <= b) or \\\n               (s1[1] + s2[1] <= a and max(s1[0], s2[0]) <= b)\n\n    for i in range(n):\n        for j in range(i):\n            if can_place(seals[i], seals[j]):\n                return seals[i][0] * seals[i][1] + seals[j][0] * seals[j][1]\n    return 0\n\nn, a, b = map(int, input().split())\nseals = [tuple(map(int, input().split())) for _ in range(n)]\nprint(max_area(n, a, b, seals))"}
{"solution": "n = int(input())\npoints = [list(map(int, input().split())) for _ in range(4*n + 1)]\n\nx_coords = [point[0] for point in points]\ny_coords = [point[1] for point in points]\n\nmin_x, max_x = min(x_coords), max(x_coords)\nmin_y, max_y = min(y_coords), max(y_coords)\n\nfor point in points:\n    if not (point[0] == min_x or point[0] == max_x or point[1] == min_y or point[1] == max_y):\n        print(point[0], point[1])\n        break"}
{"solution": "def max_product(n):\n    if n < 10:\n        return n\n\n    product = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    for i in range(10, n + 1):\n        num = i\n        prod = 1\n        while num > 0:\n            digit = num % 10\n            prod *= digit\n            num //= 10\n        product.append(prod)\n\n    return max(product)\n\nn = int(input())\nprint(max_product(n))"}
{"solution": "# Get the number of students\nn = int(input())\n\n# Get the list of votes for Elodreip\nvotes = list(map(int, input().split()))\n\n# Find the maximum number of votes Elodreip gets from a student\nmax_votes = max(votes)\n\n# Calculate the total number of votes Elodreip gets\nelodreip_votes = sum(votes)\n\n# Calculate the total number of votes all students have\ntotal_votes = n * max_votes\n\n# Calculate the minimum number of votes Awruk needs to win\nawruk_votes = elodreip_votes + 1\n\n# Calculate the minimum number of votes each student needs to have to make Awruk win\nk = awruk_votes + (total_votes - awruk_votes) // n\n\n# If the calculation results in a number of votes less than the maximum votes Elodreip gets from a student,\n# then Awruk needs to have one more vote than the maximum votes Elodreip gets from a student\nk = max(k, max_votes)\n\n# Print the result\nprint(k)"}
{"solution": "def delete_points(colors):\n    stack = []\n    operations = 0\n    for color in colors:\n        if not stack or stack[-1] == color:\n            stack.append(color)\n        else:\n            while stack and stack[-1] != color:\n                stack.pop()\n            if not stack:\n                stack.append(color)\n            operations += 1\n    return operations\n\ncolors = input()\nprint(delete_points(colors))"}
{"solution": "# Read the input\nn = int(input())\na = list(map(int, input().split()))\n\n# Sort the array\na.sort()\n\n# Initialize the count of triples\ncount = 0\n\n# Find the minimum product\nmin_product = a[0] * a[1] * a[2]\n\n# Iterate through the array\nfor i in range(n - 2):\n    for j in range(i + 1, n - 1):\n        for k in range(j + 1, n):\n            # If the product is equal to the minimum product, increment the count\n            if a[i] * a[j] * a[k] == min_product:\n                count += 1\n            # If the product is greater than the minimum product, break the loop\n            elif a[i] * a[j] * a[k] > min_product:\n                break\n\n# Print the count of triples\nprint(count)"}
{"solution": "def min_cuts(n):\n    # If there are no friends, no cuts are needed\n    if n == 0:\n        return 0\n    # If there is only one friend, one cut is needed\n    elif n == 1:\n        return 1\n    # If there are two friends, two cuts are needed\n    elif n == 2:\n        return 2\n    # For more than two friends, we can make a cut through the center\n    # and then divide the pizza into two halves. The number of cuts\n    # needed for each half is the same as the number of friends in\n    # that half. So, we recursively calculate the number of cuts\n    # needed for n//2 friends and add 1 for the cut through the center.\n    else:\n        return 1 + min_cuts(n // 2) + min_cuts(n - n // 2)\n\n# Read the input\nn = int(input())\n# Print the output\nprint(min_cuts(n))"}
{"solution": "# Get the input\nn = int(input())\n\n# If the number is positive, no need to change it\nif n >= 0:\n    print(n)\nelse:\n    # Convert the number to a list of digits\n    digits = list(str(n))\n\n    # If the number has only two digits, remove the last one\n    if len(digits) == 2:\n        print(int(digits[0]))\n    else:\n        # Remove the last digit and the digit before last, and choose the maximum\n        last_removed = int(''.join(digits[:-1]))\n        second_last_removed = int(''.join(digits[:-2] + [digits[-1]]))\n        print(max(last_removed, second_last_removed))"}
{"solution": "# Get the input\nstart, end = input().split()\nn = int(input())\n\n# Define the possible positions and their order\npositions = ['v', '>', '^', '<']\n\n# Find the starting and ending indices\nstart_index = positions.index(start)\nend_index = positions.index(end)\n\n# Calculate the difference in indices\ndiff = end_index - start_index\n\n# If the difference is negative, add 4 to make it positive\nif diff < 0:\n    diff += 4\n\n# If the difference is even, the direction is clockwise\nif diff % 2 == 0:\n    # If the difference is a multiple of 4, the direction is undefined\n    if diff % 4 == 0:\n        print('undefined')\n    else:\n        print('cw')\n# If the difference is odd, the direction is counter-clockwise\nelse:\n    print('ccw')"}
{"solution": "n = int(input())\ns = input()\n\n# Initialize an array to store the state of each domino\ndominoes = list(s)\n\n# Simulate the process\nfor _ in range(n):\n    for i in range(1, n):\n        # If the current domino is falling to the left\n        if dominoes[i] == 'L' and dominoes[i - 1] != 'R':\n            dominoes[i - 1] = 'L'\n        # If the current domino is falling to the right\n        elif dominoes[i] == 'R' and dominoes[i - 1] != 'L':\n            dominoes[i - 1] = 'R'\n\n# Count the number of dominoes that remain vertical\ncount = dominoes.count('.')\nprint(count)"}
{"solution": "def solve(n, m, leaders):\n    a = [0] * n\n    for i in range(m - 1, 0, -1):\n        diff = leaders[i] - leaders[i - 1]\n        if diff <= 0:\n            diff += n\n        if a[leaders[i - 1] - 1] != 0 and a[leaders[i - 1] - 1] != diff:\n            return [-1]\n        a[leaders[i - 1] - 1] = diff\n    for i in range(n):\n        if a[i] == 0:\n            for j in range(1, n + 1):\n                if j not in a:\n                    a[i] = j\n                    break\n    return a\n\nn, m = map(int, input().split())\nleaders = list(map(int, input().split()))\nprint(*solve(n, m, leaders))"}
{"solution": "def max_number(a, k):\n    a = list(str(a))\n    n = len(a)\n    for i in range(n):\n        if k <= 0:\n            break\n        max_idx = i\n        for j in range(i+1, min(n, i+k+1)):\n            if a[j] > a[max_idx]:\n                max_idx = j\n        k -= max_idx - i\n        a[i:max_idx+1] = [a[max_idx]] + a[i:max_idx]\n    return int(''.join(a))\n\na, k = map(int, input().split())\nprint(max_number(a, k))"}
{"solution": "def find_next_number(sequence):\n    # Check if the sequence is an arithmetic progression\n    if sequence[1] - sequence[0] == sequence[2] - sequence[1] == sequence[3] - sequence[2]:\n        return sequence[3] + (sequence[1] - sequence[0])\n    # Check if the sequence is a geometric progression\n    elif sequence[1] / sequence[0] == sequence[2] / sequence[1] == sequence[3] / sequence[2]:\n        return sequence[3] * (sequence[1] / sequence[0])\n    # If the sequence is neither arithmetic nor geometric\n    else:\n        return 42\n\n# Read the input sequence\nsequence = list(map(int, input().split()))\n# Print the next number in the sequence\nprint(find_next_number(sequence))"}
{"solution": "n = int(input())\ncolors = list(map(int, input().split()))\n\nfirst_occurrence = {}\nlast_occurrence = {}\n\nfor i in range(n):\n    if colors[i] not in first_occurrence:\n        first_occurrence[colors[i]] = i\n    last_occurrence[colors[i]] = i\n\nmax_distance = 0\nfor color in first_occurrence:\n    if color in last_occurrence and first_occurrence[color] != last_occurrence[color]:\n        max_distance = max(max_distance, n - first_occurrence[color] + last_occurrence[color] - 1)\n\nprint(max_distance)"}
{"solution": "# Get the input\nn, m, k = map(int, input().split())\n\n# Calculate the lane\nlane = (k - 1) // (2 * m) + 1\n\n# Calculate the desk\ndesk = ((k - 1) % (2 * m)) // 2 + 1\n\n# Calculate the side\nside = 'L' if k % 2 == 1 else 'R'\n\n# Print the output\nprint(lane, desk, side)"}
{"solution": "# Get the input\nn = int(input())\ns = input()\n\n# Count the number of each color\nb = s.count('B')\ng = s.count('G')\nr = s.count('R')\n\n# If there is at least one card of each color, the final card can be any color\nif b > 0 and g > 0 and r > 0:\n    print('BGR')\n# If there are no cards of two colors, the final card will be the same color as the initial cards\nelif b == 0:\n    print('G' if g > 0 else 'R')\nelif g == 0:\n    print('B' if b > 0 else 'R')\nelif r == 0:\n    print('B' if b > 0 else 'G')\n# If there are cards of only two colors, the final card can be the third color\nelse:\n    print('R' if b > 0 else 'B' if g > 0 else 'G')"}
