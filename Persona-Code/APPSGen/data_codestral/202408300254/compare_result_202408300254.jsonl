{"solution": "def find_max_accordion_length(s):\n    # Initialize the count of open and close brackets and colons\n    open_bracket_count = 0\n    close_bracket_count = 0\n    colon_count = 0\n    vertical_line_count = 0\n\n    # Iterate over the string\n    for char in s:\n        if char == '[':\n            open_bracket_count += 1\n        elif char == ']':\n            close_bracket_count += 1\n        elif char == ':':\n            colon_count += 1\n        elif char == '|':\n            vertical_line_count += 1\n\n    # If there are less than 2 colons or the number of open and close brackets are not equal, return -1\n    if colon_count < 2 or open_bracket_count != close_bracket_count:\n        return -1\n\n    # The maximum possible length of the accordion is 2 (for the colons) plus the number of vertical lines\n    return 2 + vertical_line_count\n\n# Read the input string\ns = input()\n\n# Print the maximum possible length of the accordion\nprint(find_max_accordion_length(s))"}
{"solution": "def max_sum_digits(x):\n    # Convert the number to string\n    num_str = str(x)\n\n    # Initialize the result with the input number\n    result = x\n\n    # Iterate over the digits of the number\n    for i in range(len(num_str)):\n        # If the current digit is not 9, replace it with 9\n        if num_str[i] != '9':\n            result = int(num_str[:i] + '9' + '0' * (len(num_str) - i - 1))\n            break\n\n    # If the result is greater than the input number,\n    # recursively call the function with the result - 1\n    if result > x:\n        return max_sum_digits(result - 1)\n    else:\n        return result\n\n# Read the input number\nx = int(input())\n\n# Print the result\nprint(max_sum_digits(x))"}
{"solution": "def next_lucky_year(n):\n    while True:\n        n += 1\n        if str(n).count('0') >= len(str(n)) - 1:\n            return n - int(input_year)\n\ninput_year = int(input())\nprint(next_lucky_year(input_year))"}
{"solution": "def max_painted_sections(n, q, painters):\n    # Initialize an array to store the painted sections\n    painted = [0] * n\n\n    # Mark the sections painted by each painter\n    for l, r in painters:\n        for i in range(l-1, r):\n            painted[i] = 1\n\n    # Initialize the maximum number of painted sections\n    max_painted = 0\n\n    # Try all combinations of hiring q-2 painters\n    for i in range(q):\n        for j in range(i+1, q):\n            # Create a new array to store the painted sections\n            new_painted = painted.copy()\n\n            # Mark the sections painted by the remaining painters\n            for k in range(q):\n                if k != i and k != j:\n                    for l, r in painters[k]:\n                        for m in range(l-1, r):\n                            new_painted[m] = 1\n\n            # Update the maximum number of painted sections\n            max_painted = max(max_painted, sum(new_painted))\n\n    return max_painted\n\n# Read the input\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Print the output\nprint(max_painted_sections(n, q, painters))"}
{"solution": "def is_lucky(time):\n    return '7' in time\n\ndef previous_time(hh, mm, x):\n    mm -= x\n    if mm < 0:\n        mm += 60\n        hh -= 1\n    if hh < 0:\n        hh += 24\n    return f'{hh:02d}:{mm:02d}'\n\nx = int(input())\nhh, mm = map(int, input().split())\n\ntime = f'{hh:02d}:{mm:02d}'\ncount = 0\n\nwhile not is_lucky(time):\n    time = previous_time(hh, mm, x)\n    count += 1\n\nprint(count)"}
{"solution": "# Read the input\nn, pos, l, r = map(int, input().split())\n\n# Calculate the minimum number of seconds required\n# to close all the tabs outside the segment [l, r]\nif pos < l:\n    # If the cursor is to the left of the segment,\n    # move it to the left end of the segment and close all tabs to the right,\n    # then move it to the right end of the segment and close all tabs to the left\n    result = l - pos + r - l\nelif pos > r:\n    # If the cursor is to the right of the segment,\n    # move it to the right end of the segment and close all tabs to the left,\n    # then move it to the left end of the segment and close all tabs to the right\n    result = pos - r + r - l\nelse:\n    # If the cursor is inside the segment,\n    # move it to the left end of the segment and close all tabs to the left,\n    # then move it to the right end of the segment and close all tabs to the right\n    result = min(pos - l, r - pos) * 2\n\n# Print the result\nprint(result)"}
{"solution": "import sys\n\ndef min_blows(n, x, d, h):\n    dp = [float('inf')] * (x + 1)\n    dp[0] = 0\n\n    for i in range(1, x + 1):\n        for j in range(n):\n            if d[j] < i:\n                dp[i] = min(dp[i], dp[i - d[j]] + 1 + dp[min(i + h[j], x)])\n            else:\n                dp[i] = min(dp[i], 1 + dp[min(i + h[j], x)])\n\n    return dp[x] if dp[x] != float('inf') else -1\n\ndef main():\n    t = int(sys.stdin.readline())\n\n    for _ in range(t):\n        n, x = map(int, sys.stdin.readline().split())\n        d = []\n        h = []\n\n        for _ in range(n):\n            di, hi = map(int, sys.stdin.readline().split())\n            d.append(di)\n            h.append(hi)\n\n        print(min_blows(n, x, d, h))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Read the input\nn, m = map(int, input().split())\n\n# Initialize the number of days\ndays = 0\n\n# Initialize the number of grains in the barn\ngrains = n\n\n# Loop until the barn is empty\nwhile grains > 0:\n    # Increase the number of days\n    days += 1\n\n    # Add the grains that are brought every day\n    grains += m\n\n    # Make sure the barn is not overfilled\n    grains = min(grains, n)\n\n    # Subtract the grains that are eaten by the sparrows\n    grains -= days\n\n# Print the number of days\nprint(days)"}
{"solution": "def min_tiles_to_draw(hand):\n    suits = {'m': [], 'p': [], 's': []}\n    for tile in hand:\n        suits[tile[1]].append(int(tile[0]))\n\n    for suit in suits.values():\n        suit.sort()\n        if len(suit) >= 3:\n            if suit[0] == suit[1] == suit[2] or (suit[0] + 1 == suit[1] and suit[1] + 1 == suit[2]):\n                return 0\n            elif len(suit) >= 4 and (suit[0] == suit[1] == suit[2] or suit[1] == suit[2] == suit[3]):\n                return 0\n            elif len(suit) >= 5 and (suit[0] + 1 == suit[1] and suit[2] == suit[3] == suit[4]):\n                return 1\n            elif len(suit) >= 6 and (suit[0] == suit[1] == suit[2] or suit[3] == suit[4] == suit[5]):\n                return 1\n\n    if len(suits[hand[0][1]]) >= 2 and len(suits[hand[1][1]]) >= 2 and len(suits[hand[2][1]]) >= 2:\n        return 2\n\n    return 3\n\nhand = input().split()\nprint(min_tiles_to_draw(hand))"}
{"solution": "def find_sofa(d, n, m, sofas, cnt_l, cnt_r, cnt_t, cnt_b):\n    left, right, top, bottom = [0] * d, [0] * d, [0] * d, [0] * d\n\n    for i in range(d):\n        x1, y1, x2, y2 = sofas[i]\n        for j in range(d):\n            if i == j:\n                continue\n            x3, y3, x4, y4 = sofas[j]\n            if x1 == x2:\n                if x1 < x3 and y1 == y3:\n                    left[i] += 1\n                if x1 > x4 and y1 == y4:\n                    right[i] += 1\n            else:\n                if y1 == y2:\n                    if y1 < y3 and x1 == x3:\n                        top[i] += 1\n                    if y1 > y4 and x1 == x4:\n                        bottom[i] += 1\n\n    for i in range(d):\n        if left[i] == cnt_l and right[i] == cnt_r and top[i] == cnt_t and bottom[i] == cnt_b:\n            return i + 1\n\n    return -1\n\nd = int(input())\nn, m = map(int, input().split())\nsofas = [list(map(int, input().split())) for _ in range(d)]\ncnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\nprint(find_sofa(d, n, m, sofas, cnt_l, cnt_r, cnt_t, cnt_b))"}
{"solution": "# Read the input\nn = int(input())\n\n# Calculate the minimum possible number of days off\nmin_days_off = n // 7 * 2\n\n# Calculate the maximum possible number of days off\nmax_days_off = min(n - 5, 2 + (n - 5) // 7 * 2)\n\n# Print the result\nprint(min_days_off, max_days_off)"}
{"solution": "# Get the input\nn, a, b, p, q = map(int, input().split())\n\n# Calculate the number of tiles that are divisible by a\ndivisible_by_a = n // a\n\n# Calculate the number of tiles that are divisible by b\ndivisible_by_b = n // b\n\n# Calculate the number of tiles that are divisible by both a and b\ndivisible_by_both = n // (a * b)\n\n# Calculate the maximum number of chocolates Joty can get\nmax_chocolates = (divisible_by_a - divisible_by_both) * p + (divisible_by_b - divisible_by_both) * q + divisible_by_both * max(p, q)\n\n# Print the result\nprint(max_chocolates)"}
{"solution": "n = int(input())\ntrophies = list(input())\n\n# Initialize variables to keep track of the maximum length of a subsegment of golden trophies\nmax_length = 0\ncurrent_length = 0\n\n# Initialize variables to keep track of the indices of the silver trophies\nsilver_indices = []\n\n# Iterate over the trophies\nfor i in range(n):\n    if trophies[i] == 'G':\n        # If the current trophy is golden, increment the current length\n        current_length += 1\n    else:\n        # If the current trophy is silver, add its index to the list of silver indices\n        silver_indices.append(i)\n        # Reset the current length\n        current_length = 0\n    # Update the maximum length\n    max_length = max(max_length, current_length)\n\n# If there are no silver trophies, print the maximum length and exit\nif not silver_indices:\n    print(max_length)\nelse:\n    # Initialize variables to keep track of the maximum possible length of a subsegment of golden trophies\n    # after at most one swap\n    max_possible_length = max_length\n    # Iterate over the silver indices\n    for i in silver_indices:\n        # If the current silver trophy is not at the beginning or the end of the sequence,\n        # and the two golden trophies on either side of it are adjacent,\n        # then swapping the current silver trophy with either of the golden trophies\n        # would result in a longer subsegment of golden trophies\n        if i > 0 and i < n - 1 and trophies[i - 1] == 'G' and trophies[i + 1] == 'G':\n            max_possible_length = max(max_possible_length, min(i, n - i - 1) + 1)\n    # Print the maximum possible length\n    print(max_possible_length)"}
{"solution": "from collections import deque, defaultdict\nimport sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    main_courses = set(map(int, sys.stdin.readline().split()))\n\n    dependencies = defaultdict(list)\n    for i in range(1, n + 1):\n        line = list(map(int, sys.stdin.readline().split()))\n        for j in line[1:]:\n            dependencies[j].append(i)\n\n    order = []\n    queue = deque([course for course in range(1, n + 1) if not dependencies[course]])\n    while queue:\n        course = queue.popleft()\n        if course in main_courses:\n            main_courses.remove(course)\n        order.append(course)\n        for dependent in dependencies:\n            if course in dependencies[dependent]:\n                dependencies[dependent].remove(course)\n                if not dependencies[dependent]:\n                    queue.append(dependent)\n\n    if main_courses:\n        print(-1)\n    else:\n        print(len(order))\n        print(' '.join(map(str, order)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    p = list(map(int, sys.stdin.readline().split()))\n\n    stack = []\n    b = []\n    i = 0\n    for num in range(1, n+1):\n        if i < k and num == p[i]:\n            stack.append(num)\n            i += 1\n        elif stack and stack[-1] < num:\n            b.append(stack.pop())\n        else:\n            stack.append(num)\n\n    while stack:\n        b.append(stack.pop())\n\n    if b == sorted(b):\n        while len(p) < n:\n            p.append(n)\n            n -= 1\n        print(*p)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Get the input values\na, b, c = map(int, input().split())\n\n# If the difference is 0, check if the first element is equal to Vasya's favorite number\nif c == 0:\n    if a == b:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n# If the difference is not 0, check if the difference divides the difference between the first element and Vasya's favorite number\nelse:\n    if (b - a) % c == 0 and (b - a) // c >= 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "# Read the input\ncnt_1 = int(input())\ncnt_2 = int(input())\ncnt_3 = int(input())\ncnt_4 = int(input())\n\n# Check if it is possible to form a regular bracket sequence\nif cnt_1 > 0 and cnt_4 > 0:\n    if cnt_1 > cnt_4 or cnt_3 > cnt_2:\n        print(0)\n    else:\n        print(1)\nelif cnt_1 == 0 and cnt_4 == 0:\n    print(1)\nelif cnt_2 > 0:\n    print(1)\nelse:\n    print(0)"}
{"solution": "# Get the input\nn, k, t = map(int, input().split())\n\n# Calculate the number of standing spectators\nif t <= k:\n    # In the first k seconds, t spectators are standing\n    standing = t\nelif t <= n:\n    # From k+1 to n seconds, k spectators are standing\n    standing = k\nelse:\n    # After n seconds, the wave goes back\n    standing = max(0, n - (t - n))\n\n# Print the result\nprint(standing)"}
{"solution": "s = input()\nt = ''\nu = ''\n\nwhile s:\n    if s[0] <= s[-1]:\n        t += s[0]\n        s = s[1:]\n    else:\n        t += s[-1]\n        s = s[:-1]\n\nwhile t:\n    u += t[-1]\n    t = t[:-1]\n\nprint(u)"}
{"solution": "def check_records(n, records):\n    prev_plays, prev_clears = records[0]\n    for plays, clears in records[1:]:\n        if plays < prev_plays or clears < prev_clears or clears > plays:\n            return False\n        prev_plays, prev_clears = plays, clears\n    return True\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        n = int(input())\n        records = [list(map(int, input().split())) for _ in range(n)]\n        if check_records(n, records):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def next_palindrome(time):\n    hour, minute = map(int, time.split(':'))\n    while True:\n        minute += 1\n        if minute == 60:\n            minute = 0\n            hour = (hour + 1) % 24\n        time = '{:02d}:{:02d}'.format(hour, minute)\n        if time == time[::-1]:\n            return time\n\ndef minutes_to_sleep(current_time):\n    next_time = next_palindrome(current_time)\n    next_hour, next_minute = map(int, next_time.split(':'))\n    current_hour, current_minute = map(int, current_time.split(':'))\n    minutes = (next_hour * 60 + next_minute) - (current_hour * 60 + current_minute)\n    if minutes < 0:\n        minutes += 24 * 60\n    return minutes\n\ncurrent_time = input()\nprint(minutes_to_sleep(current_time))"}
{"solution": "# Read the size of the permutation\nn = int(input())\n\n# Read the permutation\na = list(map(int, input().split()))\n\n# Find the indices of the minimum and maximum elements\nmin_index = a.index(1)\nmax_index = a.index(n)\n\n# Calculate the current distance between the minimum and maximum elements\ncurrent_distance = abs(min_index - max_index)\n\n# Calculate the maximum possible distance\nmax_distance = max(min_index, n - 1 - max_index)\n\n# Calculate the distance after swapping the minimum and maximum elements\nswapped_distance = abs(max_index - min_index - 1)\n\n# Print the maximum possible distance\nprint(max(current_distance, swapped_distance, max_distance))"}
{"solution": "def is_s_palindrome(s):\n    n = len(s)\n    for i in range(n // 2):\n        if s[i] != s[n - i - 1]:\n            return \"NIE\"\n    return \"TAK\"\n\ns = input()\nprint(is_s_palindrome(s))"}
{"solution": "from collections import Counter\n\ndef max_permutation(a, b):\n    a = str(a)\n    b = str(b)\n    count_b = Counter(b)\n    result = []\n    for digit in a:\n        while count_b[digit] > 0 and int(''.join(result + [digit])) <= int(b):\n            result.append(digit)\n            count_b[digit] -= 1\n        if count_b[digit] == 0:\n            break\n    for digit in sorted(count_b.elements(), reverse=True):\n        if int(''.join(result + [digit])) <= int(b):\n            result.append(digit)\n    return ''.join(result)\n\na = int(input())\nb = int(input())\nprint(max_permutation(a, b))"}
{"solution": "def check_win(board, player):\n    for i in range(10):\n        for j in range(10):\n            if i < 6 and board[i][j] == board[i+1][j] == board[i+2][j] == board[i+3][j] == board[i+4][j] == player:\n                return True\n            if j < 6 and board[i][j] == board[i][j+1] == board[i][j+2] == board[i][j+3] == board[i][j+4] == player:\n                return True\n            if i < 6 and j < 6 and board[i][j] == board[i+1][j+1] == board[i+2][j+2] == board[i+3][j+3] == board[i+4][j+4] == player:\n                return True\n            if i < 6 and j > 3 and board[i][j] == board[i+1][j-1] == board[i+2][j-2] == board[i+3][j-3] == board[i+4][j-4] == player:\n                return True\n    return False\n\nboard = [list(input()) for _ in range(10)]\n\nfor i in range(10):\n    for j in range(10):\n        if board[i][j] == '.':\n            board[i][j] = 'X'\n            if check_win(board, 'X'):\n                print('YES')\n                exit()\n            board[i][j] = '.'\nprint('NO')"}
{"solution": "n, k = map(int, input().split())\n\n# Check if it's possible to create the matrix\nif k > n * n or k < n:\n    print(-1)\nelse:\n    # Create an empty n x n matrix\n    matrix = [[0] * n for _ in range(n)]\n\n    # Fill the matrix\n    for i in range(n):\n        for j in range(i, n):\n            if k >= n - i:\n                matrix[i][j] = matrix[j][i] = 1\n                k -= n - i\n            if k == 0:\n                break\n\n    # Print the matrix\n    for row in matrix:\n        print(' '.join(map(str, row)))"}
{"solution": "# Get the input\nx, y, z = map(float, input().split())\n\n# Calculate all the possibilities\npossibilities = [\n    x ** y ** z,\n    x ** z ** y,\n    (x ** y) ** z,\n    (x ** z) ** y,\n    y ** x ** z,\n    y ** z ** x,\n    (y ** x) ** z,\n    (y ** z) ** x,\n    z ** x ** y,\n    z ** y ** x,\n    (z ** x) ** y,\n    (z ** y) ** x\n]\n\n# Find the maximum value and its index\nmax_value = max(possibilities)\nmax_index = possibilities.index(max_value) + 1\n\n# Print the corresponding expression\nexpressions = [\n    \"x^y^z\",\n    \"x^z^y\",\n    \"(x^y)^z\",\n    \"(x^z)^y\",\n    \"y^x^z\",\n    \"y^z^x\",\n    \"(y^x)^z\",\n    \"(y^z)^x\",\n    \"z^x^y\",\n    \"z^y^x\",\n    \"(z^x)^y\",\n    \"(z^y)^x\"\n]\nprint(expressions[max_index - 1])"}
{"solution": "n = int(input())\ns = input()\n\n# Initialize the minimum number of operations as the length of the string\nmin_operations = n\n\n# Iterate over all possible lengths of the prefix\nfor i in range(1, n // 2 + 1):\n    # Check if the prefix repeats to form the string\n    if s[:i] * (n // i) == s[:n // i * i]:\n        # Calculate the number of operations required\n        operations = i + 1 if n % i > 0 else i\n        # Update the minimum number of operations\n        min_operations = min(min_operations, operations)\n\nprint(min_operations)"}
{"solution": "n = int(input())\nfiles = []\nfor _ in range(n):\n    name, type = input().split()\n    files.append((name, int(type)))\n\nexamples = [file[0] for file in files if file[1] == 1]\nregular = [file[0] for file in files if file[1] == 0]\n\nscript = []\nfor i, example in enumerate(examples):\n    script.append(f\"move {example} {i+1}\")\n\nfor i, reg in enumerate(regular):\n    script.append(f\"move {reg} {len(examples)+i+1}\")\n\nprint(len(script))\nfor line in script:\n    print(line)"}
{"solution": "# Get the input ticket number\nticket = input()\n\n# Calculate the sum of the first three digits\nsum_first_half = sum(int(digit) for digit in ticket[:3])\n\n# Calculate the sum of the last three digits\nsum_second_half = sum(int(digit) for digit in ticket[3:])\n\n# Calculate the minimum number of digits that need to be replaced\nmin_replacements = abs(sum_first_half - sum_second_half)\n\n# Print the result\nprint(min_replacements)"}
{"solution": "def calculate_gcd(a, b):\n    if b == 0:\n        return a\n    return calculate_gcd(b, a % b)\n\ndef calculate_order(x, m):\n    if calculate_gcd(x, m) != 1:\n        return -1\n    result = 1\n    value = x\n    while value != 1:\n        value = (value * x) % m\n        result += 1\n    return result\n\nm, x = map(int, input().split())\nprint(calculate_order(x, m))"}
{"solution": "def extended_euclidean(a, b):\n    if b == 0:\n        return a, 1, 0\n    else:\n        gcd, x, y = extended_euclidean(b, a % b)\n        return gcd, y, x - (a // b) * y\n\ndef modular_inverse(a, m):\n    gcd, x, y = extended_euclidean(a, m)\n    return x % m\n\ndef calculate_probability(n, k):\n    mod = 10**6 + 3\n    numerator = 1\n    denominator = 1\n    for i in range(2**n, 2**n - k, -1):\n        numerator = (numerator * i) % mod\n        denominator = (denominator * (2**n)) % mod\n    gcd = extended_euclidean(numerator, denominator)[0]\n    numerator = (numerator // gcd) % mod\n    denominator = (denominator // gcd) % mod\n    return (denominator - numerator) % mod, denominator\n\nn, k = map(int, input().split())\nA, B = calculate_probability(n, k)\nprint(A, B)"}
{"solution": "n = int(input())\nposition = [0, 0]  # [latitude, longitude]\n\nfor _ in range(n):\n    t, dir = input().split()\n    t = int(t)\n\n    if dir == \"North\":\n        position[0] += t\n    elif dir == \"South\":\n        position[0] -= t\n    elif dir == \"East\":\n        position[1] += t\n    elif dir == \"West\":\n        position[1] -= t\n\n    # Check if Limak is on the North Pole and moving South\n    if position[0] > 20000:\n        print(\"NO\")\n        exit()\n\n    # Check if Limak is on the South Pole and moving North\n    if position[0] < -20000:\n        print(\"NO\")\n        exit()\n\n    # Make sure latitude and longitude are within valid range\n    position[0] = max(-20000, min(20000, position[0]))\n    position[1] = max(-40000, min(40000, position[1]))\n\n# Check if Limak is on the North Pole\nif position[0] == 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def solve(a1, b1, a2, b2, L, R):\n    if a1 == a2:\n        if b1 == b2 and L <= b1 <= R:\n            return R - L + 1\n        else:\n            return 0\n    else:\n        if (b2 - b1) % (a1 - a2) != 0:\n            return 0\n        else:\n            k = (b2 - b1) // (a1 - a2)\n            if k < 0:\n                return 0\n            else:\n                x = a1 * k + b1\n                if L <= x <= R:\n                    return min(R, a1 * (k + (R - x) // a1)) - max(L, a1 * (k + (L - x) // a1)) + 1\n                else:\n                    return 0\n\na1, b1, a2, b2, L, R = map(int, input().split())\nprint(solve(a1, b1, a2, b2, L, R))"}
{"solution": "# Get the input\nn, a, b = map(int, input().split())\n\n# Calculate the maximum possible number x\nx = min(a, b, n)\n\n# Print the result\nprint(x)"}
{"solution": "n, m = map(int, input().split())\nflag = [input() for _ in range(n)]\n\n# Check if the flag is valid\ndef is_valid(flag):\n    # Check if the flag can be divided into three equal parts\n    if n % 3 != 0 or m % 3 != 0:\n        return False\n\n    # Check if each part contains only one color\n    for i in range(3):\n        for j in range(3):\n            color = flag[i * n // 3][j * m // 3]\n            for x in range(i * n // 3, (i + 1) * n // 3):\n                for y in range(j * m // 3, (j + 1) * m // 3):\n                    if flag[x][y] != color:\n                        return False\n\n    # Check if all colors are used\n    colors = set()\n    for row in flag:\n        colors.update(row)\n    return len(colors) == 3\n\n# Print the result\nif is_valid(flag):\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "# Read the input\nn = int(input())\n\n# Calculate the segment number\nsegment = n // 6\n\n# Calculate the direction of the current move within the segment\ndirection = n % 6\n\n# Initialize the coordinates\nx, y = 0, 0\n\n# Calculate the offsets based on the direction and the segment number\nif direction == 0:\n    x = segment\nelif direction == 1:\n    x = segment\n    y = -segment\nelif direction == 2:\n    y = -segment\nelif direction == 3:\n    x = -segment\n    y = segment\nelif direction == 4:\n    x = -segment\nelif direction == 5:\n    y = segment\n\n# Calculate the remaining moves within the segment\nremaining_moves = n % 6\n\n# Calculate the final coordinates based on the remaining moves\nif direction == 0:\n    y -= remaining_moves\nelif direction == 1:\n    x -= remaining_moves\nelif direction == 2:\n    x -= remaining_moves\n    y += remaining_moves\nelif direction == 3:\n    y += remaining_moves\nelif direction == 4:\n    x += remaining_moves\nelif direction == 5:\n    y -= remaining_moves\n\n# Print the final coordinates\nprint(x, y)"}
{"solution": "# Get the input\na, b, c = map(int, input().split())\n\n# Check if it's possible to deal exactly c damage\nfor i in range(c // a + 1):\n    if (c - i * a) % b == 0:\n        print('Yes')\n        break\nelse:\n    print('No')"}
{"solution": "def solve():\n    n, L = map(int, input().split())\n    kefa = list(map(int, input().split()))\n    sasha = list(map(int, input().split()))\n\n    # Calculate the differences between consecutive barriers for both Kefa and Sasha\n    kefa_diff = [kefa[i] - kefa[i - 1] for i in range(1, n)] + [L - kefa[-1] + kefa[0]]\n    sasha_diff = [sasha[i] - sasha[i - 1] for i in range(1, n)] + [L - sasha[-1] + sasha[0]]\n\n    # Check if the differences are the same for both Kefa and Sasha\n    for i in range(n):\n        if kefa_diff == sasha_diff:\n            print(\"YES\")\n            return\n        # Rotate the differences list for Sasha\n        sasha_diff = sasha_diff[1:] + [sasha_diff[0]]\n\n    print(\"NO\")\n\nsolve()"}
{"solution": "def longest_non_palindrome_substring(s):\n    n = len(s)\n    max_length = 0\n\n    for i in range(n):\n        for j in range(i+1, n+1):\n            substring = s[i:j]\n            if substring != substring[::-1]:\n                max_length = max(max_length, len(substring))\n\n    return max_length\n\ns = input()\nprint(longest_non_palindrome_substring(s))"}
{"solution": "n = int(input())\nratings = []\nfor _ in range(n):\n    a, b = map(int, input().split())\n    ratings.append((a, b))\n\nrated = any(a != b for a, b in ratings)\nunrated = all(a >= b for a, b in ratings for c, d in ratings if a < c and b > d)\n\nif rated:\n    print(\"rated\")\nelif unrated:\n    print(\"unrated\")\nelse:\n    print(\"maybe\")"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Initialize the list to store the distances\ndistances = [0] * n\n\n# Initialize the variables to store the last zero index and the distance to it\nlast_zero = float('-inf')\ndist = float('inf')\n\n# Iterate over the array from left to right\nfor i in range(n):\n    # If the current element is zero, update the last zero index and reset the distance\n    if a[i] == 0:\n        last_zero = i\n        dist = 0\n    # Otherwise, update the distance to the last zero index\n    else:\n        dist = min(dist, abs(i - last_zero))\n    # Store the distance in the distances list\n    distances[i] = dist\n\n# Reset the variables to store the last zero index and the distance to it\nlast_zero = float('inf')\ndist = float('inf')\n\n# Iterate over the array from right to left\nfor i in range(n - 1, -1, -1):\n    # If the current element is zero, update the last zero index and reset the distance\n    if a[i] == 0:\n        last_zero = i\n        dist = 0\n    # Otherwise, update the distance to the last zero index\n    else:\n        dist = min(dist, abs(i - last_zero))\n    # Update the distance in the distances list if it is smaller than the current distance\n    distances[i] = min(distances[i], dist)\n\n# Print the distances list\nprint(*distances)"}
{"solution": "def z_function(string):\n    # Initialize the Z-function array with zeros\n    z_function_array = [0] * len(string)\n    left, right = 0, 0\n    for i in range(1, len(string)):\n        if i <= right:\n            z_function_array[i] = min(z_function_array[i - left], right - i + 1)\n        while i + z_function_array[i] < len(string) and string[z_function_array[i]] == string[i + z_function_array[i]]:\n            z_function_array[i] += 1\n        if i + z_function_array[i] - 1 > right:\n            left, right = i, i + z_function_array[i] - 1\n    return z_function_array\n\ndef count_substrings(n, s):\n    # Double the string s and add a separator character\n    doubled_string = s + '#' + s + s\n    # Calculate the Z-function array for the doubled string\n    z_function_array = z_function(doubled_string)\n    # Initialize the dynamic programming array with zeros\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    # Calculate the number of distinct cyclical binary strings that contain s as a substring\n    for i in range(1, n + 1):\n        for j in range(len(s), i):\n            if z_function_array[j] >= len(s):\n                dp[i] += dp[i - j]\n        dp[i] = (1 << i) - dp[i]\n    # Return the number of distinct cyclical binary strings that contain s as a substring\n    return dp[n]\n\n# Read the input\nn = int(input())\ns = input()\n# Print the output\nprint(count_substrings(n, s))"}
{"solution": "import math\n\ndef find_min_angle_vectors(vectors):\n    n = len(vectors)\n    angles = [math.atan2(y, x) for x, y in vectors]\n    angles.sort()\n    angles += [angle + 2 * math.pi for angle in angles]\n    min_angle = float('inf')\n    pair = (0, 0)\n    for i in range(n):\n        angle_diff = angles[i + n] - angles[i]\n        if angle_diff < min_angle:\n            min_angle = angle_diff\n            pair = (i + 1, i + n - 1)\n    return pair\n\nn = int(input())\nvectors = [tuple(map(int, input().split())) for _ in range(n)]\nresult = find_min_angle_vectors(vectors)\nprint(*result)"}
{"solution": "def min_time(d, k, a, b, t):\n    time = 0\n    while d > 0:\n        if d > k:\n            time += k * a\n            d -= k\n            if a < b:\n                time += t\n        else:\n            time += d * a\n            d = 0\n        if d > 0 and a > b:\n            time += min(d, k) * (b - a)\n            d = max(0, d - k)\n    return time\n\nd, k, a, b, t = map(int, input().split())\nprint(min_time(d, k, a, b, t))"}
{"solution": "def max_gcd_sequence(n, k):\n    # Check if it's possible to create such sequence\n    if k > n or (k * (k + 1)) // 2 > n:\n        return [-1]\n\n    # Calculate the maximum possible GCD\n    gcd = n // k\n\n    # Create the sequence\n    sequence = list(range(1, k))\n    sequence.append(n - sum(sequence))\n\n    return sequence\n\n# Read input\nn, k = map(int, input().split())\n\n# Get the sequence\nsequence = max_gcd_sequence(n, k)\n\n# Print the output\nprint(*sequence)"}
{"solution": "def count_pairs(n, m):\n    count = 0\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if (i + j) % 5 == 0:\n                count += 1\n    return count\n\nn, m = map(int, input().split())\nprint(count_pairs(n, m))"}
{"solution": "import sys\n\ndef max_beauty(n, x, a):\n    max_ending_here = max_so_far = 0\n    for i in range(n):\n        max_ending_here = max(0, max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n\n    max_ending_here = max_so_far_left = max_so_far_right = 0\n    for i in range(n):\n        max_ending_here = max(0, max_ending_here + a[i] * x)\n        max_so_far_left = max(max_so_far_left, max_ending_here)\n        if max_ending_here == max_ending_here + a[i] * x:\n            max_so_far_right = max(max_so_far_right, max_ending_here + max_so_far - a[i])\n\n    return max(max_so_far, max_so_far_left, max_so_far_right)\n\ndef main():\n    n, x = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    print(max_beauty(n, x, a))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def count_numbers(n, m, x):\n    count = 0\n    for i in range(1, n + 1):\n        count += min(m, x // i)\n    return count\n\ndef find_kth_largest(n, m, k):\n    left, right = 1, n * m\n    while left < right:\n        mid = (left + right) // 2\n        if count_numbers(n, m, mid) < k:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\nn, m, k = map(int, input().split())\nprint(find_kth_largest(n, m, k))"}
{"solution": "def find_kth_digit(k):\n    if k < 10:\n        return k\n\n    base = 9\n    digits = 1\n\n    while k > base * digits:\n        k -= base * digits\n        base *= 10\n        digits += 1\n\n    num = 10 ** (digits - 1) + (k - 1) // digits\n    return int(str(num)[(k - 1) % digits])\n\nk = int(input())\nprint(find_kth_digit(k))"}
{"solution": "# Read input\nn, m, r = map(int, input().split())\ns = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Find the minimum price to buy and maximum price to sell\nmin_buy = min(s)\nmax_sell = max(b)\n\n# If it's profitable to buy and sell, calculate the maximum amount of money\nif max_sell > min_buy:\n    # Buy as many shares as possible at the minimum price\n    shares = r // min_buy\n    # Sell all shares at the maximum price\n    r += shares * max_sell\n\n# Print the result\nprint(r)"}
{"solution": "def find_error(t):\n    n = len(t)\n    for i in range(1, n // 2 + 1):\n        if n % i == 0 and t[:i] * (n // i) == t:\n            return t[:i]\n    return None\n\nt = input()\ns = find_error(t)\nif s is None:\n    print('NO')\nelse:\n    print('YES')\n    print(s)"}
{"solution": "import math\n\ndef find_teams(n):\n    # Check if n is a valid number of games\n    if n % 2 != 0:\n        return [-1]\n\n    # Find the largest power of 2 that is less than or equal to n\n    power = int(math.log2(n))\n\n    # Calculate the number of teams for this power\n    teams = 2 ** (power + 1)\n\n    # Calculate the remaining number of games\n    remaining = n - (teams // 2)\n\n    # If there are remaining games, find the number of teams that can play a round robin tournament with this number of games\n    if remaining > 0:\n        # Calculate the number of teams that can play a round robin tournament with this number of games\n        round_robin_teams = 1 + int(math.sqrt(2 * remaining + 0.25))\n\n        # If this number of teams is odd, it is a valid solution\n        if round_robin_teams % 2 != 0:\n            teams += round_robin_teams\n            return [teams]\n\n    # If there are no remaining games, the initial number of teams is a valid solution\n    return [teams]\n\n# Read the input\nn = int(input())\n\n# Find the possible numbers of teams\nteams = find_teams(n)\n\n# Print the output\nfor team in teams:\n    print(team)"}
{"solution": "from collections import Counter\n\n# Get the input\nn = int(input())\ns = input()\nb = list(map(int, input().split()))\n\n# Count the occurrences of each character in the string\ncounter = Counter(s)\n\n# Initialize the maximum possible beauty\nmax_beauty = 0\n\n# Iterate over the characters and their occurrences\nfor char, count in counter.items():\n    # If the count is odd, we need to pair one character with a different one\n    if count % 2 == 1:\n        # Find the maximum beauty for the middle character\n        mid_index = n // 2\n        mid_beauty = b[mid_index]\n\n        # Find the maximum beauty for the pairing character\n        pair_beauty = max(b[i] for i in range(n) if s[i] != char)\n\n        # Add the maximum beauty of the pair to the total\n        max_beauty += pair_beauty\n\n        # Decrease the count of the pairing character\n        counter[s[n - mid_index - 1]] -= 1\n\n    # Pair the remaining characters\n    for _ in range(count // 2):\n        # Find the maximum beauty for the first character\n        first_index = next(i for i in range(n) if s[i] == char and b[i] > 0)\n        first_beauty = b[first_index]\n\n        # Find the maximum beauty for the second character\n        second_index = next(i for i in range(n - 1, -1, -1) if s[i] == char and b[i] > 0 and i != first_index)\n        second_beauty = b[second_index]\n\n        # Add the maximum beauty of the pair to the total\n        max_beauty += first_beauty + second_beauty\n\n        # Set the beauty of the used characters to 0\n        b[first_index] = 0\n        b[second_index] = 0\n\n# Print the maximum possible beauty\nprint(max_beauty)"}
{"solution": "# Read the input\nw, m = map(int, input().split())\n\n# Check if it is possible to weigh the item\nif m % w == 0 or m % w == w - 1:\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "def solve(n, k):\n    if n == 1 and k == 1:\n        return [0]\n    if n < k or (n & (n - 1)) == 0:\n        return None\n    result = []\n    i = 60\n    while n > 0 and k > 0 and i >= 0:\n        if n & (1 << i):\n            result.append(i)\n            n -= 1 << i\n            k -= 1\n        i -= 1\n    if k > 0 or n > 0:\n        return None\n    return result[::-1]\n\nn, k = map(int, input().split())\nresult = solve(n, k)\nif result is None:\n    print(\"No\")\nelse:\n    print(\"Yes\")\n    print(\" \".join(map(str, result)))"}
{"solution": "def champagne_tower(n, t):\n    # Initialize the tower with 0\n    tower = [[0.0] * k for k in range(1, n+2)]\n\n    # Pour champagne into the top glass\n    tower[0][0] = t\n\n    # Simulate the flow of champagne\n    for r in range(n):\n        for c in range(r+1):\n            q = (tower[r][c] - 1.0) / 2.0\n            if q > 0:\n                tower[r+1][c] += q\n                tower[r+1][c+1] += q\n\n    # Count the number of full glasses\n    full_glasses = sum(x >= 1 for row in tower for x in row)\n\n    return full_glasses\n\n# Read input\nn, t = map(int, input().split())\n\n# Print output\nprint(champagne_tower(n, t))"}
{"solution": "# Get the number of remaining vertices\nn = int(input())\n\n# Initialize lists to store x and y coordinates\nx_coords = []\ny_coords = []\n\n# Get the coordinates of the remaining vertices\nfor _ in range(n):\n    x, y = map(int, input().split())\n    x_coords.append(x)\n    y_coords.append(y)\n\n# If there are less than 3 vertices, the area cannot be determined\nif n < 3:\n    print(-1)\nelse:\n    # Sort the coordinates\n    x_coords.sort()\n    y_coords.sort()\n\n    # If there are exactly 3 vertices, the missing vertex is the one that makes the rectangle\n    if n == 3:\n        # The width and height of the rectangle are the differences between the largest and smallest coordinates\n        width = x_coords[2] - x_coords[0]\n        height = y_coords[2] - y_coords[0]\n    # If there are 4 vertices, the width and height are the differences between the second and third coordinates\n    else:\n        width = x_coords[2] - x_coords[1]\n        height = y_coords[2] - y_coords[1]\n\n    # Print the area of the rectangle\n    print(width * height)"}
{"solution": "# Read the input\nn = int(input())\na = int(input())\nb = int(input())\n\n# Calculate the total length of wood needed for two doors\ntotal_length = 2 * (2 * a + b)\n\n# Calculate the minimal number of wooden bars needed\nmin_bars = total_length // n\nif total_length % n != 0:\n    min_bars += 1\n\n# Print the result\nprint(min_bars)"}
{"solution": "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    swaps = input()\n\n    # Create a list of indices sorted by the values in a\n    sorted_indices = sorted(range(n), key=lambda k: a[k])\n\n    # Check if it is possible to sort the array\n    for i in range(n - 1):\n        if swaps[i] == '1':\n            # If swapping is allowed, check if the sorted index is to the right of the current index\n            if sorted_indices[i] > sorted_indices[i + 1]:\n                sorted_indices[i], sorted_indices[i + 1] = sorted_indices[i + 1], sorted_indices[i]\n        else:\n            # If swapping is not allowed, check if the sorted index is the same as the current index\n            if sorted_indices[i] != i:\n                print(\"NO\")\n                return\n\n    # If the array is sorted, print \"YES\"\n    if sorted_indices == list(range(n)):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nsolve()"}
{"solution": "# Get input\nseat = input()\n\n# Extract row number and seat letter\nrow = int(seat[:-1])\nseat_letter = seat[-1]\n\n# Define the order of seats\nseat_order = ['f', 'e', 'd', 'c', 'b', 'a']\n\n# Calculate the time it takes for the attendants to serve the rows before Vasya's row\ntime = (row - 1) // 2 * 6\n\n# Calculate the time it takes for the attendants to serve the seats before Vasya's seat in Vasya's row\ntime += seat_order.index(seat_letter)\n\n# If Vasya's row is served by the second attendant, add the time it takes for the first attendant to serve the first row\nif row % 2 == 0:\n    time += 6\n\nprint(time)"}
{"solution": "# Read input\nn, b_x = map(int, input().split())\nx_digits = list(map(int, input().split()))\nm, b_y = map(int, input().split())\ny_digits = list(map(int, input().split()))\n\n# Convert to base 10\nx = sum(x_digits[i] * (b_x ** (n - i - 1)) for i in range(n))\ny = sum(y_digits[i] * (b_y ** (m - i - 1)) for i in range(m))\n\n# Compare\nif x < y:\n    print('<')\nelif x > y:\n    print('>')\nelse:\n    print('=')"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# If there is a 0 in the list, BitAryo can always win by choosing x = 1 and decreasing that 0.\nif 0 in a:\n    print('BitAryo')\n# If all numbers are equal, the game length is even, so BitLGM wins. Otherwise, BitAryo wins.\nelif len(set(a)) == 1:\n    print('BitLGM' if n % 2 == 0 else 'BitAryo')\n# If there are exactly two different numbers, and the smaller one is 1, BitAryo can always win by choosing x = 1 and decreasing all numbers by 1.\nelif len(set(a)) == 2 and min(a) == 1:\n    print('BitAryo')\n# In all other cases, BitLGM can win.\nelse:\n    print('BitLGM')"}
{"solution": "import sys\nfrom math import gcd\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef main():\n    n, k = map(int, read_input().split())\n    a = list(map(int, read_input().split()))\n\n    g = [0] * (n + 1)\n    g[n] = a[n - 1]\n    for i in range(n - 1, 0, -1):\n        g[i] = gcd(g[i + 1], a[i - 1])\n\n    count = 0\n    if g[1] == 1:\n        for i in range(1, n + 1):\n            if a[i - 1] % k == 0:\n                while a[i - 1] % k == 0:\n                    a[i - 1] //= k\n                if g[i] == 1:\n                    count += 1\n    else:\n        while k % g[1] == 0:\n            k //= g[1]\n        if k == 1:\n            count = n * (n + 1) // 2\n\n    print(count)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Get the input\nn, k = map(int, input().split())\ns = input()\n\n# Count the frequency of each color\nfreq = {}\nfor color in s:\n    if color in freq:\n        freq[color] += 1\n    else:\n        freq[color] = 1\n\n# Check if it's possible to distribute the balloons\npossible = True\nfor color in freq:\n    if freq[color] > k:\n        possible = False\n        break\n\n# Print the result\nif possible:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "# Read the size of the array\nn = int(input())\n\n# Read the array\narr = list(map(int, input().split()))\n\n# Find the minimum value in the array\nmin_val = min(arr)\n\n# Initialize the minimum distance to a large number\nmin_dist = float('inf')\n\n# Initialize the previous index to -1\nprev_idx = -1\n\n# Iterate over the array\nfor i in range(n):\n    # If the current element is the minimum value\n    if arr[i] == min_val:\n        # If this is not the first occurrence of the minimum value\n        if prev_idx != -1:\n            # Update the minimum distance\n            min_dist = min(min_dist, i - prev_idx)\n        # Update the previous index\n        prev_idx = i\n\n# Print the minimum distance\nprint(min_dist)"}
{"solution": "import math\n\ndef gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_steps(length, step):\n    return length // step if length % step == 0 else length // step + 1\n\ndef solve(t, w, b):\n    lcm_wb = lcm(w, b)\n    count_lcm = count_steps(t, lcm_wb)\n    count_w = count_steps(t, w)\n    count_b = count_steps(t, b)\n    count_tie = count_w + count_b - count_lcm\n    return count_tie, t\n\nt, w, b = map(int, input().split())\nnumerator, denominator = solve(t, w, b)\ngcd_val = math.gcd(numerator, denominator)\nprint(f\"{numerator // gcd_val}/{denominator // gcd_val}\")"}
{"solution": "x, y, z = map(int, input().split())\n\nif x > y + z or y > x + z:\n    print(\"+\" if x > y else \"-\")\nelif x < y or y < x:\n    print(\"+\" if y < x else \"-\")\nelse:\n    print(\"?\" if z > 0 else \"0\")"}
{"solution": "def min_subsequence_length(n, operations, x, y):\n    current_x, current_y = 0, 0\n    directions = {'U': (0, 1), 'D': (0, -1), 'L': (-1, 0), 'R': (1, 0)}\n    min_length = float('inf')\n    start, end = 0, 0\n\n    while end < n:\n        current_x += directions[operations[end]][0]\n        current_y += directions[operations[end]][1]\n\n        while start <= end and (current_x != x or current_y != y):\n            current_x -= directions[operations[start]][0]\n            current_y -= directions[operations[start]][1]\n            start += 1\n\n        if current_x == x and current_y == y:\n            min_length = min(min_length, end - start + 1)\n\n        end += 1\n\n    return -1 if min_length == float('inf') else min_length\n\nn = int(input())\noperations = input()\nx, y = map(int, input().split())\n\nprint(min_subsequence_length(n, operations, x, y))"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    n, x = map(int, sys.stdin.readline().split())\n    s = sys.stdin.readline().strip()\n\n    balance = 0\n    count = defaultdict(int)\n    count[0] = 1\n    result = 0\n\n    for i in range(n):\n        balance += 1 if s[i] == '1' else -1\n        if balance - x in count:\n            result += count[balance - x]\n        count[balance] += 1\n\n    if balance == x:\n        result += 1\n\n    if balance == 0 and x == 0:\n        return -1\n\n    return result\n\ndef main():\n    t = int(sys.stdin.readline())\n    for _ in range(t):\n        print(solve())\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n, k = map(int, input().split())\nn = str(n)\n\n# Find the index of the k-th digit from the right\nindex = len(n) - k\n\n# Count the number of digits to be deleted\ncount = 0\nwhile index < len(n) and n[index] != '0':\n    count += 1\n    index += 1\n\n# If the number ends with k zeros, no need to delete any digit\nif index == len(n):\n    print(0)\nelse:\n    print(count)"}
{"solution": "def calculate_questions(n, m, k, x, y):\n    total_students = n * m\n    cycle_length = 2 * (n - 1) if n > 1 else 1\n    full_cycles = k // total_students\n    remaining_questions = k % total_students\n\n    max_questions = full_cycles * cycle_length + min(remaining_questions, cycle_length)\n    min_questions = full_cycles * cycle_length\n\n    if remaining_questions > cycle_length:\n        min_questions += 1\n        if (remaining_questions - cycle_length) % n == x - 1:\n            min_questions += 1\n\n    sergei_questions = full_cycles * 2\n    if remaining_questions >= (x - 1) * m + y:\n        sergei_questions += 1\n        if remaining_questions >= (x - 1 + n - 1) * m + y and n > 1:\n            sergei_questions += 1\n\n    return max_questions, min_questions, sergei_questions\n\nn, m, k, x, y = map(int, input().split())\nmax_questions, min_questions, sergei_questions = calculate_questions(n, m, k, x, y)\nprint(max_questions, min_questions, sergei_questions)"}
{"solution": "from collections import Counter\n\ndef max_beauty(ribbon):\n    n = len(ribbon)\n    counter = Counter(ribbon)\n    max_freq = max(counter.values())\n    max_subribbon_len = 1\n    for i in range(n):\n        for j in range(i+1, n):\n            if ribbon[i:j] == ribbon[j:j+j-i]:\n                max_subribbon_len = max(max_subribbon_len, j-i)\n    return min(max_freq, n // max_subribbon_len)\n\nn = int(input())\nribbons = [input() for _ in range(3)]\nbeauties = [max_beauty(ribbon) for ribbon in ribbons]\nmax_beauty = max(beauties)\nwinners = [name for name, beauty in zip([\"Kuro\", \"Shiro\", \"Katie\"], beauties) if beauty == max_beauty]\nprint(\"Draw\" if len(winners) > 1 else winners[0])"}
{"solution": "# Get the input\nc, v0, v1, a, l = map(int, input().split())\n\n# Initialize the days and the pages read\ndays = 0\npages_read = 0\n\n# Loop until the book is finished\nwhile pages_read < c:\n    # Calculate the pages read today\n    pages_today = min(v0 + days * a, v1)\n\n    # If it's not the first day, subtract the pages that need to be reread\n    if days > 0:\n        pages_today -= l\n\n    # Update the total pages read\n    pages_read += pages_today\n\n    # Increment the days\n    days += 1\n\n# Print the result\nprint(days)"}
{"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    i = 3\n    while i * i <= n:\n        if n % i:\n            i += 2\n        else:\n            return False\n    return True\n\nn = int(input())\n\nif n == 3:\n    print(1)\n    print(3)\nelse:\n    print(3)\n    if is_prime(n - 2):\n        print(2, n - 2, 1)\n    else:\n        i = 3\n        while True:\n            if is_prime(i) and is_prime(n - i):\n                print(2, i, n - i)\n                break\n            i += 2"}
{"solution": "n, m = map(int, input().split())\ndepot = [list(input()) for _ in range(n)]\n\nwalls_in_row = [0] * n\nwalls_in_col = [0] * m\n\nfor i in range(n):\n    for j in range(m):\n        if depot[i][j] == '*':\n            walls_in_row[i] += 1\n            walls_in_col[j] += 1\n\ntotal_walls = sum(walls_in_row)\n\nfor i in range(n):\n    for j in range(m):\n        if walls_in_row[i] + walls_in_col[j] - (1 if depot[i][j] == '*' else 0) == total_walls:\n            print('YES')\n            print(i + 1, j + 1)\n            exit()\n\nprint('NO')"}
{"solution": "# Read input\nn, m, a, b = map(int, input().split())\n\n# Calculate the remainder of n divided by m\nremainder = n % m\n\n# If remainder is 0, no need to build or demolish boxes\nif remainder == 0:\n    print(0)\n# If building a box is cheaper than demolishing boxes, build new boxes\nelif a <= b * remainder:\n    print(a * (m - remainder))\n# Otherwise, demolish boxes\nelse:\n    # Calculate the number of boxes to demolish\n    num_demolish = min(remainder, n % (m * (remainder // m + 1)))\n    print(b * num_demolish)"}
{"solution": "n = int(input())\nnumbers = list(map(int, input().split()))\n\n# Separate odd and even numbers\nodd_numbers = [num for num in numbers if num % 2 != 0]\neven_numbers = [num for num in numbers if num % 2 == 0]\n\n# Sort odd numbers in descending order\nodd_numbers.sort(reverse=True)\n\n# If there is at least one odd number, the maximum odd subsequence sum is the sum of all odd numbers\nif odd_numbers:\n    print(sum(odd_numbers))\n# If there are no odd numbers, the maximum odd subsequence sum is the maximum even number\nelse:\n    print(max(even_numbers))"}
{"solution": "MOD = 10**9 + 7\n\ndef solve():\n    n, T = map(int, input().split())\n    songs = [list(map(int, input().split())) for _ in range(n)]\n    dp = [[[0] * 4 for _ in range(4)] for _ in range(T + 1)]\n    dp[0][0][0] = 1\n    for t in range(1, T + 1):\n        for i in range(n):\n            for j in range(1, 4):\n                if songs[i][1] != j and t >= songs[i][0]:\n                    for k in range(1, 4):\n                        if k != j:\n                            dp[t][j][songs[i][1]] = (dp[t][j][songs[i][1]] + dp[t - songs[i][0]][k][j]) % MOD\n    return sum(dp[T][i][j] for i in range(1, 4) for j in range(1, 4)) % MOD\n\nprint(solve())"}
{"solution": "import sys\n\ndef expected_length(m):\n    MOD = 10**9 + 7\n    dp = [0] * (m + 1)\n    dp[1] = 1\n\n    for i in range(2, m + 1):\n        for j in range(i, m + 1, i):\n            dp[i] = (dp[i] + dp[j // i]) % MOD\n        dp[i] = (dp[i] * pow(m // i, MOD - 2, MOD)) % MOD\n\n    return dp[1]\n\nm = int(sys.stdin.readline())\nresult = expected_length(m)\nprint(result)"}
{"solution": "def gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\nl, r, x, y = map(int, input().split())\n\ncount = 0\nfor a in range(x, r + 1):\n    for b in range(a, r + 1):\n        if l <= a <= b <= r and gcd(a, b) == x and lcm(a, b) == y:\n            count += 1\n\nprint(count)"}
{"solution": "import math\n\ndef smallest_k(a, b):\n    gcd = math.gcd(a, b)\n    lcm = a * b // gcd\n    k = 0\n    while True:\n        if (a + k) % gcd != 0 or (b + k) % gcd != 0:\n            k += 1\n        else:\n            break\n    return k\n\na, b = map(int, input().split())\nprint(smallest_k(a, b))"}
{"solution": "# Get the input\nn, k = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Calculate the current average\navg = sum(marks) / n\n\n# Calculate the number of marks needed to be added\n# to make the average equal to k\n# Round up the result to the nearest integer\nmarks_needed = int(n * k - sum(marks) + n - 1) // n\n\n# Print the result\nprint(marks_needed)"}
{"solution": "n = int(input())\nnumbers = list(map(int, input().split()))\n\npositive_count = 0\nnegative_count = 0\nzero_count = 0\n\nfor num in numbers:\n    if num > 0:\n        positive_count += 1\n    elif num < 0:\n        negative_count += 1\n    else:\n        zero_count += 1\n\nif positive_count >= (n + 1) // 2:\n    for i in range(1, 1001):\n        if all(num / i >= 0 for num in numbers if num / i != 0):\n            print(i)\n            break\nelif negative_count >= (n + 1) // 2:\n    for i in range(-1, -1001, -1):\n        if all(num / i >= 0 for num in numbers if num / i != 0):\n            print(i)\n            break\nelse:\n    print(0)"}
{"solution": "n = int(input())\n\n# Calculate the maximum possible number of nines at the end of total cost\nmax_nines = 0\ntemp = 1\nwhile temp <= n:\n    temp *= 10\n    max_nines += 1\nmax_nines -= 1\n\n# Calculate the maximum possible total cost that ends with max_nines number of nines\nmax_cost = 10 ** max_nines - 1\n\n# Calculate the number of pairs of shovels that have total cost ending with max_nines number of nines\ncount = 0\nfor i in range(1, n):\n    if i <= (max_cost - i) <= n and (i + max_cost - i) % 10 == 0:\n        count += 1\n\nprint(count)"}
{"solution": "def solve(a, b):\n    if a > b:\n        a, b = b, a\n    if a == b:\n        return 0, a, a\n    if a == 1:\n        if b % 2 == 0:\n            return 1, 1, b // 2\n        elif b % 3 == 0:\n            return 1, 1, b // 3\n        else:\n            return -1, -1, -1\n    if a * 2 == b:\n        return 1, a, a\n    if a * 3 == b:\n        return 1, a, a\n    if a % 2 == 0:\n        m, x, y = solve(a // 2, b)\n        if m != -1:\n            return m + 1, x, y\n    if a % 3 == 0:\n        m, x, y = solve(a // 3, b)\n        if m != -1:\n            return m + 1, x, y\n    if b % 2 == 0:\n        m, x, y = solve(a, b // 2)\n        if m != -1:\n            return m + 1, x, y\n    if b % 3 == 0:\n        m, x, y = solve(a, b // 3)\n        if m != -1:\n            return m + 1, x, y\n    return -1, -1, -1\n\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\nm1, x1, y1 = solve(a1, b1)\nm2, x2, y2 = solve(a2, b2)\nif x1 * y1 != x2 * y2:\n    print(-1)\nelse:\n    print(m1 + m2)\n    print(x1, y1)\n    print(x2, y2)"}
{"solution": "# Get the input\nx_p, y_p, x_v, y_v = map(int, input().split())\n\n# Calculate the sum of coordinates for both players\nsum_p = x_p + y_p\nsum_v = x_v + y_v\n\n# Calculate the difference of coordinates for Polycarp\ndiff_p = x_p - y_p\n\n# If the sum of coordinates for Polycarp is less than or equal to the sum of coordinates for Vasiliy\n# or the difference of coordinates for Polycarp is less than 0, then Vasiliy will win\n# otherwise, Polycarp will win\nif sum_p <= sum_v or diff_p < 0:\n    print(\"Vasiliy\")\nelse:\n    print(\"Polycarp\")"}
{"solution": "# Get the input\nm, d = map(int, input().split())\n\n# Define the number of days in each month\ndays_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n# Calculate the number of columns\n# The first week is already accounted for, so we start from the second week\n# Each week has 7 days, so we add 7 days in each iteration until we reach the end of the month\n# We need to subtract 1 from the weekday because the input is 1-indexed and our calculation is 0-indexed\ncolumns = 1\ncurrent_day = 7 - (d - 1) + 1\nwhile current_day <= days_in_month[m - 1]:\n    columns += 1\n    current_day += 7\n\n# Print the result\nprint(columns)"}
{"solution": "def count_binary_zeros(n):\n    return bin(n).count('0') - 1\n\ndef count_years(a, b):\n    count = 0\n    for year in range(a, b + 1):\n        if count_binary_zeros(year) == 1:\n            count += 1\n    return count\n\na, b = map(int, input().split())\nprint(count_years(a, b))"}
{"solution": "# Get the input integer N\nn = int(input())\n\n# Initialize the number of layers required to 0\nlayers = 0\n\n# Initialize a list to store the frequency of each endpoint\nfreq = [0] * (n + 1)\n\n# Count the frequency of each endpoint\nfor i in range(n + 1):\n    for j in range(i, n + 1):\n        freq[i] += 1\n        freq[j] += 1\n\n# Sort the frequency list in descending order\nfreq.sort(reverse=True)\n\n# While there are still endpoints with non-zero frequency\nwhile freq[0] > 0:\n    # Increment the number of layers required\n    layers += 1\n\n    # Decrement the frequency of each endpoint in the current layer\n    for i in range(n + 1):\n        if freq[i] > 0:\n            freq[i] -= 1\n\n# Print the minimum number of layers required\nprint(layers)"}
{"solution": "import sys\nfrom math import factorial\n\ndef solve(n, k, s, a):\n    dp = [[0] * (s + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(s + 1):\n            dp[i][j] = dp[i - 1][j]\n            if a[i - 1] <= j:\n                dp[i][j] += dp[i - 1][j - a[i - 1]]\n            if k > 0 and a[i - 1] <= 20 and a[i - 1] <= j:\n                dp[i][j] += dp[i - 1][j - factorial(a[i - 1])]\n\n    return dp[n][s]\n\ndef main():\n    n, k, s = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    print(solve(n, k, s, a))\n\nif __name__ == '__main__':\n    main()"}
{"solution": "def solve(n, k, a):\n    for i in range(n):\n        while a[i] > 0:\n            if a[i] % k != 0:\n                return \"NO\"\n            a[i] //= k\n    return \"YES\"\n\nT = int(input())\nfor _ in range(T):\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    print(solve(n, k, a))"}
{"solution": "MOD = 1073741824\n\ndef divisor_count(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count\n\na, b, c = map(int, input().split())\n\ntotal = 0\nfor i in range(1, a + 1):\n    for j in range(1, b + 1):\n        for k in range(1, c + 1):\n            total = (total + divisor_count(i * j * k)) % MOD\n\nprint(total)"}
{"solution": "def get_input():\n    return [input() for _ in range(4)]\n\ndef get_state(puzzle):\n    state = 0\n    for i in range(4):\n        if puzzle[i] != 'X':\n            state |= 1 << (ord(puzzle[i]) - ord('A'))\n    return state\n\ndef can_reach(state1, state2):\n    visited = set()\n    queue = [state1]\n    while queue:\n        state = queue.pop(0)\n        if state in visited:\n            continue\n        visited.add(state)\n        if state == state2:\n            return True\n        empty = 4 - bin(state).count('1')\n        for i in range(4):\n            if (state >> i) & 1:\n                if i % 2 == 0 and empty == i + 1:\n                    queue.append(state ^ (1 << i) ^ (1 << (i + 1)))\n                if i % 2 == 1 and empty == i - 1:\n                    queue.append(state ^ (1 << i) ^ (1 << (i - 1)))\n                if i < 2 and empty == i + 2:\n                    queue.append(state ^ (1 << i) ^ (1 << (i + 2)))\n                if i > 1 and empty == i - 2:\n                    queue.append(state ^ (1 << i) ^ (1 << (i - 2)))\n    return False\n\npuzzle1, puzzle2 = get_input()\nstate1 = get_state(puzzle1)\nstate2 = get_state(puzzle2)\nprint(\"YES\" if can_reach(state1, state2) else \"NO\")"}
{"solution": "# Get input\nn = int(input())\nk = input()\n\n# Convert k to decimal\ndecimal_k = 0\nfor i in range(len(k)):\n    decimal_k += int(k[i]) * (n ** i)\n\n# Find the minimum decimal number\nmin_decimal = decimal_k\nwhile True:\n    # Convert min_decimal to base n\n    base_n = ''\n    temp = min_decimal\n    while temp:\n        base_n = str(temp % n) + base_n\n        temp //= n\n\n    # Check if base_n is equal to k\n    if base_n == k:\n        print(min_decimal)\n        break\n\n    # Increment min_decimal\n    min_decimal += 1"}
{"solution": "n = int(input())\narr = list(map(int, input().split()))\n\n# Check if array is strictly increasing\ni = 1\nwhile i < n and arr[i] > arr[i - 1]:\n    i += 1\n\n# Check if array is constant\nwhile i < n and arr[i] == arr[i - 1]:\n    i += 1\n\n# Check if array is strictly decreasing\nwhile i < n and arr[i] < arr[i - 1]:\n    i += 1\n\n# If we have traversed the whole array, it is unimodal\nif i == n:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def f(x):\n    if x % 2 == 0:\n        return x // 2\n    else:\n        return x - 1\n\ndef path(x):\n    p = [x]\n    while x != 1:\n        x = f(x)\n        p.append(x)\n    return p\n\ndef max_y(n, k):\n    count = [0] * (n + 1)\n    for x in range(1, n + 1):\n        for y in path(x):\n            count[y] += 1\n    for y in range(n, 0, -1):\n        if count[y] >= k:\n            return y\n\nn, k = map(int, input().split())\nprint(max_y(n, k))"}
{"solution": "def billiard_pockets(n, m, x, y, vx, vy):\n    if vx == 0:\n        if y == 0:\n            return '0 0'\n        elif y == m:\n            return '0 ' + str(m)\n    elif vy == 0:\n        if x == 0:\n            return str(n) + ' 0'\n        elif x == n:\n            return str(n) + ' ' + str(m)\n    elif vx == vy:\n        if x == 0:\n            if y == m:\n                return '0 ' + str(m)\n            else:\n                return str(n) + ' ' + str(m)\n        elif x == n:\n            return str(n) + ' 0'\n        elif y == 0:\n            return str(n) + ' ' + str(m)\n        elif y == m:\n            return '0 ' + str(m)\n    elif vx == -vy:\n        if x == 0:\n            return '0 0'\n        elif x == n:\n            if y == m:\n                return str(n) + ' ' + str(m)\n            else:\n                return str(n) + ' 0'\n        elif y == 0:\n            return '0 0'\n        elif y == m:\n            return str(n) + ' ' + str(m)\n    return '-1'\n\nn, m, x, y, vx, vy = map(int, input().split())\nprint(billiard_pockets(n, m, x, y, vx, vy))"}
{"solution": "# Get the input\nboard_dimensions = list(map(int, input().split()))\npainting1_dimensions = list(map(int, input().split()))\npainting2_dimensions = list(map(int, input().split()))\n\n# Sort the dimensions to ensure that the larger dimension is always first\nboard_dimensions.sort()\npainting1_dimensions.sort()\npainting2_dimensions.sort()\n\n# Check if the paintings can be placed on the board\nif (painting1_dimensions[0] + painting2_dimensions[0] <= board_dimensions[0] and max(painting1_dimensions[1], painting2_dimensions[1]) <= board_dimensions[1]) or \\\n   (painting1_dimensions[0] + painting2_dimensions[1] <= board_dimensions[0] and max(painting1_dimensions[1], painting2_dimensions[0]) <= board_dimensions[1]) or \\\n   (painting1_dimensions[1] + painting2_dimensions[0] <= board_dimensions[0] and max(painting1_dimensions[0], painting2_dimensions[1]) <= board_dimensions[1]) or \\\n   (painting1_dimensions[1] + painting2_dimensions[1] <= board_dimensions[0] and max(painting1_dimensions[0], painting2_dimensions[0]) <= board_dimensions[1]):\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "def solve():\n    b1, q, l, m = map(int, input().split())\n    bad_numbers = set(map(int, input().split()))\n\n    if b1 == 0:\n        if 0 in bad_numbers:\n            print(0)\n        else:\n            print(1 if abs(b1) <= l else 0)\n        return\n\n    if q == 1:\n        print(1 if abs(b1) <= l and b1 not in bad_numbers else 0)\n        return\n\n    if q == -1:\n        if abs(b1) > l or b1 in bad_numbers:\n            print(0)\n        elif b1 % 2 == 0:\n            print(1 if (b1 // 2) % 2 == 1 else 0)\n        else:\n            print(\"inf\")\n        return\n\n    if abs(q) > 1:\n        if abs(b1) > l or b1 in bad_numbers:\n            print(0)\n        else:\n            count = 1\n            b1 *= q\n            while abs(b1) <= l and b1 not in bad_numbers:\n                count += 1\n                b1 *= q\n            print(count)\n        return\n\n    if abs(b1) > l or b1 in bad_numbers:\n        print(0)\n    else:\n        print(\"inf\")\n\nsolve()"}
{"solution": "def find_frame(grid):\n    n, m = len(grid), len(grid[0])\n    min_size = float('inf')\n    frame = []\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'w':\n                size = min(i, j, n - i - 1, m - j - 1)\n                if size < min_size:\n                    min_size = size\n                    frame = [(i, j)]\n                elif size == min_size:\n                    frame.append((i, j))\n\n    if not frame:\n        return -1\n\n    for i, j in frame:\n        for k in range(min_size + 1):\n            grid[i - k][j] = '+'\n            grid[i + k][j] = '+'\n            grid[i][j - k] = '+'\n            grid[i][j + k] = '+'\n\n    return '\\n'.join(''.join(row) for row in grid)\n\nn, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\nprint(find_frame(grid))"}
{"solution": "n = int(input())\na = int(input())\nb = int(input())\n\nfor x in range(n // a + 1):\n    if (n - a * x) % b == 0:\n        y = (n - a * x) // b\n        print(\"YES\")\n        print(x, y)\n        break\nelse:\n    print(\"NO\")"}
{"solution": "def number_to_words(n):\n    under_20 = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten', 'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen', 'eighteen', 'nineteen']\n    tens = ['twenty', 'thirty', 'forty', 'fifty', 'sixty', 'seventy', 'eighty', 'ninety']\n    above_100 = {100: 'hundred'}\n\n    if n < 20:\n        return under_20[n]\n    if n < 100:\n        return tens[(int(n / 10)) - 2] + ('' if n % 10 == 0 else '-' + under_20[n % 10])\n    if n == 100:\n        return 'one-hundred'\n\ns = int(input())\nprint(number_to_words(s))"}
{"solution": "# Read the number of elements\nn = int(input())\n\n# Read the elements of the array\narr = list(map(int, input().split()))\n\n# Initialize the maximum number of consecutive elements that can be erased\nmax_erased = 0\n\n# Iterate over the array\nfor i in range(1, n - 1):\n    # Calculate the difference between the current element and the next element\n    diff = arr[i + 1] - arr[i]\n\n    # Calculate the number of consecutive elements that can be erased\n    # between the current element and the next element\n    erased = diff - 1\n\n    # Update the maximum number of consecutive elements that can be erased\n    max_erased = max(max_erased, erased)\n\n# Print the maximum number of consecutive elements that can be erased\nprint(max_erased)"}
{"solution": "# Read the number of days\nn = int(input())\n\n# Read the number of problems solved each day\nproblems = list(map(int, input().split()))\n\n# Calculate the total number of problems\ntotal_problems = sum(problems)\n\n# Calculate the half of the total number of problems\nhalf_problems = total_problems // 2\n\n# Initialize the number of problems solved so far\nsolved_so_far = 0\n\n# Iterate over the days\nfor i in range(n):\n    # Add the number of problems solved on the current day\n    solved_so_far += problems[i]\n\n    # Check if the half of the total number of problems is solved\n    if solved_so_far >= half_problems:\n        # Print the index of the current day\n        print(i + 1)\n        # Break the loop\n        break"}
{"solution": "import sys\nfrom heapq import heappush, heappop\n\ndef read_input():\n    return sys.stdin.readline\n\ndef write_output(x):\n    return sys.stdout.write(x)\n\ndef find_shortest_path():\n    size = int(read_input())\n    board = [list(map(int, read_input().split())) for _ in range(size)]\n    directions = [(1, 2), (2, 1), (-1, 2), (-2, 1), (1, -2), (2, -1), (-1, -2), (-2, -1)]\n    positions = [None] * (size * size + 1)\n\n    for i in range(size):\n        for j in range(size):\n            positions[board[i][j]] = (i, j)\n\n    distances = [[[float('inf')] * 3 for _ in range(size)] for _ in range(size)]\n    distances[0][0][0] = 0\n    priority_queue = [(0, 0, 0, 0)]\n\n    while priority_queue:\n        cost, piece, x, y = heappop(priority_queue)\n\n        if x == size - 1 and y == size - 1:\n            write_output(f\"{cost} {piece}\\n\")\n            break\n\n        if distances[x][y][piece] < cost:\n            continue\n\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n\n            if 0 <= nx < size and 0 <= ny < size and board[nx][ny] == board[x][y] + 1:\n                if distances[nx][ny][piece] > cost:\n                    distances[nx][ny][piece] = cost\n                    heappush(priority_queue, (cost, piece, nx, ny))\n\n        for new_piece in range(3):\n            if new_piece != piece and distances[x][y][new_piece] > cost + 1:\n                distances[x][y][new_piece] = cost + 1\n                heappush(priority_queue, (cost + 1, new_piece, x, y))\n\n        if board[x][y] < size * size:\n            nx, ny = positions[board[x][y] + 1]\n\n            if distances[nx][ny][piece] > cost + 1:\n                distances[nx][ny][piece] = cost + 1\n                heappush(priority_queue, (cost + 1, piece, nx, ny))\n\nfind_shortest_path()"}
{"solution": "def min_time(n, m, k, a, b):\n    # Calculate the apartment numbers for the first and last apartments of each entrance\n    first_apts = [i * m * k + 1 for i in range(n)]\n    last_apts = [(i + 1) * m * k for i in range(n)]\n\n    # Calculate the time it takes to go from apartment a to apartment b in the clockwise direction\n    clockwise_time = min((b - a) % (n * m * k), (a - b) % (n * m * k)) * 5\n    clockwise_time += min((abs(first_apts.index(a) - first_apts.index(b)) % n) * 15,\n                          (abs(last_apts.index(a) - last_apts.index(b)) % n) * 15)\n\n    # Calculate the time it takes to go from apartment a to apartment b in the counter-clockwise direction\n    counter_clockwise_time = min((a - b) % (n * m * k), (b - a) % (n * m * k)) * 5\n    counter_clockwise_time += min((abs(first_apts.index(b) - first_apts.index(a)) % n) * 15,\n                                  (abs(last_apts.index(b) - last_apts.index(a)) % n) * 15)\n\n    # Calculate the time it takes to use the elevator\n    elevator_time = 10 + abs(a // (k * m) - b // (k * m))\n    elevator_time += min(a % (k * m) // k, b % (k * m) // k)\n\n    # Return the minimum time\n    return min(clockwise_time, counter_clockwise_time, elevator_time)\n\n# Read the input\nn, m, k = map(int, input().split())\na, b = map(int, input().split())\n\n# Print the output\nprint(min_time(n, m, k, a, b))"}
{"solution": "def is_divisible_by_64(s):\n    # Count the number of zeros in the string\n    count_zeros = s.count('0')\n\n    # If there are less than 6 zeros, it's not possible to form a number divisible by 64\n    if count_zeros < 6:\n        return False\n\n    # Count the number of ones in the string\n    count_ones = s.count('1')\n\n    # If there are no ones, it's not possible to form a number divisible by 64\n    if count_ones == 0:\n        return False\n\n    # If the number of ones is not divisible by 6, it's not possible to form a number divisible by 64\n    if count_ones % 6 != 0:\n        return False\n\n    # If we passed all the checks, it's possible to form a number divisible by 64\n    return True\n\n# Read the input string\ns = input()\n\n# Check if it's possible to form a number divisible by 64\nif is_divisible_by_64(s):\n    print('yes')\nelse:\n    print('no')"}
{"solution": "def solve(s):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    j = 0\n    result = ''\n    for i in range(len(s)):\n        if j < 26 and s[i] == alphabet[j]:\n            result += s[i]\n            j += 1\n        elif s[i] < alphabet[j]:\n            result += chr(ord(s[i]) + 1)\n        else:\n            result += s[i]\n    return result if j == 26 else '-1'\n\ns = input()\nprint(solve(s))"}
{"solution": "def max_expected_fish(n, m, r, k):\n    total_cells = n * m\n    total_scoop_positions = (n - r + 1) * (m - r + 1)\n    max_fish_in_scoop = r * r\n\n    if k >= max_fish_in_scoop:\n        return max_fish_in_scoop\n\n    fish_per_scoop_position = k / total_scoop_positions\n    return min(fish_per_scoop_position, max_fish_in_scoop)\n\nn, m, r, k = map(int, input().split())\nprint(max_expected_fish(n, m, r, k))"}
{"solution": "# Read the number of elements\nn = int(input())\n\n# Read the elements\na = list(map(int, input().split()))\n\n# Count the number of negative numbers\nneg_count = sum(1 for x in a if x < 0)\n\n# If there is an odd number of negative numbers, find the smallest number and change its sign\nif neg_count % 2 == 1:\n    min_val = min(a)\n    a = [-x - 1 if x == min_val else x for x in a]\n\n# If there are no negative numbers, find the smallest number and change its sign\nelif neg_count == 0:\n    min_val = min(a)\n    a = [-x - 1 if x == min_val else x for x in a]\n\n# Change the sign of all numbers\na = [-x - 1 for x in a]\n\n# Print the result\nprint(' '.join(map(str, a)))"}
{"solution": "import math\n\ndef find_kth_divisor(n, k):\n    divisors = []\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    divisors.sort()\n    return divisors[k - 1] if k <= len(divisors) else -1\n\nn, k = map(int, input().split())\nprint(find_kth_divisor(n, k))"}
{"solution": "def rotate(cube):\n    return [cube[3], cube[0], cube[2], cube[5], cube[1], cube[4]]\n\ndef can_make(num, cubes):\n    for i in range(1, num + 1):\n        digits = set(str(i))\n        if not any(set(str(c[0])).issuperset(digits) for c in cubes):\n            return False\n    return True\n\ndef solve(cubes):\n    for x in range(10000, -1, -1):\n        if can_make(x, cubes):\n            return x\n    return 0\n\nn = int(input())\ncubes = [list(map(int, input().split())) for _ in range(n)]\ncubes = [rotate(cube) for cube in cubes] * 6\nprint(solve(cubes))"}
{"solution": "# Get the input\nn, k = map(int, input().split())\n\n# Calculate the k-rounding of n\nrounded_n = n * (10 ** k)\nwhile rounded_n % n != 0:\n    rounded_n += 10 ** k\n\n# Print the result\nprint(rounded_n)"}
{"solution": "def solve(n, m, A):\n    B = [[0] * m for _ in range(n)]\n    operations = []\n\n    for i in range(n - 1):\n        for j in range(m - 1):\n            if A[i][j] == 1 and B[i][j] == 0:\n                B[i][j] = B[i][j + 1] = B[i + 1][j] = B[i + 1][j + 1] = 1\n                operations.append((i + 1, j + 1))\n\n    if A == B:\n        return len(operations), operations\n    else:\n        return -1, []\n\nn, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\n\nresult = solve(n, m, A)\n\nif result[0] == -1:\n    print(-1)\nelse:\n    print(result[0])\n    for op in result[1]:\n        print(*op)"}
{"solution": "def calculate_probabilities(r, s, p):\n    dp = [[[0.0 for _ in range(p+1)] for _ in range(s+1)] for _ in range(r+1)]\n    dp[r][s][p] = 1.0\n\n    for i in range(r, -1, -1):\n        for j in range(s, -1, -1):\n            for k in range(p, -1, -1):\n                if i > 0 and j > 0:\n                    dp[i-1][j-1][k] += dp[i][j][k] * i * j / (i + j)\n                if i > 0 and k > 0:\n                    dp[i-1][j][k-1] += dp[i][j][k] * i * k / (i + k)\n                if j > 0 and k > 0:\n                    dp[i][j-1][k-1] += dp[i][j][k] * j * k / (j + k)\n\n    return [dp[r][0][0], dp[0][s][0], dp[0][0][p]]\n\nr, s, p = map(int, input().split())\nprint(*calculate_probabilities(r, s, p))"}
{"solution": "# Get the input\nl1, r1, l2, r2, k = map(int, input().split())\n\n# Calculate the overlapping time\noverlap = max(0, min(r1, r2) - max(l1, l2) + 1)\n\n# If Sonya prinks during the overlapping time, subtract 1 from the overlap\nif k >= max(l1, l2) and k <= min(r1, r2):\n    overlap -= 1\n\n# Print the result\nprint(overlap)"}
{"solution": "import sys\nfrom bisect import bisect_left, bisect_right\n\ndef main():\n    input = sys.stdin.readline\n\n    n, m = map(int, input().split())\n\n    horizontal_lines = []\n    vertical_lines = []\n\n    for _ in range(n):\n        a, b, c = map(int, input().split())\n        horizontal_lines.append((c, a, b))\n\n    for _ in range(m):\n        d, e, f = map(int, input().split())\n        vertical_lines.append((d, e, f))\n\n    horizontal_lines.sort()\n    vertical_lines.sort()\n\n    horizontal_intervals = []\n    vertical_intervals = []\n\n    for c, a, b in horizontal_lines:\n        if not horizontal_intervals or horizontal_intervals[-1][1] < a:\n            horizontal_intervals.append((a, b))\n        else:\n            _, prev_b = horizontal_intervals[-1]\n            if prev_b < b:\n                horizontal_intervals[-1] = (_, b)\n\n    for d, e, f in vertical_lines:\n        if not vertical_intervals or vertical_intervals[-1][1] < e:\n            vertical_intervals.append((e, f))\n        else:\n            _, prev_f = vertical_intervals[-1]\n            if prev_f < f:\n                vertical_intervals[-1] = (_, f)\n\n    horizontal_intervals.sort()\n    vertical_intervals.sort()\n\n    horizontal_intervals.append((10**9 + 1, 10**9 + 1))\n    vertical_intervals.append((10**9 + 1, 10**9 + 1))\n\n    horizontal_intervals_acc = [0]\n    vertical_intervals_acc = [0]\n\n    for a, b in horizontal_intervals:\n        horizontal_intervals_acc.append(horizontal_intervals_acc[-1] + b - a)\n\n    for e, f in vertical_intervals:\n        vertical_intervals_acc.append(vertical_intervals_acc[-1] + f - e)\n\n    horizontal_intervals_acc.pop()\n    vertical_intervals_acc.pop()\n\n    total_area = 0\n\n    for c, a, b in horizontal_lines:\n        i = bisect_right(vertical_intervals, (a, 10**9 + 1))\n        j = bisect_left(vertical_intervals, (b, -10**9 - 1))\n        total_area += vertical_intervals_acc[j] - vertical_intervals_acc[i - 1]\n\n    for d, e, f in vertical_lines:\n        i = bisect_right(horizontal_intervals, (e, 10**9 + 1))\n        j = bisect_left(horizontal_intervals, (f, -10**9 - 1))\n        total_area += horizontal_intervals_acc[j] - horizontal_intervals_acc[i - 1]\n\n    print(total_area)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Get the input\nt, s, x = map(int, input().split())\n\n# Calculate the first bark time after x\nfirst_bark_after_x = t + s * ((x - t) // s)\n\n# Check if the pineapple barks at time x\nif x == first_bark_after_x or x == first_bark_after_x + 1:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n = int(input())\nsegments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r, i+1))\nsegments.sort()\n\nfor i in range(n):\n    for j in range(i+1, n):\n        if segments[i][1] >= segments[j][1]:\n            print(segments[j][2], segments[i][2])\n            exit()\nprint(-1, -1)"}
{"solution": "n = int(input())\ns = list(input())\n\n# Count the number of each nucleotide\ncounts = {'A': 0, 'C': 0, 'G': 0, 'T': 0}\nfor nucleotide in s:\n    if nucleotide != '?':\n        counts[nucleotide] += 1\n\n# Check if it's possible to decode the genome\nif max(counts.values()) - min(counts.values()) > len([nucleotide for nucleotide in s if nucleotide == '?']):\n    print(\"===\")\nelse:\n    # Replace each unrecognized nucleotide with one of the four types\n    for i in range(n):\n        if s[i] == '?':\n            for nucleotide in 'ACGT':\n                if counts[nucleotide] < n // 4:\n                    s[i] = nucleotide\n                    counts[nucleotide] += 1\n                    break\n    print(''.join(s))"}
{"solution": "def check_win(board):\n    # Check rows, columns and diagonals for a win\n    for i in range(4):\n        if board[i][0] == board[i][1] == board[i][2] == 'x' or board[i][1] == board[i][2] == board[i][3] == 'x':\n            return True\n        if board[0][i] == board[1][i] == board[2][i] == 'x' or board[1][i] == board[2][i] == board[3][i] == 'x':\n            return True\n    if board[0][0] == board[1][1] == board[2][2] == 'x' or board[1][1] == board[2][2] == board[3][3] == 'x':\n        return True\n    if board[0][3] == board[1][2] == board[2][1] == 'x' or board[1][2] == board[2][1] == board[3][0] == 'x':\n        return True\n    return False\n\ndef can_win(board):\n    # Try placing 'x' in each empty cell and check if it results in a win\n    for i in range(4):\n        for j in range(4):\n            if board[i][j] == '.':\n                board[i][j] = 'x'\n                if check_win(board):\n                    return True\n                board[i][j] = '.'\n    return False\n\n# Read the input\nboard = [list(input()) for _ in range(4)]\n\n# Check if Ilya can win in a single turn\nif can_win(board):\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\ntotal_sum = sum(a)\nprefix_sum = 0\n\nfor i in range(n):\n    if prefix_sum == total_sum - prefix_sum - a[i]:\n        print(\"YES\")\n        exit()\n    prefix_sum += a[i]\n\nprint(\"NO\")"}
{"solution": "def solve(n, k, a, b):\n    a = [x for x in a if x != 0]\n    b.sort()\n    a.sort()\n\n    if a[-1] > b[0]:\n        return \"No\"\n\n    i = 0\n    j = 0\n    while i < n and j < k:\n        if a[i] > b[j]:\n            j += 1\n        else:\n            i += 1\n            j += 1\n\n    return \"Yes\" if i < n else \"No\"\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nprint(solve(n, k, a, b))"}
{"solution": "# Get the input\nx, y, z = map(int, input().split())\na, b, c = map(int, input().split())\n\n# Check if Andrew can eat enough green grapes\nif x > a:\n    print(\"NO\")\nelse:\n    # Calculate the remaining green grapes after Andrew eats\n    remaining_green = a - x\n\n    # Check if Dmitry can eat enough non-black grapes\n    if y > remaining_green + b:\n        print(\"NO\")\n    else:\n        # Calculate the remaining non-black grapes after Dmitry eats\n        remaining_non_black = remaining_green + b - y\n\n        # Check if Michal can eat enough remaining grapes\n        if z > remaining_non_black + c:\n            print(\"NO\")\n        else:\n            print(\"YES\")"}
{"solution": "# Get the input\nlights = [list(map(int, input().split())) for _ in range(4)]\n\n# Check for accidents\nfor i in range(4):\n    for j in range(4):\n        # If the pedestrian light and a car light are both green\n        if lights[i][3] == 1 and lights[i][j] == 1:\n            # Check if the car can reach the pedestrian\n            if (i == 0 and j == 2) or (i == 1 and j == 1) or (i == 2 and j == 0) or (i == 3 and j == 3):\n                print(\"YES\")\n                exit()\n\n# If no accidents are possible\nprint(\"NO\")"}
{"solution": "# Define the possible movements from each key\nmovements = {\n    '1': ['2', '4', '5'],\n    '2': ['1', '3', '5', '6', '8'],\n    '3': ['2', '6', '9'],\n    '4': ['1', '5', '7'],\n    '5': ['1', '2', '4', '6', '8'],\n    '6': ['2', '3', '5', '9'],\n    '7': ['4', '8'],\n    '8': ['2', '5', '7', '9', '0'],\n    '9': ['3', '6', '8'],\n    '0': ['8']\n}\n\n# Get the input\nn = int(input())\nnumber = input()\n\n# Check if there is another number with the same finger movements\nfor i in range(1, n):\n    if number[i] not in movements[number[i-1]]:\n        print('NO')\n        break\nelse:\n    print('YES')"}
{"solution": "import heapq\n\ndef max_sold_products(n, f, k, l):\n    # Create a list of tuples where each tuple contains the difference in products sold\n    # if the day is a sell-out and the number of products on that day\n    diff_sold = [(2*k[i] - k[i], k[i]) for i in range(n)]\n\n    # Sort the list in descending order based on the difference in products sold\n    diff_sold.sort(reverse=True)\n\n    # Initialize the total number of products sold to 0\n    total_sold = 0\n\n    # Choose the f days with the highest difference in products sold\n    for i in range(f):\n        # Add the number of products sold on that day to the total\n        total_sold += min(diff_sold[i][1], l[i])\n\n    # For the remaining days, add the number of products that can be sold to the total\n    for i in range(f, n):\n        total_sold += min(k[i], l[i])\n\n    return total_sold\n\n# Read the input\nn, f = map(int, input().split())\nk = []\nl = []\nfor i in range(n):\n    ki, li = map(int, input().split())\n    k.append(ki)\n    l.append(li)\n\n# Print the output\nprint(max_sold_products(n, f, k, l))"}
{"solution": "# Read input\nn, k = map(int, input().split())\n\n# Calculate the maximum messiness\nmax_messiness = 0\nif k >= n - 1:\n    # If the number of swaps is greater than or equal to n - 1,\n    # we can sort the cows in descending order\n    max_messiness = n * (n - 1) // 2\nelse:\n    # Otherwise, we can swap the first k cows with the last k cows\n    max_messiness = k * (k + 1) // 2\n\n# Print the result\nprint(max_messiness)"}
{"solution": "# Get the input\nn, m, k, l = map(int, input().split())\n\n# Calculate the number of coins each friend needs to gift\ncoins_per_friend = (k + l) // m\n\n# Check if it's possible to meet all the terms\nif coins_per_friend > n or m > n or l > n - k:\n    print(-1)\nelse:\n    print(coins_per_friend)"}
{"solution": "n, m = map(int, input().split())\ngrid = [list(input()) for _ in range(n)]\n\ndef count_black(i, j, k):\n    count = 0\n    for x in range(i, i+k):\n        for y in range(j, j+k):\n            if grid[x][y] == 'W':\n                count += 1\n    return count\n\nmin_paint = float('inf')\nfor k in range(1, min(n, m) + 1):\n    for i in range(n - k + 1):\n        for j in range(m - k + 1):\n            min_paint = min(min_paint, count_black(i, j, k))\n\nprint(min_paint if min_paint != float('inf') else -1)"}
{"solution": "# Read the number of piles\nn = int(input())\n\n# Read the initial number of stones in each pile\nx = list(map(int, input().split()))\n\n# Read the final number of stones in each pile\ny = list(map(int, input().split()))\n\n# Calculate the difference between the initial and final number of stones in each pile\ndiff = [y[i] - x[i] for i in range(n)]\n\n# Calculate the total difference\ntotal_diff = sum(diff)\n\n# If the total difference is not zero, it is impossible to convert the initial array into the final array\nif total_diff != 0:\n    print(\"No\")\nelse:\n    # If the total difference is zero, it is possible to convert the initial array into the final array\n    # if and only if the sum of the absolute values of the differences is even\n    if sum(map(abs, diff)) % 2 == 0:\n        print(\"Yes\")\n    else:\n        print(\"No\")"}
{"solution": "n = int(input())\nangles = list(map(int, input().split()))\n\ntotal_sum = sum(angles)\nmin_diff = total_sum\ncurrent_sum = 0\n\nfor i in range(n):\n    current_sum += angles[i]\n    if abs(total_sum - 2 * current_sum) < min_diff:\n        min_diff = abs(total_sum - 2 * current_sum)\n\nprint(min_diff)"}
{"solution": "MOD = 10**9 + 7\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1:\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\ndef find_ways(n, m):\n    return power(2, n * m - n, MOD)\n\nn, m = map(int, input().split())\nprint(find_ways(n, m))"}
{"solution": "import math\n\ndef find_pythagorean_triple(n):\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            j = n // i\n            if (i % 2 == 0 and j % 2 == 1) or (i % 2 == 1 and j % 2 == 0):\n                if i < j:\n                    a = (j - i) // 2\n                    b = (j + i) // 2\n                    return a, b\n    return -1\n\nn = int(input())\nresult = find_pythagorean_triple(n)\nif result == -1:\n    print(-1)\nelse:\n    print(*result)"}
{"solution": "n, k = map(int, input().split())\nremainders = set()\n\nfor i in range(1, k + 1):\n    remainder = n % i\n    if remainder in remainders:\n        print(\"No\")\n        break\n    remainders.add(remainder)\nelse:\n    print(\"Yes\")"}
{"solution": "# Read the input\na = raw_input().strip('0')\nb = raw_input().strip('0')\n\n# Compare the lengths of the numbers\nif len(a) < len(b):\n    print('<')\nelif len(a) > len(b):\n    print('>')\nelse:\n    # If the lengths are equal, compare the numbers\n    if a < b:\n        print('<')\n    elif a > b:\n        print('>')\n    else:\n        print('=')"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(n, p, c):\n    dp = [[0, 0] for _ in range(n+1)]\n    dp[0][0] = 1\n    for i in range(1, n+1):\n        if c[i-1] != -1:\n            dp[i][c[i-1]] = dp[i-1][1-c[i-1]]\n        else:\n            dp[i][0] = (dp[i-1][1] + dp[i-1][0]) % MOD\n            dp[i][1] = (dp[i-1][0] + dp[i-1][1]) % MOD\n    return dp[n][p]\n\nn, p = map(int, input().split())\nc = list(map(int, input().split()))\nprint(solve(n, p, c))"}
{"solution": "# Get the input\nn, a, b, c = map(int, input().split())\n\n# Calculate the number of copybooks Alyona needs to buy\nk = (4 - n % 4) % 4\n\n# Calculate the cost of buying k copybooks\n# The minimum cost is the minimum of buying k copybooks individually,\n# buying k/2 pairs of copybooks, or buying k/3 packs of three copybooks\ncost = min(k * a, k // 2 * b, k // 3 * c)\n\n# Print the result\nprint(cost)"}
{"solution": "import sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(node, graph, visited, stack):\n    visited[node] = 1\n    for neighbor in graph[node]:\n        if visited[neighbor] == 1:\n            return True\n        elif visited[neighbor] == 0:\n            if dfs(neighbor, graph, visited, stack):\n                return True\n    visited[node] = 2\n    stack.append(node)\n    return False\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u-1].append(v-1)\n\n    visited = [0] * n\n    stack = []\n    for node in range(n):\n        if visited[node] == 0:\n            if dfs(node, graph, visited, stack):\n                return True\n\n    reversed_graph = [[] for _ in range(n)]\n    for u, v in edges:\n        reversed_graph[v-1].append(u-1)\n\n    order = stack[::-1]\n    visited = [0] * n\n    for node in order:\n        if visited[node] == 0:\n            if dfs(node, reversed_graph, visited, []):\n                return True\n    return False\n\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nprint('YES' if solve(n, m, edges) else 'NO')"}
{"solution": "import sys\n\ndef min_coins(n, m, antennas):\n    dp = [0] + [float('inf')] * m\n    for i in range(1, m + 1):\n        for x, s in antennas:\n            if x - s <= i <= x + s:\n                dp[i] = min(dp[i], dp[max(0, i - s - 1)] + max(0, x - i + s))\n    return dp[m]\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    antennas = [tuple(map(int, sys.stdin.readline().split())) for _ in range(n)]\n    print(min_coins(n, m, antennas))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Read the input\nW = int(input())\ncnt = list(map(int, input().split()))\n\n# Initialize the maximum possible weight of a good subset\nmax_weight = 0\n\n# Iterate over all possible weights from 1 to 8\nfor i in range(1, 9):\n    # If there are items with weight i and adding them to the current subset does not exceed W\n    if cnt[i-1] > 0 and i <= W:\n        # Add as many items of weight i as possible to the subset\n        max_weight += i * min(cnt[i-1], W // i)\n        # Update W to the remaining weight that can be added to the subset\n        W %= i\n\n# Print the maximum possible weight of a good subset\nprint(max_weight)"}
{"solution": "import sys\n\ndef min_cost(n, L, costs):\n    volumes = [(1 << i) - 1 for i in range(n)]\n    dp = [sys.maxsize] * (L + 1)\n    dp[0] = 0\n\n    for i in range(n):\n        for j in range(volumes[i], L + 1):\n            dp[j] = min(dp[j], dp[j - volumes[i]] + costs[i])\n\n    return dp[L]\n\nn, L = map(int, input().split())\ncosts = list(map(int, input().split()))\n\nprint(min_cost(n, L, costs))"}
{"solution": "# Read the number of elements\nn = int(input())\n\n# Read the elements of the array\narr = list(map(int, input().split()))\n\n# Sort the array\narr.sort()\n\n# Initialize the mex value\nmex = 1\n\n# Iterate over the sorted array\nfor num in arr:\n    # If the current number is equal to mex, increment mex\n    if num == mex:\n        mex += 1\n    # If the current number is greater than mex, break the loop\n    elif num > mex:\n        break\n\n# Print the maximum possible value of mex\nprint(mex)"}
{"solution": "n = int(input())\nticket = input()\ndigits = [int(d) for d in ticket]\n\ndef is_lucky(digits):\n    total_sum = sum(digits)\n    if total_sum % 2 != 0:\n        return False\n    target_sum = total_sum // 2\n    current_sum = 0\n    for i in range(len(digits)):\n        current_sum += digits[i]\n        if current_sum == target_sum:\n            return is_lucky(digits[i+1:]) or (i == len(digits) - 1)\n    return False\n\nif is_lucky(digits):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "# Get the user name\nuser_name = input()\n\n# Find the number of distinct characters in the user name\ndistinct_chars = len(set(user_name))\n\n# Determine the gender based on the number of distinct characters\nif distinct_chars % 2 == 0:\n    print(\"IGNORE HIM!\")\nelse:\n    print(\"CHAT WITH HER!\")"}
{"solution": "# Read input\nn, k = map(int, input().split())\ntabs = list(map(int, input().split()))\n\n# Initialize maximum difference\nmax_diff = 0\n\n# Iterate over all possible starting points\nfor b in range(1, n + 1):\n    # Initialize counts of test and social network tabs\n    e = 0\n    s = 0\n\n    # Iterate over all tabs\n    for i in range(n):\n        # If tab is not closed\n        if (i + 1 - b) % k != 0:\n            # If tab contains test information\n            if tabs[i] == 1:\n                e += 1\n            # If tab contains social network\n            else:\n                s += 1\n\n    # Update maximum difference\n    max_diff = max(max_diff, abs(e - s))\n\n# Print maximum difference\nprint(max_diff)"}
{"solution": "# Get the input\nn, c0, c1 = map(int, input().split())\n\n# Initialize the total cost\ntotal_cost = 0\n\n# Initialize the binary string\nbinary_string = '0'\n\n# Loop through the number of letters in the alphabet\nfor i in range(n):\n    # Add the binary string to the total cost\n    total_cost += binary_string.count('0') * c0 + binary_string.count('1') * c1\n\n    # Generate the next binary string\n    if '1' in binary_string:\n        # Find the rightmost '1'\n        index = binary_string.rindex('1')\n\n        # Replace it with '0' and append '1'\n        binary_string = binary_string[:index] + '01' + binary_string[index + 1:]\n    else:\n        # Append '1' to the binary string\n        binary_string += '1'\n\n# Print the total cost\nprint(total_cost)"}
{"solution": "# Get the input\nn, a, x, b, y = map(int, input().split())\n\n# Initialize Daniel's and Vlad's positions\ndaniel_pos = a\nvlad_pos = b\n\n# Loop until Daniel and Vlad meet or their trains pass each other\nwhile daniel_pos != vlad_pos:\n    # Move Daniel's train\n    daniel_pos = (daniel_pos % n) + 1\n    # Move Vlad's train\n    vlad_pos = (vlad_pos - 2) % n + 1\n    # Check if their trains pass each other\n    if (daniel_pos > vlad_pos and daniel_pos > a and vlad_pos < b) or \\\n       (daniel_pos < vlad_pos and daniel_pos < a and vlad_pos > b):\n        print(\"NO\")\n        break\n# If Daniel and Vlad meet\nelse:\n    print(\"YES\")"}
{"solution": "def unlucky_years(x, y, l, r):\n    unlucky = set()\n    a, b = 0, 0\n    while x**a <= r:\n        while y**b <= r:\n            if l <= x**a + y**b <= r:\n                unlucky.add(x**a + y**b)\n            b += 1\n        a += 1\n        b = 0\n\n    if not unlucky:\n        return r - l + 1\n\n    unlucky = sorted(list(unlucky))\n    max_length = max(unlucky[0] - l, r - unlucky[-1])\n    for i in range(1, len(unlucky)):\n        max_length = max(max_length, unlucky[i] - unlucky[i-1] - 1)\n\n    return max_length\n\nx, y, l, r = map(int, input().split())\nprint(unlucky_years(x, y, l, r))"}
{"solution": "def max_divisor(n):\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            return n // i\n    return 1\n\ndef min_tax(n):\n    if n == 2:\n        return 1\n    if n % 2 == 0:\n        return 2\n    if max_divisor(n - 2) > 1:\n        return 2\n    return 3\n\nn = int(input())\nprint(min_tax(n))"}
{"solution": "def check_typo(word):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    consonant_count = 0\n    prev_consonant = None\n\n    for char in word:\n        if char not in vowels:\n            consonant_count += 1\n            if consonant_count >= 3 and char != prev_consonant:\n                return True\n            prev_consonant = char\n        else:\n            consonant_count = 0\n            prev_consonant = None\n\n    return False\n\ndef fix_typo(word):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    fixed_word = ''\n    consonant_count = 0\n    prev_consonant = None\n\n    for char in word:\n        if char not in vowels:\n            consonant_count += 1\n            if consonant_count >= 3 and char != prev_consonant:\n                fixed_word += ' ' + char\n                consonant_count = 1\n            else:\n                fixed_word += char\n            prev_consonant = char\n        else:\n            fixed_word += char\n            consonant_count = 0\n            prev_consonant = None\n\n    return fixed_word\n\nword = input()\nif check_typo(word):\n    print(fix_typo(word))\nelse:\n    print(word)"}
{"solution": "import sys\n\ndef min_time_to_prepare_potions():\n    n, m, k = map(int, sys.stdin.readline().split())\n    x, s = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n    c = list(map(int, sys.stdin.readline().split()))\n    d = list(map(int, sys.stdin.readline().split()))\n\n    min_time = n * x\n\n    # Try using a spell of the first type\n    for i in range(m):\n        if b[i] <= s:\n            time_with_spell = (n - 1) // a[i] * a[i] + x\n            min_time = min(min_time, time_with_spell)\n\n    # Try using a spell of the second type\n    for i in range(k):\n        if d[i] <= s:\n            time_with_spell = (n - c[i]) * x if n > c[i] else 0\n            min_time = min(min_time, time_with_spell)\n\n    # Try using both types of spells\n    for i in range(m):\n        if b[i] > s:\n            continue\n        for j in range(k):\n            if d[j] > s - b[i]:\n                break\n            time_with_spells = (n - c[j]) * a[i] if n > c[j] else 0\n            min_time = min(min_time, time_with_spells)\n\n    return min_time\n\nprint(min_time_to_prepare_potions())"}
{"solution": "import sys\n\ndef max_points(n, k, M, t):\n    t.sort()\n    prefix_sum = [0] * (k + 1)\n    for i in range(1, k + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + t[i - 1]\n\n    dp = [0] * (M + 1)\n    for i in range(1, k + 1):\n        for j in range(M, prefix_sum[i] - 1, -1):\n            dp[j] = max(dp[j], dp[j - prefix_sum[i]] + 1)\n            if i < k and j >= prefix_sum[i + 1]:\n                dp[j] = max(dp[j], dp[j - prefix_sum[i + 1]] + i + 1)\n\n    return dp[M]\n\nn, k, M = map(int, sys.stdin.readline().split())\nt = list(map(int, sys.stdin.readline().split()))\nprint(max_points(n, k, M, t))"}
{"solution": "MOD = 998244353\n\ndef solve(n):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            dp[i] = (dp[i - 1] * 2 + dp[i // 2 - 1] * (i - 1)) % MOD\n        else:\n            dp[i] = (dp[i - 1] * 2) % MOD\n\n    return dp[n]\n\nn = int(input())\nprint(solve(n))"}
{"solution": "def find_position(n, m, k):\n    # Lara moves down first\n    if k < n:\n        return k + 1, 1\n\n    k -= n\n    # Then she moves in a snake fashion\n    for i in range(n - 1, 0, -1):\n        # If k is less than the number of cells in the current row,\n        # Lara is still in this row\n        if k < m - 1:\n            if i % 2 == 0:\n                return i, k + 2\n            else:\n                return i, m - k - 1\n\n        k -= m - 1\n\n    # If Lara hasn't moved k times yet, she moves to the left\n    return 1, k + 1\n\nn, m, k = map(int, input().split())\nrow, col = find_position(n, m, k)\nprint(row, col)"}
{"solution": "import math\n\ndef find_min_max_pair(X):\n    # If X is 1, then a and b should be 1\n    if X == 1:\n        return 1, 1\n\n    # Initialize a and b as X and 1\n    a, b = X, 1\n\n    # Iterate from sqrt(X) to 1\n    for i in range(int(math.sqrt(X)), 0, -1):\n        # If X is divisible by i and i is not equal to 1\n        if X % i == 0 and i != 1:\n            # Update a and b\n            a, b = i, X // i\n            break\n\n    return a, b\n\n# Read input\nX = int(input())\n\n# Find the pair\na, b = find_min_max_pair(X)\n\n# Print the output\nprint(a, b)"}
{"solution": "# Get the input\nlemons = int(input())\napples = int(input())\npears = int(input())\n\n# Calculate the maximum number of lemons that can be used\nmax_lemons = min(lemons, apples // 2, pears // 4)\n\n# Calculate the maximum total number of fruits that can be used\nmax_fruits = max_lemons * 7\n\n# Print the result\nprint(max_fruits)"}
{"solution": "n = int(input())\nratings = list(map(int, input().split()))\nratings.sort()\n\nteam1 = ratings[:n]\nteam2 = ratings[n:]\n\nfor i in range(n):\n    if team1[i] <= team2[i]:\n        print(\"NO\")\n        break\nelse:\n    print(\"YES\")"}
{"solution": "from math import gcd\n\ndef make_coprime(n, arr):\n    moves = 0\n    new_arr = []\n    for i in range(n):\n        new_arr.append(arr[i])\n        if i < n - 1 and gcd(arr[i], arr[i + 1]) != 1:\n            new_arr.append(arr[i] + 1)\n            moves += 1\n    return moves, new_arr\n\nn = int(input())\narr = list(map(int, input().split()))\nmoves, new_arr = make_coprime(n, arr)\nprint(moves)\nprint(*new_arr)"}
{"solution": "import math\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculate the sum of the elements\ns = sum(a)\n\n# Calculate the maximum possible positive integer that divides every element of A\ng = math.gcd(s, k)\n\n# Print the result\nprint(g)"}
{"solution": "def cat_furrier_transform(x):\n    operations = []\n    for i in range(30, -1, -1):\n        if x & (1 << i):\n            operations.append(i)\n            x ^= (1 << i) - 1\n    if len(operations) % 2 == 0:\n        operations.append(0)\n    return operations\n\nx = int(input())\noperations = cat_furrier_transform(x)\nprint(len(operations))\nfor i in range(0, len(operations), 2):\n    print(operations[i], end=' ')"}
{"solution": "# Read the input\nn, k = map(int, input().split())\nbuckets = list(map(int, input().split()))\n\n# Find the maximum bucket size\nmax_bucket = max(buckets)\n\n# Calculate the minimum number of hours required\nmin_hours = k // max_bucket\nif k % max_bucket != 0:\n    min_hours += 1\n\n# Print the result\nprint(min_hours)"}
{"solution": "n, k = map(int, input().split())\nline = input()\n\ngrasshopper = line.index('G')\ninsect = line.index('T')\n\nif (grasshopper - insect) % k == 0 and all(line[i] != '#' for i in range(min(grasshopper, insect) + k, max(grasshopper, insect), k)):\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "import math\n\ndef find_xw(y1, y2, yw, xb, yb, r):\n    # Calculate the slope of the line from the ball to the wall\n    m = (yw - yb) / xb\n\n    # Calculate the y-coordinate of the intersection point of the line and the wall\n    y_intersect = m * xb + yb\n\n    # Check if the ball can hit the wall\n    if y_intersect < y1 - r or y_intersect > y2 + r:\n        return -1\n\n    # Calculate the distance from the intersection point to the goal line\n    d = abs(y_intersect - (y1 + y2) / 2)\n\n    # Check if the ball can bounce off the wall and into the goal\n    if d > (y2 - y1) / 2 + r:\n        return -1\n\n    # Calculate the x-coordinate of the point of aiming\n    xw = xb * (yw - y_intersect) / (yw - yb)\n\n    return xw\n\n# Read the input\ny1, y2, yw, xb, yb, r = map(int, input().split())\n\n# Find the x-coordinate of the point of aiming\nxw = find_xw(y1, y2, yw, xb, yb, r)\n\n# Print the result\nprint(xw)"}
{"solution": "# Get the input\nb, d, s = map(int, input().split())\n\n# Calculate the minimum possible number of missed meals\nmissed_meals = max(0, b + d + s - 2 * max(b, d, s) + 1)\n\n# Print the result\nprint(missed_meals)"}
{"solution": "def find_dimensions(n, sequence):\n    x, y = 1, 1\n    current_position = sequence[0]\n\n    for i in range(1, n):\n        next_position = sequence[i]\n\n        if next_position == current_position + 1:\n            y += 1\n        elif next_position == current_position + y:\n            x += 1\n        elif next_position == current_position - 1 and current_position % y != 1:\n            y -= 1\n        elif next_position == current_position - y and current_position > y:\n            x -= 1\n        else:\n            return \"NO\"\n\n        current_position = next_position\n\n    return \"YES\\n{} {}\\n\".format(x, y)\n\nn = int(input())\nsequence = list(map(int, input().split()))\n\nprint(find_dimensions(n, sequence))"}
{"solution": "def longest_common_subsequence(a, b):\n    m, n = len(a), len(b)\n    dp = [[\"\" for _ in range(n + 1)] for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if a[i - 1] == b[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + a[i - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], key=len)\n\n    return dp[m][n]\n\na = input()\nb = input()\n\nresult = longest_common_subsequence(a, b)\n\nif result:\n    print(result)\nelse:\n    print(\"-\")"}
{"solution": "# Read the number of operations\nn = int(input())\n\n# Read the operations\noperations = input()\n\n# Initialize the number of stones in the pile\nstones = 0\n\n# Initialize the minimum number of stones in the pile\nmin_stones = 0\n\n# Iterate over the operations\nfor op in operations:\n    # If Vasya took a stone\n    if op == '-':\n        # Decrease the number of stones in the pile\n        stones -= 1\n    # If Vasya added a stone\n    else:\n        # Increase the number of stones in the pile\n        stones += 1\n    # Update the minimum number of stones in the pile\n    min_stones = min(min_stones, stones)\n\n# Print the minimum number of stones in the pile\nprint(-min_stones)"}
{"solution": "def max_kefir_liters():\n    n = int(input())\n    a = int(input())\n    b = int(input())\n    c = int(input())\n\n    # Calculate the maximum number of liters Kolya can drink by buying only plastic bottles\n    max_plastic_bottles = n // a\n\n    # Calculate the maximum number of liters Kolya can drink by buying glass bottles\n    # and returning them for a refund\n    max_glass_bottles = 0\n    if b - c > a:\n        # It's not optimal to buy glass bottles and return them\n        pass\n    else:\n        # Kolya can buy as many glass bottles as he can afford\n        glass_bottles = n // b\n        # He can return all of them and get a refund\n        refund = glass_bottles * c\n        # Kolya can use the refund to buy additional plastic bottles\n        additional_plastic_bottles = refund // a\n        # The total number of liters Kolya can drink is the sum of plastic and glass bottles\n        max_glass_bottles = glass_bottles + additional_plastic_bottles\n\n    # Return the maximum number of liters Kolya can drink\n    return max(max_plastic_bottles, max_glass_bottles)\n\nprint(max_kefir_liters())"}
{"solution": "def card_war(n, k1, deck1, k2, deck2):\n    seen_configurations = set()\n    fights = 0\n\n    while deck1 and deck2:\n        card1 = deck1.pop(0)\n        card2 = deck2.pop(0)\n\n        if card1 > card2:\n            deck1.append(card2)\n            deck1.append(card1)\n        else:\n            deck2.append(card1)\n            deck2.append(card2)\n\n        fights += 1\n        configuration = (tuple(deck1), tuple(deck2))\n\n        if configuration in seen_configurations:\n            return -1, -1\n\n        seen_configurations.add(configuration)\n\n    return fights, 1 if deck1 else 2\n\nn = int(input())\nk1 = int(input())\ndeck1 = list(map(int, input().split()))\nk2 = int(input())\ndeck2 = list(map(int, input().split()))\n\nfights, winner = card_war(n, k1, deck1, k2, deck2)\n\nif fights == -1:\n    print(-1)\nelse:\n    print(fights, winner)"}
{"solution": "import re\n\npassword = input()\n\nif len(password) < 5:\n    print(\"Too weak\")\nelif not re.search(\"[a-z]\", password):\n    print(\"Too weak\")\nelif not re.search(\"[A-Z]\", password):\n    print(\"Too weak\")\nelif not re.search(\"[0-9]\", password):\n    print(\"Too weak\")\nelse:\n    print(\"Correct\")"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\ncount_a = [0] * 6\ncount_b = [0] * 6\n\nfor i in a:\n    count_a[i] += 1\n\nfor i in b:\n    count_b[i] += 1\n\nswaps = 0\nfor i in range(1, 6):\n    diff = abs(count_a[i] - count_b[i])\n    if diff % 2 != 0:\n        print(-1)\n        exit()\n    swaps += diff // 2\n\nprint(swaps)"}
{"solution": "def solve():\n    n, m = map(int, input().split())\n    horizontal = input()\n    vertical = input()\n\n    # Create a graph where each junction is a node\n    graph = [[] for _ in range(n * m)]\n\n    # Add edges based on the street directions\n    for i in range(n):\n        for j in range(m - 1):\n            if horizontal[i] == '>':\n                graph[i * m + j].append(i * m + j + 1)\n            else:\n                graph[i * m + j + 1].append(i * m + j)\n\n    for i in range(n - 1):\n        for j in range(m):\n            if vertical[j] == 'v':\n                graph[i * m + j].append((i + 1) * m + j)\n            else:\n                graph[(i + 1) * m + j].append(i * m + j)\n\n    # Check if there is a path from every node to every other node\n    for i in range(n * m):\n        visited = [False] * (n * m)\n        stack = [i]\n        while stack:\n            node = stack.pop()\n            if not visited[node]:\n                visited[node] = True\n                stack.extend(graph[node])\n        if not all(visited):\n            return \"NO\"\n\n    return \"YES\"\n\nprint(solve())"}
{"solution": "def solve(n, a):\n    if n == 1:\n        return \"YES\\n\" + str(a[0])\n    if a[-1] == 0:\n        return \"YES\\n\" + \"(\" + \"->\".join(map(str, a)) + \")\"\n    else:\n        for i in range(n - 1):\n            if a[i] == 1 and a[i + 1] == 1:\n                return \"YES\\n\" + \"(\" * i + \"->\".join(map(str, a[:i + 1])) + \")\" + \"->\" + \"->\".join(map(str, a[i + 1:])) + \")\" * i\n    return \"NO\"\n\nn = int(input())\na = list(map(int, input().split()))\nprint(solve(n, a))"}
{"solution": "def solve(a, b):\n    while a != 0 and b != 0:\n        if a >= 2 * b:\n            a = a - 2 * b\n        elif b >= 2 * a:\n            b = b - 2 * a\n        else:\n            break\n    return a, b\n\nn, m = map(int, input().split())\nresult = solve(n, m)\nprint(result[0], result[1])"}
{"solution": "def count_divisible_numbers(k, a, b):\n    # Calculate the number of multiples of k in the range [1, b]\n    count_b = b // k\n\n    # Calculate the number of multiples of k in the range [1, a-1]\n    count_a = (a - 1) // k\n\n    # The number of k-divisible numbers on the segment [a, b] is the difference between the two counts\n    return count_b - count_a\n\n# Read the input values\nk, a, b = map(int, input().split())\n\n# Print the result\nprint(count_divisible_numbers(k, a, b))"}
{"solution": "k = int(input())\n\ncount = 0\nnum = 1\nresult = 0\n\nwhile count < k:\n    for digit in str(num):\n        count += 1\n        if count == k:\n            result = digit\n            break\n    num += 1\n\nprint(result)"}
{"solution": "n = int(input())\ns = input()\n\n# Count the number of 8's in the string\ncount_eight = s.count('8')\n\n# If there are no 8's, Vasya cannot win\nif count_eight == 0:\n    print('NO')\nelse:\n    # If there is only one 8 and it's not the first character, Vasya cannot win\n    if count_eight == 1 and s[0] != '8':\n        print('NO')\n    else:\n        # If the length of the string is less than or equal to 11, Vasya can win if there is an 8\n        if n <= 11:\n            print('YES')\n        else:\n            # If the length of the string is greater than 11, Vasya can win if there are at least two 8's\n            if count_eight >= 2:\n                print('YES')\n            else:\n                print('NO')"}
{"solution": "MOD = 10**9 + 7\n\ndef factorial(n):\n    fact = [1]\n    for i in range(1, n + 1):\n        fact.append((fact[-1] * i) % MOD)\n    return fact\n\ndef binary_search_permutations(n, x, pos):\n    fact = factorial(n)\n    if pos < x - 1:\n        return 0\n    elif pos == x - 1:\n        return fact[n - 1]\n    else:\n        return (fact[x - 1] * fact[n - x]) % MOD\n\nn, x, pos = map(int, input().split())\nprint(binary_search_permutations(n, x, pos))"}
{"solution": "def decode(s, k):\n    n = len(s)\n    dp = [[False] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n    for i in range(1, n + 1):\n        if s[i - 1] == '?':\n            dp[i][0] = dp[i - 2][0]\n        else:\n            dp[i][0] = True\n        for j in range(1, k + 1):\n            if s[i - 1] == '?':\n                dp[i][j] = dp[i - 2][j] or dp[i - 2][j - 1]\n            elif s[i - 1] == '*':\n                dp[i][j] = dp[i - 2][j - 1]\n                for l in range(2, j + 1):\n                    if dp[i - 2][j - l]:\n                        dp[i][j] = True\n                        break\n            else:\n                dp[i][j] = dp[i - 1][j - 1]\n    if not dp[n][k]:\n        return \"Impossible\"\n    res = [''] * k\n    i = n\n    j = k\n    while i > 0 and j > 0:\n        if s[i - 1] == '?':\n            if dp[i - 2][j]:\n                i -= 2\n            else:\n                res[j - 1] = s[i - 2]\n                i -= 2\n                j -= 1\n        elif s[i - 1] == '*':\n            l = 1\n            while j - l >= 0 and not dp[i - 2][j - l]:\n                l += 1\n            res[j - l:j] = [s[i - 2]] * l\n            i -= 2\n            j -= l\n        else:\n            res[j - 1] = s[i - 1]\n            i -= 1\n            j -= 1\n    return ''.join(res)\n\ns = input()\nk = int(input())\nprint(decode(s, k))"}
{"solution": "# Get the input\nx = int(input())\n\n# Normalize the angle to be in the range of 0 to 360 degrees\nx = (x % 360 + 360) % 360\n\n# Calculate the minimum number of 90 degrees clockwise turns\n# necessary to get a picture in which up direction deviation\n# from vertical is minimum\nif x <= 45 or x >= 315:\n    print(0)\nelif x <= 135:\n    print(1)\nelif x <= 225:\n    print(2)\nelse:\n    print(3)"}
{"solution": "# Get the input\na, b, c = map(int, input().split())\nx, y, z = map(int, input().split())\n\n# Check if it's possible to get the required numbers of spheres\nif a >= x and b >= y and c >= z:\n    print(\"Yes\")\nelif a + b >= x + y and a + c >= x + z and b + c >= y + z:\n    print(\"Yes\")\nelif a + b + c >= x + y + z and (a + b - x - y >= 0 or a + c - x - z >= 0 or b + c - y - z >= 0):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "def solve(n, k, m):\n    dp = [[0] * k for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(k):\n            for digit in range(10):\n                dp[i][(j * 10 + digit) % k] = (dp[i][(j * 10 + digit) % k] + dp[i - 1][j]) % m\n    return dp[n][0]\n\nn, k, m = map(int, input().split())\nprint(solve(n, k, m))"}
{"solution": "# Get the input\nl, r, a = map(int, input().split())\n\n# Calculate the maximum possible size of the team\nteam_size = 2 * min(l, r) + 2 * min(a, abs(l - r))\n\n# Print the result\nprint(team_size)"}
{"solution": "def min_moves(n, k):\n    # If there is only one manhole, return 1\n    if n == 1:\n        return 1\n    # If Nastya is at the first manhole, return 2 * n - 1\n    elif k == 1:\n        return 2 * n - 1\n    # If Nastya is at the last manhole, return 2 * n - 3\n    elif k == n:\n        return 2 * n - 3\n    # Otherwise, return 2 * n + 1\n    else:\n        return 2 * n + 1\n\n# Read input\nn, k = map(int, input().split())\n# Print output\nprint(min_moves(n, k))"}
{"solution": "# Get the input\nn, m = map(int, input().split())\n\n# Initialize the height of the tallest tower\nheight = 0\n\n# Initialize the number of blocks used by the students\nblocks_used = set()\n\n# Loop until all students have made their towers\nwhile n > 0 or m > 0:\n    # If there are students using three-block pieces and they haven't used all their blocks yet\n    if m > 0 and height + 3 not in blocks_used:\n        # Add the height of the tower to the set of blocks used\n        blocks_used.add(height + 3)\n        # Decrease the number of students using three-block pieces\n        m -= 1\n    # If there are students using two-block pieces and they haven't used all their blocks yet\n    elif n > 0 and height + 2 not in blocks_used:\n        # Add the height of the tower to the set of blocks used\n        blocks_used.add(height + 2)\n        # Decrease the number of students using two-block pieces\n        n -= 1\n    # Increment the height of the tallest tower\n    height += 1\n\n# Print the minimum possible height of the tallest tower\nprint(height)"}
{"solution": "n = int(input())\ncards = [int(input()) for _ in range(n)]\n\nfrom collections import Counter\ncard_counts = Counter(cards)\n\npetya_card = None\nvasya_card = None\n\nfor card, count in card_counts.items():\n    if count == n // 2:\n        if petya_card is None:\n            petya_card = card\n        elif vasya_card is None:\n            vasya_card = card\n            break\n\nif petya_card is not None and vasya_card is not None:\n    print(\"YES\")\n    print(petya_card, vasya_card)\nelse:\n    print(\"NO\")"}
{"solution": "# Get the input\nn, k = map(int, input().split())\nsoldiers = list(map(int, input().split()))\n\n# Calculate the total number of soldiers\ntotal_soldiers = sum(soldiers)\n\n# Check if it's possible to arrange the soldiers\nif total_soldiers > 8 * n:\n    print(\"NO\")\nelse:\n    # Count the number of groups with more than 4 soldiers\n    large_groups = sum(1 for s in soldiers if s > 4)\n\n    # If there are more than 2 large groups, it's not possible to arrange them\n    if large_groups > 2:\n        print(\"NO\")\n    else:\n        # If there are 2 large groups, check if they can be arranged in the same row\n        if large_groups == 2:\n            # Find the two large groups\n            large_group_soldiers = [s for s in soldiers if s > 4]\n\n            # Check if they can be arranged in the same row\n            if large_group_soldiers[0] + large_group_soldiers[1] > 8:\n                print(\"NO\")\n            else:\n                print(\"YES\")\n        else:\n            print(\"YES\")"}
{"solution": "n = int(input())\nsticks = list(map(int, input().split()))\n\nmin_cost = float('inf')\nt = 0\n\nfor i in range(1, 101):\n    cost = 0\n    for stick in sticks:\n        cost += min(abs(stick - i), abs(stick - i - 1), abs(stick - i + 1))\n    if cost < min_cost:\n        min_cost = cost\n        t = i\n\nprint(t, min_cost)"}
{"solution": "# Read the input\nn, m = map(int, input().split())\nsky_map = [input() for _ in range(n)]\n\n# Find the boundaries of the stars\nmin_row, max_row, min_col, max_col = n, 0, m, 0\nfor i in range(n):\n    for j in range(m):\n        if sky_map[i][j] == '*':\n            min_row = min(min_row, i)\n            max_row = max(max_row, i)\n            min_col = min(min_col, j)\n            max_col = max(max_col, j)\n\n# Calculate the side length of the square\nside_length = max(max_row - min_row + 1, max_col - min_col + 1)\n\n# Print the result\nprint(side_length)"}
{"solution": "MOD = 10**9 + 7\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\n\ndef solve(n, k, a):\n    cnt = sum(a)\n    if (n - cnt) * cnt > k:\n        return 0\n    k -= (n - cnt) * cnt\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    inv_fact = [1] * (n + 1)\n    inv_fact[n] = inv(fact[n])\n    for i in range(n, 0, -1):\n        inv_fact[i - 1] = inv_fact[i] * i % MOD\n    def C(n, k):\n        return fact[n] * inv_fact[k] * inv_fact[n - k] % MOD\n    res = 0\n    for i in range(k + 1):\n        if i % 2 == k % 2 and i <= 2 * cnt and n - cnt <= i <= n:\n            res = (res + C(n, i) * C(n - 1, i - 1) % MOD) % MOD\n    return res * inv(fact[n]) % MOD * fact[n] % MOD\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nprint(solve(n, k, a))"}
{"solution": "def min_seconds(x, y):\n    seconds = 0\n    while x > y:\n        if x % 2 == 0:\n            x = x // 2\n        else:\n            x = x - 1\n        seconds += 1\n    return seconds\n\nx, y = map(int, input().split())\nprint(min_seconds(x, y))"}
{"solution": "# Get the input\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Calculate the determinant\ndet = a * d - b * c\n\n# If the determinant is not zero, the matrix is not degenerate\nif det != 0:\n    print(0)\nelse:\n    # Calculate the maximum absolute value of the elements\n    max_val = max(abs(a), abs(b), abs(c), abs(d))\n\n    # Calculate the minimum possible value of ||A - B||\n    min_diff = min(abs(a), abs(b), abs(c), abs(d))\n    if min_diff == 0:\n        min_diff = max_val\n    else:\n        min_diff = min(min_diff, max_val - min_diff)\n\n    print(min_diff)"}
{"solution": "# Read input\nn, a, b = map(int, input().split())\ngroups = list(map(int, input().split()))\n\n# Initialize variables\ndenied = 0\none_seaters = a\ntwo_seaters = b\nsingle_in_two_seater = 0\n\n# Iterate over groups\nfor group in groups:\n    # If group is of one person\n    if group == 1:\n        # Try to seat at one-seater table\n        if one_seaters > 0:\n            one_seaters -= 1\n        # If no one-seaters available, try to seat at two-seater table\n        elif two_seaters > 0:\n            two_seaters -= 1\n            single_in_two_seater += 1\n        # If no two-seaters available, try to seat at two-seater table with single person\n        elif single_in_two_seater > 0:\n            single_in_two_seater -= 1\n        # If no seats available, deny service\n        else:\n            denied += 1\n    # If group is of two persons\n    else:\n        # Try to seat at two-seater table\n        if two_seaters > 0:\n            two_seaters -= 1\n        # If no two-seaters available, deny service\n        else:\n            denied += 2\n\n# Print result\nprint(denied)"}
{"solution": "# Get the input\nA, B, C, N = map(int, input().split())\n\n# Check if the data is valid\nif A + B - C > N or A < C or B < C or N < A + B - C or N < 1:\n    print(-1)\nelse:\n    # Calculate the number of students who didn't pass the exam\n    not_passed = N - (A + B - C)\n    # Check if at least one student stayed home\n    if not_passed > 0:\n        print(not_passed)\n    else:\n        print(-1)"}
{"solution": "MOD = 10**9 + 7\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1:\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\ndef inverse(n, p):\n    return power(n, p - 2, p)\n\ndef solve(x, k):\n    if k == 0:\n        return x\n    else:\n        return (solve(x, k - 1) * 2 % MOD * inverse(2, MOD) + solve(x, k - 1) * 2 % MOD * inverse(2, MOD)) % MOD\n\nx, k = map(int, input().split())\nprint(solve(x, k))"}
{"solution": "MOD = 998244353\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\n\ndef solve():\n    n = int(input())\n    lr = [list(map(int, input().split())) for _ in range(n)]\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(n):\n        ndp = [0] * (n + 1)\n        for j in range(i, -1, -1):\n            for k in range(lr[i][0], lr[i][1] + 1):\n                ndp[min(j + (k > lr[i][0] - 1), n)] = (ndp[min(j + (k > lr[i][0] - 1), n)] + dp[j] * inv(lr[i][1] - lr[i][0] + 1)) % MOD\n        dp = ndp\n\n    return dp[n]\n\nprint(solve())"}
{"solution": "# Get the length of the stick\nn = int(input())\n\n# Initialize the count of ways to split the stick\ncount = 0\n\n# Iterate through all possible lengths of the first part\nfor i in range(1, n // 4 + 1):\n    # Iterate through all possible lengths of the second part\n    for j in range(i, (n - i) // 3 + 1):\n        # Calculate the length of the third part\n        k = n - i - j\n        # Check if the lengths form a rectangle but not a square\n        if i != j and i != k and j != k:\n            # Increment the count of ways to split the stick\n            count += 1\n\n# Print the count of ways to split the stick\nprint(count)"}
{"solution": "# Read input\nn, s = map(int, input().split())\nkegs = list(map(int, input().split()))\n\n# Sort the kegs in ascending order\nkegs.sort()\n\n# Calculate the total volume of kvass\ntotal_volume = sum(kegs)\n\n# Check if it's possible to pour s liters of kvass\nif total_volume < s:\n    print(-1)\nelse:\n    # Calculate the minimum volume that can be in the least keg\n    min_volume = (total_volume - s) // (n - 1)\n    # Add the remaining volume to the least keg\n    least_keg = kegs[0] - min_volume\n    print(least_keg)"}
{"solution": "# Read input\nh1, h2 = map(int, input().split())\na, b = map(int, input().split())\n\n# Calculate the distance the caterpillar needs to cover each day\nday_distance = 12 * a\n\n# Calculate the distance the caterpillar slips down each night\nnight_distance = 12 * b\n\n# Calculate the distance the caterpillar needs to cover in total\ntotal_distance = h2 - h1\n\n# If the caterpillar can't cover the distance during the day, it can't reach the apple\nif day_distance <= night_distance:\n    print(-1)\nelse:\n    # Calculate the distance the caterpillar covers during the day without slipping down\n    net_day_distance = day_distance - night_distance\n\n    # Calculate the number of days it takes for the caterpillar to reach the apple\n    days = (total_distance - 1) // net_day_distance + 1\n\n    # If the caterpillar reaches the apple at night, it doesn't count as a full day\n    if (total_distance - 1) % net_day_distance + h1 + day_distance * days <= h2:\n        days += 1\n\n    print(days)"}
{"solution": "# Get the input\nC, Hr, Hb, Wr, Wb = map(int, input().split())\n\n# Calculate the maximum number of red candies Om Nom can eat\nmax_red = min(C // Wr, C // Hr)\n\n# Calculate the maximum number of blue candies Om Nom can eat\nmax_blue = min(C // Wb, C // Hb)\n\n# Calculate the maximum number of joy units Om Nom can get\nmax_joy = max_red * Hr + max_blue * Hb\n\n# Print the result\nprint(max_joy)"}
{"solution": "# Get the start and end coordinates\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\n\n# Calculate the absolute difference between the coordinates\ndx = abs(x1 - x2)\ndy = abs(y1 - y2)\n\n# The minimal number of steps is the maximum of dx and dy\nmin_steps = max(dx, dy)\n\n# Print the result\nprint(min_steps)"}
{"solution": "n = int(input())\nemployees = input()\n\ndepublicans = []\nremocrats = []\n\nfor i in range(n):\n    if employees[i] == 'D':\n        depublicans.append(i)\n    else:\n        remocrats.append(i)\n\nwhile len(depublicans) > 0 and len(remocrats) > 0:\n    if depublicans[0] < remocrats[0]:\n        depublicans.pop(0)\n        if len(remocrats) > 0:\n            remocrats.pop(0)\n    else:\n        remocrats.pop(0)\n        if len(depublicans) > 0:\n            depublicans.pop(0)\n\nif len(depublicans) > 0:\n    print('D')\nelse:\n    print('R')"}
{"solution": "def gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\na, b, x, y = map(int, input().split())\n\n# Reduce the aspect ratio\ng = gcd(x, y)\nx //= g\ny //= g\n\n# Calculate the maximum possible width and height\nmax_width = b * x\nmax_height = a * y\n\n# Calculate the least common multiple of x and y\nlcm = x * y // gcd(x, y)\n\n# Calculate the number of possible variants\nif max_width < a or max_height < b:\n    print(0)\nelse:\n    print(min(max_width // x, max_height // y))"}
{"solution": "def factorial_trailing_zeros(n, b):\n    count = 0\n    while n > 0:\n        n //= b\n        count += n\n    return count\n\nn, b = map(int, input().split())\nprint(factorial_trailing_zeros(n, b))"}
{"solution": "def solve(m, a, b):\n    if a == b:\n        return (m + 1) * (m + 2) // 2\n\n    if a < b:\n        a, b = b, a\n\n    def f(x):\n        return x // a + x // b - x // (a + b)\n\n    return sum(f(i) for i in range(m + 1))\n\nm, a, b = map(int, input().split())\nprint(solve(m, a, b))"}
{"solution": "n = int(input())\nseq = list(map(int, input().split()))\n\n# Check if the first and last elements are odd\nif seq[0] % 2 == 0 or seq[-1] % 2 == 0:\n    print(\"No\")\nelse:\n    # Count the number of odd elements in the sequence\n    odd_count = sum(1 for num in seq if num % 2 != 0)\n\n    # If the number of odd elements is even, it's not possible to divide the sequence into an odd number of subsegments\n    if odd_count % 2 == 0:\n        print(\"No\")\n    else:\n        print(\"Yes\")"}
{"solution": "# Get the coordinates of the two known trees\nx1, y1, x2, y2 = map(int, input().split())\n\n# Check if the two known trees are on the same horizontal or vertical line\nif x1 == x2 or y1 == y2:\n    # Calculate the coordinates of the two unknown trees\n    x3 = x2 if x1 == x2 else x1\n    y3 = y1 if x1 == x2 else y2\n    x4 = x3\n    y4 = y3 if x1 == x2 else y2\nelse:\n    # Check if the two known trees are on a diagonal line\n    if abs(x1 - x2) == abs(y1 - y2):\n        # Calculate the coordinates of the two unknown trees\n        x3 = x1\n        y3 = y2\n        x4 = x2\n        y4 = y1\n    else:\n        # If the two known trees are not on the same horizontal, vertical, or diagonal line, there is no solution\n        x3 = y3 = x4 = y4 = -1\n\n# Print the coordinates of the two unknown trees\nprint(x3, y3, x4, y4)"}
{"solution": "MOD = 10**9 + 7\n\ndef matrix_mult(a, b):\n    c = [[0, 0], [0, 0]]\n    for i in range(2):\n        for j in range(2):\n            for k in range(2):\n                c[i][j] = (c[i][j] + a[i][k] * b[k][j]) % MOD\n    return c\n\ndef matrix_pow(a, n):\n    if n == 1:\n        return a\n    if n % 2 == 1:\n        return matrix_mult(a, matrix_pow(a, n - 1))\n    half_pow = matrix_pow(a, n // 2)\n    return matrix_mult(half_pow, half_pow)\n\nx, y = map(int, input().split())\nn = int(input())\n\nif n == 1:\n    print(x % MOD)\nelse:\n    base = [[1, 1], [1, 0]]\n    power = matrix_pow(base, n - 2)\n    result = (y * power[0][0] + x * power[0][1]) % MOD\n    print(result)"}
{"solution": "n = int(input())\narr = list(map(int, input().split()))\n\n# Check if all elements are zero\nif all(x == 0 for x in arr):\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    # Initialize variables\n    k = 0\n    l = 1\n    r = 0\n    # Iterate over the array\n    for i in range(n):\n        # Update the sum of the current subarray\n        r += arr[i]\n        # If the sum is not zero, increment the number of subarrays and print the subarray\n        if r != 0:\n            k += 1\n            print(l, i + 1)\n            # Reset the sum and the left index of the next subarray\n            r = 0\n            l = i + 2\n    # If the last subarray has zero sum, print it as a separate subarray\n    if r == 0:\n        k += 1\n        print(n, n)\n    # Print the number of subarrays\n    print(k)"}
{"solution": "MOD = 1000000009\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1:\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\ndef min_score(n, m, k):\n    score = m\n    doubles = 0\n    while m >= k:\n        doubles += m // k\n        m %= k\n    score += power(2, doubles, MOD) - 1\n    return score % MOD\n\nn, m, k = map(int, input().split())\nprint(min_score(n, m, k))"}
{"solution": "def is_divisible_by_eight(n):\n    if n == '':\n        return False\n    if int(n) % 8 == 0:\n        return True\n    for i in range(len(n)):\n        if is_divisible_by_eight(n[:i] + n[i+1:]):\n            return True\n    return False\n\ndef find_divisible_by_eight(n):\n    if n == '':\n        return ''\n    if int(n) % 8 == 0:\n        return n\n    for i in range(len(n)):\n        temp = n[:i] + n[i+1:]\n        if is_divisible_by_eight(temp):\n            return temp\n    return ''\n\nn = input()\nif is_divisible_by_eight(n):\n    print('YES')\n    print(find_divisible_by_eight(n))\nelse:\n    print('NO')"}
{"solution": "n, m = map(int, input().split())\nmemory = [list(map(int, input().split())) for _ in range(m)]\n\n# Sort memory by flat number\nmemory.sort()\n\n# Calculate differences between consecutive flats\ndiffs = [memory[i][0] - memory[i-1][0] for i in range(1, m)]\n\n# Check if differences are all equal\nif len(set(diffs)) == 1:\n    # Calculate flats per floor\n    flats_per_floor = diffs[0]\n    # Calculate the floor for the n-th flat\n    for flat, floor in memory:\n        if n <= flat:\n            result = (n - 1) // flats_per_floor + 1\n            break\n    else:\n        result = (n - memory[-1][0]) // flats_per_floor + memory[-1][1]\nelse:\n    result = -1\n\nprint(result)"}
{"solution": "def count_bishwocks(board):\n    count = 0\n    for i in range(len(board) - 1):\n        for j in range(len(board[0])):\n            if i % 2 == 0:\n                if board[i][j] == '0' and board[i+1][j] == '0':\n                    if j < len(board[0]) - 1 and board[i][j+1] == '0':\n                        count += 1\n                    if j > 0 and board[i+1][j-1] == '0':\n                        count += 1\n            else:\n                if board[i][j] == '0' and board[i+1][j] == '0':\n                    if j > 0 and board[i][j-1] == '0':\n                        count += 1\n                    if j < len(board[0]) - 1 and board[i+1][j+1] == '0':\n                        count += 1\n    return count\n\nboard = [input().strip() for _ in range(2)]\nprint(count_bishwocks(board))"}
{"solution": "n = int(input())\ns = input()\n\n# Initialize variables\nmax_pretty = 0\ncurrent_pretty = 0\nlast_upper = -1\nlast_lower = {}\n\n# Iterate over the string\nfor i in range(n):\n    # If the character is uppercase\n    if s[i].isupper():\n        # Update the last uppercase character position\n        last_upper = i\n        # Reset the current pretty set\n        current_pretty = 0\n        last_lower = {}\n    # If the character is lowercase\n    else:\n        # If the character is not in the last lowercase dictionary\n        if s[i] not in last_lower:\n            # Add the character to the dictionary with its position\n            last_lower[s[i]] = i\n            # Increment the current pretty set\n            current_pretty += 1\n        # If the character is in the last lowercase dictionary\n        else:\n            # If the last uppercase character is before the last occurrence of the character\n            if last_upper < last_lower[s[i]]:\n                # Update the last occurrence of the character\n                last_lower[s[i]] = i\n            # If the last uppercase character is after the last occurrence of the character\n            else:\n                # Reset the current pretty set\n                current_pretty = i - last_upper\n                # Update the last occurrence of the character\n                last_lower[s[i]] = i\n        # Update the maximum pretty set\n        max_pretty = max(max_pretty, current_pretty)\n\n# Print the maximum pretty set\nprint(max_pretty)"}
{"solution": "# Read the number of elements\nn = int(input())\n\n# Read the elements and store them in a list\na = list(map(int, input().split()))\n\n# Calculate the total sum of the elements\ntotal_sum = sum(a)\n\n# Initialize the maximum possible value of B - C\nmax_diff = 0\n\n# Iterate over all possible subsets of the sequence\nfor i in range(1 << n):\n    # Calculate the sum of the current subset\n    subset_sum = 0\n    for j in range(n):\n        if i & (1 << j):\n            subset_sum += a[j]\n\n    # Update the maximum possible value of B - C\n    max_diff = max(max_diff, abs(total_sum - 2 * subset_sum))\n\n# Print the maximum possible value of B - C\nprint(max_diff)"}
{"solution": "def min_refuels(a, b, f, k):\n    # Calculate the distance the bus can travel with a full tank\n    full_tank_distance = b\n\n    # Calculate the distance the bus can travel in one journey\n    journey_distance = 2 * a\n\n    # Calculate the distance the bus can travel between refuels in one direction\n    refuel_distance = min(f, full_tank_distance)\n\n    # Calculate the number of journeys the bus can make with one refuel\n    journeys_per_refuel = refuel_distance // a\n\n    # Calculate the minimum number of refuels needed\n    min_refuels = k // journeys_per_refuel\n    if k % journeys_per_refuel != 0:\n        min_refuels += 1\n\n    # Check if it is possible to make k journeys\n    if min_refuels * refuel_distance < k * a:\n        return -1\n\n    return min_refuels\n\n# Read input\na, b, f, k = map(int, input().split())\n\n# Print output\nprint(min_refuels(a, b, f, k))"}
{"solution": "n, p, q = map(int, input().split())\ns = input()\n\ndef split_string(s, p, q):\n    result = []\n    i = 0\n    while i < len(s):\n        if i + p <= len(s):\n            result.append(s[i:i+p])\n            i += p\n        elif i + q <= len(s):\n            result.append(s[i:i+q])\n            i += q\n        else:\n            return -1\n    return result\n\nresult = split_string(s, p, q)\nif result == -1:\n    print(-1)\nelse:\n    print(len(result))\n    for r in result:\n        print(r)"}
{"solution": "def solve(n, m, s, d, obstacles):\n    obstacles.sort()\n    current_position = 0\n    for obstacle in obstacles:\n        if obstacle - current_position < s:\n            return \"IMPOSSIBLE\"\n        else:\n            print(f\"RUN {s}\")\n            current_position += s\n            if obstacle - current_position > d:\n                return \"IMPOSSIBLE\"\n            else:\n                print(f\"JUMP {obstacle - current_position}\")\n                current_position = obstacle\n    if m - current_position < s:\n        return \"IMPOSSIBLE\"\n    else:\n        print(f\"RUN {m - current_position}\")\n        return \"POSSIBLE\"\n\nn, m, s, d = map(int, input().split())\nobstacles = list(map(int, input().split()))\nprint(solve(n, m, s, d, obstacles))"}
{"solution": "def count_pairs(s, x):\n    if s < x or (s + x) % 2 != 0:\n        return 0\n\n    a = (s + x) // 2\n    b = (s - a)\n\n    if a < b or a < 1 or b < 1:\n        return 0\n\n    if a == b:\n        return 1\n\n    count = 0\n    for i in range(60):\n        if (a >> i) & 1 != (b >> i) & 1:\n            if (x >> i) & 1:\n                return 0\n        elif (a >> i) & 1:\n            count += 1\n\n    return 2 ** count\n\ns, x = map(int, input().split())\nprint(count_pairs(s, x))"}
{"solution": "# Read the input\nn, k = map(int, input().split())\n\n# Calculate the minimum number of actions\nl = (n + 2 * k) // (2 * k + 1)\n\n# Calculate the positions of the skewers to be turned\npositions = [(i - 1) * (2 * k + 1) + k + 1 for i in range(l)]\n\n# Print the output\nprint(l)\nprint(' '.join(map(str, positions)))"}
{"solution": "def min_operations(n):\n    # Convert the number to string for easy manipulation\n    n = str(n)\n\n    # Initialize the minimum operations to infinity\n    min_ops = float('inf')\n\n    # Iterate over all possible lengths of the square root\n    for i in range(1, len(n) // 2 + 2):\n        # Iterate over all possible starting indices of the square root\n        for j in range(len(n) - i + 1):\n            # Extract the square root candidate\n            sqrt = n[j:j + i]\n\n            # Check if the square root is a valid number\n            if sqrt[0] != '0' and int(sqrt) ** 2 <= int(n):\n                # Calculate the number of operations required\n                ops = len(n) - len(str(int(sqrt) ** 2))\n\n                # Update the minimum number of operations\n                min_ops = min(min_ops, ops)\n\n    # Return the minimum number of operations or -1 if it is impossible\n    return min_ops if min_ops != float('inf') else -1\n\n# Read the input\nn = int(input())\n\n# Print the result\nprint(min_operations(n))"}
{"solution": "MOD = 10**9 + 7\n\ndef factorial(n):\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = (fact[i - 1] * i) % MOD\n    return fact\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1:\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\ndef find_f_max(n):\n    fact = factorial(n)\n    inv_fact = [power(i, MOD - 2, MOD) for i in fact]\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        for j in range(i, 0, -1):\n            dp[j] = (dp[j] + dp[j - 1] * inv_fact[i] * fact[j - 1]) % MOD\n    return dp[n]\n\nn = int(input())\nprint(find_f_max(n))"}
{"solution": "# Get the input string\ns = input()\n\n# Define the vowels\nvowels = ['A', 'E', 'I', 'O', 'U', 'Y']\n\n# Initialize the maximum jump length and the current position\nmax_jump = 0\ncurrent_pos = 0\n\n# Loop through the string\nwhile current_pos < len(s):\n    # Find the next vowel position\n    next_vowel_pos = float('inf')\n    for v in vowels:\n        try:\n            next_vowel_pos = min(next_vowel_pos, s.index(v, current_pos))\n        except ValueError:\n            pass\n\n    # If there is no next vowel, break the loop\n    if next_vowel_pos == float('inf'):\n        break\n\n    # Update the maximum jump length\n    max_jump = max(max_jump, next_vowel_pos - current_pos)\n\n    # Move the current position to the next vowel\n    current_pos = next_vowel_pos\n\n# Print the result\nprint(max_jump)"}
{"solution": "# Get the input\na1, a2, a3, a4 = map(int, input().split())\n\n# Calculate the total sum of candies\ntotal = a1 + a2 + a3 + a4\n\n# Check if the total sum is odd, if so, it's impossible to distribute the candies equally\nif total % 2 != 0:\n    print(\"NO\")\nelse:\n    # Check if it's possible to distribute the candies equally\n    if (a1 == total // 2) or (a2 == total // 2) or (a3 == total // 2) or (a4 == total // 2):\n        print(\"YES\")\n    elif (a1 + a2 == total // 2) or (a1 + a3 == total // 2) or (a1 + a4 == total // 2) or (a2 + a3 == total // 2) or (a2 + a4 == total // 2) or (a3 + a4 == total // 2):\n        print(\"YES\")\n    elif a1 + a2 + a3 == total // 2 or a1 + a2 + a4 == total // 2 or a1 + a3 + a4 == total // 2 or a2 + a3 + a4 == total // 2:\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "# Get the number of slices\nn = int(input())\n\n# Get the sizes of the slices\nslices = list(map(int, input().split()))\n\n# Initialize the scores of Alice and Bob\nalice_score = 0\nbob_score = 0\n\n# Initialize the decider as Bob\ndecider = 'Bob'\n\n# While there are still slices left\nwhile slices:\n    # If it's Bob's turn to decide\n    if decider == 'Bob':\n        # Bob takes the largest slice\n        bob_score += max(slices)\n        # Remove the slice from the list\n        slices.remove(max(slices))\n        # Bob gives the decider to Alice\n        decider = 'Alice'\n    # If it's Alice's turn to decide\n    else:\n        # Alice takes the largest slice\n        alice_score += max(slices)\n        # Remove the slice from the list\n        slices.remove(max(slices))\n        # Alice gives the decider to Bob\n        decider = 'Bob'\n\n# Print the scores of Alice and Bob\nprint(alice_score, bob_score)"}
{"solution": "def find_min_variables(n, a):\n    # Create a dictionary to store the sums of pairs of variables\n    sums = {}\n    # Initialize the number of variables to 0\n    m = 0\n    # Iterate through the given sequence of integers\n    for i in range(n):\n        # If the current integer is not in the dictionary of sums\n        if a[i] not in sums:\n            # If there are no variables available\n            if m == 0:\n                # Assign the current integer to a new variable\n                sums[a[i]] = (m, m)\n                m += 1\n            # If there is only one variable available\n            elif m == 1:\n                # Check if the current integer can be obtained by adding the existing variable to itself\n                if a[i] % 2 == 0 and a[i] // 2 in sums:\n                    # Assign the current integer to a new variable by adding the existing variable to itself\n                    sums[a[i]] = (sums[a[i] // 2][0], sums[a[i] // 2][0])\n                    m += 1\n                else:\n                    # It is not possible to obtain the current integer using the existing variable\n                    return -1\n            # If there are two or more variables available\n            else:\n                # Initialize a flag to indicate if the current integer can be obtained using the existing variables\n                found = False\n                # Iterate through all pairs of variables\n                for x in sums:\n                    if (a[i] - x) in sums and sums[x] != sums[a[i] - x]:\n                        # Assign the current integer to a new variable by adding the pair of variables\n                        sums[a[i]] = (sums[x][0], sums[a[i] - x][0])\n                        found = True\n                        break\n                # If the current integer cannot be obtained using the existing variables\n                if not found:\n                    # It is not possible to obtain the current integer using the existing variables\n                    return -1\n    # Return the minimum number of variables required\n    return m\n\n# Read the input\nn = int(input())\na = list(map(int, input().split()))\n\n# Print the minimum number of variables required\nprint(find_min_variables(n, a))"}
{"solution": "n = int(input())\npiles = list(map(int, input().split()))\n\n# If all piles have the same number of stones, the second player will win\nif len(set(piles)) == 1:\n    print(\"Bob\")\nelse:\n    print(\"Alice\")"}
{"solution": "n = int(input())\nnums = list(map(int, input().split()))\nnums.sort()\n\nif n == 1:\n    print(\"YES\")\nelif n == 2:\n    if (nums[1] - nums[0]) % 2 == 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    diff1 = nums[1] - nums[0]\n    diff2 = nums[2] - nums[1]\n    if diff1 == diff2:\n        if all(nums[i] - nums[i - 1] == diff1 for i in range(2, n)):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n    else:\n        print(\"NO\")"}
{"solution": "n = int(input())\ns = input()\n\nmax_len = 0\nfor i in range(n):\n    for j in range(i+max_len, n):\n        substring = s[i:j+1]\n        if s.count(substring) >= 2 and len(substring) > max_len:\n            max_len = len(substring)\n\nprint(max_len)"}
{"solution": "# Read input\nn, a = map(int, input().split())\n\n# Calculate the minimum time Vasya needs to reach house a\nif a <= n // 2:\n    # If house a is on the left side of the street\n    time = a\nelse:\n    # If house a is on the right side of the street\n    time = n - a\n\n# Print the result\nprint(time)"}
{"solution": "def check_possible(n, m, lightsabers, desired_counts):\n    counts = [0] * m\n    for i in range(n):\n        counts[lightsabers[i] - 1] += 1\n        if i >= desired_counts[0]:\n            counts[lightsabers[i - desired_counts[0]] - 1] -= 1\n        if i >= sum(desired_counts) - 1 and counts == desired_counts:\n            return True\n    return False\n\nn, m = map(int, input().split())\nlightsabers = list(map(int, input().split()))\ndesired_counts = list(map(int, input().split()))\n\nif check_possible(n, m, lightsabers, desired_counts):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n = int(input())\nmishka_wins = 0\nchris_wins = 0\n\nfor _ in range(n):\n    mishka, chris = map(int, input().split())\n    if mishka > chris:\n        mishka_wins += 1\n    elif chris > mishka:\n        chris_wins += 1\n\nif mishka_wins > chris_wins:\n    print(\"Mishka\")\nelif chris_wins > mishka_wins:\n    print(\"Chris\")\nelse:\n    print(\"Friendship is magic!^^\")"}
{"solution": "def is_valid(field, n, m):\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                continue\n            elif field[i][j] == '.':\n                if not is_safe(field, i, j, n, m):\n                    return False\n            else:\n                if not is_correct(field, i, j, n, m):\n                    return False\n    return True\n\ndef is_safe(field, i, j, n, m):\n    for x in range(max(0, i-1), min(n, i+2)):\n        for y in range(max(0, j-1), min(m, j+2)):\n            if field[x][y] == '*':\n                return False\n    return True\n\ndef is_correct(field, i, j, n, m):\n    count = 0\n    for x in range(max(0, i-1), min(n, i+2)):\n        for y in range(max(0, j-1), min(m, j+2)):\n            if field[x][y] == '*':\n                count += 1\n    return count == int(field[i][j])\n\nn, m = map(int, input().split())\nfield = []\nfor _ in range(n):\n    field.append(list(input()))\n\nprint(\"YES\" if is_valid(field, n, m) else \"NO\")"}
{"solution": "def min_candies(n):\n    k = 1\n    while True:\n        vasya_eats = 0\n        candies = n\n        while candies > 0:\n            vasya_eats += min(k, candies)\n            candies -= min(k, candies)\n            if candies > 0:\n                candies -= candies // 10\n        if vasya_eats >= n // 2:\n            return k\n        k += 1\n\nn = int(input())\nprint(min_candies(n))"}
{"solution": "def check_necklace(s):\n    pearls = [i for i, x in enumerate(s) if x == 'o']\n    n = len(pearls)\n    diff = [pearls[(i+1)%n] - pearls[i] - 1 for i in range(n)]\n    return 'YES' if len(set(diff)) == 1 else 'NO'\n\ns = input()\nprint(check_necklace(s))"}
{"solution": "# Get the input\nn, m, k = map(int, input().split())\n\n# Calculate the maximum number of pillows Frodo can have\n# First, each hobbit gets one pillow\nm -= n\n# Then, Frodo takes as many pillows as he can without making anyone hurt\nfrodo_pillows = min(m, k-1, n-k) * 2 + 1\n\n# Print the result\nprint(frodo_pillows)"}
{"solution": "import math\n\ndef max_subarray_cost(n, m, k, a):\n    max_cost = 0\n    curr_cost = 0\n    curr_sum = 0\n    for i in range(n):\n        curr_sum += a[i]\n        curr_cost = curr_sum - k * math.ceil((i + 1) / m)\n        if curr_cost > max_cost:\n            max_cost = curr_cost\n        if curr_cost < 0:\n            curr_cost = 0\n            curr_sum = 0\n    return max_cost\n\nn, m, k = map(int, input().split())\na = list(map(int, input().split()))\nprint(max_subarray_cost(n, m, k, a))"}
{"solution": "def main():\n    n, m = map(int, input().split())\n\n    if n > m:\n        n, m = m, n\n\n    if n == 0:\n        print(f\"0 0\\n0 {m}\\n0 {m-1}\\n0 {m-2}\")\n    elif n == 1:\n        print(f\"0 0\\n1 0\\n1 {m}\\n0 {m}\")\n    else:\n        print(f\"0 0\\n{n} 0\\n{n} {m}\\n0 {m}\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "from collections import Counter\n\ndef find_smallest_number(shuffled, substring):\n    shuffled_counter = Counter(shuffled)\n    substring_counter = Counter(substring)\n\n    # Find the first occurrence of the substring in the shuffled string\n    start_index = shuffled.index(substring)\n\n    # Calculate the number of digits to the left of the substring\n    left_digits = ''\n    for char in shuffled[:start_index]:\n        if shuffled_counter[char] > substring_counter[char]:\n            left_digits += char\n            shuffled_counter[char] -= 1\n\n    # Calculate the number of digits to the right of the substring\n    right_digits = ''\n    for char in shuffled[start_index + len(substring):]:\n        if shuffled_counter[char] > substring_counter[char]:\n            right_digits += char\n            shuffled_counter[char] -= 1\n\n    # Sort the left and right digits\n    left_digits = ''.join(sorted(left_digits))\n    right_digits = ''.join(sorted(right_digits, reverse=True))\n\n    # Construct the smallest possible initial integer\n    n = left_digits + substring + right_digits\n\n    # Remove leading zeros, except if n is 0\n    if n != '0':\n        n = n.lstrip('0')\n\n    return n\n\n# Read input\nshuffled = input()\nsubstring = input()\n\n# Find and print the smallest possible initial integer\nn = find_smallest_number(shuffled, substring)\nprint(n)"}
{"solution": "n, m, min_val, max_val = map(int, input().split())\ntemperatures = list(map(int, input().split()))\n\n# Check if the minimum and maximum temperatures are in the list of reported temperatures\nif min_val not in temperatures or max_val not in temperatures:\n    print('Incorrect')\nelse:\n    # Check if the number of temperatures that are equal to min_val or max_val is greater than or equal to n - m\n    if temperatures.count(min_val) + temperatures.count(max_val) >= n - m:\n        print('Correct')\n    else:\n        print('Incorrect')"}
{"solution": "def find_factorials_with_trailing_zeros(m):\n    # Initialize the count of numbers with m trailing zeros\n    count = 0\n    # Initialize the list to store the numbers\n    numbers = []\n    # Initialize the factorial and the number\n    factorial = 1\n    n = 1\n    # Loop until the number of trailing zeros in factorial is less than or equal to m\n    while True:\n        # Calculate the factorial\n        factorial *= n\n        # Count the number of trailing zeros in factorial\n        num_zeros = 0\n        while factorial % 10 == 0:\n            factorial //= 10\n            num_zeros += 1\n        # If the number of trailing zeros is equal to m, increment the count and add the number to the list\n        if num_zeros == m:\n            count += 1\n            numbers.append(n)\n        # If the number of trailing zeros is greater than m, break the loop\n        elif num_zeros > m:\n            break\n        # Increment the number\n        n += 1\n    # Return the count and the list of numbers\n    return count, numbers\n\n# Read the input\nm = int(input())\n# Find the number of factorials with m trailing zeros and the list of numbers\ncount, numbers = find_factorials_with_trailing_zeros(m)\n# Print the output\nprint(count)\nprint(*numbers)"}
{"solution": "import heapq\nimport sys\n\ndef dijkstra(graph, start):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n\n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node].items():\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n\n    return distances\n\ndef find_farthest_special_vertex(graph, special_vertices):\n    farthest_distances = []\n\n    for special_vertex in special_vertices:\n        distances = dijkstra(graph, special_vertex)\n        max_distance = 0\n\n        for vertex in special_vertices:\n            max_distance = max(max_distance, distances[vertex])\n\n        farthest_distances.append(max_distance)\n\n    return farthest_distances\n\ndef main():\n    n, m, k = map(int, sys.stdin.readline().split())\n    special_vertices = list(map(int, sys.stdin.readline().split()))\n    graph = {i: {} for i in range(1, n + 1)}\n\n    for _ in range(m):\n        u, v, w = map(int, sys.stdin.readline().split())\n        graph[u][v] = min(graph[u].get(v, float('inf')), w)\n        graph[v][u] = min(graph[v].get(u, float('inf')), w)\n\n    farthest_distances = find_farthest_special_vertex(graph, special_vertices)\n    print(*farthest_distances)\n\nif __name__ == '__main__':\n    main()"}
{"solution": "n = int(input())\nx = int(input())\n\n# If the number of movements is even, the ball's position will be the same as the final position\n# If the number of movements is odd, the ball's position will be the opposite of the final position\n# when considering the left and right shells (0 and 2)\n\nif n % 2 == 0:\n    print(x)\nelse:\n    if x == 0:\n        print(1)\n    elif x == 1:\n        print(0)\n    else:\n        print(1)"}
{"solution": "def check_square(rectangles):\n    x_coords = set()\n    y_coords = set()\n    for rect in rectangles:\n        x_coords.add(rect[0])\n        x_coords.add(rect[2])\n        y_coords.add(rect[1])\n        y_coords.add(rect[3])\n\n    x_coords = sorted(list(x_coords))\n    y_coords = sorted(list(y_coords))\n\n    if len(x_coords) != len(y_coords):\n        return False\n\n    length = x_coords[-1] - x_coords[0]\n    for i in range(1, len(x_coords)):\n        if x_coords[i] - x_coords[i-1] != length:\n            return False\n\n    for i in range(1, len(y_coords)):\n        if y_coords[i] - y_coords[i-1] != length:\n            return False\n\n    return True\n\nn = int(input())\nrectangles = []\nfor _ in range(n):\n    rect = list(map(int, input().split()))\n    rectangles.append(rect)\n\nif check_square(rectangles):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def sum_of_digits(n):\n    return sum(int(digit) for digit in str(n))\n\ndef count_really_big_numbers(n, s):\n    count = 0\n    for i in range(1, n + 1):\n        if i - sum_of_digits(i) >= s:\n            count += 1\n    return count\n\nn, s = map(int, input().split())\nprint(count_really_big_numbers(n, s))"}
{"solution": "from collections import defaultdict\n\ndef check_possible(n, points):\n    x_dict = defaultdict(int)\n    y_dict = defaultdict(int)\n    xy_dict = defaultdict(int)\n    yx_dict = defaultdict(int)\n\n    for x, y in points:\n        x_dict[x] += 1\n        y_dict[y] += 1\n        xy_dict[x - y] += 1\n        yx_dict[y - x] += 1\n\n    max_x = max(x_dict.values())\n    max_y = max(y_dict.values())\n    max_xy = max(xy_dict.values())\n    max_yx = max(yx_dict.values())\n\n    return max_x + max_y >= n or max_xy + max_yx >= n\n\ndef main():\n    n = int(input())\n    points = [tuple(map(int, input().split())) for _ in range(n)]\n\n    if check_possible(n, points):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "MOD = 10**9 + 7\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1:\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\ndef find_ways(a, b, k, t):\n    if a >= b + t * k:\n        return 0\n    if a <= b - t * k:\n        return power(2 * k + 1, t, MOD)\n    diff = b - a\n    total_ways = power(2 * k + 1, t, MOD)\n    for i in range(diff // k, t + 1):\n        total_ways -= power(2 * k - (diff - i * k), t - i, MOD)\n        total_ways %= MOD\n    return total_ways\n\na, b, k, t = map(int, input().split())\nprint(find_ways(a, b, k, t))"}
{"solution": "def find_min_marks(n, l, x, y, marks):\n    marks_set = set(marks)\n    add_marks = []\n\n    if x not in [marks[i] - marks[j] for i in range(n) for j in range(i)]:\n        if x in marks_set:\n            pass\n        elif x + marks[-1] <= l and x + marks[-1] not in marks_set:\n            add_marks.append(x + marks[-1])\n        elif x + marks[0] <= l and x + marks[0] not in marks_set:\n            add_marks.append(x + marks[0])\n\n    if y not in [marks[i] - marks[j] for i in range(n) for j in range(i)]:\n        if y in marks_set:\n            pass\n        elif y + marks[-1] <= l and y + marks[-1] not in marks_set:\n            add_marks.append(y + marks[-1])\n        elif y + marks[0] <= l and y + marks[0] not in marks_set:\n            add_marks.append(y + marks[0])\n\n    return len(add_marks), add_marks\n\nn, l, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\n\nv, p = find_min_marks(n, l, x, y, marks)\nprint(v)\nprint(*p)"}
{"solution": "import math\n\ndef max_volume_cake(n, cakes):\n    # Sort cakes by radius\n    cakes.sort(key=lambda x: x[0])\n\n    # Initialize dp array with volume of each cake\n    dp = [math.pi * r * r * h for r, h in cakes]\n\n    # Iterate over cakes\n    for i in range(1, n):\n        # Iterate over previous cakes\n        for j in range(i):\n            # If current cake can be placed on previous cake\n            if cakes[i][0] < cakes[j][0] and cakes[i][1] > cakes[j][1]:\n                # Update dp value\n                dp[i] = max(dp[i], dp[j] + math.pi * cakes[i][0] * cakes[i][0] * cakes[i][1])\n\n    # Return maximum volume\n    return max(dp)\n\n# Read input\nn = int(input())\ncakes = [list(map(int, input().split())) for _ in range(n)]\n\n# Print output\nprint(max_volume_cake(n, cakes))"}
{"solution": "def min_slices(n, k, h):\n    h.sort()\n    min_height = h[0]\n    slices = 0\n    removed_cubes = 0\n    for i in range(n):\n        if h[i] > min_height:\n            if removed_cubes + (h[i] - min_height) * (n - i) <= k:\n                removed_cubes += (h[i] - min_height) * (n - i)\n            else:\n                min_height = h[i] - (k - removed_cubes) // (n - i)\n                removed_cubes = k\n                slices += 1\n        if removed_cubes == k:\n            slices += 1\n            removed_cubes = 0\n    return slices\n\nn, k = map(int, input().split())\nh = list(map(int, input().split()))\nprint(min_slices(n, k, h))"}
{"solution": "n = int(input())\ncards = list(map(int, input().split()))\n\n# Calculate prefix sum array\nprefix_sum = [0] * (n + 1)\nfor i in range(1, n + 1):\n    prefix_sum[i] = prefix_sum[i - 1] + cards[i - 1]\n\n# Initialize maximum score\nmax_score = 0\n\n# Iterate over all possible segments\nfor l in range(1, n + 1):\n    for r in range(l, n + 1):\n        # Calculate score for current segment\n        score = prefix_sum[l - 1] + prefix_sum[n] - prefix_sum[r]\n        # Remove the card that Bob will choose\n        score -= min(cards[l - 1], cards[r - 1])\n        # Update maximum score\n        max_score = max(max_score, score)\n\nprint(max_score)"}
{"solution": "def gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\nk1, k2, k3 = map(int, input().split())\n\nif lcm(k1, k2) <= 1500 or lcm(k1, k3) <= 1500 or lcm(k2, k3) <= 1500 or lcm(lcm(k1, k2), k3) <= 1500:\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "n = int(input())\ns = input()\n\nstack = []\n\nfor char in s:\n    if stack and stack[-1][0] == char:\n        stack[-1][1] += 1\n    else:\n        stack.append([char, 1])\n\noperations = 0\nwhile stack:\n    if stack[-1][1] == 1:\n        operations += 1\n        stack.pop()\n    else:\n        stack[-1][1] -= 1\n\nprint(operations)"}
{"solution": "# Read the number of boys\nn = int(input())\n\n# Read the boys' dancing skills\nboys = list(map(int, input().split()))\n\n# Read the number of girls\nm = int(input())\n\n# Read the girls' dancing skills\ngirls = list(map(int, input().split()))\n\n# Sort the boys' and girls' dancing skills\nboys.sort()\ngirls.sort()\n\n# Initialize the number of pairs\npairs = 0\n\n# Iterate over the boys' and girls' dancing skills\ni = 0\nj = 0\nwhile i < n and j < m:\n    # If the current boy and girl can form a pair\n    if abs(boys[i] - girls[j]) <= 1:\n        # Increment the number of pairs\n        pairs += 1\n        # Move to the next boy and girl\n        i += 1\n        j += 1\n    # If the current boy's skill is less than the current girl's skill\n    elif boys[i] < girls[j]:\n        # Move to the next boy\n        i += 1\n    # If the current girl's skill is less than the current boy's skill\n    else:\n        # Move to the next girl\n        j += 1\n\n# Print the maximum possible number of pairs\nprint(pairs)"}
{"solution": "# Read the input\nteam1_player1 = list(map(int, input().split()))\nteam1_player2 = list(map(int, input().split()))\nteam2_player1 = list(map(int, input().split()))\nteam2_player2 = list(map(int, input().split()))\n\n# Calculate the possible defence and attack for each team\nteam1_defence = max(team1_player1[0], team1_player2[0])\nteam1_attack = max(team1_player1[1], team1_player2[1])\nteam2_defence = max(team2_player1[0], team2_player2[0])\nteam2_attack = max(team2_player1[1], team2_player2[1])\n\n# Determine the winner\nif team1_defence > team2_attack and team1_attack > team2_defence:\n    print(\"Team 1\")\nelif team2_defence > team1_attack and team2_attack > team1_defence:\n    print(\"Team 2\")\nelse:\n    print(\"Draw\")"}
{"solution": "import sys\nfrom scipy.optimize import minimize_scalar\nfrom math import sqrt\n\ndef distance(x, y, points):\n    return sum(c / sqrt((px - x) ** 2 + (py - y) ** 2) for px, py, c in points)\n\ndef solve():\n    n, k = map(int, sys.stdin.readline().split())\n    points = [tuple(map(int, sys.stdin.readline().split())) for _ in range(n)]\n\n    min_x = min(x for x, _, _ in points)\n    max_x = max(x for x, _, _ in points)\n    min_y = min(y for _, y, _ in points)\n    max_y = max(y for _, y, _ in points)\n\n    def objective(t):\n        return max(distance(x, y, points) for x in (min_x, max_x) for y in (min_y, max_y)) - t\n\n    result = minimize_scalar(objective, bounds=(0, 10000), method='bounded')\n    print(result.fun + k)\n\nsolve()"}
{"solution": "n = int(input())\nticket = input()\n\nleft_sum = 0\nright_sum = 0\nleft_unknown = 0\nright_unknown = 0\n\nfor i in range(n // 2):\n    if ticket[i] == '?':\n        left_unknown += 1\n    else:\n        left_sum += int(ticket[i])\n\nfor i in range(n // 2, n):\n    if ticket[i] == '?':\n        right_unknown += 1\n    else:\n        right_sum += int(ticket[i])\n\nif left_unknown % 2 == 1 and right_unknown % 2 == 1:\n    print(\"Monocarp\")\nelif left_sum > right_sum or (left_sum == right_sum and left_unknown > right_unknown):\n    print(\"Monocarp\")\nelse:\n    print(\"Bicarp\")"}
{"solution": "# Get the number of bus routes and the time Serval goes to the station\nn, t = map(int, input().split())\n\n# Initialize a list to store the earliest arrival time for each bus route\nearliest_arrival = []\n\n# For each bus route\nfor i in range(n):\n    # Get the time when the first bus of this route arrives and the interval between two buses of this route\n    s, d = map(int, input().split())\n\n    # Calculate the earliest arrival time for this bus route\n    if s <= t:\n        earliest_arrival.append(s + (t - s) // d * d)\n    else:\n        earliest_arrival.append(s)\n\n# Find the index of the earliest arrival time\nindex = earliest_arrival.index(min(earliest_arrival))\n\n# Print the bus route Serval will use\nprint(index + 1)"}
{"solution": "from math import comb\n\ndef count_numbers(n, k):\n    if k > n.bit_length():\n        return 0\n    if k == n.bit_length():\n        return 1\n    if k == 1:\n        return bin(n).count('1')\n    return count_numbers(n - (1 << (n.bit_length() - 1)), k - 1) + \\\n           (1 << (n.bit_length() - 1)) - (n - (1 << (n.bit_length() - 1)) + 1) + \\\n           count_numbers((1 << (n.bit_length() - 1)) - 1, k)\n\ndef find_n(m, k):\n    left, right = 1, 10**18\n    while left < right:\n        mid = (left + right) // 2\n        if count_numbers(2 * mid, k) - count_numbers(mid, k) >= m:\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\nm, k = map(int, input().split())\nprint(find_n(m, k))"}
{"solution": "n = int(input())\nlevel = input()\n\n# Find the indices of all platforms\nplatforms = [i for i in range(n) if level[i] == '*']\n\n# Check if there is a sequence of four jumps of the same length\nfor i in range(len(platforms) - 4):\n    if (platforms[i + 1] - platforms[i] ==\n        platforms[i + 2] - platforms[i + 1] ==\n        platforms[i + 3] - platforms[i + 2] ==\n        platforms[i + 4] - platforms[i + 3]):\n        print('yes')\n        exit()\n\nprint('no')"}
{"solution": "def solve_magic_square(n, grid):\n    total_sum = (n * n + 1) * n // 2\n    row_sums = [sum(row) for row in grid]\n    col_sums = [sum(col) for col in zip(*grid)]\n    diag_sum1 = sum(grid[i][i] for i in range(n))\n    diag_sum2 = sum(grid[i][n - i - 1] for i in range(n))\n\n    empty_cell = (0, 0)\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 0:\n                empty_cell = (i, j)\n\n    for x in range(1, 10**9 + 1):\n        new_row_sum = row_sums[empty_cell[0]] + x\n        new_col_sum = col_sums[empty_cell[1]] + x\n        new_diag_sum1 = diag_sum1 if empty_cell[0] != empty_cell[1] else diag_sum1 + x\n        new_diag_sum2 = diag_sum2 if empty_cell[0] != n - empty_cell[1] - 1 else diag_sum2 + x\n\n        if new_row_sum == new_col_sum == new_diag_sum1 == new_diag_sum2 == total_sum:\n            return x\n\n    return -1\n\nn = int(input())\ngrid = [list(map(int, input().split())) for _ in range(n)]\nprint(solve_magic_square(n, grid))"}
{"solution": "# Read the input\nn = int(input())\nm = int(input())\nbenches = [int(input()) for _ in range(n)]\n\n# Calculate the minimum possible k\nmin_k = max(benches) + m // n\nif m % n != 0:\n    min_k += 1\n\n# Calculate the maximum possible k\nmax_k = max(benches) + m\n\n# Print the output\nprint(min_k, max_k)"}
{"solution": "MOD = 10**9 + 7\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1:\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\ndef find_ways(n, m):\n    if m > n:\n        return 0\n    if m == 1:\n        return n\n    if m == 2:\n        return (n * (n - 1)) % MOD\n    return (power(2, m - 2, MOD) * (n - m + 1) * (n - m + 2) * power(2, m - 2, MOD) * power(2, m - 1, MOD)) % MOD\n\nn, m = map(int, input().split())\nprint(find_ways(n, m))"}
{"solution": "import sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    friends = [0] * n\n    for i in range(n):\n        f, *b = map(int, sys.stdin.readline().split())\n        for j in b:\n            friends[i] |= 1 << (j - 1)\n    pizzas = [(0, 0)] * m\n    for i in range(m):\n        c, r, *a = map(int, sys.stdin.readline().split())\n        ingredients = 0\n        for j in a:\n            ingredients |= 1 << (j - 1)\n        pizzas[i] = (c, ingredients)\n    max_pleased = 0\n    min_price = float('inf')\n    best_pair = (-1, -1)\n    for i in range(m):\n        for j in range(i + 1, m):\n            pleased = 0\n            for k in range(n):\n                if (friends[k] & pizzas[i][1] and friends[k] & pizzas[j][1]):\n                    pleased += 1\n            if pleased > max_pleased or (pleased == max_pleased and pizzas[i][0] + pizzas[j][0] < min_price):\n                max_pleased = pleased\n                min_price = pizzas[i][0] + pizzas[j][0]\n                best_pair = (i + 1, j + 1)\n    print(*best_pair)\n\nif __name__ == '__main__':\n    main()"}
{"solution": "def find_min_max(m, s):\n    if s == 0:\n        if m == 1:\n            return (0, 0)\n        else:\n            return (-1, -1)\n    if s > m * 9:\n        return (-1, -1)\n\n    min_num = ['0'] * m\n    max_num = ['0'] * m\n\n    s_temp = s\n    for i in range(m - 1, -1, -1):\n        if s_temp > 9:\n            max_num[i] = '9'\n            s_temp -= 9\n        else:\n            max_num[i] = str(s_temp)\n            s_temp = 0\n\n    s_temp = s\n    for i in range(m - 1, 0, -1):\n        if s_temp > 9:\n            min_num[i] = '9'\n            s_temp -= 9\n        else:\n            if s_temp != 0:\n                min_num[i] = str(s_temp)\n                s_temp = 0\n            break\n\n    if s_temp != 0:\n        min_num[0] = str(s_temp)\n\n    return (int(''.join(min_num)), int(''.join(max_num)))\n\nm, s = map(int, input().split())\nprint(*find_min_max(m, s))"}
{"solution": "def solve(l, r, k):\n    MOD = 998244353\n    dp = [[0] * (1 << 10) for _ in range(20)]\n    dp[0][0] = 1\n    for i in range(1, 20):\n        for mask in range(1 << 10):\n            for digit in range(10):\n                if (mask >> digit) & 1 or bin(mask).count('1') < k:\n                    dp[i][mask | (1 << digit)] = (dp[i][mask | (1 << digit)] + dp[i - 1][mask]) % MOD\n    def f(n):\n        s = str(n)\n        res = 0\n        for i in range(1, len(s)):\n            for mask in range(1, 1 << 10):\n                res = (res + dp[i][mask]) % MOD\n        mask = 0\n        for i in range(len(s) - 1, -1, -1):\n            for digit in range(int(s[i])):\n                if (mask >> digit) & 1 or bin(mask).count('1') < k:\n                    res = (res + dp[i][mask | (1 << digit)]) % MOD\n            if not ((mask >> int(s[i])) & 1):\n                break\n            mask |= (1 << int(s[i]))\n        return (res + int(s[-1])) % MOD\n    return (f(r) - f(l - 1)) % MOD\n\nl, r, k = map(int, input().split())\nprint(solve(l, r, k))"}
{"solution": "def can_distribute_pencils(n, k, d, pencils):\n    pencils.sort()\n    i = 0\n    while i < n:\n        j = i + k - 1\n        if j >= n:\n            return False\n        if pencils[j] - pencils[i] > d:\n            return False\n        i = j + 1\n    return True\n\nn, k, d = map(int, input().split())\npencils = list(map(int, input().split()))\n\nif can_distribute_pencils(n, k, d, pencils):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "# Get the input string\ns = input()\n\n# Initialize the count of dead light bulbs for each color\nk_r, k_b, k_y, k_g = 0, 0, 0, 0\n\n# Iterate over the string\nfor i in range(len(s)):\n    # If the current light bulb is dead\n    if s[i] == '!':\n        # If the previous light bulb was red, the current one must be blue\n        if i > 0 and s[i - 1] == 'R':\n            k_b += 1\n        # If the previous light bulb was blue, the current one must be yellow\n        elif i > 0 and s[i - 1] == 'B':\n            k_y += 1\n        # If the previous light bulb was yellow, the current one must be green\n        elif i > 0 and s[i - 1] == 'Y':\n            k_g += 1\n        # If the previous light bulb was green, the current one must be red\n        elif i > 0 and s[i - 1] == 'G':\n            k_r += 1\n        # If this is the first light bulb, we don't know its color yet\n        else:\n            # If the next light bulb is not red, the current one must be red\n            if i < len(s) - 1 and s[i + 1] != 'R':\n                k_r += 1\n            # If the next light bulb is not blue, the current one must be blue\n            elif i < len(s) - 1 and s[i + 1] != 'B':\n                k_b += 1\n            # If the next light bulb is not yellow, the current one must be yellow\n            elif i < len(s) - 1 and s[i + 1] != 'Y':\n                k_y += 1\n            # If the next light bulb is not green, the current one must be green\n            elif i < len(s) - 1 and s[i + 1] != 'G':\n                k_g += 1\n\n# Print the count of dead light bulbs for each color\nprint(k_r, k_b, k_y, k_g)"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef read_input():\n    return sys.stdin.readline\n\ndef main():\n    n, m = map(int, read_input().split())\n    graph = defaultdict(list)\n    for _ in range(m):\n        s, t = map(int, read_input().split())\n        graph[s].append(t)\n\n    dp = [0] * (n + 1)\n    dp[n] = 0\n    for i in range(n - 1, 0, -1):\n        total = 0\n        for j in graph[i]:\n            total += 1 + dp[j]\n        dp[i] = total / len(graph[i])\n\n    min_expected_passages = float('inf')\n    for j in graph[1]:\n        expected_passages = 1 + dp[j]\n        if len(graph[1]) > 1:\n            expected_passages += (dp[1] - 1) / (len(graph[1]) - 1)\n        min_expected_passages = min(min_expected_passages, expected_passages)\n\n    print(min_expected_passages)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Get the input number\nn = int(input())\n\n# If the number already ends with 0, print it as it is\nif n % 10 == 0:\n    print(n)\n# If the last digit is less than or equal to 5, round down to the nearest integer ending with 0\nelif n % 10 <= 5:\n    print(n - n % 10)\n# If the last digit is greater than 5, round up to the nearest integer ending with 0\nelse:\n    print(n + 10 - n % 10)"}
{"solution": "def find_mixed_keys(s, t):\n    mixed_keys = []\n    s_list = list(s)\n    t_list = list(t)\n    for i in range(len(s_list)):\n        if s_list[i] != t_list[i]:\n            if t_list[i] in s_list:\n                index = s_list.index(t_list[i])\n                s_list[i], s_list[index] = s_list[index], s_list[i]\n                mixed_keys.append((s[i], t[i]))\n            else:\n                return -1\n    return mixed_keys\n\ns = input()\nt = input()\nresult = find_mixed_keys(s, t)\nif result == -1:\n    print(-1)\nelse:\n    print(len(result))\n    for pair in result:\n        print(pair[0], pair[1])"}
{"solution": "# Get the input\nfirst_name, last_name = input().split()\n\n# Initialize the login\nlogin = \"\"\n\n# Iterate over the characters in the first name\nfor i in range(len(first_name)):\n    # Iterate over the characters in the last name\n    for j in range(len(last_name)):\n        # If the characters match\n        if first_name[i] == last_name[j]:\n            # Add the character to the login\n            login = first_name[:i+1] + last_name[j:]\n            # Break the inner loop\n            break\n    # If a login has been found\n    if login:\n        # Break the outer loop\n        break\n\n# If no login has been found\nif not login:\n    # Add the first character of the first name and the first character of the last name to the login\n    login = first_name[0] + last_name[0]\n\n# Print the login\nprint(login)"}
{"solution": "def draw_brackets(sequence):\n    n = len(sequence)\n    height = n // 2\n    width = 2 * height - 1\n    grid = [[' '] * width for _ in range(2 * height + 1)]\n\n    def draw(start, end, level):\n        if start >= end:\n            return\n        grid[level][start] = '+'\n        grid[level][end] = '+'\n        grid[level + height][start] = '+'\n        grid[level + height][end] = '+'\n        for i in range(start + 1, end):\n            grid[level][i] = '-'\n            grid[level + height][i] = '-'\n        grid[level + 1][start] = '|'\n        grid[level + height - 1][start] = '|'\n        grid[level + 1][end] = '|'\n        grid[level + height - 1][end] = '|'\n        for i in range(level + 2, level + height - 1):\n            grid[i][start] = '|'\n            grid[i][end] = '|'\n        i = start + 1\n        while i < end:\n            if sequence[i] == '[':\n                j = i + 1\n                balance = 1\n                while balance > 0:\n                    if sequence[j] == '[':\n                        balance += 1\n                    else:\n                        balance -= 1\n                    j += 1\n                draw(i, j - 1, level + 1)\n                i = j\n            else:\n                i += 1\n\n    draw(0, n - 1, 0)\n    return '\\n'.join(''.join(row) for row in grid)\n\nn = int(input())\nsequence = input()\nprint(draw_brackets(sequence))"}
{"solution": "def golden_value(s):\n    q = (1 + 5 ** 0.5) / 2\n    value = 0\n    for i, digit in enumerate(reversed(s)):\n        value += int(digit) * q ** i\n    return value\n\ndef compare_golden_numbers():\n    s1 = input()\n    s2 = input()\n    value1 = golden_value(s1)\n    value2 = golden_value(s2)\n    if value1 > value2:\n        print(\">\")\n    elif value1 < value2:\n        print(\"<\")\n    else:\n        print(\"=\")\n\ncompare_golden_numbers()"}
{"solution": "# Define a dictionary that maps each gem color to its name\ngem_colors = {\n    'purple': 'Power',\n    'green': 'Time',\n    'blue': 'Space',\n    'orange': 'Soul',\n    'red': 'Reality',\n    'yellow': 'Mind'\n}\n\n# Get the number of gems Thanos has\nn = int(input())\n\n# Get the colors of the gems Thanos has\nthanos_gems = [input() for _ in range(n)]\n\n# Find the names of the gems Thanos doesn't have\nabsent_gems = [name for color, name in gem_colors.items() if color not in thanos_gems]\n\n# Print the number of absent gems\nprint(len(absent_gems))\n\n# Print the names of the absent gems\nfor gem in absent_gems:\n    print(gem)"}
{"solution": "def find_round(n, a, b):\n    round = 1\n    while n > 2:\n        if (a - 1) // 2 == (b - 1) // 2:\n            return round\n        a = (a + 1) // 2\n        b = (b + 1) // 2\n        n = n // 2\n        round += 1\n    return \"Final!\"\n\nn, a, b = map(int, input().split())\nprint(find_round(n, a, b))"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef find_parent(parent, i):\n    if parent[i] == i:\n        return i\n    parent[i] = find_parent(parent, parent[i])\n    return parent[i]\n\ndef union(parent, rank, x, y):\n    xroot = find_parent(parent, x)\n    yroot = find_parent(parent, y)\n\n    if rank[xroot] < rank[yroot]:\n        parent[xroot] = yroot\n    elif rank[xroot] > rank[yroot]:\n        parent[yroot] = xroot\n    else:\n        parent[yroot] = xroot\n        rank[xroot] += 1\n\ndef solve():\n    n = int(read_input())\n    p = list(map(int, read_input().split()))\n    b = list(map(int, read_input().split()))\n\n    parent = [i for i in range(n)]\n    rank = [0] * n\n\n    for i in range(n):\n        if b[i] == 1:\n            union(parent, rank, i, p[i] - 1)\n\n    visited = [0] * n\n    cycles = []\n\n    for i in range(n):\n        if visited[i] == 0:\n            cycle = []\n            j = i\n            while visited[j] == 0:\n                visited[j] = 1\n                cycle.append(j)\n                j = p[j] - 1\n            cycles.append(cycle)\n\n    odd_cycles = [cycle for cycle in cycles if len(cycle) % 2 == 1]\n\n    if len(odd_cycles) == 0:\n        print(0)\n    elif len(odd_cycles) == 2:\n        print(1)\n    else:\n        print(len(odd_cycles) - 2)\n\nsolve()"}
{"solution": "# Get the input\nv1, v2 = map(int, input().split())\nt, d = map(int, input().split())\n\n# Initialize the maximum possible length of the path section\nmax_length = v1 * t\n\n# Initialize the current speed\ncurrent_speed = v1\n\n# Iterate over the time\nfor _ in range(1, t):\n    # Calculate the next speed\n    next_speed = current_speed + d if current_speed < v2 else current_speed - d\n    next_speed = min(max(next_speed, v1), v2)\n\n    # Update the maximum possible length of the path section\n    max_length += next_speed\n\n    # Update the current speed\n    current_speed = next_speed\n\n# Print the maximum possible length of the path section\nprint(max_length)"}
{"solution": "import sys\n\ndef solve():\n    N, M = map(int, sys.stdin.readline().split())\n    weights = list(map(int, sys.stdin.readline().split()))\n    bridges = [list(map(int, sys.stdin.readline().split())) for _ in range(M)]\n\n    # Sort the camels by weight\n    weights.sort()\n\n    # Calculate the total weight of all camels\n    total_weight = sum(weights)\n\n    # Calculate the total length of all bridges\n    total_length = sum(bridge[0] for bridge in bridges)\n\n    # Check if it's possible to make the camels cross the bridge without it collapsing\n    for bridge in bridges:\n        if bridge[1] < total_weight:\n            print(-1)\n            return\n\n    # Calculate the minimum possible distance between the first and last camels\n    min_distance = total_length\n    for i in range(N - 1):\n        min_distance = min(min_distance, total_length - (N - 1 - i) * weights[i] - i * weights[-1])\n\n    print(min_distance)\n\nsolve()"}
{"solution": "def last_digit_factorial(n):\n    if n == 0:\n        return 1\n    last_digits = [1, 1, 2, 6, 4, 2, 2, 4, 2, 8]\n    return last_digits[n % 10]\n\ndef last_digit_ratio(a, b):\n    return (last_digit_factorial(b) * pow(last_digit_factorial(a), -1, 10)) % 10\n\na, b = map(int, input().split())\nprint(last_digit_ratio(a, b))"}
{"solution": "n, d = map(int, input().split())\ns = input()\n\njumps = 0\ncurrent_position = 0\n\nwhile current_position < n - 1:\n    found_lily = False\n    for i in range(min(n - 1, current_position + d), current_position, -1):\n        if s[i] == '1':\n            current_position = i\n            jumps += 1\n            found_lily = True\n            break\n    if not found_lily:\n        print(-1)\n        break\nelse:\n    print(jumps)"}
{"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    if num == 2:\n        return True\n    if num % 2 == 0:\n        return False\n    i = 3\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 2\n    return True\n\nn = int(input())\n\nfor m in range(1, 1001):\n    if not is_prime(n * m + 1):\n        print(m)\n        break"}
{"solution": "n = int(input())\n\nfor a in range(n // 1234567 + 1):\n    for b in range((n - a * 1234567) // 123456 + 1):\n        c = (n - a * 1234567 - b * 123456) // 1234\n        if a * 1234567 + b * 123456 + c * 1234 == n:\n            print('YES')\n            exit()\nprint('NO')"}
{"solution": "def check_intersection(lines, x1, x2):\n    intersections = set()\n    for i in range(len(lines)):\n        for j in range(i+1, len(lines)):\n            k1, b1 = lines[i]\n            k2, b2 = lines[j]\n            if k1 == k2:\n                continue\n            x = (b2 - b1) / (k1 - k2)\n            if x1 < x < x2:\n                intersections.add((x, k1*x + b1))\n    return len(intersections) > 0\n\nn = int(input())\nx1, x2 = map(int, input().split())\nlines = [tuple(map(int, input().split())) for _ in range(n)]\n\nif check_intersection(lines, x1, x2):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def count_splits(n):\n    count = 0\n    i = 1\n    while i <= n:\n        count += n // i\n        n -= i\n        i += 1\n    return count\n\nn = int(input())\nprint(count_splits(n))"}
{"solution": "# Read input\nn, k = map(int, input().split())\n\n# Calculate minimum possible number of good apartments\nmin_good = max(0, k - (n - k))\n\n# Calculate maximum possible number of good apartments\nmax_good = min(k, n - 1)\n\n# Print output\nprint(min_good, max_good)"}
{"solution": "def max_games(n):\n    # Initialize the number of games played by the winner\n    games_played = 0\n\n    # While there are more than 1 player left in the tournament\n    while n > 1:\n        # The winner plays against the player who has played the same number of games\n        n //= 2\n        # Increment the number of games played by the winner\n        games_played += 1\n\n    # Return the maximum number of games the winner can participate in\n    return games_played\n\n# Read the input\nn = int(input())\n\n# Print the output\nprint(max_games(n))"}
{"solution": "s = input()\nn = len(s)\n\n# Initialize count of VK\ncount = 0\n\n# Count the number of VK in the string\nfor i in range(n - 1):\n    if s[i] == 'V' and s[i + 1] == 'K':\n        count += 1\n\n# If the string has less than 2 characters, the maximum count is the current count\nif n < 2:\n    print(count)\nelse:\n    # Initialize maximum count\n    max_count = count\n\n    # Iterate over the string\n    for i in range(n):\n        # Create a new string by changing one character\n        new_s = s[:i] + ('K' if s[i] == 'V' else 'V') + s[i + 1:]\n\n        # Initialize local count\n        local_count = 0\n\n        # Count the number of VK in the new string\n        for j in range(n - 1):\n            if new_s[j] == 'V' and new_s[j + 1] == 'K':\n                local_count += 1\n\n        # Update maximum count\n        max_count = max(max_count, local_count)\n\n    # Print the maximum count\n    print(max_count)"}
{"solution": "# Read the input\nn = int(input())\n\n# Calculate the minimum number of segments that Sofia will have to draw with a ruler without a guide\nif n == 1:\n    print(2)\nelse:\n    # The first two segments will be drawn with a ruler\n    # For each additional square, Sofia can use two existing segments to draw two new segments\n    # So, the total number of segments that Sofia will have to draw with a ruler is 2 + 2 * (n - 1)\n    print(2 + 2 * (n - 1))"}
{"solution": "# Get the initial weights of Limak and Bob\na, b = map(int, input().split())\n\n# Initialize the number of years\nyears = 0\n\n# While Limak's weight is less than or equal to Bob's weight\nwhile a <= b:\n    # Triple Limak's weight and double Bob's weight\n    a *= 3\n    b *= 2\n\n    # Increment the number of years\n    years += 1\n\n# Print the number of years it takes for Limak to become strictly larger than Bob\nprint(years)"}
{"solution": "def solve(h, n):\n    visited = set()\n    node = 1\n    count = 0\n    cmd = 0\n\n    while node != n:\n        visited.add(node)\n        if cmd % 2 == 0:\n            next_node = 2 * node\n        else:\n            next_node = 2 * node + 1\n\n        if next_node > 2 ** h or next_node in visited:\n            node = node // 2\n            cmd += 1\n            continue\n\n        node = next_node\n        cmd += 1\n        count += 1\n\n    return count\n\nh, n = map(int, input().split())\nprint(solve(h, n))"}
{"solution": "from math import sqrt, ceil\n\ndef count_squares(n, m):\n    return sum((i * j for i in range(1, n + 1) for j in range(1, m + 1) if i * j <= n * m))\n\ndef find_pairs(x):\n    pairs = []\n    for n in range(1, ceil(sqrt(x)) + 1):\n        if x % n == 0:\n            m = x // n\n            if count_squares(n, m) == x:\n                pairs.append((n, m))\n            if n != m and count_squares(m, n) == x:\n                pairs.append((m, n))\n    return pairs\n\nx = int(input())\npairs = find_pairs(x)\nprint(len(pairs))\nfor pair in pairs:\n    print(*pair)"}
{"solution": "# Get the input\nn = int(input())\nmonths = list(map(int, input().split()))\n\n# Define the months with 31 days and the months with 30 days\nmonths_31_days = [1, 3, 5, 7, 8, 10, 12]\nmonths_30_days = [4, 6, 9, 11]\n\n# Define a function to check if a year is leap\ndef is_leap(year):\n    if year % 4 != 0:\n        return False\n    elif year % 100 != 0:\n        return True\n    elif year % 400 != 0:\n        return False\n    return True\n\n# Define a function to check if the given sequence is valid\ndef is_valid(months):\n    # Initialize the current month and year\n    current_month = 1\n    current_year = 2000\n\n    # Iterate over the given sequence\n    for month in months:\n        # Check if the current month has the given number of days\n        if month == 28 and is_leap(current_year):\n            current_month += 1\n        elif month == 29 and not is_leap(current_year):\n            current_month += 1\n        elif month == 30 and current_month in months_30_days:\n            current_month += 1\n        elif month == 31 and current_month in months_31_days:\n            current_month += 1\n        else:\n            return False\n\n        # If the current month is greater than 12, reset it to 1 and increment the year\n        if current_month > 12:\n            current_month = 1\n            current_year += 1\n\n    # If we have iterated over all the months, the sequence is valid\n    return True\n\n# Print the result\nif is_valid(months):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def find_fractions(n):\n    fractions = []\n    for b in range(2, n):\n        if n % b == 0:\n            a = n // b - 1\n            if a > 0:\n                fractions.append((a, b))\n                n -= a\n    if n > 1:\n        return None\n    return fractions\n\nn = int(input())\nfractions = find_fractions(n)\nif fractions is None:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(len(fractions))\n    for a, b in fractions:\n        print(a, b)"}
{"solution": "def min_unattractiveness(n, a, b, h):\n    total_area = sum(h)\n    if total_area > a + b:\n        return -1\n\n    dp = [[0] * (b + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(b + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= h[i - 1]:\n                dp[i][j] = min(dp[i][j], dp[i - 1][j - h[i - 1]] + (h[i - 1] if i > 1 and h[i - 1] != h[i - 2] else 0))\n\n    min_unattractiveness = float('inf')\n    for j in range(b + 1):\n        if a >= total_area - j:\n            min_unattractiveness = min(min_unattractiveness, dp[n][j])\n\n    return min_unattractiveness if min_unattractiveness != float('inf') else -1\n\nn = int(input())\na, b = map(int, input().split())\nh = list(map(int, input().split()))\nprint(min_unattractiveness(n, a, b, h))"}
{"solution": "def solve(n, m, k):\n    if n * m < 2 * k:\n        return \"NO\"\n    else:\n        return \"YES\\n0 0\\n{} 0\\n0 {}\".format(n, m * (k - 1) // k)\n\nn, m, k = map(int, input().split())\nprint(solve(n, m, k))"}
{"solution": "n, k = map(int, input().split())\n\n# If n is less than or equal to k, Sasha can win in one move\nif n <= k:\n    print(\"YES\")\n# If n is greater than k and n is odd, Sasha can win\nelif n % 2 != 0:\n    print(\"YES\")\n# If n is greater than k and n is even, Lena can win\nelse:\n    print(\"NO\")"}
{"solution": "n = int(input())\nexercises = list(map(int, input().split()))\n\nchest = 0\nbiceps = 0\nback = 0\n\nfor i in range(n):\n    if i % 3 == 0:\n        chest += exercises[i]\n    elif i % 3 == 1:\n        biceps += exercises[i]\n    else:\n        back += exercises[i]\n\nif chest > biceps and chest > back:\n    print('chest')\nelif biceps > chest and biceps > back:\n    print('biceps')\nelse:\n    print('back')"}
{"solution": "n = int(input())\ngrades = list(map(int, input().split()))\n\navg = sum(grades) / n\nrounded_avg = round(avg)\n\nif rounded_avg >= 5:\n    print(0)\nelse:\n    grades.sort()\n    count = 0\n    while avg < 4.5:\n        grades[-1] = 5\n        count += 1\n        avg = (sum(grades) - grades[-1] + 5) / n\n    print(count)"}
{"solution": "def solve(u, v):\n    if u > v or (u & 1) != (v & 1):\n        return -1\n    if u == 0:\n        return [0]\n    if u == v:\n        return [u]\n    if v > u * 2:\n        return [u, v - u]\n    if (v - u) & (u + (v - u) // 2) == 0:\n        return [(v - u) // 2, u + (v - u) // 2, (v - u) // 2]\n    return -1\n\nu, v = map(int, input().split())\nresult = solve(u, v)\nif result == -1:\n    print(-1)\nelse:\n    print(len(result))\n    print(' '.join(map(str, result)))"}
{"solution": "def min_digits_1(n):\n    count = 0\n    while n > 0:\n        if n % 10 != 0:\n            count += n % 10\n            n -= n % 10\n        else:\n            n //= 10\n    return count\n\nn = int(input())\nprint(min_digits_1(n))"}
{"solution": "# Get the input\nx1, y1, x2, y2 = map(int, input().split())\nx, y = map(int, input().split())\n\n# Check if it is possible to reach the treasure\nif (x2 - x1) % x == 0 and (y2 - y1) % y == 0 and (x2 - x1) // x * y == (y2 - y1) // y:\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "from collections import Counter\n\ndef calculate_variants(counter, leading_zero=False):\n    if not counter:\n        return 1\n    total = 0\n    for digit in counter:\n        if leading_zero and digit == '0':\n            continue\n        counter[digit] -= 1\n        if counter[digit] == 0:\n            del counter[digit]\n        total += calculate_variants(counter, leading_zero=False)\n        counter[digit] += 1\n    return total\n\nn = input()\ncounter = Counter(n)\nprint(calculate_variants(counter, leading_zero=True))"}
{"solution": "# Read the input\na = int(input())\nb = int(input())\nc = int(input())\nd = int(input())\ne = int(input())\nf = int(input())\n\n# Calculate the maximum number of suits of the first type that can be composed\nfirst_type_suits = min(a, d)\n\n# Calculate the maximum number of suits of the second type that can be composed\nsecond_type_suits = min(b, c, d)\n\n# Calculate the maximum possible cost of a set of suits\nmax_cost = first_type_suits * e + second_type_suits * f\n\n# Print the output\nprint(max_cost)"}
{"solution": "def solve(a, b, p, x):\n    inv_a = pow(a, p - 2, p)\n    b_inv_a = (b * inv_a) % p\n    count = 0\n    for n in range(1, x + 1):\n        if (n * pow(b_inv_a, n, p)) % p == 1:\n            count += 1\n    return count\n\na, b, p, x = map(int, input().split())\nprint(solve(a, b, p, x))"}
{"solution": "# Get the input\nk2, k3, k5, k6 = map(int, input().split())\n\n# Calculate the number of 256 that can be formed\nmin_256 = min(k2, k5, k6)\n\n# Calculate the remaining 2's after forming 256\nremaining_2 = k2 - min_256\n\n# Calculate the number of 32 that can be formed\nmin_32 = min(k3, remaining_2)\n\n# Calculate the total sum\ntotal_sum = min_256 * 256 + min_32 * 32\n\n# Print the result\nprint(total_sum)"}
{"solution": "def bender_happiness(n, x, y, c):\n    grid = [[0]*n for _ in range(n)]\n    grid[x-1][y-1] = 1\n    seconds = 0\n    on_cells = 1\n\n    while on_cells < c:\n        new_grid = [row[:] for row in grid]\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == 0:\n                    if i > 0 and grid[i-1][j] == 1:\n                        new_grid[i][j] = 1\n                        on_cells += 1\n                    elif i < n-1 and grid[i+1][j] == 1:\n                        new_grid[i][j] = 1\n                        on_cells += 1\n                    elif j > 0 and grid[i][j-1] == 1:\n                        new_grid[i][j] = 1\n                        on_cells += 1\n                    elif j < n-1 and grid[i][j+1] == 1:\n                        new_grid[i][j] = 1\n                        on_cells += 1\n        grid = new_grid\n        seconds += 1\n\n    return seconds\n\nn, x, y, c = map(int, input().split())\nprint(bender_happiness(n, x, y, c))"}
{"solution": "def max_xor(l, r):\n    max_val = 0\n    for i in range(63, -1, -1):\n        if (max_val | (1 << i)) <= r:\n            max_val |= (1 << i)\n    return max_val ^ (max_val - l)\n\nl, r = map(int, input().split())\nprint(max_xor(l, r))"}
{"solution": "def min_height(n, k):\n    left, right = 0, k\n    while left < right:\n        mid = (left + right) // 2\n        if (mid * (mid + 1)) // 2 > k or (mid * (mid + 1) // 2 + mid * (n - mid)) < k:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\nn, k = map(int, input().split())\nprint(min_height(n, k))"}
{"solution": "# Get input\nx, y, z, t1, t2, t3 = map(int, input().split())\n\n# Calculate time to use stairs\nstairs_time = abs(x - y) * t1\n\n# Calculate time to use elevator\nelevator_time = abs(z - x) * t2 + t3 + abs(x - y) * t2 + t3\n\n# Compare times and print result\nif elevator_time <= stairs_time:\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "# Get the input\nn, m = map(int, input().split())\n\n# Calculate the optimal value for a\nif m <= (n + 1) // 2:\n    a = n + 1 - m\nelse:\n    a = m - 1\n\n# Print the output\nprint(a)"}
{"solution": "# Get the number of lessons\nn = int(input())\n\n# Get the schedule for the lessons\nschedule = list(map(int, input().split()))\n\n# Initialize the count of pairs Alena stays at the university\ncount = 0\n\n# Initialize the flag to check if Alena is at the university\nat_university = False\n\n# Iterate over the schedule\nfor i in range(n):\n    # If Alena has a pair\n    if schedule[i] == 1:\n        # Increment the count\n        count += 1\n        # Set the flag to True\n        at_university = True\n    # If Alena doesn't have a pair and she is at the university\n    elif at_university:\n        # Check if the next pair is also a break\n        if i < n - 1 and schedule[i + 1] == 0:\n            # If the next pair is also a break, Alena goes home\n            at_university = False\n        else:\n            # Otherwise, Alena stays at the university\n            count += 1\n\n# Print the result\nprint(count)"}
{"solution": "n, k = map(int, input().split())\ncandies = list(map(int, input().split()))\n\nbran_candies = 0\ndays = 0\n\nfor i in range(n):\n    arya_candies = candies[i]\n    bran_candies += min(8, arya_candies)\n    arya_candies -= min(8, arya_candies)\n    days += 1\n    if bran_candies >= k:\n        print(days)\n        break\n    bran_candies += arya_candies\n\nif bran_candies < k:\n    print(-1)"}
{"solution": "# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Initialize additional walks and schedule\nadditional_walks = 0\nb = [0] * n\n\n# Handle first day\nif a[0] < k:\n    additional_walks += k - a[0]\n    b[0] = k\nelse:\n    b[0] = a[0]\n\n# Handle remaining days\nfor i in range(1, n):\n    if a[i] < k or a[i] < b[i - 1] + 1:\n        b[i] = b[i - 1] + 1\n        additional_walks += b[i] - a[i]\n    else:\n        b[i] = a[i]\n\n# Print output\nprint(additional_walks)\nprint(' '.join(map(str, b)))"}
{"solution": "# Get the input value for the order of the rhombus\nn = int(input())\n\n# Calculate the number of cells in the rhombus using the formula for the sum of an arithmetic series\n# The first term of the series is 1, the last term is n^2, and there are n terms in the series\nnum_cells = (n * (1 + n**2)) // 2\n\n# Print the result\nprint(num_cells)"}
{"solution": "# Get the number of characters in the string\nn = int(input())\n\n# Get the string\ns = input()\n\n# Convert the string to lowercase\ns = s.lower()\n\n# Create a set of all the letters in the alphabet\nalphabet = set('abcdefghijklmnopqrstuvwxyz')\n\n# Check if all the letters in the alphabet are in the string\nif set(s) == alphabet:\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "# Read the input\ncurrent_time = input().split(':')\nminutes_to_add = int(input())\n\n# Convert the current time to minutes\ncurrent_time_in_minutes = int(current_time[0]) * 60 + int(current_time[1])\n\n# Add the minutes\nnew_time_in_minutes = current_time_in_minutes + minutes_to_add\n\n# Convert the new time to hours and minutes\nnew_time_hours = new_time_in_minutes // 60 % 24\nnew_time_minutes = new_time_in_minutes % 60\n\n# Print the new time\nprint(f'{new_time_hours:02d}:{new_time_minutes:02d}')"}
{"solution": "# Read the input\nn, m = map(int, input().split())\nswitches = [list(map(int, input())) for _ in range(n)]\n\n# Calculate the total state of the lamps for each switch\ntotal_state = [sum(switch) for switch in switches]\n\n# Check if there is a switch that can be ignored\nfor i in range(n):\n    # Calculate the total state of the lamps if the i-th switch is ignored\n    total_state_without_i = sum(total_state[:i]) + sum(total_state[i+1:])\n    # If the total state of the lamps is equal to the number of lamps, then the i-th switch can be ignored\n    if total_state_without_i == m:\n        print(\"YES\")\n        break\n# If no such switch is found, print \"NO\"\nelse:\n    print(\"NO\")"}
{"solution": "n = int(input())\nupper_sum = 0\nlower_sum = 0\nswaps = 0\n\nfor _ in range(n):\n    x, y = map(int, input().split())\n    upper_sum += x\n    lower_sum += y\n    if x % 2 != y % 2:\n        swaps += 1\n\nif upper_sum % 2 == 0 and lower_sum % 2 == 0:\n    print(0)\nelif upper_sum % 2 != 0 and lower_sum % 2 != 0:\n    if swaps > 0:\n        print(1)\n    else:\n        print(-1)\nelse:\n    print(-1)"}
{"solution": "import math\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    sqrt_n = math.isqrt(n)\n    for i in range(3, sqrt_n + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\nt = int(input())\nfor _ in range(t):\n    a, b = map(int, input().split())\n    area = a**2 - b**2\n    if is_prime(area):\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "n = int(input())\npoints = [list(map(int, input().split())) for _ in range(n)]\n\n# Check the sign of the x-coordinate of each point\nsigns = [point[0] > 0 for point in points]\n\n# If all signs are the same, then there is no point that can be removed\nif all(signs) or not any(signs):\n    print(\"No\")\nelse:\n    print(\"Yes\")"}
{"solution": "import math\n\n# Get the input\nA, B = map(int, input().split())\n\n# Calculate the factorial of A and B\nA_factorial = math.factorial(A)\nB_factorial = math.factorial(B)\n\n# Calculate the greatest common divisor of A! and B!\ngcd = math.gcd(A_factorial, B_factorial)\n\n# Print the result\nprint(gcd)"}
{"solution": "def is_composite(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False\n\ndef find_composites(n):\n    a = n + 4\n    while not is_composite(a):\n        a += 1\n    b = a - n\n    return a, b\n\nn = int(input())\na, b = find_composites(n)\nprint(a, b)"}
{"solution": "import sys\nfrom heapq import heappush, heappop\n\ndef bellman_ford(graph, start, end, price):\n    dist = [-float('inf')] * len(graph)\n    dist[start] = 0\n\n    for _ in range(len(graph) - 1):\n        for u, v, w in graph:\n            if dist[u] + w > dist[v]:\n                dist[v] = dist[u] + w\n\n    for u, v, w in graph:\n        if dist[u] + w > dist[v]:\n            return -1\n\n    max_score = -float('inf')\n    for t in range(len(graph)):\n        score = dist[end] - t * price\n        max_score = max(max_score, score)\n\n    return max_score\n\ndef main():\n    n, m, p = map(int, sys.stdin.readline().split())\n    graph = []\n    for _ in range(m):\n        a, b, c = map(int, sys.stdin.readline().split())\n        graph.append((a - 1, b - 1, c))\n\n    max_score = bellman_ford(graph, 0, n - 1, p)\n    print(max_score)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef min_cost_palindrome():\n    n = int(sys.stdin.readline())\n    strings = []\n    costs = []\n    for _ in range(n):\n        s, c = sys.stdin.readline().split()\n        strings.append(s)\n        costs.append(int(c))\n\n    dp = defaultdict(lambda: float('inf'))\n    dp[''] = 0\n    for s, c in zip(strings, costs):\n        for prefix in list(dp.keys()):\n            if prefix + s == (prefix + s)[::-1]:\n                dp[prefix + s] = min(dp[prefix + s], dp[prefix] + c)\n            if s + prefix == (s + prefix)[::-1]:\n                dp[s + prefix] = min(dp[s + prefix], dp[prefix] + c)\n\n    return min(dp[k] for k in dp if k == k[::-1]) if dp else -1\n\nprint(min_cost_palindrome())"}
{"solution": "def max_xor_sum(n, k):\n    if k == n or k % 2 == 1:\n        return n\n    else:\n        return max(n - 1, n ^ (n - k))\n\nn, k = map(int, input().split())\nprint(max_xor_sum(n, k))"}
{"solution": "def min_triangle_side():\n    n = int(input())\n    x_coords = []\n    y_coords = []\n\n    for _ in range(n):\n        x, y = map(int, input().split())\n        x_coords.append(x)\n        y_coords.append(y)\n\n    x_coords.sort()\n    y_coords.sort()\n\n    max_x = x_coords[-1]\n    max_y = y_coords[-1]\n\n    if max_x >= max_y:\n        return max_x\n    else:\n        return max_y\n\nprint(min_triangle_side())"}
{"solution": "def max_nineteens(s):\n    # Count the number of each character in the string\n    counts = {c: s.count(c) for c in set(s)}\n\n    # The word 'nineteen' contains two 'n's and one 'e'\n    # So, the maximum number of 'nineteen's is limited by the number of 'n's and 'e's\n    max_n = counts.get('n', 0) // 2\n    max_e = counts.get('e', 0) // 3\n\n    # Return the minimum of max_n and max_e, as this is the maximum number of 'nineteen's we can form\n    return min(max_n, max_e)\n\n# Read the input string\ns = input()\n\n# Print the maximum number of 'nineteen's that can be formed\nprint(max_nineteens(s))"}
{"solution": "import math\n\ndef highest_branch(p, y):\n    for i in range(y, 1, -1):\n        if all(i % j != 0 for j in range(2, min(p, int(math.sqrt(i))) + 1)):\n            return i\n    return -1\n\np, y = map(int, input().split())\nprint(highest_branch(p, y))"}
{"solution": "# Get input\nn, m, k = map(int, input().split())\nhouses = list(map(int, input().split()))\n\n# Initialize minimum distance to a large number\nmin_distance = float('inf')\n\n# Iterate over all houses\nfor i in range(n):\n    # If the house is affordable\n    if houses[i] <= k:\n        # Calculate the distance to the girl's house\n        distance = abs(i - m + 1) * 10\n        # Update the minimum distance\n        min_distance = min(min_distance, distance)\n\n# Print the minimum distance\nprint(min_distance)"}
{"solution": "def solve():\n    n, m = map(int, input().split())\n    A = [list(map(int, input().split())) for _ in range(n)]\n    B = [list(map(int, input().split())) for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            if A[i][j] == B[i][j]:\n                continue\n            found = False\n            for k in range(min(n-i, m-j), 0, -1):\n                if A[i][j:j+k] == [row[j:j+k] for row in B[i:i+k]]:\n                    found = True\n                    break\n                if [row[j] for row in A[i:i+k]] == [B[i+p][j] for p in range(k)]:\n                    found = True\n                    break\n            if not found:\n                print(\"NO\")\n                return\n    print(\"YES\")\n\nsolve()"}
{"solution": "# Get the input strings\na = input()\nb = input()\n\n# If the strings are equal, there is no uncommon subsequence\nif a == b:\n    print(-1)\n# Otherwise, the longest uncommon subsequence is the length of the longer string\nelse:\n    print(max(len(a), len(b)))"}
{"solution": "# Get the input\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Calculate the first scream times for Rick and Morty\nrick_scream = b\nmorty_scream = d\n\n# Check if they scream at the same time\nwhile rick_scream != morty_scream:\n    # If Rick's scream time is less than Morty's, increase Rick's scream time\n    if rick_scream < morty_scream:\n        rick_scream += a\n    # If Morty's scream time is less than Rick's, increase Morty's scream time\n    else:\n        morty_scream += c\n\n    # If they never scream at the same time, print -1 and exit the loop\n    if rick_scream > 10000 or morty_scream > 10000:\n        print(-1)\n        break\n\n# If they scream at the same time, print the time\nelse:\n    print(rick_scream)"}
{"solution": "n = int(input())\n\n# If n is not a multiple of 3, we can split it into three numbers\n# by subtracting 1 from n and then dividing the remaining number\n# into three parts.\nif n % 3 != 0:\n    a = 1\n    b = 1\n    c = n - 2\nelse:\n    # If n is a multiple of 3, we need to find another way to split it.\n    # We can split it into three numbers by subtracting 2 from n\n    # and then dividing the remaining number into three parts.\n    # However, we need to make sure that none of the three numbers\n    # is a multiple of 3. So, we subtract 3 from the second number.\n    a = 1\n    b = 2\n    c = n - 3\n\nprint(a, b, c)"}
{"solution": "def find_squares(n, a, b, c, d):\n    count = 0\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i + j + a + b == i + c + d + j == a + b + i + j == b + c + i + j:\n                count += 1\n    return count\n\nn, a, b, c, d = map(int, input().split())\nprint(find_squares(n, a, b, c, d))"}
{"solution": "# Get the initial weight and height of the snowball\nw, h = map(int, input().split())\n\n# Get the weight and height of the first stone\nu1, d1 = map(int, input().split())\n\n# Get the weight and height of the second stone\nu2, d2 = map(int, input().split())\n\n# Simulate the movement of the snowball\nwhile h > 0:\n    # Increase the weight of the snowball\n    w += h\n\n    # Check if the snowball hits a stone\n    if h == d1:\n        w = max(0, w - u1)\n    elif h == d2:\n        w = max(0, w - u2)\n\n    # Move the snowball down\n    h -= 1\n\n# Print the final weight of the snowball\nprint(w)"}
{"solution": "# Read the input\nm = int(input())\nc = list(map(int, input().split()))\nx, y = map(int, input().split())\n\n# Initialize the variables\nbeginners = 0\nintermediates = 0\nk = 0\n\n# Iterate over the scores\nfor i in range(m):\n    # If adding the current group to the beginners group doesn't exceed the limit\n    if beginners + c[i] <= y:\n        # Add the current group to the beginners group\n        beginners += c[i]\n        # If the beginners group is now large enough\n        if beginners >= x:\n            # Set the passing rate to the current score\n            k = i + 1\n            # Add the remaining students to the intermediates group\n            intermediates = sum(c[i+1:])\n            # If the intermediates group is also large enough\n            if intermediates >= x and intermediates <= y:\n                # Print the passing rate and exit\n                print(k)\n                exit()\n    # If adding the current group to the beginners group exceeds the limit\n    else:\n        # Break the loop\n        break\n\n# If no passing rate was found\nprint(0)"}
{"solution": "n = int(input())\nk = int(input())\nA = int(input())\nB = int(input())\n\ndef min_coins(x):\n    if x == 1:\n        return 0\n    elif x % k == 0:\n        return min(min_coins(x // k) + B, min_coins(x - 1) + A)\n    else:\n        return min_coins(x - 1) + A\n\nprint(min_coins(n))"}
{"solution": "import math\n\ndef min_operations(n):\n    operations = 0\n    while n % 2 == 0:\n        n = math.sqrt(n)\n        operations += 1\n    while n % 3 == 0:\n        n /= 3\n        operations += 1\n    while n % 5 == 0:\n        n /= 5\n        operations += 1\n    while n % 7 == 0:\n        n /= 7\n        operations += 1\n    if n > 1:\n        operations += 1\n        n = 1\n    return int(n), operations\n\nn = int(input())\nmin_n, min_operations = min_operations(n)\nprint(min_n, min_operations)"}
{"solution": "# Read input\nN, K = map(int, input().split())\nR, S, P = map(int, input().split())\nT = input()\n\n# Initialize score and previous moves list\nscore = 0\nprev_moves = []\n\n# Iterate over each round\nfor i in range(N):\n    # Get the machine's move\n    machine_move = T[i]\n\n    # If the current round is within the first K rounds, choose the move that earns the most points\n    if i < K:\n        if machine_move == 'r':\n            score += P\n            prev_moves.append('p')\n        elif machine_move == 'p':\n            score += S\n            prev_moves.append('s')\n        else:\n            score += R\n            prev_moves.append('r')\n    # If the current round is after the first K rounds, choose the move that earns the most points and is not the same as the move K rounds ago\n    else:\n        if machine_move == 'r':\n            if prev_moves[i-K] != 'p':\n                score += P\n                prev_moves.append('p')\n            else:\n                prev_moves.append('r')\n        elif machine_move == 'p':\n            if prev_moves[i-K] != 's':\n                score += S\n                prev_moves.append('s')\n            else:\n                prev_moves.append('p')\n        else:\n            if prev_moves[i-K] != 'r':\n                score += R\n                prev_moves.append('r')\n            else:\n                prev_moves.append('s')\n\n# Print the maximum total score\nprint(score)"}
{"solution": "# Read the input\na, b, c = map(int, input().split())\n\n# Calculate the maximum possible length\nmax_length = 2 * min(a, b) + 2 * c\nif a != b:\n    max_length += 1\n\n# Print the result\nprint(max_length)"}
{"solution": "n, k, p, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Calculate the sum of marks Vova already has\nsum_marks = sum(marks)\n\n# Calculate the number of remaining tests\nremaining_tests = n - k\n\n# Calculate the minimum sum of marks Vova needs to get for the remaining tests\nmin_sum = max(x - sum_marks, 0)\n\n# Calculate the minimum number of marks Vova needs to get for the remaining tests\n# to ensure his median mark is at least y\nmin_marks = max(y, (sum_marks + min_sum + 1) // (k + remaining_tests))\n\n# Calculate the number of marks Vova needs to get for the remaining tests\n# to achieve the minimum sum and median marks\nneeded_marks = min_sum // remaining_tests\nremaining_sum = min_sum % remaining_tests\n\n# Check if it is possible for Vova to achieve the desired result\nif needed_marks > p or min_marks > p or needed_marks * remaining_tests + sum_marks > x:\n    print(-1)\nelse:\n    # Print the marks Vova needs to get for the remaining tests\n    print(*([needed_marks] * remaining_tests + [min_marks + remaining_sum]))"}
{"solution": "def is_berlanese(word):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    prev_char = word[0]\n    for char in word[1:]:\n        if prev_char not in vowels and prev_char != 'n':\n            if char not in vowels:\n                return False\n        prev_char = char\n    if prev_char not in vowels and prev_char != 'n':\n        return False\n    return True\n\nword = input()\nif is_berlanese(word):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "from collections import defaultdict\n\ndef max_dominoes(n, m, edges):\n    graph = defaultdict(list)\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    degrees = [len(graph[i]) for i in range(1, n + 1)]\n    max_degree = max(degrees)\n\n    if max_degree > 3:\n        return 0\n    elif max_degree == 3:\n        return n\n    elif max_degree == 2:\n        if degrees.count(2) % 2 == 0:\n            return m\n        else:\n            return m - 1\n    else:\n        return m\n\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nprint(max_dominoes(n, m, edges))"}
{"solution": "import sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = set(map(int, sys.stdin.readline().split()))\n\n    dp = [[0] * (n * max(a) + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(n * max(a) + 1):\n            if dp[i - 1][j]:\n                if i in b:\n                    for k in range(a[i - 1], min(j, a[i - 1]) + 1):\n                        dp[i][j - k + a[i - 1]] = 1\n                else:\n                    dp[i][j + a[i - 1]] = 1\n                    dp[i][abs(j - a[i - 1])] = 1\n\n    print(max(i for i in range(n * max(a), -1, -1) if dp[n][i]))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Get the input\nm = list(map(int, input().split()))\nw = list(map(int, input().split()))\nh = list(map(int, input().split()))\n\n# Define the maximum points for each problem\nmax_points = [500, 1000, 1500, 2000, 2500]\n\n# Calculate the score for each problem\nscores = [max(0.3 * max_points[i], (1 - m[i] / 250) * max_points[i] - 50 * w[i]) for i in range(5)]\n\n# Calculate the total score\ntotal_score = sum(scores) + 100 * h[0] - 50 * h[1]\n\n# Print the total score\nprint(int(total_score))"}
{"solution": "MODULO = 998244353\n\ndef power(base, exponent):\n    result = 1\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % MODULO\n        base = (base * base) % MODULO\n        exponent //= 2\n    return result\n\ndef inverse(number):\n    return power(number, MODULO - 2)\n\ndef count_grids(n, m, L, R):\n    if L == R:\n        return 1\n    if n == 1 or m == 1:\n        return (R - L + 1) % MODULO\n    return (power(2, n * m - 1) * (R - L + 1) * inverse(n * m)) % MODULO\n\nn, m, L, R = map(int, input().split())\nresult = count_grids(n, m, L, R)\nprint(result)"}
{"solution": "def check_possible(matrix1, matrix2, n, m):\n    for i in range(n):\n        for j in range(m):\n            if (i > 0 and matrix1[i][j] <= matrix1[i-1][j]) or (j > 0 and matrix1[i][j] <= matrix1[i][j-1]):\n                if (i > 0 and matrix2[i][j] <= matrix2[i-1][j]) or (j > 0 and matrix2[i][j] <= matrix2[i][j-1]):\n                    return False\n            elif (i > 0 and matrix2[i][j] <= matrix2[i-1][j]) or (j > 0 and matrix2[i][j] <= matrix2[i][j-1]):\n                if (i > 0 and matrix1[i][j] <= matrix1[i-1][j]) or (j > 0 and matrix1[i][j] <= matrix1[i][j-1]):\n                    return False\n    return True\n\nn, m = map(int, input().split())\nmatrix1 = [list(map(int, input().split())) for _ in range(n)]\nmatrix2 = [list(map(int, input().split())) for _ in range(n)]\n\nif check_possible(matrix1, matrix2, n, m):\n    print(\"Possible\")\nelse:\n    print(\"Impossible\")"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\na.sort(reverse=True)\n\nmax_length = 0\nfor i in range(n):\n    if a[i] > i:\n        max_length += i + 1\n    else:\n        max_length += a[i]\n\nprint(max_length)"}
{"solution": "n, k = map(int, input().split())\nproblems = list(map(int, input().split()))\nproblems.sort()\n\nextra_problems = 0\nfor problem in problems:\n    if problem > k:\n        if k * 2 < problem:\n            extra_problems += 1\n            k = problem\n        else:\n            k = (problem + 1) // 2\n\nprint(extra_problems)"}
{"solution": "def distribute_diplomas(n, min_1, max_1, min_2, max_2, min_3, max_3):\n    # Start from the maximum possible number of diplomas of the first degree\n    for first_degree in range(max_1, min_1 - 1, -1):\n        # Calculate the remaining number of diplomas to distribute\n        remaining = n - first_degree\n        # Check if it's possible to distribute the remaining diplomas within the given limits\n        if min_2 <= remaining - max_3 <= max_2:\n            # Calculate the number of diplomas of the second degree\n            second_degree = min(remaining - min_3, max_2)\n            # Calculate the number of diplomas of the third degree\n            third_degree = remaining - second_degree\n            return first_degree, second_degree, third_degree\n    # If no solution is found, return -1 for all degrees\n    return -1, -1, -1\n\n# Read the input\nn = int(input())\nmin_1, max_1 = map(int, input().split())\nmin_2, max_2 = map(int, input().split())\nmin_3, max_3 = map(int, input().split())\n\n# Distribute the diplomas\nfirst_degree, second_degree, third_degree = distribute_diplomas(n, min_1, max_1, min_2, max_2, min_3, max_3)\n\n# Print the output\nprint(first_degree, second_degree, third_degree)"}
{"solution": "# Read the input\nn = int(input())\nmoon_sizes = list(map(int, input().split()))\n\n# Define the moon cycle\nmoon_cycle = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n\n# Check if the moon sizes match the end of the moon cycle\nif moon_sizes[-3:] == moon_cycle[-3:]:\n    print(\"DOWN\")\n# Check if the moon sizes match the start of the moon cycle\nelif moon_sizes[-3:] == moon_cycle[:3]:\n    print(\"UP\")\n# If the moon sizes don't match either end of the moon cycle, it's impossible to determine\nelse:\n    print(-1)"}
{"solution": "def is_transformable(s, t):\n    vowels = set('aeiou')\n    for char_s, char_t in zip(s, t):\n        if char_s == char_t:\n            continue\n        if (char_s in vowels) != (char_t in vowels):\n            return False\n    return True\n\ns = input()\nt = input()\n\nif is_transformable(s, t):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "board = [input() for _ in range(8)]\n\n# Check if there is a white pawn in the first row\nif 'W' in board[0]:\n    print('A')\n# Check if there is a black pawn in the last row\nelif 'B' in board[7]:\n    print('B')\n# Check if there is a white pawn in the second row and a black pawn in the seventh row\nelif 'W' in board[1] and 'B' in board[6]:\n    print('B')\n# If none of the above conditions are met, then player A can win\nelse:\n    print('A')"}
{"solution": "def max_length(A, B):\n    n, m = len(A), len(B)\n    i, j, sum_A, sum_B = 0, 0, 0, 0\n    max_len = 0\n\n    while i < n and j < m:\n        sum_A += A[i]\n        sum_B += B[j]\n\n        while sum_A != sum_B and i < n - 1:\n            i += 1\n            sum_A += A[i]\n\n        while sum_A != sum_B and j < m - 1:\n            j += 1\n            sum_B += B[j]\n\n        if sum_A == sum_B:\n            max_len += 1\n            sum_A, sum_B = 0, 0\n            i += 1\n            j += 1\n        else:\n            break\n\n    if i == n and j == m and sum_A == sum_B:\n        max_len += 1\n\n    return max_len if max_len > 1 else -1\n\nn = int(input())\nA = list(map(int, input().split()))\nm = int(input())\nB = list(map(int, input().split()))\n\nprint(max_length(A, B))"}
{"solution": "# Get the input string\ns = input()\n\n# Initialize a counter for the number of times a friend's name appears in the string\ncount = 0\n\n# Check for each friend's name\nif 'Danil' in s:\n    count += 1\nif 'Olya' in s:\n    count += 1\nif 'Slava' in s:\n    count += 1\nif 'Ann' in s:\n    count += 1\nif 'Nikita' in s:\n    count += 1\n\n# If exactly one friend's name appears in the string, print \"YES\", otherwise print \"NO\"\nif count == 1:\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "import math\n\ndef sieve_of_eratosthenes(n):\n    primes = [True for i in range(n+1)]\n    p = 2\n    while(p * p <= n):\n        if (primes[p] == True):\n            for i in range(p * p, n+1, p):\n                primes[i] = False\n        p += 1\n    return primes\n\ndef count_primes(a, b, k):\n    primes = sieve_of_eratosthenes(b)\n    count = 0\n    max_count = 0\n    for i in range(a, b+1):\n        if primes[i]:\n            count += 1\n        if i >= k:\n            if primes[i-k+1]:\n                count -= 1\n        if count >= k:\n            max_count = max(max_count, i - a + 1)\n    return max_count if max_count > 0 else -1\n\na, b, k = map(int, input().split())\nprint(count_primes(a, b, k))"}
{"solution": "def calculate_min_distance(a, h, w):\n    # Check if the photo size is a divisor of the wall size\n    if h % a != 0 or w % a != 0:\n        return -1\n    # Calculate the number of photos that can be placed on the wall\n    num_photos_h = h // a\n    num_photos_w = w // a\n    # Calculate the minimum distance between photos\n    min_distance_h = h / (num_photos_h + 1)\n    min_distance_w = w / (num_photos_w + 1)\n    # Return the minimum distance\n    return max(min_distance_h, min_distance_w)\n\n# Read the input\na, h, w = map(int, input().split())\n# Calculate the minimum distance\nmin_distance = calculate_min_distance(a, h, w)\n# Print the result\nprint(min_distance)"}
{"solution": "# Read the number of chapters\nn = int(input())\n\n# Initialize a list to store the chapters\nchapters = []\n\n# Read the chapters\nfor _ in range(n):\n    l, r = map(int, input().split())\n    chapters.append((l, r))\n\n# Read the marked page\nk = int(input())\n\n# Initialize a counter for the unread chapters\nunread_chapters = 0\n\n# Iterate over the chapters\nfor l, r in chapters:\n    # If the marked page is after the current chapter, increment the counter\n    if k <= l:\n        unread_chapters += 1\n    # If the marked page is inside the current chapter, break the loop\n    elif l < k <= r:\n        unread_chapters += 1\n        break\n\n# Print the number of unread chapters\nprint(unread_chapters)"}
{"solution": "def check_substring(s):\n    target = \"CODEFORCES\"\n    if target in s:\n        return True\n    for i in range(len(target)):\n        if s.startswith(target[i:]) or s.endswith(target[:i]):\n            return True\n    return False\n\nbanner = input()\nif check_substring(banner):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "# Read the number of vertices\nn = int(input())\n\n# Initialize the minimum weight to 0\nmin_weight = 0\n\n# Iterate through all possible diagonals\nfor i in range(1, n - 1):\n    # Calculate the weight of the current triangulation\n    weight = i * (i + 1) + (i + 1) * (i + 2)\n    # Update the minimum weight if necessary\n    if i == 1 or weight < min_weight:\n        min_weight = weight\n\n# Print the minimum weight\nprint(min_weight)"}
{"solution": "# Get the input\nn = int(input())\n\n# Initialize the count of digits\ndigits = 0\n\n# Loop through the numbers from 1 to n\nfor i in range(1, n + 1):\n    # Add the number of digits in the current number to the total count\n    digits += len(str(i))\n\n# Print the result\nprint(digits)"}
{"solution": "# Read input\nn, A = map(int, input().split())\ncars = list(map(int, input().split()))\n\n# Count occurrences of each color\ncount = [0] * (10**6 + 1)\nfor car in cars:\n    count[car] += 1\n\n# Check each color to see if Bob can win\nfor B in range(1, 10**6 + 1):\n    if B == A:\n        continue\n    cnt_A = cnt_B = 0\n    can_win = True\n    for car in cars:\n        if car == A:\n            cnt_A += 1\n        if car == B:\n            cnt_B += 1\n        if cnt_B > cnt_A:\n            can_win = False\n            break\n    if can_win and cnt_B < cnt_A:\n        print(B)\n        exit()\n\n# If no color allows Bob to win\nprint(-1)"}
{"solution": "n, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculate the total length of the segments\ntotal_length = sum(a)\n\n# Calculate the total length of the gaps between segments\ngap_length = n - 1\n\n# Check if the total length of the segments and gaps is equal to the length of the crossword\nif total_length + gap_length == x:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "# Read input\nn, S = map(int, input().split())\n\n# Calculate the largest triangular number that is less than or equal to S\ntriangular_number = (n * (n + 1)) // 2\nwhile triangular_number > S:\n    n -= 1\n    triangular_number = (n * (n + 1)) // 2\n\n# Calculate the minimum number of coins required\nmin_coins = n\nif S > triangular_number:\n    min_coins += (S - triangular_number) // n\n    if (S - triangular_number) % n != 0:\n        min_coins += 1\n\n# Print output\nprint(min_coins)"}
{"solution": "def min_changes_palindrome(s):\n    n = len(s)\n    count = [0] * 26\n    for i in range(n):\n        count[ord(s[i]) - ord('a')] += 1\n\n    odd_count = 0\n    odd_char = ''\n    for i in range(26):\n        if count[i] % 2 != 0:\n            odd_count += 1\n            odd_char = chr(i + ord('a'))\n\n    if odd_count > 1:\n        return None\n\n    half = [0] * 26\n    for i in range(26):\n        half[i] = count[i] // 2\n\n    result = []\n    for i in range(26):\n        result.extend([chr(i + ord('a'))] * half[i])\n\n    if odd_char:\n        result.append(odd_char)\n\n    result.extend(result[::-1])\n\n    return ''.join(result)\n\ns = input()\nprint(min_changes_palindrome(s))"}
{"solution": "# Define the weights of the chess pieces\nweights = {'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'P': 1, 'q': -9, 'r': -5, 'b': -3, 'n': -3, 'p': -1}\n\n# Initialize the total weight of the white and black pieces\nwhite_weight = 0\nblack_weight = 0\n\n# Read the input and calculate the total weight of the white and black pieces\nfor _ in range(8):\n    row = input()\n    for piece in row:\n        if piece != '.':\n            if piece.isupper():\n                white_weight += weights[piece]\n            else:\n                black_weight += weights[piece]\n\n# Print the result\nif white_weight > black_weight:\n    print(\"White\")\nelif white_weight < black_weight:\n    print(\"Black\")\nelse:\n    print(\"Draw\")"}
{"solution": "import sys\nfrom collections import deque\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    s = sys.stdin.readline().strip()\n\n    # dp[i][j] is the minimum number of turns to reach square i\n    # with the last dice roll being j\n    dp = [[float('inf')] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    # prev[i][j] is the previous square and dice roll that leads to dp[i][j]\n    prev = [[None] * (m + 1) for _ in range(n + 1)]\n\n    for i in range(n):\n        if s[i] == '1':\n            continue\n        for j in range(1, m + 1):\n            if i + j <= n and s[i + j] == '0':\n                for k in range(1, m + 1):\n                    if dp[i][k] + 1 < dp[i + j][j]:\n                        dp[i + j][j] = dp[i][k] + 1\n                        prev[i + j][j] = (i, k)\n\n    if dp[n][0] == float('inf'):\n        print(-1)\n        return\n\n    path = []\n    i, j = n, 0\n    while i > 0:\n        path.append(j)\n        i, j = prev[i][j]\n    path.reverse()\n    print(*path)\n\nsolve()"}
{"solution": "import sys\n\ndef main():\n    K = int(sys.stdin.readline())\n    X, Y = map(int, sys.stdin.readline().split())\n\n    # Check if the game can be finished\n    if (abs(X) + abs(Y)) % (2 * K) != 0:\n        print(-1)\n        return\n\n    # Find one way to bring the ball to the goal with the lowest score possible\n    path = []\n    x, y = 0, 0\n    while x != X or y != Y:\n        # Move diagonally as far as possible\n        dx = K if x < X else -K if x > X else 0\n        dy = K if y < Y else -K if y > Y else 0\n        x += dx\n        y += dy\n        path.append((x, y))\n\n        # If we're not at the goal yet, move horizontally or vertically to get closer\n        if x != X:\n            x += K if x < X else -K\n            path.append((x, y))\n        elif y != Y:\n            y += K if y < Y else -K\n            path.append((x, y))\n\n    # Print the result\n    print(len(path))\n    for x, y in path:\n        print(x, y)\n\nif __name__ == '__main__':\n    main()"}
{"solution": "def find_smallest_n(m):\n    left, right = 1, 10**18\n    while left < right:\n        mid = (left + right) // 2\n        if count_ways(mid) >= m:\n            right = mid\n        else:\n            left = mid + 1\n    return left if count_ways(left) == m else -1\n\ndef count_ways(n):\n    count = 0\n    for a in range(1, n + 1):\n        for b in range(a + 1, n + 1):\n            if b > a * 2:\n                break\n            for c in range(b + 1, n + 1):\n                if c > b * 2:\n                    break\n                d = n - a - b - c\n                if d > c * 2:\n                    break\n                if d > b and d > c:\n                    count += 1\n    return count\n\nm = int(input())\nprint(find_smallest_n(m))"}
{"solution": "import math\n\ndef circle_intersection_area(x1, y1, r1, x2, y2, r2):\n    d = math.sqrt((x1 - x2)**2 + (y1 - y2)**2)\n\n    if d >= r1 + r2:\n        return 0\n    elif d <= abs(r1 - r2):\n        return min(math.pi * r1**2, math.pi * r2**2)\n    else:\n        a = (r1**2 - r2**2 + d**2) / (2 * d)\n        h = math.sqrt(r1**2 - a**2)\n        theta1 = 2 * math.asin(h / r1)\n        theta2 = 2 * math.asin(h / r2)\n        area1 = 0.5 * r1**2 * (theta1 - math.sin(theta1))\n        area2 = 0.5 * r2**2 * (theta2 - math.sin(theta2))\n        return area1 + area2\n\nx1, y1, r1 = map(int, input().split())\nx2, y2, r2 = map(int, input().split())\n\nprint(circle_intersection_area(x1, y1, r1, x2, y2, r2))"}
{"solution": "# Read the input\nv = int(input())\n\n# If v is 1, then the minimum value of n is 1\nif v == 1:\n    print(1)\n# If v is 2, then the minimum value of n is 1\nelif v == 2:\n    print(1)\n# If v is odd, then the minimum value of n is 1\nelif v % 2 != 0:\n    print(1)\n# If v is even, then the minimum value of n is 2\nelse:\n    print(2)"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef main():\n    n = int(read_input())\n    parents = list(map(int, read_input().split()))\n    citizens = list(map(int, read_input().split()))\n\n    graph = defaultdict(list)\n    for i in range(2, n + 1):\n        graph[parents[i - 1]].append(i)\n\n    def dfs(node):\n        if not graph[node]:\n            return citizens[node - 1]\n        children_citizens = [dfs(child) for child in graph[node]]\n        total_citizens = sum(children_citizens) + citizens[node - 1]\n        return max(citizens[node - 1], min(children_citizens) if children_citizens else 0)\n\n    print(dfs(1))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n = int(input())\nS = input()\nT = input()\n\n# Initialize count of common words\ncount = 0\n\n# Check if S can be obtained from T by deleting one character\nfor i in range(n):\n    if S[:i] + S[i+1:] == T:\n        count += 1\n        break\n\n# Check if T can be obtained from S by deleting one character\nfor i in range(n):\n    if T[:i] + T[i+1:] == S:\n        count += 1\n        break\n\nprint(count)"}
{"solution": "import sys\n\ndef dfs(node, parent, graph, strengths):\n    max_depth = 0\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            depth = dfs(neighbor, node, graph, strengths) + 1\n            max_depth = max(max_depth, depth)\n            strengths[node] = max(strengths[node], depth)\n    return max_depth\n\ndef solve():\n    n = int(sys.stdin.readline())\n    strengths = list(map(int, sys.stdin.readline().split()))\n    graph = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n\n    dfs(0, -1, graph, strengths)\n    print(max(strengths))\n\nsolve()"}
{"solution": "# Get the input values for the number of cats and the number of cats who left\nn, m = map(int, input().split())\n\n# Calculate the maximum possible number of groups\nif m == 0:\n    # If no cats have left, there is only one group\n    groups = 1\nelif m == n:\n    # If all cats have left, there are no groups\n    groups = 0\nelse:\n    # Otherwise, the maximum possible number of groups is m + 1\n    groups = m + 1\n\n# Print the result\nprint(groups)"}
{"solution": "k, r = map(int, input().split())\n\nfor i in range(1, k + 1):\n    if (i * k) % 10 == r:\n        print(i)\n        break"}
{"solution": "import sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(grid, i, j, n, m):\n    if i < 0 or i >= n or j < 0 or j >= m or grid[i][j] == '.':\n        return 0\n    grid[i][j] = '.'\n    return 1 + dfs(grid, i-1, j, n, m) + dfs(grid, i+1, j, n, m) + dfs(grid, i, j-1, n, m) + dfs(grid, i, j+1, n, m)\n\ndef solve():\n    n, m = map(int, input().split())\n    grid = [list(input()) for _ in range(n)]\n    size = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'X':\n                size = dfs(grid, i, j, n, m)\n                break\n        if size > 0:\n            break\n    if size == 0 or n * m < 2 * size or (n * m - size) % size != 0:\n        print('NO')\n    else:\n        print('YES')\n\nsolve()"}
{"solution": "# Read the coordinates of the three points\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\nx3, y3 = map(int, input().split())\n\n# Check if all points are on the same line\nif (x1 == x2 == x3) or (y1 == y2 == y3):\n    print(1)\n# Check if two points are on the same line and the third point is not on this line\nelif (x1 == x2 and y3 != y1) or (y1 == y2 and x3 != x1) or (x1 == x3 and y2 != y1) or (y1 == y3 and x2 != x1):\n    print(2)\n# If none of the above conditions are met, then the minimum number of segments is 3\nelse:\n    print(3)"}
{"solution": "# Read the input degree k\nk = int(input())\n\n# Check if k is even and greater than 1\nif k % 2 == 0 and k > 1:\n    # Print \"YES\" if such a graph exists\n    print(\"YES\")\n    # Calculate the number of vertices and edges\n    n = 2 * k\n    m = k * (k + 1)\n    # Print the number of vertices and edges\n    print(n, m)\n    # Connect the first k vertices to the last k vertices to form a cycle\n    for i in range(1, k + 1):\n        print(i, i + k)\n    # Connect the first k vertices to each other\n    for i in range(1, k):\n        print(i, i + 1)\n        print(i + k, i + k + 1)\n    # Add one more edge to create a bridge\n    print(1, k + 1)\n    print(k, 2 * k)\nelse:\n    # Print \"NO\" if such a graph does not exist\n    print(\"NO\")"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef solve():\n    n, m, q = map(int, read_input().split())\n    s = read_input()\n    t = read_input()\n\n    base = 31\n    mod = 1000000007\n\n    hash_t = 0\n    power = 1\n    for i in range(m - 1, -1, -1):\n        hash_t = (hash_t + (ord(t[i]) - ord('a') + 1) * power) % mod\n        power = (power * base) % mod\n\n    hash_s = [0] * (n + 1)\n    power = 1\n    for i in range(n - 1, -1, -1):\n        hash_s[i] = (hash_s[i + 1] + (ord(s[i]) - ord('a') + 1) * power) % mod\n        power = (power * base) % mod\n\n    occurrences = defaultdict(int)\n    occurrences[hash_t] += 1\n\n    power = 1\n    for i in range(m):\n        power = (power * base) % mod\n\n    for _ in range(q):\n        l, r = map(int, read_input().split())\n        l -= 1\n        r -= 1\n        current_hash = (hash_s[l] - hash_s[r + 1] + mod) % mod\n        current_hash = (current_hash * power) % mod\n        print(occurrences[current_hash])\n\nsolve()"}
{"solution": "MOD = 1000000007\n\ndef solve(n, k, d):\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(1, min(i, k) + 1):\n            for l in range(j, i + 1):\n                dp[j][l] = (dp[j][l] + dp[j - 1][l - j]) % MOD\n\n    ans = 0\n    for i in range(d, n + 1):\n        ans = (ans + dp[k][i]) % MOD\n\n    return ans\n\nn, k, d = map(int, input().split())\nprint(solve(n, k, d))"}
{"solution": "n = int(input())\ns = input()\n\n# Initialize variables\ncount = 0\nresult = []\n\n# Iterate over the string\nfor i in range(n):\n    # If the current character is 'B'\n    if s[i] == 'B':\n        # Increment the count\n        count += 1\n        # If this is the last character or the next character is 'W'\n        if i == n - 1 or s[i + 1] == 'W':\n            # Append the count to the result list\n            result.append(count)\n            # Reset the count\n            count = 0\n\n# Print the number of groups\nprint(len(result))\n# Print the groups\nprint(' '.join(map(str, result)))"}
{"solution": "def solve():\n    n, m, p = map(int, input().split())\n    sequence = list(input())\n    operations = input()\n    stack = []\n    cursor = p - 1\n\n    for i in range(n):\n        if sequence[i] == '(':\n            stack.append(i)\n        else:\n            start = stack.pop()\n            sequence[start] = sequence[i] = i - start\n\n    for op in operations:\n        if op == 'L':\n            cursor -= 1\n        elif op == 'R':\n            cursor += 1\n        elif op == 'D':\n            length = sequence[cursor]\n            for i in range(cursor - length, cursor + length + 1):\n                sequence[i] = ''\n            if cursor + length + 1 < n and sequence[cursor + length + 1]:\n                cursor += length + 1\n            else:\n                cursor -= length + 1\n\n    print(''.join(sequence))\n\nsolve()"}
{"solution": "n = int(input())\nlower_bound = -2*10**9\nupper_bound = 2*10**9\n\nfor _ in range(n):\n    query = input().split()\n    sign = query[0]\n    x = int(query[1])\n    answer = query[2]\n\n    if answer == 'Y':\n        if sign == '>':\n            lower_bound = max(lower_bound, x)\n        elif sign == '<':\n            upper_bound = min(upper_bound, x)\n        elif sign == '>=':\n            lower_bound = max(lower_bound, x - 1)\n        elif sign == '<=':\n            upper_bound = min(upper_bound, x + 1)\n    else:\n        if sign == '>':\n            upper_bound = min(upper_bound, x)\n        elif sign == '<':\n            lower_bound = max(lower_bound, x)\n        elif sign == '>=':\n            upper_bound = min(upper_bound, x)\n        elif sign == '<=':\n            lower_bound = max(lower_bound, x)\n\nif lower_bound <= upper_bound:\n    print(lower_bound)\nelse:\n    print('Impossible')"}
{"solution": "import math\n\ndef count_periods(a, b):\n    total_length = a + b\n    periods = set()\n\n    for i in range(1, int(math.sqrt(total_length)) + 1):\n        if total_length % i == 0:\n            periods.add(i)\n            periods.add(total_length // i)\n\n    for i in range(1, total_length):\n        if a % i == b % i:\n            periods.add(i)\n\n    return len(periods)\n\na, b = map(int, input().split())\nprint(count_periods(a, b))"}
{"solution": "n, k = map(int, input().split())\ngroups = input().split()\n\nnames = ['A'] * n\n\nfor i in range(n - k + 1):\n    if groups[i] == 'NO':\n        for j in range(i, i + k):\n            if names[j] == names[i]:\n                names[j] = chr(ord(names[j]) + 1)\n\nprint(' '.join(names))"}
{"solution": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef count_steps(a, b):\n    if a == b:\n        return 0\n    if a < b:\n        a, b = b, a\n    if a % b == 0 and a // b in [2, 3, 5]:\n        return 1\n    if a % 2 == 0 and (a // 2) % b == 0 and (a // 2) // b in [2, 3, 5]:\n        return 2\n    if a % 3 == 0 and (a // 3) % b == 0 and (a // 3) // b in [2, 3, 5]:\n        return 2\n    if a % 5 == 0 and (a // 5) % b == 0 and (a // 5) // b in [2, 3, 5]:\n        return 2\n    if gcd(a, b) in [2, 3, 5]:\n        return 3\n    return -1\n\na, b = map(int, input().split())\nprint(count_steps(a, b))"}
{"solution": "n, a, b = map(int, input().split())\nsuits = list(map(int, input().split()))\n\ncost = 0\nfor i in range(n // 2):\n    if suits[i] == suits[n - i - 1]:\n        continue\n    elif suits[i] == 2 and suits[n - i - 1] == 2:\n        cost += min(a, b) * 2\n    elif suits[i] == 2:\n        suits[i] = suits[n - i - 1]\n        cost += a if suits[i] == 0 else b\n    elif suits[n - i - 1] == 2:\n        suits[n - i - 1] = suits[i]\n        cost += a if suits[n - i - 1] == 0 else b\n    else:\n        print(-1)\n        exit()\n\nprint(cost)"}
{"solution": "def print_cube(k):\n    if k % 2 == 1:\n        print(-1)\n        return\n\n    for i in range(k):\n        for j in range(k):\n            if (i // 2 + j // 2) % 2 == 0:\n                print(\"w\", end=\"\")\n            else:\n                print(\"b\", end=\"\")\n        print()\n\nk = int(input())\nprint_cube(k)"}
{"solution": "import math\n\ndef max_lovely_number(n):\n    i = int(math.sqrt(n))\n    while i > 0:\n        if n % (i * i) == 0:\n            n //= (i * i)\n        i -= 1\n    return n\n\nn = int(input())\nprint(max_lovely_number(n))"}
{"solution": "n = int(input())\nseating = input()\n\n# Check if the first or last seat is occupied\nif seating[0] == '1' or seating[-1] == '1':\n    print('No')\nelse:\n    # Check if there are any two adjacent occupied seats\n    for i in range(1, n - 1):\n        if seating[i] == '1' and seating[i - 1] == '1':\n            print('No')\n            break\n    else:\n        # Check if it's possible to seat one more person\n        for i in range(1, n - 1):\n            if seating[i - 1] == '0' and seating[i] == '0' and seating[i + 1] == '0':\n                print('No')\n                break\n        else:\n            print('Yes')"}
{"solution": "n = int(input())\na = [0] + list(map(int, input().split()))\n\npossible_k = []\nfor k in range(1, n + 1):\n    x = [a[i] - a[i - 1] for i in range(1, k + 1)]\n    valid = True\n    for i in range(k, n + 1):\n        if a[i] != a[i - 1] + x[i % k]:\n            valid = False\n            break\n    if valid:\n        possible_k.append(k)\n\nprint(len(possible_k))\nprint(' '.join(map(str, possible_k)))"}
{"solution": "# Get the input scores\nscores = list(map(int, input().split()))\n\n# Sort the scores in descending order\nscores.sort(reverse=True)\n\n# Calculate the total sum of scores\ntotal_sum = sum(scores)\n\n# Check if the total sum is odd, if so, it's impossible to divide into two equal teams\nif total_sum % 2 != 0:\n    print(\"NO\")\nelse:\n    # Initialize the sum of the first team\n    team_sum = 0\n\n    # Iterate over the scores\n    for score in scores:\n        # Add the score to the first team\n        team_sum += score\n\n        # If the sum of the first team is equal to half of the total sum, it's possible to divide into two equal teams\n        if team_sum == total_sum / 2:\n            print(\"YES\")\n            break\n\n        # If the sum of the first team is greater than half of the total sum, it's impossible to divide into two equal teams\n        elif team_sum > total_sum / 2:\n            print(\"NO\")\n            break"}
{"solution": "def count_2_3_integers(l, r):\n    # Initialize the count of 2-3 integers\n    count = 0\n\n    # Iterate over all possible powers of 2 and 3\n    for i in range(32):\n        for j in range(21):\n            # Calculate the current number\n            num = 2**i * 3**j\n\n            # If the number is within the given range, increment the count\n            if l <= num <= r:\n                count += 1\n\n            # If the number is greater than the right endpoint of the range, break the inner loop\n            if num > r:\n                break\n\n    return count\n\n# Read the input\nl, r = map(int, input().split())\n\n# Print the result\nprint(count_2_3_integers(l, r))"}
{"solution": "# Read the input\nn, k = map(int, input().split())\n\n# Initialize the number of candies Alya ate\ncandies_eaten = 0\n\n# Initialize the number of candies in the box\ncandies_in_box = 0\n\n# Perform each action\nfor i in range(1, n + 1):\n    # If the box is empty or the number of candies to put is less than or equal to the number of candies in the box\n    if candies_in_box == 0 or i <= candies_in_box:\n        # Put i candies into the box\n        candies_in_box += i\n    else:\n        # Eat one candy from the box\n        candies_in_box -= 1\n        candies_eaten += 1\n\n# Print the number of candies Alya ate\nprint(candies_eaten)"}
{"solution": "# Read the number of line segments\nn = int(input())\n\n# Read the lengths of line segments\nsegments = list(map(int, input().split()))\n\n# Sort the lengths of line segments\nsegments.sort()\n\n# Check if the sum of the lengths of the two smallest segments is greater than the length of the third smallest segment\nif segments[n-1] < segments[n-2] + segments[n-3]:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "x, y = map(int, input().split())\n\n# If the number of original toys is less than the number of copies, it's impossible\nif y < x:\n    print(\"No\")\n# If the number of copies is even, it's possible if the number of original toys is at least half the number of copies plus one\nelif x % 2 == 0 and y >= x // 2 + 1:\n    print(\"Yes\")\n# If the number of copies is odd, it's possible if the number of original toys is at least half the number of copies plus two\nelif x % 2 == 1 and y >= x // 2 + 2:\n    print(\"Yes\")\n# In all other cases, it's impossible\nelse:\n    print(\"No\")"}
{"solution": "# Read input\nn, k = map(int, input().split())\nskills = list(map(int, input().split()))\n\n# Calculate initial rating\nrating = sum(skill // 10 for skill in skills)\n\n# Sort skills in ascending order\nskills.sort()\n\n# Use improvement units to increase skills\nfor i in range(n):\n    if k == 0:\n        break\n    # Calculate how many units are needed to increase the skill to the next level\n    needed = (skills[i] // 10 + 1) * 10 - skills[i]\n    # Use all available units or just enough to increase the skill to the next level\n    units = min(k, needed)\n    skills[i] += units\n    k -= units\n    # Recalculate rating\n    rating = sum(skill // 10 for skill in skills)\n\n# Print the result\nprint(rating)"}
{"solution": "# Read input\nn, m = map(int, input().split())\na = set(map(int, input().split()))\nb = set(map(int, input().split()))\n\n# Check if there is a common digit\ncommon = a & b\nif common:\n    print(min(common))\nelse:\n    # Find the smallest pretty integer\n    a_min = min(a)\n    b_min = min(b)\n    print(min(a_min * 10 + b_min, b_min * 10 + a_min))"}
{"solution": "# Get the input\nn, k = map(int, input().split())\n\n# Calculate the total time available for solving problems\ntotal_time = 240 - k\n\n# Initialize the number of problems solved\nproblems_solved = 0\n\n# Initialize the time spent\ntime_spent = 0\n\n# Loop through the problems\nfor i in range(1, n + 1):\n    # Calculate the time required to solve the current problem\n    problem_time = 5 * i\n\n    # Check if Limak has enough time to solve the problem\n    if time_spent + problem_time <= total_time:\n        # Update the time spent\n        time_spent += problem_time\n\n        # Increment the number of problems solved\n        problems_solved += 1\n\n# Print the maximum possible number of problems Limak can solve\nprint(problems_solved)"}
{"solution": "n, x, y = map(int, input().split())\na = list(map(int, input().split()))\n\n# Sort the list of tasks in descending order\na.sort(reverse=True)\n\n# Initialize the count of teams\ncount = 0\n\n# Iterate over the list of tasks\nfor task in a:\n    # If the task requires more than one page\n    if task > 1:\n        # If there are enough sheets with two clean sides\n        if x >= task // 2:\n            # Use the sheets with two clean sides\n            x -= task // 2\n            # Increment the count of teams\n            count += 1\n        # If there are not enough sheets with two clean sides\n        else:\n            # Use all the sheets with two clean sides\n            task -= 2 * x\n            x = 0\n            # If there are enough sheets with one clean side\n            if y >= task:\n                # Use the sheets with one clean side\n                y -= task\n                # Increment the count of teams\n                count += 1\n    # If the task requires one page\n    else:\n        # If there are enough sheets with one clean side\n        if y > 0:\n            # Use a sheet with one clean side\n            y -= 1\n            # Increment the count of teams\n            count += 1\n\n# Print the maximum number of teams\nprint(count)"}
{"solution": "import math\n\ndef count_distinct_fractions(b):\n    # Initialize the count of distinct fractions\n    count = 0\n\n    # Iterate over all possible values of a from 1 to b\n    for a in range(1, b + 1):\n        # Calculate the least common multiple of a and b\n        lcm = a * b // math.gcd(a, b)\n\n        # Calculate the fraction [a, b] / a\n        fraction = lcm / a\n\n        # If this fraction has not been encountered before, increment the count\n        if fraction not in set(range(1, count + 1)):\n            count += 1\n\n    # Return the count of distinct fractions\n    return count\n\n# Read the input value of b\nb = int(input())\n\n# Print the result\nprint(count_distinct_fractions(b))"}
{"solution": "# Read the input\nn = int(input())\nbumpers = input()\n\n# Initialize the count of positions where the ball will fall off\ncount = 0\n\n# Iterate over the bumpers\nfor i in range(n):\n    # Initialize the current position of the ball\n    pos = i\n\n    # While the ball is still on the field\n    while 0 <= pos < n:\n        # Move the ball according to the type of the bumper\n        if bumpers[pos] == '<':\n            pos -= 1\n        else:\n            pos += 1\n\n        # If the ball has fallen off the field, break the loop\n        if pos < 0 or pos >= n:\n            count += 1\n            break\n\n# Print the result\nprint(count)"}
{"solution": "from collections import Counter\n\n# Get the number of sticks\nn = int(input())\n\n# Get the lengths of the sticks\nlengths = list(map(int, input().split()))\n\n# Count the occurrences of each length\nlength_counts = Counter(lengths)\n\n# Initialize the total area\ntotal_area = 0\n\n# Iterate over the lengths\nfor length in length_counts:\n    # If there are at least 4 sticks of the same length,\n    # use them to make a rectangle\n    if length_counts[length] >= 4:\n        total_area += length * length * (length_counts[length] // 4)\n        length_counts[length] %= 4\n\n    # If there are at least 2 sticks of the same length,\n    # and there is a stick of the same length or one less,\n    # use them to make a rectangle\n    if length_counts[length] >= 2 and length_counts[length - 1] >= 2:\n        total_area += length * (length - 1)\n        length_counts[length] -= 2\n        length_counts[length - 1] -= 2\n\n# Print the total area\nprint(total_area)"}
{"solution": "n = int(input())\nnumbers = [input() for _ in range(n)]\n\n# Create a dictionary to store the frequency of each character\nfreq = {}\nfor number in numbers:\n    for char in number:\n        if char not in freq:\n            freq[char] = 0\n        freq[char] += 1\n\n# Sort the characters by their frequency in descending order\nsorted_chars = sorted(freq.keys(), key=lambda x: freq[x], reverse=True)\n\n# Assign the digits to the characters in the order of their frequency\ndigits = {}\nfor i, char in enumerate(sorted_chars):\n    digits[char] = str(i) if i > 0 else ''\n\n# Restore the numbers and calculate their sum\ntotal = 0\nfor number in numbers:\n    restored_number = ''\n    for char in number:\n        restored_number += digits[char]\n    total += int(restored_number)\n\nprint(total)"}
{"solution": "# Read the input\nn, m = map(int, input().split())\n\n# Initialize the number of teams\nteams = 0\n\n# While there are enough newbies for a team of one experienced and two newbies\nwhile n > 0 and m >= 2:\n    # Form a team\n    teams += 1\n    # Decrease the number of newbies by 2 and the number of experienced by 1\n    m -= 2\n    n -= 1\n\n# While there are enough newbies for a team of two experienced and one newbie\nwhile n >= 2 and m > 0:\n    # Form a team\n    teams += 1\n    # Decrease the number of newbies by 1 and the number of experienced by 2\n    m -= 1\n    n -= 2\n\n# Print the number of teams\nprint(teams)"}
{"solution": "def check_string(s):\n    if 'AB' in s and 'BA' in s:\n        ab_index = s.index('AB')\n        ba_index = s.index('BA')\n        if ab_index < ba_index + 2 and ba_index < ab_index + 2:\n            return 'NO'\n        else:\n            return 'YES'\n    elif 'BA' in s and 'AB' in s:\n        ba_index = s.index('BA')\n        ab_index = s.index('AB')\n        if ba_index < ab_index + 2 and ab_index < ba_index + 2:\n            return 'NO'\n        else:\n            return 'YES'\n    else:\n        return 'NO'\n\ns = input()\nprint(check_string(s))"}
{"solution": "def solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    k = int(input())\n    b = list(map(int, input().split()))\n\n    # Simulate the eating process\n    while a != b:\n        # If the queues are not equal and there are no more monsters left to eat, return \"NO\"\n        if len(a) < len(b):\n            print(\"NO\")\n            return\n\n        # Iterate over the queue\n        for i in range(len(a)):\n            # If the current monster can eat the monster on its left, do so\n            if i > 0 and a[i] > a[i - 1]:\n                a[i] += a[i - 1]\n                a.pop(i - 1)\n                print(f\"{i + 1} L\")\n                break\n            # If the current monster can eat the monster on its right, do so\n            elif i < len(a) - 1 and a[i] > a[i + 1]:\n                a[i] += a[i + 1]\n                a.pop(i + 1)\n                print(f\"{i + 1} R\")\n                break\n\n    # If the final queue is achieved, print \"YES\"\n    print(\"YES\")\n\nsolve()"}
{"solution": "import sys\n\ndef hopcroft_karp(graph):\n    pair_u = [-1] * len(graph)\n    pair_v = [-1] * len(graph[0])\n    def bfs():\n        queue = [u for u in range(len(graph)) if pair_u[u] == -1]\n        dist = [-1] * len(graph)\n        for u in queue:\n            dist[u] = 0\n        i = 0\n        while i < len(queue):\n            u = queue[i]\n            for v in range(len(graph[u])):\n                if graph[u][v] and pair_v[v] == -1:\n                    return u, v\n                if graph[u][v] and dist[pair_v[v]] == dist[u] + 1:\n                    queue.append(pair_v[v])\n                    dist[pair_v[v]] = dist[u] + 1\n            i += 1\n        return None\n    def dfs(u):\n        for v in range(len(graph[u])):\n            if graph[u][v] and pair_v[v] == -1:\n                pair_v[v] = u\n                pair_u[u] = v\n                return True\n            if graph[u][v] and dist[pair_v[v]] == dist[u] + 1 and dfs(pair_v[v]):\n                pair_v[v] = u\n                pair_u[u] = v\n                return True\n        return False\n    matching = 0\n    while True:\n        match = bfs()\n        if match is None:\n            break\n        u, v = match\n        pair_u[u] = v\n        pair_v[v] = u\n        matching += 1\n        while dfs(u):\n            matching += 1\n    return matching\n\ndef can_assign_guards(R, B, rebel_pos, base_pos):\n    graph = [[False] * B for _ in range(R)]\n    for i in range(R):\n        for j in range(B):\n            x1, y1 = rebel_pos[i]\n            x2, y2 = base_pos[j]\n            if (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2) > (x1 - x2) * (x1 - x2):\n                graph[i][j] = True\n    return hopcroft_karp(graph) == R\n\ndef main():\n    R, B = map(int, sys.stdin.readline().split())\n    rebel_pos = [tuple(map(int, sys.stdin.readline().split())) for _ in range(R)]\n    base_pos = [tuple(map(int, sys.stdin.readline().split())) for _ in range(B)]\n    if can_assign_guards(R, B, rebel_pos, base_pos):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n = int(input())\nnumbers = list(map(int, input().split()))\n\nmax_power = 0\ncount = 0\n\nfor num in numbers:\n    power = 0\n    while num % 2 == 0:\n        num //= 2\n        power += 1\n    if power > max_power:\n        max_power = power\n        count = 1\n    elif power == max_power:\n        count += 1\n\nprint(2**max_power, count)"}
{"solution": "# Get the input\nn, m = map(int, input().split())\n\n# Initialize the number of clicks\nclicks = 0\n\n# While n is not equal to m\nwhile n != m:\n    # If m is greater than n and m is even\n    if m > n and m % 2 == 0:\n        # Divide m by 2\n        m //= 2\n        # Increment the number of clicks\n        clicks += 1\n    # Otherwise\n    else:\n        # Decrement m\n        m -= 1\n        # Increment the number of clicks\n        clicks += 1\n\n# Print the number of clicks\nprint(clicks)"}
{"solution": "import sys\n\ndef find(parent, i):\n    if parent[i] == i:\n        return i\n    return find(parent, parent[i])\n\ndef union(parent, rank, x, y):\n    xroot = find(parent, x)\n    yroot = find(parent, y)\n\n    if rank[xroot] < rank[yroot]:\n        parent[xroot] = yroot\n    elif rank[xroot] > rank[yroot]:\n        parent[yroot] = xroot\n    else:\n        parent[yroot] = xroot\n        rank[xroot] += 1\n\ndef is_cycle(n, segments):\n    parent = [i for i in range(n)]\n    rank = [0] * n\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if segments[i][0] < segments[j][0] < segments[i][1] < segments[j][1] or segments[j][0] < segments[i][0] < segments[j][1] < segments[i][1]:\n                x = find(parent, i)\n                y = find(parent, j)\n\n                if x == y:\n                    return True\n\n                union(parent, rank, x, y)\n\n    return False\n\ndef main():\n    n = int(sys.stdin.readline())\n    segments = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n\n    if is_cycle(n, segments):\n        print(\"NO\")\n    else:\n        print(\"YES\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "n = int(input())\nrequests = list(map(int, input().split()))\n\nmax_length = 0\ncurrent_length = 0\n\nfor i in range(n):\n    if requests[i] > 100 * (i + 1 - current_length):\n        current_length = i + 1\n    else:\n        max_length = max(max_length, current_length - (i - 100 * (i - current_length)))\n        current_length = i + 1\n\nmax_length = max(max_length, current_length - (n - 100 * (n - current_length)))\n\nprint(max_length)"}
{"solution": "def check_dissatisfaction(n, k, episodes):\n    # Initialize variables\n    max_consecutive_missed = 0\n    current_consecutive_missed = 0\n\n    # Iterate over each episode\n    for i in range(n):\n        # If the episode was not watched\n        if episodes[i] == 'N':\n            current_consecutive_missed += 1\n        # If the episode was watched or unsure\n        else:\n            max_consecutive_missed = max(max_consecutive_missed, current_consecutive_missed)\n            current_consecutive_missed = 0\n\n    # Check if the last episode was not watched\n    max_consecutive_missed = max(max_consecutive_missed, current_consecutive_missed)\n\n    # If the maximum number of consecutive missed episodes is equal to k\n    if max_consecutive_missed == k:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn, k = map(int, input().split())\nepisodes = input()\n\n# Print output\nprint(check_dissatisfaction(n, k, episodes))"}
{"solution": "# Read input\nN, X, D = map(int, input().split())\n\n# Calculate the last element of the sequence\nlast_element = X + D * (N - 1)\n\n# If D is 0, there is only one possible value of S - T\nif D == 0:\n    print(1)\nelse:\n    # Calculate the number of possible values of S - T\n    # Takahashi can take any number of elements from the first half of the sequence\n    # Aoki will take the remaining elements from the second half of the sequence\n    # The difference between the sum of the elements taken by Takahashi and Aoki is maximized\n    # when Takahashi takes the first half of the elements and Aoki takes the second half\n    # The maximum difference is the difference between the last element of the first half and the first element of the second half\n    # The number of possible values of S - T is twice the number of elements in the first half plus one\n    first_half_length = (N + 1) // 2\n    max_diff = last_element - X + D\n    num_possible_values = 2 * first_half_length + 1\n    print(num_possible_values)"}
{"solution": "n = int(input())\nred_before_increased = False\n\nfor _ in range(n):\n    name, before, after = input().split()\n    before, after = int(before), int(after)\n\n    if before < 2400 and after >= 2400:\n        red_before_increased = True\n\nif red_before_increased:\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "# Get the binary input\ns = input()\n\n# Convert the binary input to an integer\ns = int(s, 2)\n\n# Initialize the count of trains missed\ncount = 0\n\n# Initialize the time of the next train\ntime = 1\n\n# While the next train has departed before time s\nwhile time < s:\n    # Increment the count of trains missed\n    count += 1\n    # Calculate the time of the next train\n    time *= 4\n\n# Print the number of trains missed\nprint(count)"}
{"solution": "# Get the dimensions of the matrix\nn, m = map(int, input().split())\n\n# Read the matrix\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# Initialize the minimum number of rows\nmin_rows = n\n\n# Iterate over all possible numbers of rows for the mirrored matrix\nfor i in range(1, n // 2 + 1):\n    # Check if the first i rows are equal to the last i rows\n    if matrix[:i] == matrix[n - i:]:\n        # If they are, update the minimum number of rows\n        min_rows = i\n\n# Print the minimum number of rows\nprint(min_rows)"}
{"solution": "# Read the number of orders\nn = int(input())\n\n# Create a list of orders, each order is a tuple of start and end time\norders = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Sort the orders by their end time\norders.sort(key=lambda x: x[1])\n\n# Initialize the count of accepted orders and the end time of the last accepted order\ncount = 0\nlast_end = 0\n\n# Iterate over the orders\nfor order in orders:\n    # If the current order does not intersect with the last accepted order\n    if order[0] >= last_end:\n        # Accept the order\n        count += 1\n        # Update the end time of the last accepted order\n        last_end = order[1]\n\n# Print the maximal number of orders that can be accepted\nprint(count)"}
{"solution": "def solve(n, k, x, y):\n    tables = 0\n    formulas = 0\n    for i in range(n):\n        if tables + x[i] > k or formulas + y[i] > k:\n            return \"NO\"\n        tables = min(k, tables + x[i])\n        formulas = min(k, formulas + y[i])\n        if i < n - 1:\n            x[i + 1] += x[i] - tables\n            y[i + 1] += y[i] - formulas\n            tables = 0\n            formulas = 0\n    return \"YES\"\n\nn, k = map(int, input().split())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\nprint(solve(n, k, x, y))"}
{"solution": "def can_win(n, k, a):\n    # If n is 0, the polynomial is a constant and can be divided by x - k if and only if a[0] = k\n    if n == 0:\n        return a[0] == k\n\n    # If a[n] is not defined, the human can set it to k to guarantee the victory\n    if a[n] is None:\n        return True\n\n    # Calculate the remainder of the polynomial division by x - k\n    remainder = a[n]\n    for i in range(n - 1, -1, -1):\n        remainder = remainder * k + a[i]\n\n    # If the remainder is 0, the human has lost\n    if remainder == 0:\n        return False\n\n    # If the remainder is not 0, the human can set a coefficient to a value that makes the remainder 0\n    return True\n\n# Read the input\nn, k = map(int, input().split())\na = [None] * (n + 1)\nfor i in range(n + 1):\n    coeff = input()\n    if coeff != '?':\n        a[i] = int(coeff)\n\n# Print the result\nif can_win(n, k, a):\n    print('Yes')\nelse:\n    print('No')"}
{"solution": "def smallest_prime_factor(n):\n    spf = [0 for i in range(n+1)]\n    spf[1] = 1\n    for i in range(2, n+1):\n        spf[i] = i\n    for i in range(2, int(n**0.5)+1):\n        if spf[i] == i:\n            for j in range(i*i, n+1, i):\n                if spf[j] == j:\n                    spf[j] = i\n    return spf\n\ndef smallest_possible_starting_number(X_2):\n    spf = smallest_prime_factor(X_2)\n    X_1 = X_2 // spf[X_2] * spf[X_2]\n    X_0 = X_1 // spf[X_1] * spf[X_1]\n    return X_0\n\nX_2 = int(input())\nprint(smallest_possible_starting_number(X_2))"}
{"solution": "n, p = map(int, input().split())\n\n# Check if it is possible to represent n as the sum of any number of p-binary numbers\nif n < p and p > 0:\n    print(-1)\nelse:\n    # Find the smallest possible number of summands\n    count = 0\n    while n >= p:\n        # Find the largest p-binary number that is less than or equal to n\n        x = 0\n        while (2 ** x + p) <= n:\n            x += 1\n        x -= 1\n        # Subtract the p-binary number from n\n        n -= (2 ** x + p)\n        # Increment the count of summands\n        count += 1\n    # If n is not equal to 0, it means that it is not possible to represent n as the sum of any number of p-binary numbers\n    if n != 0:\n        print(-1)\n    else:\n        print(count)"}
{"solution": "n, k = map(int, input().split())\nS = list(input())\n\n# If the first digit is not 1, change it to 1\nif S[0] != '1' and k > 0:\n    S[0] = '1'\n    k -= 1\n\n# Change the remaining digits to 0\nfor i in range(1, n):\n    if S[i] != '0' and k > 0:\n        S[i] = '0'\n        k -= 1\n\nprint(''.join(S))"}
{"solution": "def sieve_of_eratosthenes(n):\n    primes = [True for i in range(n+1)]\n    p = 2\n    while (p * p <= n):\n        if (primes[p] == True):\n            for i in range(p * p, n+1, p):\n                primes[i] = False\n        p += 1\n    return primes\n\ndef count_numbers(cnt1, cnt2, x, y):\n    primes = sieve_of_eratosthenes(30000)\n    v = 1\n    cnt_x, cnt_y, cnt_both = 0, 0, 0\n    while cnt_x < cnt1 or cnt_y < cnt2 or cnt_both > 0:\n        if v % x != 0 and v % y != 0:\n            if cnt_x < cnt1 and cnt_y < cnt2:\n                cnt_both += 1\n            elif cnt_x < cnt1:\n                cnt_x += 1\n            else:\n                cnt_y += 1\n        elif v % x != 0:\n            cnt_x += 1\n        elif v % y != 0:\n            cnt_y += 1\n        v += 1\n    return v - 1\n\ncnt1, cnt2, x, y = map(int, input().split())\nprint(count_numbers(cnt1, cnt2, x, y))"}
{"solution": "def main():\n    n, sx, sy, dx, dy, t = map(int, input().split())\n\n    # Calculate the number of moves the bear will make\n    moves = t // (2 * n)\n\n    # Calculate the new speed of the bear after eating all the raspberries\n    dx += moves * (sx + sy)\n    dy += moves * (sx + sy)\n\n    # Calculate the new position of the bear after moving\n    sx = ((sx + dx - 1 + moves * n) % n) + 1\n    sy = ((sy + dy - 1 + moves * n) % n) + 1\n\n    # Calculate the remaining time\n    t %= 2 * n\n\n    # Calculate the new speed of the bear after eating the remaining raspberries\n    dx += t * (sx + sy)\n    dy += t * (sx + sy)\n\n    # Calculate the final position of the bear\n    sx = ((sx + dx - 1) % n) + 1\n    sy = ((sy + dy - 1) % n) + 1\n\n    print(sx, sy)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def solve(s):\n    n = len(s)\n    if n < 26:\n        return -1\n\n    alphabet = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n    missing = alphabet.copy()\n    result = list(s)\n\n    for i in range(n - 26 + 1):\n        substring = s[i:i + 26]\n        substring_missing = missing.copy()\n\n        for j in range(26):\n            if substring[j] != '?':\n                substring_missing.discard(substring[j])\n\n        if len(substring_missing) == 0:\n            for j in range(26):\n                if result[i + j] == '?':\n                    result[i + j] = missing.pop()\n            return ''.join(result)\n\n        if i + 26 < n and substring[0] != '?' and substring[25] != '?':\n            missing.discard(substring[0])\n            missing.add(substring[25])\n\n    return -1\n\ns = input()\nprint(solve(s))"}
{"solution": "n = int(input())\nweights = list(map(int, input().split()))\n\ncount_100 = weights.count(100)\ncount_200 = weights.count(200)\n\nif count_100 % 2 == 0 and (count_100 > 0 or count_200 % 2 == 0):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def min_time_to_turn_off_lights(n, m, building):\n    dp = [[0] * (m + 2) for _ in range(n)]\n\n    # Fill the first row\n    for j in range(1, m + 1):\n        dp[0][j] = dp[0][j - 1] + building[0][j]\n\n    # Fill the rest of the rows\n    for i in range(1, n):\n        left_to_right = [0] * (m + 2)\n        right_to_left = [0] * (m + 2)\n\n        # Left to right\n        for j in range(1, m + 1):\n            left_to_right[j] = min(left_to_right[j - 1], dp[i - 1][j]) + building[i][j]\n\n        # Right to left\n        for j in range(m, 0, -1):\n            right_to_left[j] = min(right_to_left[j + 1], dp[i - 1][j]) + building[i][j]\n\n        # Fill the current row\n        for j in range(1, m + 1):\n            dp[i][j] = min(left_to_right[j - 1] + 1 + building[i][j] + right_to_left[j + 1],\n                           right_to_left[j + 1] + 1 + building[i][j] + left_to_right[j - 1])\n\n    return dp[n - 1][1]\n\n# Read input\nn, m = map(int, input().split())\nbuilding = [list(map(int, input())) for _ in range(n)]\n\n# Print output\nprint(min_time_to_turn_off_lights(n, m, building))"}
{"solution": "def find_min_cost(n, costs, moves):\n    visited = [False] * n\n    min_cost = float('inf')\n    min_cost_node = -1\n\n    for i in range(n):\n        if not visited[i]:\n            cycle_cost = costs[i]\n            cycle_nodes = set([i])\n            visited[i] = True\n            next_node = moves[i] - 1\n\n            while not visited[next_node]:\n                visited[next_node] = True\n                cycle_cost = min(cycle_cost, costs[next_node])\n                cycle_nodes.add(next_node)\n                next_node = moves[next_node] - 1\n\n            if next_node in cycle_nodes:\n                min_cost = min(min_cost, cycle_cost)\n\n    return min_cost\n\nn = int(input())\ncosts = list(map(int, input().split()))\nmoves = list(map(int, input().split()))\n\nprint(find_min_cost(n, costs, moves))"}
{"solution": "# Get the input\nn, a, b = map(int, input().split())\n\n# Calculate the final position\nfinal_position = (a + b - 1) % n\n\n# If final position is 0, it means Vasya is at the last entrance\nif final_position == 0:\n    final_position = n\n\n# Print the result\nprint(final_position)"}
{"solution": "def min_arithmetic_progressions(arr):\n    n = len(arr)\n    dp = [0] * n\n    last = [-1] * n\n\n    for i in range(n):\n        dp[i] = dp[i-1] + 1\n        j = i - 1\n        while j >= 0:\n            if arr[j] != -1 and arr[i] != -1 and (arr[i] - arr[j]) % (i - j) != 0:\n                j = last[(arr[i] - arr[j]) % (i - j) + 10**9]\n            if j >= 0 and dp[j] + 1 < dp[i]:\n                dp[i] = dp[j] + 1\n                last[(arr[i] - arr[j]) % (i - j) + 10**9] = j\n            j -= 1\n\n    return dp[n-1]\n\nn = int(input())\narr = list(map(int, input().split()))\nprint(min_arithmetic_progressions(arr))"}
{"solution": "def max_beauty(n, k, s):\n    max_len = 0\n    curr_len = 1\n    for i in range(1, n):\n        if s[i] == s[i-1]:\n            curr_len += 1\n        else:\n            max_len = max(max_len, curr_len)\n            curr_len = 1\n    max_len = max(max_len, curr_len)\n    return min(n, max_len + k)\n\nn, k = map(int, input().split())\ns = input()\nprint(max_beauty(n, k, s))"}
{"solution": "n = int(input())\nseats = list(map(int, input().split()))\n\ntotal_seats = sum(seats)\nmajority = total_seats // 2 + 1\n\n# Check if Alice's party can form a coalition on its own\nif seats[0] >= majority:\n    print(1)\n    print(1)\nelse:\n    # Find potential coalition partners\n    partners = [i for i in range(1, n) if seats[i] <= seats[0] // 2 and seats[0] + seats[i] >= majority]\n    if partners:\n        # Print the number of parties in the coalition\n        print(len(partners) + 1)\n        # Print the indices of the parties in the coalition\n        print('1', ' '.join(map(str, partners)))\n    else:\n        print(0)"}
{"solution": "# Read the number of opponents\nn = int(input())\n\n# Initialize the total reward\ntotal_reward = 0.0\n\n# Calculate the total reward in the best possible scenario\nwhile n > 0:\n    total_reward += 1 / n\n    n -= 1\n\n# Print the maximum prize (in dollars) JOE could have\nprint(\"{:.10f}\".format(total_reward))"}
{"solution": "# Get the input\nn = int(input())\n\n# Initialize the list of candies for each child\ncandies = []\n\n# Start from the largest possible number of candies\nfor i in range(n, 0, -1):\n    # If Santa can give away all remaining candies\n    if n - sum(candies) >= i:\n        # Add the number of candies to the list\n        candies.append(i)\n\n# Print the number of children\nprint(len(candies))\n\n# Print the number of candies for each child\nprint(' '.join(map(str, candies)))"}
{"solution": "# Read input\nn = int(input())\nm = int(input())\n\n# Calculate 2^n\npower_of_two = 2 ** n\n\n# Calculate m mod 2^n\nresult = m % power_of_two\n\n# Print the result\nprint(result)"}
{"solution": "n = int(input())\ns = input()\nvowels = 'aeiouy'\n\nwhile True:\n    found = False\n    for i in range(1, len(s)):\n        if s[i] in vowels and s[i-1] in vowels:\n            s = s[:i-1] + s[i:]\n            found = True\n            break\n    if not found:\n        break\n\nprint(s)"}
{"solution": "def solve(n, a, b, seats):\n    seats = list(seats)\n    count = 0\n    for i in range(n):\n        if seats[i] == '.':\n            if i > 0 and seats[i - 1] != '*':\n                continue\n            if i < n - 1 and seats[i + 1] != '*':\n                continue\n            if a > 0:\n                seats[i] = 'A'\n                a -= 1\n                count += 1\n            elif b > 0:\n                seats[i] = 'B'\n                b -= 1\n                count += 1\n    return count\n\nn, a, b = map(int, input().split())\nseats = input()\nprint(solve(n, a, b, seats))"}
{"solution": "import math\n\ndef find_pair(r):\n    # Iterate over all possible values of x\n    for x in range(1, int(math.sqrt(r)) + 1):\n        # Calculate the corresponding value of y\n        y = (r - x**2 - x - 1) / (2*x)\n        # Check if y is a positive integer\n        if y == int(y):\n            return x, int(y)\n    # If no pair is found, return \"NO\"\n    return \"NO\"\n\n# Read the input value of r\nr = int(input())\n# Find the pair (x, y) that satisfies the condition\nresult = find_pair(r)\n# Print the result\nprint(result)"}
{"solution": "n = int(input())\nballoons = list(map(int, input().split()))\n\nif n <= 2:\n    print(-1)\nelse:\n    total_sum = sum(balloons)\n    half_sum = total_sum // 2\n    current_sum = 0\n    for i in range(n):\n        if current_sum + balloons[i] <= half_sum:\n            current_sum += balloons[i]\n            print(i + 1, end=' ')\n        if current_sum > half_sum and current_sum != total_sum - current_sum:\n            break\n    if current_sum == half_sum or current_sum == total_sum - current_sum:\n        print(-1)"}
{"solution": "n = int(input())\n\n# Start from the largest possible digit\nfor i in range(9, 0, -1):\n    if n % i == 0:\n        # If n is divisible by i, print i n/i times\n        print(n // i)\n        print(' '.join([str(i)] * (n // i)))\n        break\n    elif n > i:\n        # If n is not divisible by i, but is greater than i,\n        # subtract i from n and continue the loop\n        n -= i\n        print(1, end=' ')\n        print(i, end=' ')"}
{"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef max_simple_subset(a):\n    n = len(a)\n    primes = [i for i in range(2, 2 * 10**6 + 1) if is_prime(i)]\n    prime_set = set(primes)\n    dp = [0] * (n + 1)\n    parent = [-1] * n\n    for i in range(n - 1, -1, -1):\n        dp[i] = dp[i + 1]\n        for j in range(i + 1, n):\n            if a[i] + a[j] not in prime_set:\n                if dp[j + 1] + 1 > dp[i]:\n                    dp[i] = dp[j + 1] + 1\n                    parent[i] = j\n                break\n    m = dp[0]\n    subset = []\n    i = 0\n    while i != -1:\n        subset.append(a[i])\n        i = parent[i]\n    return m, subset\n\nn = int(input())\na = list(map(int, input().split()))\nm, subset = max_simple_subset(a)\nprint(m)\nprint(' '.join(map(str, subset)))"}
{"solution": "def greatest_beautiful_divisor(n):\n    k = 1\n    while (2**(k+1) - 1) * (2**k) <= n:\n        k += 1\n    return (2**(k-1) - 1) * (2**(k-1))\n\nn = int(input())\nprint(greatest_beautiful_divisor(n))"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(m, d, a, b):\n    n = len(a)\n    dp = [[0] * 2 for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(2):\n            for k in range(10):\n                if (i % 2 == 0 and k == d) == j:\n                    dp[i + 1][j | (k > 0)] = (dp[i + 1][j | (k > 0)] + dp[i][j]) % MOD\n                if k == 0 and j == 0:\n                    dp[i + 1][j] = (dp[i + 1][j] + dp[i][j]) % MOD\n    return (dp[n][1] - dp[n][0] + (a % m == 0) + (b % m == 0)) % MOD\n\nm, d = map(int, input().split())\na = input()\nb = input()\nprint(solve(m, d, a, b))"}
{"solution": "n, m = map(int, input().split())\na = list(map(int, input().split()))\n\nqueue = list(range(1, n + 1))\nlast_child = 0\n\nwhile queue:\n    child = queue.pop(0)\n    a[child - 1] -= m\n    if a[child - 1] > 0:\n        queue.append(child)\n    else:\n        last_child = child\n\nprint(last_child)"}
{"solution": "# Get the input\nn = int(input())\n\n# Initialize the count of bills\ncount = 0\n\n# Denominations of bills\ndenominations = [100, 20, 10, 5, 1]\n\n# Iterate over each denomination\nfor denomination in denominations:\n    # Count the number of bills of this denomination\n    count += n // denomination\n    # Update the remaining amount\n    n %= denomination\n\n# Print the minimum number of bills\nprint(count)"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(n, k):\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(min(i, k) + 1):\n            dp[i][j] = (dp[i - 1][j] * (i - j) + dp[i - 1][j - 1] * (j + 1)) % MOD\n\n    return dp[n][k]\n\nn, k = map(int, input().split())\nprint(solve(n, k))"}
{"solution": "def max_beauty(n, k, b, c):\n    roses = sorted(zip(b, c), key=lambda x: (-x[0], x[1]))\n    prefix_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + roses[i - 1][0]\n\n    max_beauty = -1\n    last_color = None\n    count = 0\n    for i in range(n):\n        if roses[i][1] != last_color:\n            count += 1\n            last_color = roses[i][1]\n        if count == 2 and i >= k - 1:\n            max_beauty = max(max_beauty, prefix_sum[i + 1] - prefix_sum[i + 1 - k])\n\n    return max_beauty\n\nn, k = map(int, input().split())\nb = list(map(int, input().split()))\nc = input()\nprint(max_beauty(n, k, b, c))"}
{"solution": "def convert_continued_fraction(coefficients):\n    num, den = coefficients[-1], 1\n    for i in range(len(coefficients) - 2, -1, -1):\n        num, den = coefficients[i] * num + den, num\n    return num, den\n\np, q = map(int, input().split())\nn = int(input())\ncoefficients = list(map(int, input().split()))\n\nnum, den = convert_continued_fraction(coefficients)\n\nif num == p and den == q:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "# Get the input expression\nexpression = input()\n\n# Split the expression into parts\nparts = expression.split('+')\na = len(parts[0])\nparts = parts[1].split('=')\nb = len(parts[0])\nc = len(parts[1])\n\n# Check if it's possible to shift a stick\nif a + b == c:\n    print(expression)\nelif a + b - 1 == c:\n    print(expression[:a-1] + '+' + expression[a:])\nelif a + b + 1 == c:\n    print(expression[:a+1] + '+' + expression[a+1:])\nelse:\n    print('Impossible')"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(n, k):\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(i * i):\n            for l in range(i + 1):\n                if j - l * (2 * i - 1 - l) >= 0:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - l * (2 * i - 1 - l)]) % MOD\n\n    return dp[n][k]\n\nn, k = map(int, input().split())\nprint(solve(n, k))"}
{"solution": "def solve(N, points):\n    m = 40\n    d = [10**12] * m\n    w = [''] * N\n\n    for j in range(N):\n        x, y = points[j]\n        for i in range(m):\n            if i % 4 == 0:\n                if x > 0:\n                    w[j] += 'R'\n                    x -= d[i]\n                elif x < 0:\n                    w[j] += 'L'\n                    x += d[i]\n            elif i % 4 == 1:\n                if y > 0:\n                    w[j] += 'U'\n                    y -= d[i]\n                elif y < 0:\n                    w[j] += 'D'\n                    y += d[i]\n            elif i % 4 == 2:\n                if x > 0:\n                    w[j] += 'L'\n                    x += d[i]\n                elif x < 0:\n                    w[j] += 'R'\n                    x -= d[i]\n            elif i % 4 == 3:\n                if y > 0:\n                    w[j] += 'D'\n                    y += d[i]\n                elif y < 0:\n                    w[j] += 'U'\n                    y -= d[i]\n\n    return m, d, w\n\nN = int(input())\npoints = [list(map(int, input().split())) for _ in range(N)]\nm, d, w = solve(N, points)\nprint(m)\nprint(' '.join(map(str, d)))\nfor j in range(N):\n    print(w[j])"}
{"solution": "n = int(input())\ns = input()\n\n# Replace all filler words with '***'\nwhile 'ogo' in s:\n    s = s.replace('ogo', '***')\n\n# Replace all remaining 'go' with empty string\nwhile 'go' in s:\n    s = s.replace('go', '')\n\nprint(s)"}
{"solution": "import math\n\nMOD = 10**9 + 7\n\ndef prime_factors(n):\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef g(x, p):\n    k = 0\n    while x % p**k == 0:\n        k += 1\n    return p**(k-1)\n\ndef f(x, y):\n    factors = prime_factors(x)\n    product = 1\n    for p in factors:\n        product = (product * g(y, p)) % MOD\n    return product\n\ndef solve(x, n):\n    result = 1\n    for i in range(1, n+1):\n        result = (result * f(x, i)) % MOD\n    return result\n\nx, n = map(int, input().split())\nprint(solve(x, n))"}
{"solution": "def sum_of_digits(n):\n    return sum(int(digit) for digit in str(n))\n\na, b, c = map(int, input().split())\nsolutions = []\n\nfor x in range(1, 10**9):\n    if x == b * (sum_of_digits(x) ** a) + c:\n        solutions.append(x)\n\nprint(len(solutions))\nprint(*solutions)"}
{"solution": "def check_solvable(cube):\n    # Define the possible rotations\n    rotations = [\n        [0, 1, 2, 3, 45, 46, 47, 44, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23],\n        [0, 1, 5, 6, 2, 3, 7, 4, 8, 9, 13, 14, 10, 11, 15, 12, 16, 17, 21, 22, 18, 19, 23, 20],\n        [0, 4, 7, 3, 1, 5, 6, 2, 8, 17, 18, 19, 9, 10, 11, 12, 13, 14, 15, 16, 20, 23, 21, 22],\n        [2, 6, 7, 3, 1, 0, 4, 5, 18, 19, 20, 11, 9, 13, 14, 10, 8, 12, 15, 16, 17, 21, 22, 23],\n        [12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7, 19, 20, 21, 22, 8, 9, 10, 11, 23, 16, 17, 18],\n        [16, 17, 18, 19, 8, 9, 10, 11, 12, 13, 14, 15, 2, 3, 0, 1, 5, 6, 22, 23, 20, 21, 4, 5]\n    ]\n\n    # Check each rotation\n    for rotation in rotations:\n        if all(cube[i] == cube[rotation[i]] for i in range(24)):\n            return True\n\n    return False\n\n# Read the input\ncube = list(map(int, input().split()))\n\n# Check if the cube is solvable\nif check_solvable(cube):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def solve(p, x, y):\n    s = y\n    i = (s // 50) % 475\n    tshirt_winners = set()\n    for _ in range(25):\n        i = (i * 96 + 42) % 475\n        tshirt_winners.add(26 + i)\n\n    while s < x or p not in tshirt_winners:\n        s += 100\n        i = (s // 50) % 475\n        tshirt_winners = set()\n        for _ in range(25):\n            i = (i * 96 + 42) % 475\n            tshirt_winners.add(26 + i)\n\n    return (s - y) // 100\n\np, x, y = map(int, input().split())\nprint(solve(p, x, y))"}
{"solution": "# Get the input\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# If Winnie-the-Pooh has to have a meal only once, he doesn't need to move\nif n == 1:\n    print(0)\nelse:\n    # Initialize the minimum distance to a large number\n    min_distance = float('inf')\n\n    # Calculate the distance for the case when Winnie-the-Pooh visits Rabbit's house, then Owl's house, and then Eeyore's house\n    distance1 = a + (n - 2) * min(b, c)\n    min_distance = min(min_distance, distance1)\n\n    # Calculate the distance for the case when Winnie-the-Pooh visits Owl's house, then Rabbit's house, and then Eeyore's house\n    distance2 = b + (n - 2) * min(a, c)\n    min_distance = min(min_distance, distance2)\n\n    # Calculate the distance for the case when Winnie-the-Pooh visits Eeyore's house, then Rabbit's house, and then Owl's house\n    distance3 = c + (n - 2) * min(a, b)\n    min_distance = min(min_distance, distance3)\n\n    # Print the minimum distance\n    print(min_distance)"}
{"solution": "# Get the input\nx1, x2, x3 = map(int, input().split())\n\n# Sort the coordinates\ncoordinates = sorted([x1, x2, x3])\n\n# Calculate the minimum total distance\nmin_distance = coordinates[1] - coordinates[0] + coordinates[2] - coordinates[1]\n\n# Print the result\nprint(min_distance)"}
{"solution": "from collections import Counter\n\ndef solve(n, x, arr):\n    # Create a counter to store the frequency of each element in the array\n    counter = Counter(arr)\n\n    # If there are already two equal elements, return 0\n    if any(freq >= 2 for freq in counter.values()):\n        return 0\n\n    # Create a new array where each element is the result of bitwise AND with x\n    new_arr = [num & x for num in arr]\n\n    # Create a new counter for the new array\n    new_counter = Counter(new_arr)\n\n    # If there are two equal elements in the new array, return 1\n    if any(freq >= 2 for freq in new_counter.values()):\n        return 1\n\n    # If it's not possible to make two elements equal, return -1\n    return -1\n\n# Read the input\nn, x = map(int, input().split())\narr = list(map(int, input().split()))\n\n# Print the result\nprint(solve(n, x, arr))"}
{"solution": "def is_plus_shape(grid):\n    h = len(grid)\n    w = len(grid[0])\n    center = None\n\n    # Find the center\n    for i in range(1, h - 1):\n        for j in range(1, w - 1):\n            if grid[i][j] == '*' and grid[i-1][j] == '*' and grid[i+1][j] == '*' and grid[i][j-1] == '*' and grid[i][j+1] == '*':\n                center = (i, j)\n                break\n        if center:\n            break\n\n    if not center:\n        return False\n\n    # Check the shape\n    i, j = center\n    while i > 0 and grid[i-1][j] == '*':\n        i -= 1\n    if i != 0:\n        return False\n\n    i, j = center\n    while i < h - 1 and grid[i+1][j] == '*':\n        i += 1\n    if i != h - 1:\n        return False\n\n    i, j = center\n    while j > 0 and grid[i][j-1] == '*':\n        j -= 1\n    if j != 0:\n        return False\n\n    i, j = center\n    while j < w - 1 and grid[i][j+1] == '*':\n        j += 1\n    if j != w - 1:\n        return False\n\n    # Check if there are any other '*'\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == '*' and (i, j) != center and (i != center[0] or j != center[1]):\n                return False\n\n    return True\n\nh, w = map(int, input().split())\ngrid = [input() for _ in range(h)]\nprint('YES' if is_plus_shape(grid) else 'NO')"}
{"solution": "def solve(n, a, b):\n    if a + b > n + 1 or a * b > (n * (n - 1)) // 2:\n        return \"NO\"\n\n    graph = [[0] * n for _ in range(n)]\n\n    # Create a graph with 'a' components\n    for i in range(1, a):\n        graph[i][i - 1] = graph[i - 1][i] = 1\n\n    # Create a graph with 'b' components in its complement\n    # by adding edges between vertices that are not already connected\n    edge_count = 0\n    for i in range(a, n):\n        for j in range(i + 1, n):\n            if edge_count < (n * (n - 1)) // 2 - (a * (a - 1)) // 2 - (b - 1) * (n - b):\n                graph[i][j] = graph[j][i] = 1\n                edge_count += 1\n\n    return \"YES\\n\" + \"\\n\".join(\"\".join(map(str, row)) for row in graph)\n\nn, a, b = map(int, input().split())\nprint(solve(n, a, b))"}
{"solution": "# Get input\nc, d = map(int, input().split())\nn, m = map(int, input().split())\nk = int(input())\n\n# Calculate the number of people who need to go to the finals from main rounds\nmain_rounds_needed = max(0, n * m - k)\npeople_needed_from_main = main_rounds_needed // n\nif main_rounds_needed % n != 0:\n    people_needed_from_main += 1\n\n# Calculate the number of problems needed from main rounds\nproblems_needed_from_main = people_needed_from_main * c\n\n# Calculate the number of additional rounds needed\nadditional_rounds_needed = max(0, main_rounds_needed - people_needed_from_main * n)\n\n# Calculate the number of problems needed from additional rounds\nproblems_needed_from_additional = additional_rounds_needed * d\n\n# Calculate the total number of problems needed\ntotal_problems_needed = problems_needed_from_main + problems_needed_from_additional\n\n# Print the result\nprint(total_problems_needed)"}
{"solution": "def find_path(s):\n    grid = [[' ']*13 for _ in range(2)]\n    letters = list(s)\n    last_index = {letter: i for i, letter in enumerate(letters)}\n\n    def is_adjacent(a, b):\n        return abs(a[0] - b[0]) <= 1 and abs(a[1] - b[1]) <= 1\n\n    def dfs(i, j, k):\n        if k == 27:\n            return True\n        grid[i][j] = letters[k]\n        for di in [-1, 0, 1]:\n            for dj in [-1, 0, 1]:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < 2 and 0 <= nj < 13 and grid[ni][nj] == ' ':\n                    next_letter = letters[k + 1]\n                    if (ni, nj) == (last_index[next_letter] // 13, last_index[next_letter] % 13) or all(is_adjacent((ni, nj), (last_index[c] // 13, last_index[c] % 13)) for c in letters[k + 2:]):\n                        if dfs(ni, nj, k + 1):\n                            return True\n        grid[i][j] = ' '\n        return False\n\n    for i in range(2):\n        for j in range(13):\n            if dfs(i, j, 0):\n                return grid\n    return \"Impossible\"\n\ns = input()\nresult = find_path(s)\nif result == \"Impossible\":\n    print(result)\nelse:\n    for row in result:\n        print(''.join(row))"}
{"solution": "import math\n\n# Get input\nx, y = map(int, input().split())\n\n# Calculate logarithms\nlog_x_y = y * math.log(x)\nlog_y_x = x * math.log(y)\n\n# Compare and print result\nif log_x_y < log_y_x:\n    print('<')\nelif log_x_y > log_y_x:\n    print('>')\nelse:\n    print('=')"}
{"solution": "import math\n\n# Get the input\nr, h = map(int, input().split())\n\n# Calculate the height of the semicircle\nsemicircle_height = math.sqrt(r**2 - (r/2)**2)\n\n# Calculate the number of balloons that can fit in the semicircle part\nsemicircle_balloons = math.floor(semicircle_height / r)\n\n# Calculate the number of balloons that can fit in the rectangular part\nrectangle_balloons = math.floor((h + semicircle_height) / r)\n\n# Calculate the total number of balloons\ntotal_balloons = semicircle_balloons + rectangle_balloons\n\n# Print the result\nprint(total_balloons)"}
{"solution": "from collections import Counter\n\n# Get the input\nnumbers = list(map(int, input().split()))\n\n# Count the occurrences of each number\ncounter = Counter(numbers)\n\n# Calculate the total sum\ntotal_sum = sum(numbers)\n\n# Find the minimum possible sum of numbers written on remaining cards\nmin_sum = total_sum\nfor num, count in counter.items():\n    if count >= 2:\n        min_sum = min(min_sum, total_sum - 2 * num)\n    if count >= 3:\n        min_sum = min(min_sum, total_sum - 3 * num)\n\n# Print the result\nprint(min_sum)"}
{"solution": "# Read input\nn, a = map(int, input().split())\ncheckpoints = list(map(int, input().split()))\n\n# Sort checkpoints\ncheckpoints.sort()\n\n# Find the closest checkpoint to Vasya's starting position\nclosest_checkpoint = min(checkpoints, key=lambda x: abs(x - a))\n\n# Calculate the minimum distance Vasya has to travel\nmin_distance = abs(closest_checkpoint - a)\n\n# Remove the closest checkpoint from the list\ncheckpoints.remove(closest_checkpoint)\n\n# Calculate the distance between consecutive checkpoints\ndistances = [abs(checkpoints[i] - checkpoints[i - 1]) for i in range(1, len(checkpoints))]\n\n# Add the minimum distance between consecutive checkpoints to the total distance\nmin_distance += sum(distances)\n\n# Print the result\nprint(min_distance)"}
{"solution": "def sum_of_digits(n):\n    return sum(int(digit) for digit in str(n))\n\ndef find_root(n):\n    x = 1\n    while True:\n        if x * x + sum_of_digits(x) * x - n == 0:\n            return x\n        elif x * x + sum_of_digits(x) * x > n:\n            return -1\n        x += 1\n\nn = int(input())\nprint(find_root(n))"}
{"solution": "from datetime import datetime, timedelta\n\n# Get the current time and sleep duration from user\ncurrent_time = input()\nsleep_duration = input()\n\n# Convert the time strings to datetime objects\ncurrent_time = datetime.strptime(current_time, \"%H:%M\")\nsleep_duration = datetime.strptime(sleep_duration, \"%H:%M\")\n\n# Calculate the time George went to bed\nbed_time = current_time - timedelta(hours=sleep_duration.hour, minutes=sleep_duration.minute)\n\n# Print the time George went to bed in the format \"hh:mm\"\nprint(bed_time.strftime(\"%H:%M\"))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nmax_mean = float('-inf')\nmax_len = 0\ncurr_sum = 0\ncurr_len = 0\n\nfor i in range(n):\n    curr_sum += a[i]\n    curr_len += 1\n    curr_mean = curr_sum / curr_len\n    if curr_mean > max_mean:\n        max_mean = curr_mean\n        max_len = curr_len\n    elif curr_mean == max_mean:\n        max_len = max(max_len, curr_len)\n    if curr_sum < 0:\n        curr_sum = 0\n        curr_len = 0\n\nprint(max_len)"}
{"solution": "MOD = 998244353\n\ndef main():\n    n, m, k = map(int, input().split())\n\n    # dp[i][j] is the number of ways to paint i bricks with j color changes\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[1][0] = m\n\n    for i in range(2, n + 1):\n        for j in range(min(i, k + 1)):\n            # If the color of the current brick is the same as the previous one\n            dp[i][j] = dp[i - 1][j] * (m - 1) % MOD\n            # If the color of the current brick is different from the previous one\n            if j > 0:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1] * m) % MOD\n\n    # The answer is the sum of dp[n][j] for all j from 0 to k\n    answer = sum(dp[n]) % MOD\n    print(answer)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_magic_number(n):\n    while n > 0:\n        if n % 100 == 14:\n            n //= 100\n        elif n % 10 == 1:\n            n //= 10\n        elif n == 144:\n            return True\n        else:\n            return False\n    return True\n\nn = int(input())\nif is_magic_number(n):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def min_moves(n, m, i, j, a, b):\n    moves = float('inf')\n\n    # Check if the candy can reach the corner (1, m)\n    if (j - b) % a == 0 and (i - 1) % a == 0:\n        moves = min(moves, (j - b) // a + (i - 1) // a)\n\n    # Check if the candy can reach the corner (n, 1)\n    if (i - a) % b == 0 and (j - 1) % b == 0:\n        moves = min(moves, (i - a) // b + (j - 1) // b)\n\n    # Check if the candy can reach the corner (n, m)\n    if (i - a) % b == 0 and (j - b) % a == 0:\n        moves = min(moves, (i - a) // b + (j - b) // a)\n\n    # Check if the candy can reach the corner (1, 1)\n    if (i - 1) % a == 0 and (j - 1) % b == 0:\n        moves = min(moves, (i - 1) // a + (j - 1) // b)\n\n    if moves == float('inf'):\n        return \"Poor Inna and pony!\"\n    else:\n        return moves\n\nn, m, i, j, a, b = map(int, input().split())\nprint(min_moves(n, m, i, j, a, b))"}
{"solution": "n = int(input())\ns = input()\n\n# Convert string to list of ASCII values\ns = [ord(c) - ord('a') for c in s]\n\n# Initialize dynamic programming array\ndp = [0] * n\n\n# Iterate over string\nfor i in range(1, n):\n    # Initialize maximum value for current position\n    dp[i] = dp[i - 1]\n\n    # Check if current character has a previous character\n    if s[i] > 0:\n        # Iterate over previous positions\n        for j in range(i - 1, -1, -1):\n            # Check if previous character is one less than current character\n            if s[j] == s[i] - 1:\n                # Update maximum value for current position\n                dp[i] = max(dp[i], dp[j] + 1)\n                break\n\n# Print maximum possible number of characters that can be removed\nprint(n - dp[-1])"}
{"solution": "def min_bills(denominations, target, k):\n    dp = [float('inf')] * (target + 1)\n    dp[0] = 0\n    for coin in denominations:\n        for x in range(coin, target + 1):\n            dp[x] = min(dp[x], dp[x - coin] + 1)\n    for x in range(1, target + 1):\n        if dp[x] > k:\n            dp[x] = float('inf')\n    return dp\n\nn, k = map(int, input().split())\ndenominations = list(map(int, input().split()))\nq = int(input())\nqueries = [int(input()) for _ in range(q)]\n\ndp = min_bills(denominations, max(queries), k)\nfor query in queries:\n    print(-1 if dp[query] == float('inf') else dp[query])"}
{"solution": "def min_time(s, x1, x2, t1, t2, p, d):\n    # Calculate the time it takes for Igor to walk to the tram\n    walk_time = abs(x1 - p) / t2\n\n    # Calculate the time it takes for the tram to reach Igor's destination\n    if d == 1:\n        tram_time = (x2 - p) / t1 if x2 > p else (s - p + s - x2) / t1\n    else:\n        tram_time = (p - x2) / t1 if p > x2 else (p + x2) / t1\n\n    # Return the minimum time\n    return min(walk_time, tram_time)\n\n# Get the input\ns, x1, x2 = map(int, input().split())\nt1, t2 = map(int, input().split())\np, d = map(int, input().split())\n\n# Print the minimum time\nprint(min_time(s, x1, x2, t1, t2, p, d))"}
{"solution": "# Get the input\nn, x = map(int, input().split())\n\n# Initialize the count\ncount = 0\n\n# Iterate over the rows\nfor i in range(1, n + 1):\n    # If x is divisible by i, then check if x/i is within the range\n    if x % i == 0 and x // i <= n:\n        # Increment the count\n        count += 1\n\n# Print the count\nprint(count)"}
{"solution": "n, k = map(int, input().split())\npassword = ''\n\n# Add first k letters to the password\nfor i in range(k):\n    password += chr(ord('a') + i)\n\n# Add remaining letters to the password, making sure no two consecutive letters are the same\nfor i in range(n - k):\n    if password[i] != password[i + k - 1]:\n        password += password[i]\n    else:\n        password += chr(ord('a') + (ord(password[i]) - ord('a') + 1) % k)\n\nprint(password)"}
{"solution": "# Read the input\nn = int(input())\ndirections = input()\npositions = list(map(int, input().split()))\n\n# Initialize the minimum time to infinity\nmin_time = float('inf')\n\n# Iterate over the particles\nfor i in range(n - 1):\n    # If the particles are moving towards each other\n    if directions[i] == 'R' and directions[i + 1] == 'L':\n        # Calculate the time to collision\n        time = (positions[i + 1] - positions[i]) // 2\n        # Update the minimum time\n        min_time = min(min_time, time)\n\n# Print the result\nif min_time == float('inf'):\n    print(-1)\nelse:\n    print(min_time)"}
{"solution": "def solve():\n    n, a, b = map(int, input().split())\n    seals = [list(map(int, input().split())) for _ in range(n)]\n    seals = [(x, y) if x <= a and y <= b else (y, x) for x, y in seals]\n    seals.sort(key=lambda x: x[0] * x[1], reverse=True)\n\n    max_area = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = seals[i]\n            x2, y2 = seals[j]\n\n            if x1 + x2 <= a and max(y1, y2) <= b:\n                max_area = max(max_area, x1 * y1 + x2 * y2)\n\n            if max(x1, x2) <= a and y1 + y2 <= b:\n                max_area = max(max_area, x1 * y1 + x2 * y2)\n\n    print(max_area)\n\nsolve()"}
{"solution": "# Get the number of points on each side of the square\nn = int(input())\n\n# Initialize lists to store the x and y coordinates\nx_coords = []\ny_coords = []\n\n# Read in the coordinates and store them in the lists\nfor _ in range(4*n + 1):\n    x, y = map(int, input().split())\n    x_coords.append(x)\n    y_coords.append(y)\n\n# Find the unique x and y coordinates\nunique_x = list(set(x_coords))\nunique_y = list(set(y_coords))\n\n# Sort the unique x and y coordinates\nunique_x.sort()\nunique_y.sort()\n\n# The point not on the boundary of the square will be the one that is not in the range of the unique x and y coordinates\nfor x in x_coords:\n    for y in y_coords:\n        if x not in unique_x[1:-1] and y not in unique_y[1:-1]:\n            print(x, y)\n            break\n    else:\n        continue\n    break"}
{"solution": "def max_product(n):\n    if n < 10:\n        return n\n\n    product = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    for i in range(10, n + 1):\n        num = i\n        prod = 1\n        while num > 0:\n            digit = num % 10\n            prod *= digit\n            num //= 10\n        product.append(prod)\n\n    return max(product)\n\nn = int(input())\nprint(max_product(n))"}
{"solution": "# Get the number of students\nn = int(input())\n\n# Get the list of votes for Elodreip\nvotes = list(map(int, input().split()))\n\n# Find the maximum number of votes Elodreip gets from a student\nmax_votes = max(votes)\n\n# Calculate the total number of votes Elodreip gets\nelodreip_votes = sum(votes)\n\n# Calculate the total number of votes Awruk needs to win\nawruk_votes = elodreip_votes + n\n\n# Calculate the minimum number of votes each student needs to have\nk = max(max_votes, (awruk_votes + n - 1) // n)\n\n# Print the result\nprint(k)"}
{"solution": "def solve(s):\n    stack = []\n    operations = 0\n    for c in s:\n        if stack and stack[-1] != c:\n            while stack and stack[-1] != c:\n                stack.pop()\n            stack.pop()\n            operations += 1\n        stack.append(c)\n    return operations\n\ns = input()\nprint(solve(s))"}
{"solution": "# Read the input\nn = int(input())\na = list(map(int, input().split()))\n\n# Sort the array\na.sort()\n\n# Initialize the minimum product and count of triples\nmin_product = a[0] * a[1] * a[2]\ncount = 0\n\n# Iterate over all possible triples\nfor i in range(n - 2):\n    for j in range(i + 1, n - 1):\n        for k in range(j + 1, n):\n            # If the product of the triple is equal to the minimum product, increment the count\n            if a[i] * a[j] * a[k] == min_product:\n                count += 1\n            # If the product of the triple is greater than the minimum product, break the loop\n            elif a[i] * a[j] * a[k] > min_product:\n                break\n\n# Print the count of triples\nprint(count)"}
{"solution": "def min_cuts(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 2\n    else:\n        cuts = 0\n        while n > 1:\n            if n % 2 == 0:\n                cuts += n // 2\n                n //= 2\n            else:\n                cuts += n\n                n -= 1\n        return cuts + 1\n\nn = int(input())\nprint(min_cuts(n))"}
{"solution": "# Get the input\nn = int(input())\n\n# If the number is positive, no need to change it\nif n >= 0:\n    print(n)\nelse:\n    # Convert the number to a string to easily manipulate its digits\n    n = str(n)\n\n    # If the last digit is less than the digit before last, remove the last digit\n    if n[-1] < n[-2]:\n        print(int(n[:-1]))\n    # Otherwise, remove the digit before last\n    else:\n        print(int(n[:-2] + n[-1]))"}
{"solution": "# Define the spinner positions and their rotations\nspinner_positions = {'v': 0, '>': 1, '^': 2, '<': 3}\nrotations = {0: 'v', 1: '>', 2: '^', 3: '<'}\n\n# Get the input\nstart, end = input().split()\nn = int(input())\n\n# Calculate the ending position for clockwise and counter-clockwise rotations\ncw_end = rotations[(spinner_positions[start] + n) % 4]\nccw_end = rotations[(spinner_positions[start] - n) % 4]\n\n# Compare the ending position with the given end position\nif end == cw_end:\n    print('cw')\nelif end == ccw_end:\n    print('ccw')\nelse:\n    print('undefined')"}
{"solution": "n = int(input())\ns = input()\n\n# Initialize an array to store the state of each domino\ndominoes = list(s)\n\n# Simulate the process\nfor _ in range(n):\n    for i in range(n):\n        # If the domino is pushed to the left and the one to its right is not pushed to the right\n        if dominoes[i] == 'L' and (i == n - 1 or dominoes[i + 1] != 'R'):\n            # Make the domino to its right fall to the left\n            if i < n - 1:\n                dominoes[i + 1] = 'L'\n        # If the domino is pushed to the right and the one to its left is not pushed to the left\n        elif dominoes[i] == 'R' and (i == 0 or dominoes[i - 1] != 'L'):\n            # Make the domino to its left fall to the right\n            if i > 0:\n                dominoes[i - 1] = 'R'\n\n# Count the number of dominoes that remain vertical\ncount = dominoes.count('.')\nprint(count)"}
{"solution": "n, m = map(int, input().split())\nleaders = list(map(int, input().split()))\n\n# Initialize the permutation with all 0s\nperm = [0] * n\n\n# Iterate over the leaders\nfor i in range(m):\n    # If the current leader's position is already filled, check if it matches the current leader\n    if perm[leaders[i] - 1] != 0 and perm[leaders[i] - 1] != (leaders[i + 1] - leaders[i]) % n:\n        print(-1)\n        exit()\n    # Otherwise, fill the current leader's position\n    else:\n        perm[leaders[i] - 1] = (leaders[i + 1] - leaders[i]) % n\n\n# If there are still unfilled positions, fill them with the smallest possible value that doesn't cause a contradiction\nfor i in range(n):\n    if perm[i] == 0:\n        for j in range(1, n):\n            if j not in perm:\n                perm[i] = j\n                break\n\n# Print the permutation\nprint(*perm)"}
{"solution": "def max_number(a, k):\n    a = list(str(a))\n    n = len(a)\n    for i in range(n):\n        if k <= 0:\n            break\n        max_idx = i\n        for j in range(i+1, min(n, i+k+1)):\n            if a[j] > a[max_idx]:\n                max_idx = j\n        k -= max_idx - i\n        a[i:max_idx+1] = [a[max_idx]] + a[i:max_idx]\n    return int(''.join(a))\n\na, k = map(int, input().split())\nprint(max_number(a, k))"}
{"solution": "def find_next_number(seq):\n    if seq[1] - seq[0] == seq[2] - seq[1] == seq[3] - seq[2]:\n        return seq[-1] + seq[1] - seq[0]\n    elif seq[1] / seq[0] == seq[2] / seq[1] == seq[3] / seq[2]:\n        return seq[-1] * seq[1] / seq[0]\n    else:\n        return 42\n\nseq = list(map(int, input().split()))\nprint(find_next_number(seq))"}
{"solution": "# Read the input\nn = int(input())\ncolors = list(map(int, input().split()))\n\n# Initialize the maximum distance and the last occurrence of each color\nmax_distance = 0\nlast_occurrence = [-1] * (n + 1)\n\n# Iterate over the houses\nfor i in range(n):\n    # If the color of the current house has been seen before\n    if last_occurrence[colors[i]] != -1:\n        # Update the maximum distance\n        max_distance = max(max_distance, i - last_occurrence[colors[i]])\n    # Update the last occurrence of the current color\n    last_occurrence[colors[i]] = i\n\n# Print the maximum distance\nprint(max_distance)"}
{"solution": "# Read the input\nn, m, k = map(int, input().split())\n\n# Calculate the lane\nlane = (k - 1) // (2 * m) + 1\n\n# Calculate the desk\ndesk = ((k - 1) % (2 * m)) // 2 + 1\n\n# Calculate the side\nside = 'L' if k % 2 == 1 else 'R'\n\n# Print the output\nprint(lane, desk, side)"}
{"solution": "# Read the input\nn = int(input())\ns = input()\n\n# Count the number of red, green, and blue cards\nr = s.count('R')\ng = s.count('G')\nb = s.count('B')\n\n# If there are cards of all three colors, the final card can be any color\nif r > 0 and g > 0 and b > 0:\n    print('BGR')\n# If there are cards of two colors, the final card can be the third color\nelif r > 0 and g > 0:\n    print('R')\nelif r > 0 and b > 0:\n    print('G')\nelif g > 0 and b > 0:\n    print('R')\n# If there is only one color, the final card will be of that color\nelse:\n    print(s[0])"}
