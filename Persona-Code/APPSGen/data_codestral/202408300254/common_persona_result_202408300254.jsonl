{"solution": "def find_longest_accordion(s):\n    # Initialize variables\n    open_bracket = '['\n    close_bracket = ']'\n    colon = ':'\n    vertical_line = '|'\n    max_length = -1\n    current_length = 0\n    open_bracket_count = 0\n    close_bracket_count = 0\n    colon_count = 0\n    vertical_line_count = 0\n\n    # Iterate through the string\n    for char in s:\n        if char == open_bracket:\n            open_bracket_count += 1\n        elif char == close_bracket:\n            close_bracket_count += 1\n        elif char == colon:\n            colon_count += 1\n        elif char == vertical_line:\n            vertical_line_count += 1\n\n        # Check if a valid accordion can be formed\n        if open_bracket_count >= 1 and colon_count >= 2 and close_bracket_count >= 1:\n            current_length = open_bracket_count + colon_count + vertical_line_count + close_bracket_count\n            max_length = max(max_length, current_length)\n\n        # If an invalid character is encountered, reset the counts\n        if char not in [open_bracket, close_bracket, colon, vertical_line]:\n            open_bracket_count = 0\n            close_bracket_count = 0\n            colon_count = 0\n            vertical_line_count = 0\n\n    return max_length\n\n# Read the input string\ns = input()\n\n# Print the maximum possible length of the resulting accordion\nprint(find_longest_accordion(s))"}
{"solution": "def max_sum_digits(x):\n    # Convert the number to string for easy manipulation\n    num_str = str(x)\n\n    # Initialize the result as the input number\n    result = x\n\n    # Start from the most significant digit\n    for i in range(len(num_str)):\n        # If the current digit is not 9, we can replace it with 9\n        # and decrease the remaining digits to maximize the sum\n        if num_str[i] != '9':\n            # Replace the current digit with 9\n            new_num_str = num_str[:i] + '9'\n            # Decrease the remaining digits\n            new_num_str += '8' * (len(num_str) - i - 1)\n            # Convert the new number back to integer\n            new_num = int(new_num_str)\n            # If the new number is less than or equal to the input number,\n            # update the result\n            if new_num <= x:\n                result = new_num\n            # Break the loop since we have found the maximum possible number\n            break\n\n    return result\n\n# Read the input number\nx = int(input())\n\n# Print the result\nprint(max_sum_digits(x))"}
{"solution": "def find_next_lucky_year(n):\n    while True:\n        n += 1\n        if str(n).count('0') >= len(str(n)) - 1:\n            return n - int(input_year)\n\ninput_year = int(input())\nprint(find_next_lucky_year(input_year))"}
{"solution": "# Read input\nn, q = map(int, input().split())\nintervals = []\nfor _ in range(q):\n    l, r = map(int, input().split())\n    intervals.append((l, r))\n\n# Sort intervals based on starting points\nintervals.sort()\n\n# Initialize variables\nmax_right = intervals[0][1]\nmax_painted = 0\n\n# Iterate through intervals\nfor i in range(q - 2):\n    # Calculate number of sections painted by current painter and painter with max right endpoint\n    painted = intervals[i][1] - intervals[i][0] + 1\n    if intervals[i][1] < max_right:\n        painted += max_right - intervals[i][1]\n    # Update maximum right endpoint\n    max_right = max(max_right, intervals[i + 1][1])\n    # Update maximum number of painted sections\n    max_painted = max(max_painted, painted)\n\n# Print output\nprint(min(n, max_painted))"}
{"solution": "def contains_seven(time):\n    return '7' in str(time)\n\ndef find_lucky_time(x, hh, mm):\n    for y in range(0, 10000):\n        new_mm = (mm - y * x) % 60\n        new_hh = (hh - (mm - new_mm) // 60) % 24\n        if contains_seven(new_hh) or contains_seven(new_mm):\n            return y\n\nx = int(input())\nhh, mm = map(int, input().split())\nprint(find_lucky_time(x, hh, mm))"}
{"solution": "def min_seconds_to_close_tabs(n, pos, l, r):\n    if l == 1 and r == n:\n        return 0\n    elif l == 1:\n        return abs(pos - r) + 1\n    elif r == n:\n        return abs(pos - l) + 1\n    else:\n        return min(abs(pos - l), abs(pos - r)) + (r - l) + 2\n\nn, pos, l, r = map(int, input().split())\nprint(min_seconds_to_close_tabs(n, pos, l, r))"}
{"solution": "def min_blows(n, x, blows):\n    blows.sort(key=lambda x: x[0]-x[1])\n    count = 0\n    while x > 0:\n        for d, h in blows:\n            if d >= x:\n                x = 0\n                count += 1\n                break\n            elif d < h:\n                x = (x - d + h - 1) // h * h + d\n                count += 1\n                break\n        else:\n            return -1\n    return count\n\nt = int(input())\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [list(map(int, input().split())) for _ in range(n)]\n    print(min_blows(n, x, blows))"}
{"solution": "def barn_empty_day(n, m):\n    grains = n\n    sparrows = 0\n    day = 0\n\n    while grains > 0:\n        day += 1\n        sparrows += day\n        grains = min(n, grains + m)\n        grains = max(0, grains - sparrows)\n\n    return day\n\nn, m = map(int, input().split())\nprint(barn_empty_day(n, m))"}
{"solution": "def min_draws_to_win(tiles):\n    # Parse the input tiles\n    tile1, tile2, tile3 = tiles.split()\n\n    # Extract numbers and suits\n    num1, suit1 = int(tile1[0]), tile1[1]\n    num2, suit2 = int(tile2[0]), tile2[1]\n    num3, suit3 = int(tile3[0]), tile3[1]\n\n    # Check for koutsu (triplet)\n    if tile1 == tile2 == tile3:\n        return 0\n\n    # Check for shuntsu (sequence)\n    def is_shuntsu(n1, n2, n3):\n        return sorted([n1, n2, n3]) in [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7], [6, 7, 8], [7, 8, 9]]\n\n    if suit1 == suit2 == suit3 and is_shuntsu(num1, num2, num3):\n        return 0\n\n    # Check for possible koutsu with one more draw\n    if tile1 == tile2 or tile1 == tile3 or tile2 == tile3:\n        return 1\n\n    # Check for possible shuntsu with one more draw\n    def needs_one_for_shuntsu(n1, n2):\n        return abs(n1 - n2) == 1 or abs(n1 - n2) == 2\n\n    if suit1 == suit2 and needs_one_for_shuntsu(num1, num2):\n        return 1\n    if suit1 == suit3 and needs_one_for_shuntsu(num1, num3):\n        return 1\n    if suit2 == suit3 and needs_one_for_shuntsu(num2, num3):\n        return 1\n\n    # If no koutsu or shuntsu can be formed with one more draw, return 2\n    return 2\n\n# Read input\ntiles = input()\n\n# Print output\nprint(min_draws_to_win(tiles))"}
{"solution": "def find_grandpa_maks_sofa():\n    # Read the input\n    d = int(input())\n    n, m = map(int, input().split())\n    sofas = []\n    for _ in range(d):\n        x1, y1, x2, y2 = map(int, input().split())\n        sofas.append(((x1, y1), (x2, y2)))\n    cnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\n    # Initialize variables\n    left_count = [0] * d\n    right_count = [0] * d\n    top_count = [0] * d\n    bottom_count = [0] * d\n\n    # Determine spatial relationships\n    for i in range(d):\n        for j in range(i+1, d):\n            sofa_i = sofas[i]\n            sofa_j = sofas[j]\n\n            # Check if sofa_i is to the left of sofa_j\n            if sofa_i[0][0] < sofa_j[0][0] and sofa_i[1][0] < sofa_j[1][0]:\n                left_count[i] += 1\n                right_count[j] += 1\n            # Check if sofa_i is to the right of sofa_j\n            elif sofa_i[0][0] > sofa_j[0][0] and sofa_i[1][0] > sofa_j[1][0]:\n                left_count[j] += 1\n                right_count[i] += 1\n            # Check if sofa_i is to the top of sofa_j\n            elif sofa_i[0][1] < sofa_j[0][1] and sofa_i[1][1] < sofa_j[1][1]:\n                top_count[i] += 1\n                bottom_count[j] += 1\n            # Check if sofa_i is to the bottom of sofa_j\n            elif sofa_i[0][1] > sofa_j[0][1] and sofa_i[1][1] > sofa_j[1][1]:\n                top_count[j] += 1\n                bottom_count[i] += 1\n\n    # Find Grandpa Maks's sofa\n    for i in range(d):\n        if left_count[i] == cnt_l and right_count[i] == cnt_r and top_count[i] == cnt_t and bottom_count[i] == cnt_b:\n            return i + 1\n\n    return -1\n\n# Call the function to find Grandpa Maks's sofa\nresult = find_grandpa_maks_sofa()\nprint(result)"}
{"solution": "def mars_days_off(n):\n    full_weeks = n // 7\n    remaining_days = n % 7\n\n    min_days_off = full_weeks * 2\n    max_days_off = full_weeks * 2 + min(remaining_days, 2)\n\n    return min_days_off, max_days_off\n\nn = int(input())\nmin_days_off, max_days_off = mars_days_off(n)\nprint(min_days_off, max_days_off)"}
{"solution": "def gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_tiles(n, a, b):\n    red_tiles = n // a\n    blue_tiles = n // b\n    both_tiles = n // lcm(a, b)\n    return red_tiles, blue_tiles, both_tiles\n\ndef max_chocolates(n, a, b, p, q):\n    red_tiles, blue_tiles, both_tiles = count_tiles(n, a, b)\n    if p > q:\n        max_chocolates = red_tiles * p + (blue_tiles - both_tiles) * q + max(p, q) * both_tiles\n    else:\n        max_chocolates = (red_tiles - both_tiles) * p + blue_tiles * q + max(p, q) * both_tiles\n    return max_chocolates\n\nn, a, b, p, q = map(int, input().split())\nprint(max_chocolates(n, a, b, p, q))"}
{"solution": "def max_golden_subsegment(n, trophies):\n    # Convert the string to a list for easier manipulation\n    trophies = list(trophies)\n\n    # Initialize the maximum possible length of a subsegment of golden trophies\n    max_length = 0\n\n    # Iterate through all possible pairs of trophies to swap\n    for i in range(n):\n        for j in range(i+1, n):\n            # Swap the trophies\n            trophies[i], trophies[j] = trophies[j], trophies[i]\n\n            # Calculate the length of the longest subsegment of golden trophies\n            current_length = 0\n            max_current_length = 0\n            for trophy in trophies:\n                if trophy == 'G':\n                    current_length += 1\n                    max_current_length = max(max_current_length, current_length)\n                else:\n                    current_length = 0\n\n            # Update the maximum possible length\n            max_length = max(max_length, max_current_length)\n\n            # Swap the trophies back to their original positions\n            trophies[i], trophies[j] = trophies[j], trophies[i]\n\n    return max_length\n\n# Read the input\nn = int(input())\ntrophies = input()\n\n# Print the output\nprint(max_golden_subsegment(n, trophies))"}
{"solution": "import sys\nfrom collections import deque\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef main():\n    n, k = map(int, read_input().split())\n    main_courses = set(map(int, read_input().split()))\n    dependencies = [set(map(int, read_input().split()[1:])) for _ in range(n)]\n\n    # Calculate the number of dependencies for each course\n    num_dependencies = [len(dep) for dep in dependencies]\n\n    # Initialize a queue with courses that have no dependencies\n    queue = deque([i for i in range(1, n + 1) if num_dependencies[i - 1] == 0])\n\n    # Initialize a list to store the order of courses\n    order = []\n\n    # Process courses in topological order\n    while queue:\n        course = queue.popleft()\n        order.append(course)\n\n        # Decrease the number of dependencies for courses that depend on the current course\n        for i in range(1, n + 1):\n            if course in dependencies[i - 1]:\n                dependencies[i - 1].remove(course)\n                num_dependencies[i - 1] -= 1\n\n                # If a course has no dependencies left, add it to the queue\n                if num_dependencies[i - 1] == 0:\n                    queue.append(i)\n\n    # Check if it's possible to pass all main courses\n    if any(num_dependencies[course - 1] > 0 for course in main_courses):\n        print(-1)\n    else:\n        # Print the minimum number of courses to pass and the order of courses\n        print(len(order))\n        print(' '.join(map(str, order)))\n\nif __name__ == '__main__':\n    main()"}
{"solution": "def is_stack_sortable(arr):\n    stack = []\n    b = []\n    i = 0\n    while arr or stack:\n        if arr and (not stack or arr[0] >= stack[-1]):\n            stack.append(arr.pop(0))\n        elif stack:\n            b.append(stack.pop())\n        else:\n            return False\n    return b == sorted(b)\n\ndef restore_permutation(n, k, p):\n    remaining = [i for i in range(1, n+1) if i not in p]\n    for i in range(n-k, -1, -1):\n        for j in range(len(remaining)-1, -1, -1):\n            if is_stack_sortable(p + remaining[j:] + p[i+1:]):\n                p.insert(i, remaining.pop(j))\n                break\n    return p if is_stack_sortable(p) else -1\n\nn, k = map(int, input().split())\np = list(map(int, input().split()))\nresult = restore_permutation(n, k, p)\nprint(*result)"}
{"solution": "def does_b_appear_in_sequence(a, b, c):\n    if c == 0:\n        return \"YES\" if a == b else \"NO\"\n    else:\n        if (b - a) % c == 0 and (b - a) // c >= 0:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n# Get input\na, b, c = map(int, input().split())\n\n# Print output\nprint(does_b_appear_in_sequence(a, b, c))"}
{"solution": "def can_form_regular_sequence(cnt_1, cnt_2, cnt_3, cnt_4):\n    if cnt_1 == cnt_4:\n        return 1\n    else:\n        return 0\n\ncnt_1 = int(input())\ncnt_2 = int(input())\ncnt_3 = int(input())\ncnt_4 = int(input())\n\nprint(can_form_regular_sequence(cnt_1, cnt_2, cnt_3, cnt_4))"}
{"solution": "def standing_spectators(n, k, t):\n    # Calculate the number of full waves completed at time t\n    full_waves = t // (k + 1)\n\n    # Calculate the number of spectators standing at the end of the full waves\n    standing = full_waves * k\n\n    # Calculate the number of additional spectators standing after the full waves\n    additional = max(0, min(t % (k + 1), k))\n\n    # Calculate the total number of standing spectators\n    total = standing + additional\n\n    return total\n\n# Get the input\nn, k, t = map(int, input().split())\n\n# Print the output\nprint(standing_spectators(n, k, t))"}
{"solution": "def lexicographically_minimal_string(s):\n    t = []\n    u = []\n    min_char = min(s)\n    s = list(s)\n\n    while s or t:\n        if t and (not s or t[-1] <= min_char):\n            u.append(t.pop())\n        else:\n            char = s.pop(0)\n            t.append(char)\n            if s:\n                min_char = min(s)\n\n    return ''.join(u)\n\n# Example usage:\ns = input().strip()\nprint(lexicographically_minimal_string(s))"}
{"solution": "def check_records(n, records):\n    prev_plays, prev_clears = records[0]\n    for plays, clears in records[1:]:\n        if plays < prev_plays or clears < prev_clears or clears > plays:\n            return \"NO\"\n        prev_plays, prev_clears = plays, clears\n    return \"YES\"\n\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    records = [list(map(int, input().split())) for _ in range(n)]\n    print(check_records(n, records))"}
{"solution": "def next_palindrome(time):\n    hour, minute = map(int, time.split(':'))\n    while True:\n        minute += 1\n        if minute == 60:\n            minute = 0\n            hour = (hour + 1) % 24\n        time = f'{hour:02d}:{minute:02d}'\n        if time == time[::-1]:\n            return time\n\ndef min_to_sleep(current_time):\n    next_time = next_palindrome(current_time)\n    next_hour, next_minute = map(int, next_time.split(':'))\n    current_hour, current_minute = map(int, current_time.split(':'))\n    return (next_hour * 60 + next_minute - current_hour * 60 - current_minute) % (24 * 60)\n\ncurrent_time = input()\nprint(min_to_sleep(current_time))"}
{"solution": "# Get the size of the permutation\nn = int(input())\n\n# Get the permutation\na = list(map(int, input().split()))\n\n# Find the indices of the minimum and maximum elements\nmin_index = a.index(1)\nmax_index = a.index(n)\n\n# Calculate the current distance between the minimum and maximum elements\ncurrent_distance = abs(min_index - max_index)\n\n# Calculate the distances if we swap the minimum element with another element\ndistances_if_swap_min = [abs(i - max_index) for i in range(n) if i != min_index]\n\n# Calculate the distances if we swap the maximum element with another element\ndistances_if_swap_max = [abs(min_index - i) for i in range(n) if i != max_index]\n\n# Calculate the maximum possible distance\nmax_possible_distance = max(max(distances_if_swap_min), max(distances_if_swap_max), current_distance)\n\n# Print the maximum possible distance\nprint(max_possible_distance)"}
{"solution": "def is_s_palindrome(s):\n    n = len(s)\n    mid = n // 2\n    if n % 2 == 0:\n        first_half = s[:mid]\n        second_half = s[mid:]\n    else:\n        first_half = s[:mid]\n        second_half = s[mid+1:]\n\n    if first_half == second_half[::-1]:\n        return \"TAK\"\n    else:\n        return \"NIE\"\n\n# Read the input string\ns = input().strip()\n# Print the result\nprint(is_s_palindrome(s))"}
{"solution": "def max_permutation(a, b):\n    a = list(str(a))\n    b = list(str(b))\n    a.sort(reverse=True)\n    res = []\n    for digit in a:\n        if digit in b:\n            b.remove(digit)\n            res.append(digit)\n    for digit in b:\n        if digit > res[0]:\n            res.insert(0, digit)\n            break\n    return ''.join(res)\n\na = int(input())\nb = int(input())\nprint(max_permutation(a, b))"}
{"solution": "def check_win(board, player):\n    # Check rows, columns, and diagonals for a win\n    for i in range(10):\n        if all(board[i][j] == player for j in range(10)) or all(board[j][i] == player for j in range(10)):\n            return True\n    for i in range(6):\n        if all(board[i+j][j] == player for j in range(6)) or all(board[i+j][9-j] == player for j in range(6)):\n            return True\n    return False\n\ndef can_win(board):\n    # Check if Alice can win in one turn\n    for i in range(10):\n        for j in range(10):\n            if board[i][j] == '.':\n                board[i][j] = 'X'\n                if check_win(board, 'X'):\n                    return True\n                board[i][j] = '.'\n    return False\n\n# Read input\nboard = [list(input()) for _ in range(10)]\n\n# Check if Alice can win in one turn\nif can_win(board):\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "def solve(n, k, matrix, row, col):\n    # Base case: if k is 0, we've placed all ones\n    if k == 0:\n        return True\n    # If we've reached the end of the matrix, we can't place any more ones\n    if row > n or col > n:\n        return False\n    # If the current cell is on the main diagonal, we can only place one if k is 1\n    if row == col and k == 1:\n        matrix[row][col] = 1\n        return True\n    # Try placing a one in the current cell\n    if k > 0:\n        matrix[row][col] = matrix[col][row] = 1\n        if solve(n, k - 2, matrix, row, col + 1):\n            return True\n        matrix[row][col] = matrix[col][row] = 0\n    # Try moving to the next cell\n    if solve(n, k, matrix, row, col + 1):\n        return True\n    # If we've reached the end of the row, move to the next row\n    if col == n:\n        return solve(n, k, matrix, row + 1, row + 1)\n    return False\n\ndef main():\n    n, k = map(int, input().split())\n    # If k is greater than the number of cells in the upper triangle of the matrix, it's impossible\n    if k > n * (n + 1) // 2:\n        print(-1)\n        return\n    matrix = [[0] * n for _ in range(n)]\n    if solve(n, k, matrix, 0, 0):\n        for row in matrix:\n            print(' '.join(map(str, row)))\n    else:\n        print(-1)\n\nif __name__ == '__main__':\n    main()"}
{"solution": "# Get the input values\nx, y, z = map(float, input().split())\n\n# Define all 12 expressions\nexpressions = [\n    x ** y ** z,\n    x ** z ** y,\n    (x ** y) ** z,\n    (x ** z) ** y,\n    y ** x ** z,\n    y ** z ** x,\n    (y ** x) ** z,\n    (y ** z) ** x,\n    z ** x ** y,\n    z ** y ** x,\n    (z ** x) ** y,\n    (z ** y) ** x\n]\n\n# Define the corresponding expressions as strings\nexpression_strings = [\n    \"x^y^z\",\n    \"x^z^y\",\n    \"(x^y)^z\",\n    \"(x^z)^y\",\n    \"y^x^z\",\n    \"y^z^x\",\n    \"(y^x)^z\",\n    \"(y^z)^x\",\n    \"z^x^y\",\n    \"z^y^x\",\n    \"(z^x)^y\",\n    \"(z^y)^x\"\n]\n\n# Find the maximum value and the corresponding expression\nmax_value = max(expressions)\nmax_index = expressions.index(max_value)\nmax_expression = expression_strings[max_index]\n\n# Print the result\nprint(max_expression)"}
{"solution": "def min_operations(n, s):\n    # Initialize the minimum operations as the length of the string\n    min_ops = n\n\n    # Iterate through all possible prefixes of the string\n    for i in range(1, n // 2 + 1):\n        # Check if the prefix repeats to form the string\n        if n % i == 0 and s[:i] * (n // i) == s:\n            # If it does, update the minimum operations\n            min_ops = i + 1\n            break\n\n    return min_ops\n\n# Read the input\nn = int(input())\ns = input()\n\n# Print the minimum number of operations\nprint(min_operations(n, s))"}
{"solution": "n = int(input())\nfiles = []\nfor _ in range(n):\n    name, type = input().split()\n    files.append((name, int(type)))\n\nexamples = [name for name, type in files if type == 1]\nregular = [name for name, type in files if type == 0]\n\nscript = []\nfor i, name in enumerate(examples, 1):\n    script.append(f\"move {name} {i}\")\n\nfor i, name in enumerate(regular, len(examples) + 1):\n    script.append(f\"move {name} {i}\")\n\nprint(len(script))\nfor line in script:\n    print(line)"}
{"solution": "def min_changes(ticket):\n    # Calculate the sum of the first three digits and the last three digits\n    sum_first_three = sum(int(digit) for digit in ticket[:3])\n    sum_last_three = sum(int(digit) for digit in ticket[3:])\n\n    # If the sums are equal, no changes are needed\n    if sum_first_three == sum_last_three:\n        return 0\n\n    # Calculate the difference between the sums\n    diff = abs(sum_first_three - sum_last_three)\n\n    # If the difference is less than or equal to 9, one change is needed\n    if diff <= 9:\n        return 1\n\n    # Otherwise, two changes are needed\n    return 2\n\n# Get the input ticket\nticket = input()\n\n# Print the minimum number of changes needed\nprint(min_changes(ticket))"}
{"solution": "def minimum_traps(m, x):\n    return m - 1\n\n# Get input\nm, x = map(int, input().split())\n\n# Print output\nprint(minimum_traps(m, x))"}
{"solution": "MOD = 10**6 + 3\n\ndef power(base, exponent, mod):\n    result = 1\n    base %= mod\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % mod\n        base = (base * base) % mod\n        exponent //= 2\n    return result\n\ndef inverse(n, mod):\n    return power(n, mod - 2, mod)\n\ndef factorial(n, mod):\n    if n >= mod:\n        return 0\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % mod\n    return result\n\ndef ncr(n, r, mod):\n    if r > n:\n        return 0\n    num = factorial(n, mod)\n    den = (factorial(r, mod) * factorial(n - r, mod)) % mod\n    return (num * inverse(den, mod)) % mod\n\ndef solve(n, k):\n    total_days = 1 << n\n    total_ways = power(total_days, k, MOD)\n    unique_ways = 0\n    for i in range(k):\n        unique_ways = (unique_ways + ncr(total_days, i, MOD)) % MOD\n    return (total_ways - unique_ways) % MOD, total_ways\n\nn, k = map(int, input().split())\nA, B = solve(n, k)\nprint(A, B)"}
{"solution": "def check_journey(n, journey):\n    position = [0, 0]  # North Pole\n    for i in range(n):\n        distance, direction = journey[i]\n        if direction == 'North':\n            position[1] += distance\n        elif direction == 'South':\n            position[1] -= distance\n        elif direction == 'East':\n            position[0] += distance\n        elif direction == 'West':\n            position[0] -= distance\n\n        # Check conditions\n        if position[1] > 20000 or position[1] < -20000:\n            return 'NO'\n        if position[1] == 20000 and direction != 'South':\n            return 'NO'\n        if position[1] == -20000 and direction != 'North':\n            return 'NO'\n\n    # Check if the journey ends on the North Pole\n    if position[1] == 0:\n        return 'YES'\n    else:\n        return 'NO'\n\n# Read input\nn = int(input())\njourney = []\nfor _ in range(n):\n    distance, direction = input().split()\n    journey.append((int(distance), direction))\n\n# Check journey and print result\nprint(check_journey(n, journey))"}
{"solution": "def solve(a1, b1, a2, b2, L, R):\n    if a1 == a2:\n        if b1 == b2 and L <= b1 <= R:\n            return R - L + 1\n        elif (b2 - b1) % a1 == 0 and L <= b1 <= R:\n            return max(0, (min(R, b2 + ((R - b2) // a1) * a1) - max(L, b1 + ((L - b1) // a1) * a1)) // a1 + 1)\n        else:\n            return 0\n    elif (b2 - b1) % (a1 - a2) == 0:\n        k = (b2 - b1) // (a1 - a2)\n        if L <= a1 * k + b1 <= R:\n            return max(0, min(R // a1, k + (R - b1) // a1) - max(L // a1, k + (L - b1) // a1) + 1)\n        else:\n            return 0\n    else:\n        return 0\n\na1, b1, a2, b2, L, R = map(int, input().split())\nprint(solve(a1, b1, a2, b2, L, R))"}
{"solution": "# Get the input\nn, a, b = map(int, input().split())\n\n# Calculate the maximum possible number x\nx = min(a, b, n)\nwhile x > 0:\n    if a // x + b // x >= n:\n        break\n    x -= 1\n\n# Print the result\nprint(x)"}
{"solution": "def check_flag(n, m, flag):\n    # Check if the flag is divisible into three equal stripes\n    if n % 3 != 0 or m % 3 != 0:\n        return \"NO\"\n\n    # Divide the flag into three equal stripes\n    stripes = [flag[i*n//3:(i+1)*n//3] for i in range(3)]\n\n    # Check if each stripe is a single color\n    for stripe in stripes:\n        if len(set(stripe)) != 1:\n            return \"NO\"\n\n    # Check if each color is used exactly once\n    colors = set()\n    for stripe in stripes:\n        colors.add(stripe[0])\n\n    if len(colors) != 3:\n        return \"NO\"\n\n    return \"YES\"\n\n# Get the input\nn, m = map(int, input().split())\nflag = [input() for _ in range(n)]\n\n# Flatten the flag into a single string\nflag = ''.join(flag)\n\n# Check the flag and print the result\nprint(check_flag(n, m, flag))"}
{"solution": "def calculate_position(n):\n    # The spiral can be divided into rings.\n    # Each ring has 6 segments, and each segment has a length of 1, 2, 3, ...\n    # First, we need to find the ring that Ayrat is in.\n    ring = 0\n    while (ring + 1) * 6 * (ring + 2) <= n:\n        ring += 1\n\n    # Now, we know which ring Ayrat is in.\n    # Let's find the segment and the position within the segment.\n    segment_length = ring + 1\n    segment = (n - ring * 6 * segment_length) // segment_length\n    position = (n - ring * 6 * segment_length) % segment_length\n\n    # Now, we can calculate the coordinates.\n    x, y = 0, 0\n    if segment == 0:\n        x = ring\n        y = -ring + position\n    elif segment == 1:\n        x = ring - position\n        y = ring\n    elif segment == 2:\n        x = -ring\n        y = ring - position\n    elif segment == 3:\n        x = -ring + position\n        y = -ring\n    elif segment == 4:\n        x = ring - position\n        y = -ring\n    elif segment == 5:\n        x = ring\n        y = position - ring\n\n    return x, y\n\nn = int(input())\nx, y = calculate_position(n)\nprint(x, y)"}
{"solution": "import math\n\ndef can_break_shield(a, b, c):\n    # Calculate the greatest common divisor of a and b\n    gcd_ab = math.gcd(a, b)\n\n    # Check if c is divisible by the gcd of a and b\n    if c % gcd_ab == 0:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read input values\na, b, c = map(int, input().split())\n\n# Output the result\nprint(can_break_shield(a, b, c))"}
{"solution": "def can_tracks_coincide(n, L, kefa_barriers, sasha_barriers):\n    # Calculate distances between consecutive barriers for Kefa\n    kefa_distances = [(kefa_barriers[(i + 1) % n] - kefa_barriers[i]) % L for i in range(n)]\n    # Calculate distances between consecutive barriers for Sasha\n    sasha_distances = [(sasha_barriers[(i + 1) % n] - sasha_barriers[i]) % L for i in range(n)]\n\n    # Double the kefa_distances to handle circular rotation\n    doubled_kefa_distances = kefa_distances + kefa_distances\n\n    # Check if sasha_distances is a sublist of doubled_kefa_distances\n    for i in range(n):\n        if doubled_kefa_distances[i:i + n] == sasha_distances:\n            return \"YES\"\n\n    return \"NO\"\n\n# Read input\nn, L = map(int, input().split())\nkefa_barriers = list(map(int, input().split()))\nsasha_barriers = list(map(int, input().split()))\n\n# Output the result\nprint(can_tracks_coincide(n, L, kefa_barriers, sasha_barriers))"}
{"solution": "def is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindrome_substring(s):\n    n = len(s)\n    max_length = 0\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = s[i:j]\n            if not is_palindrome(substring) and len(substring) > max_length:\n                max_length = len(substring)\n\n    return max_length\n\ns = input()\nprint(longest_non_palindrome_substring(s))"}
{"solution": "n = int(input())\nratings = [list(map(int, input().split())) for _ in range(n)]\n\n# Check if any rating has changed\nif any(a != b for a, b in ratings):\n    print(\"rated\")\nelse:\n    # Check if the standings are in non-increasing order of rating\n    if all(ratings[i][0] >= ratings[i + 1][0] for i in range(n - 1)):\n        print(\"unrated\")\n    else:\n        print(\"maybe\")"}
{"solution": "# Read the input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Initialize the result list\nresult = [0] * n\n\n# Initialize the previous zero index\nprev_zero = float('-inf')\n\n# Iterate over the array from left to right\nfor i in range(n):\n    # If the current element is zero, update the previous zero index\n    if arr[i] == 0:\n        prev_zero = i\n    # Update the result for the current element\n    result[i] = i - prev_zero\n\n# Initialize the next zero index\nnext_zero = float('inf')\n\n# Iterate over the array from right to left\nfor i in range(n - 1, -1, -1):\n    # If the current element is zero, update the next zero index\n    if arr[i] == 0:\n        next_zero = i\n    # Update the result for the current element\n    result[i] = min(result[i], next_zero - i)\n\n# Print the result\nprint(*result)"}
{"solution": "def count_distinct_cyclical_strings(n, s):\n    from itertools import product\n\n    def is_substring_in_cyclical_shifts(t, s):\n        t_extended = t + t\n        return any(s in t_extended[i:i+len(t)] for i in range(len(t)))\n\n    distinct_cyclical_strings = set()\n\n    for bits in product('01', repeat=n):\n        t = ''.join(bits)\n        if is_substring_in_cyclical_shifts(t, s):\n            distinct_cyclical_strings.add(t)\n\n    return len(distinct_cyclical_strings)\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Print output\nprint(count_distinct_cyclical_strings(n, s))"}
{"solution": "import math\n\ndef find_min_angle_vectors(vectors):\n    n = len(vectors)\n    angles = [math.atan2(y, x) for x, y in vectors]\n    angles.sort()\n    angles += [angle + 2 * math.pi for angle in angles]\n    min_angle = float('inf')\n    min_pair = (0, 0)\n    for i in range(n):\n        angle_diff = angles[i + n] - angles[i]\n        if angle_diff < min_angle:\n            min_angle = angle_diff\n            min_pair = (i % n, (i + n) % n)\n    return min_pair\n\nn = int(input())\nvectors = [tuple(map(int, input().split())) for _ in range(n)]\nmin_pair = find_min_angle_vectors(vectors)\nprint(*min_pair)"}
{"solution": "def minimal_time(d, k, a, b, t):\n    if d <= k:\n        return d * a\n\n    # Full segments\n    full_segments = d // k\n    remaining_distance = d % k\n\n    # Time for full segments\n    time_for_full_segments = full_segments * k * a + (full_segments - 1) * t\n\n    # Time for remaining distance\n    if remaining_distance == 0:\n        return time_for_full_segments\n    else:\n        # Option 1: Drive the remaining distance\n        time_drive_remaining = remaining_distance * a + t\n        # Option 2: Walk the remaining distance\n        time_walk_remaining = remaining_distance * b\n\n        return time_for_full_segments + min(time_drive_remaining, time_walk_remaining)\n\n# Get input\nd, k, a, b, t = map(int, input().split())\n\n# Print the minimal time\nprint(minimal_time(d, k, a, b, t))"}
{"solution": "def max_gcd_sequence(n, k):\n    # If k is greater than n, no sequence is possible\n    if k > n:\n        return [-1]\n\n    # If k is equal to n, the sequence is [1, 2, ..., n]\n    if k == n:\n        return list(range(1, n + 1))\n\n    # Calculate the maximum possible gcd\n    max_gcd = n // k\n\n    # Check if it's possible to create the sequence\n    while max_gcd > 0:\n        if (max_gcd * k + k * (k - 1) // 2) <= n:\n            break\n        max_gcd -= 1\n\n    # If no sequence is possible, return [-1]\n    if max_gcd == 0:\n        return [-1]\n\n    # Create the sequence\n    sequence = list(range(max_gcd, max_gcd * k + 1, max_gcd))\n\n    # Distribute the remaining sum to the sequence\n    remaining_sum = n - sum(sequence)\n    sequence[-1] += remaining_sum\n\n    return sequence\n\n# Read the input\nn, k = map(int, input().split())\n\n# Print the output\nprint(*max_gcd_sequence(n, k))"}
{"solution": "def count_pairs(n, m):\n    # Count the number of multiples of 5 in the range [1, n] and [1, m]\n    multiples_of_5_in_n = n // 5\n    multiples_of_5_in_m = m // 5\n\n    # Count the number of pairs (x, y) such that (x + y) % 5 == 0\n    # This is equal to the product of the number of multiples of 5 in n and m\n    # plus the number of pairs (x, y) such that x % 5 != 0 and y % 5 != 0\n    # which is equal to the product of the number of non-multiples of 5 in n and m\n    return multiples_of_5_in_n * multiples_of_5_in_m + (n - multiples_of_5_in_n) * (m - multiples_of_5_in_m)\n\n# Read the input\nn, m = map(int, input().split())\n\n# Print the result\nprint(count_pairs(n, m))"}
{"solution": "def max_beauty(n, x, a):\n    # Initialize prefix sum array\n    prefix_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + a[i - 1]\n\n    # Initialize max beauty array\n    max_beauty_arr = [0] * (n + 1)\n    max_beauty_arr[0] = max(0, prefix_sum[0])\n\n    # Initialize variables to keep track of the maximum subarray sum and the maximum beauty\n    max_subarray_sum = max(0, prefix_sum[0])\n    max_beauty_so_far = max_subarray_sum\n\n    # Iterate through the array\n    for i in range(1, n + 1):\n        # Calculate the maximum subarray sum ending at index i\n        max_subarray_sum = max(0, prefix_sum[i] - min(prefix_sum[:i]))\n\n        # Calculate the maximum beauty ending at index i\n        max_beauty_arr[i] = max(max_beauty_so_far, max_subarray_sum, max_subarray_sum + (prefix_sum[i] - prefix_sum[i - 1]) * x)\n\n        # Update the maximum beauty so far\n        max_beauty_so_far = max_beauty_arr[i]\n\n    return max_beauty_so_far\n\n# Read input\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Print output\nprint(max_beauty(n, x, a))"}
{"solution": "def find_kth_largest(n, m, k):\n    def count_less_equal(x):\n        count = 0\n        for i in range(1, n + 1):\n            count += min(m, x // i)\n        return count\n\n    low, high = 1, n * m\n    while low < high:\n        mid = (low + high) // 2\n        if count_less_equal(mid) < k:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n\n# Example usage:\nn, m, k = map(int, input().split())\nprint(find_kth_largest(n, m, k))"}
{"solution": "def find_kth_digit(k):\n    if k < 10:\n        return k\n\n    # Initialize variables\n    digits = 1\n    count = 9\n    start = 1\n\n    # Find the range in which kth digit lies\n    while k > count * digits:\n        k -= count * digits\n        digits += 1\n        start *= 10\n        count *= 10\n\n    # Find the number which contains the kth digit\n    num = start + (k - 1) // digits\n\n    # Find the kth digit in the number\n    return int(str(num)[(k - 1) % digits])\n\n# Read input\nk = int(input())\n\n# Print the kth digit\nprint(find_kth_digit(k))"}
{"solution": "# Read input\nn, m, r = map(int, input().split())\ns = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Find the minimum buying price\nmin_buy = min(s)\n\n# Find the maximum selling price\nmax_sell = max(b)\n\n# Calculate the maximum number of bourles that can be held after the evening\nif min_buy < max_sell:\n    # Buy shares at the minimum price and sell them at the maximum price\n    max_bourles = r // min_buy * max_sell + r % min_buy\nelse:\n    # It's not profitable to buy and sell shares, so keep the initial amount of bourles\n    max_bourles = r\n\n# Print the result\nprint(max_bourles)"}
{"solution": "def find_original_message(t):\n    n = len(t)\n\n    # Iterate over all possible overlap lengths\n    for overlap in range(1, n // 2 + 1):\n        # Check if the string t can be split into two parts with overlap length overlap\n        if t[:overlap] == t[-overlap:]:\n            s = t[:-overlap]\n            if s + t[-overlap:] == t:\n                return \"YES\", s\n\n    return \"NO\", None\n\n# Read input\nt = input().strip()\n\n# Find possible message s\nresult, s = find_original_message(t)\n\n# Print result\nprint(result)\nif result == \"YES\":\n    print(s)"}
{"solution": "def find_teams(n):\n    # Initialize an empty list to store the possible number of teams\n    teams = []\n\n    # Start with the smallest possible number of teams\n    x = 1\n\n    # Keep looping until we find a number of teams that yields exactly n games\n    while True:\n        # Calculate the number of games for the current number of teams\n        games = 0\n        while x % 2 == 0:\n            games += x // 2\n            x //= 2\n        if x > 1:\n            games += x * (x - 1) // 2\n\n        # If the number of games is equal to n, add the number of teams to the list\n        if games == n:\n            teams.append(x)\n\n        # If the number of games is greater than n, we can stop the loop\n        if games > n:\n            break\n\n        # Increment the number of teams\n        x += 1\n\n    # If the list is empty, return -1\n    if not teams:\n        return [-1]\n\n    # Otherwise, return the list of possible number of teams\n    return teams\n\n# Read the input\nn = int(input())\n\n# Find the possible number of teams\nteams = find_teams(n)\n\n# Print the output\nfor team in teams:\n    print(team)"}
{"solution": "# Read input\nn = int(input())\ns = input()\nb = list(map(int, input().split()))\n\n# Count the frequency of each character in s\nfreq = [0] * 26\nfor c in s:\n    freq[ord(c) - ord('a')] += 1\n\n# Sort the beauty values in descending order\nb.sort(reverse=True)\n\n# Initialize the maximum possible beauty of t\nmax_beauty = 0\n\n# Iterate over the characters in the first half of s\nfor i in range(n // 2):\n    # If the current character is not equal to its corresponding character in the second half of s\n    if s[i] != s[n - i - 1]:\n        # Add the beauty values of the current index and its corresponding index to max_beauty\n        max_beauty += b[i] + b[n - i - 1]\n    else:\n        # If the frequency of the current character is greater than 2\n        if freq[ord(s[i]) - ord('a')] > 2:\n            # Add the beauty values of the current index and its corresponding index to max_beauty\n            max_beauty += b[i] + b[n - i - 1]\n            # Decrease the frequency of the current character by 2\n            freq[ord(s[i]) - ord('a')] -= 2\n        # If the frequency of the current character is equal to 2\n        elif freq[ord(s[i]) - ord('a')] == 2:\n            # Add the beauty value of the current index to max_beauty\n            max_beauty += b[i]\n            # Decrease the frequency of the current character by 1\n            freq[ord(s[i]) - ord('a')] -= 1\n\n# Print the maximum possible beauty of t\nprint(max_beauty)"}
{"solution": "def can_weigh(w, m):\n    # If the item's mass is less than or equal to the weight, it can be weighed\n    if m <= w:\n        return True\n\n    # If the weight is 2, the item can be weighed if its mass is even\n    if w == 2:\n        return m % 2 == 0\n\n    # If the item's mass is less than or equal to twice the weight minus 2, it can be weighed\n    if m <= 2 * w - 2:\n        return True\n\n    # If the item's mass is greater than twice the weight minus 2, it cannot be weighed\n    return False\n\n# Read the input\nw, m = map(int, input().split())\n\n# Print the output\nprint('YES' if can_weigh(w, m) else 'NO')"}
{"solution": "def find_sequence(n, k):\n    sequence = []\n    i = 60  # start from the largest possible power of 2\n    while n > 0 and k > 0:\n        if n & (1 << i):  # if the i-th bit of n is set\n            sequence.append(i)\n            n -= (1 << i)\n            k -= 1\n        i -= 1\n    if n > 0 or k > 0:  # if there's still some n left or k is not used up\n        return \"No\"\n    else:\n        sequence.extend([0] * k)  # fill the rest of the sequence with 0s\n        return \"Yes\\n\" + \" \".join(map(str, sequence[::-1]))  # reverse the sequence to get the lexicographically largest one\n\nn, k = map(int, input().split())\nprint(find_sequence(n, k))"}
{"solution": "def champagne_pyramid(n, t):\n    # Initialize the pyramid with 0s\n    pyramid = [[0.0] * i for i in range(1, n+1)]\n\n    # Pour champagne\n    pyramid[0][0] = t\n\n    # Simulate the pouring process\n    for i in range(n-1):\n        for j in range(i+1):\n            if pyramid[i][j] > 1:\n                overflow = (pyramid[i][j] - 1) / 2\n                pyramid[i][j] = 1\n                pyramid[i+1][j] += overflow\n                pyramid[i+1][j+1] += overflow\n\n    # Count the full glasses\n    full_glasses = sum(glass == 1 for row in pyramid for glass in row)\n\n    return full_glasses\n\n# Read input\nn, t = map(int, input().split())\n\n# Print output\nprint(champagne_pyramid(n, t))"}
{"solution": "def calculate_area(n, vertices):\n    if n == 1:\n        return -1\n    elif n == 2:\n        x1, y1 = vertices[0]\n        x2, y2 = vertices[1]\n        if x1 != x2 and y1 != y2:\n            return abs(x1 - x2) * abs(y1 - y2)\n        else:\n            return -1\n    elif n == 3:\n        x_coords = set()\n        y_coords = set()\n        for x, y in vertices:\n            x_coords.add(x)\n            y_coords.add(y)\n        if len(x_coords) == 2 and len(y_coords) == 2:\n            x1, x2 = x_coords\n            y1, y2 = y_coords\n            return abs(x1 - x2) * abs(y1 - y2)\n        else:\n            return -1\n    elif n == 4:\n        x_coords = set()\n        y_coords = set()\n        for x, y in vertices:\n            x_coords.add(x)\n            y_coords.add(y)\n        if len(x_coords) == 2 and len(y_coords) == 2:\n            x1, x2 = x_coords\n            y1, y2 = y_coords\n            return abs(x1 - x2) * abs(y1 - y2)\n        else:\n            return -1\n\n# Read input\nn = int(input())\nvertices = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the area\nprint(calculate_area(n, vertices))"}
{"solution": "# Get the input values\nn = int(input())\na = int(input())\nb = int(input())\n\n# Calculate the total length needed for two doors\ntotal_length = 2 * (2 * a + b)\n\n# Calculate the minimal number of wooden bars needed\nmin_bars = total_length // n\n\n# If the total length is not a multiple of n, an additional bar is needed\nif total_length % n != 0:\n    min_bars += 1\n\n# Print the result\nprint(min_bars)"}
{"solution": "def check_sortability(n, arr, swaps):\n    # Analyzing Constraints\n    segments = []\n    current_segment = [arr[0]]\n    for i in range(1, n):\n        if swaps[i - 1] == '1':\n            current_segment.append(arr[i])\n        else:\n            segments.append(current_segment)\n            current_segment = [arr[i]]\n    segments.append(current_segment)\n\n    # Formulating a Plan\n    sorted_arr = sorted(arr)\n    for segment in segments:\n        segment.sort()\n\n    # Implementing the Solution\n    for i in range(n):\n        if arr[i] != sorted_arr[i]:\n            return False\n\n    return True\n\n# Understanding the Problem\nn = int(input())\narr = list(map(int, input().split()))\nswaps = input()\n\n# Testing and Verification\nif check_sortability(n, arr, swaps):\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "def calculate_time(n, s):\n    # Define the order of seats\n    seats = ['f', 'e', 'd', 'c', 'b', 'a']\n\n    # Calculate the time taken to serve the rows before Vasya's row\n    time = 0\n    i = 1\n    while i < n:\n        time += 6\n        if i + 2 < n:\n            i += 3\n        else:\n            i += 1\n\n    # Calculate the time taken to serve the seats before Vasya's seat\n    time += seats.index(s)\n\n    return time\n\n# Get the input\ninput_str = input()\nn = int(input_str[:-1])\ns = input_str[-1]\n\n# Calculate and print the output\nprint(calculate_time(n, s))"}
{"solution": "def convert_to_decimal(number, base):\n    decimal = 0\n    for digit in number:\n        decimal = decimal * base + digit\n    return decimal\n\nn, b_x = map(int, input().split())\nx = list(map(int, input().split()))\nm, b_y = map(int, input().split())\ny = list(map(int, input().split()))\n\nx_decimal = convert_to_decimal(x, b_x)\ny_decimal = convert_to_decimal(y, b_y)\n\nif x_decimal < y_decimal:\n    print('<')\nelif x_decimal > y_decimal:\n    print('>')\nelse:\n    print('=')"}
{"solution": "def determine_winner(n, a):\n    # If the number of elements is even, BitLGM can always win by mirroring BitAryo's moves.\n    # If the number of elements is odd, BitLGM can win if and only if there is an odd number of odd elements in the sequence.\n    if n % 2 == 0 or sum(x % 2 for x in a) % 2 == 1:\n        return \"BitLGM\"\n    else:\n        return \"BitAryo\"\n\n# Read the input\nn = int(input())\na = list(map(int, input().split()))\n\n# Determine the winner\nwinner = determine_winner(n, a)\n\n# Print the output\nprint(winner)"}
{"solution": "from math import gcd\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculate prefix and suffix products\nprefix_products = [0] * (n + 1)\nsuffix_products = [0] * (n + 1)\nprefix_products[0] = 1\nsuffix_products[n] = 1\n\nfor i in range(1, n + 1):\n    prefix_products[i] = prefix_products[i - 1] * a[i - 1] % k\nfor i in range(n - 1, -1, -1):\n    suffix_products[i] = suffix_products[i + 1] * a[i] % k\n\n# Calculate the number of valid decks\ncount = 0\nfor i in range(n):\n    if prefix_products[i] * suffix_products[i + 1] % k == 0:\n        count += 1\n\n# Print the result\nprint(count)"}
{"solution": "# Get the input\nn, k = map(int, input().split())\ns = input()\n\n# Create a dictionary to store the count of each color\ncolor_count = {}\nfor color in s:\n    if color in color_count:\n        color_count[color] += 1\n    else:\n        color_count[color] = 1\n\n# Check if it's possible to distribute the balloons\nfor count in color_count.values():\n    if count > k:\n        print(\"NO\")\n        exit()\n\nprint(\"YES\")"}
{"solution": "# Read the size of the array\nn = int(input())\n\n# Read the elements of the array\narr = list(map(int, input().split()))\n\n# Initialize variables to store the minimum value and its indices\nmin_val = float('inf')\nmin_indices = []\n\n# Iterate through the array to find the minimum value and its indices\nfor i in range(n):\n    if arr[i] < min_val:\n        min_val = arr[i]\n        min_indices = [i]\n    elif arr[i] == min_val:\n        min_indices.append(i)\n\n# Initialize a variable to store the minimum distance between two minimum values\nmin_distance = float('inf')\n\n# Iterate through the indices of the minimum values to find the minimum distance\nfor i in range(1, len(min_indices)):\n    min_distance = min(min_distance, min_indices[i] - min_indices[i - 1])\n\n# Print the minimum distance\nprint(min_distance)"}
{"solution": "import math\n\ndef calculate_probability(t, w, b):\n    # Calculate the least common multiple of w and b\n    lcm = math.lcm(w, b)\n\n    # Calculate the number of steps that can be taken within the racetrack length\n    steps_w = t // w\n    steps_b = t // b\n\n    # Calculate the number of steps that will result in a tie\n    tie_steps = t // lcm\n\n    # Calculate the total number of possible steps\n    total_steps = steps_w + steps_b - tie_steps\n\n    # Calculate the probability\n    probability = tie_steps / total_steps\n\n    return probability\n\n# Read the input values\nt, w, b = map(int, input().split())\n\n# Calculate the probability\nprobability = calculate_probability(t, w, b)\n\n# Convert the probability to an irreducible fraction\nnumerator = probability.numerator\ndenominator = probability.denominator\n\n# Output the probability as an irreducible fraction\nprint(f\"{numerator}/{denominator}\")"}
{"solution": "# Get the input\nx, y, z = map(int, input().split())\n\n# Calculate the difference between upvotes and downvotes\ndiff = x - y\n\n# If the difference is greater than z, the result is \"+\"\nif diff > z:\n    print(\"+\")\n# If the difference is less than -z, the result is \"-\"\nelif diff < -z:\n    print(\"-\")\n# If the difference is between -z and z, the result is uncertain\nelif -z <= diff <= z:\n    print(\"?\")\n# If the difference is equal to 0, the result is \"0\"\nelse:\n    print(\"0\")"}
{"solution": "def min_subsegment_length(n, operations, x, y):\n    # Initialize the robot's position\n    robot_x, robot_y = 0, 0\n\n    # Initialize the minimum and maximum indices of the changed subsegment\n    min_index, max_index = -1, -1\n\n    # Iterate through the sequence of operations\n    for i in range(n):\n        # Update the robot's position based on the current operation\n        if operations[i] == 'U':\n            robot_y += 1\n        elif operations[i] == 'D':\n            robot_y -= 1\n        elif operations[i] == 'L':\n            robot_x -= 1\n        elif operations[i] == 'R':\n            robot_x += 1\n\n        # Check if the robot's position matches the target position\n        if robot_x == x and robot_y == y:\n            # Update the minimum and maximum indices of the changed subsegment\n            if min_index == -1:\n                min_index = i\n            max_index = i\n\n    # Check if the robot reached the target position\n    if min_index == -1:\n        return -1\n\n    # Calculate the length of the changed subsegment\n    length = max_index - min_index + 1\n\n    return length\n\n# Read the input\nn = int(input())\noperations = input()\nx, y = map(int, input().split())\n\n# Calculate the minimum length of the changed subsegment\nresult = min_subsegment_length(n, operations, x, y)\n\n# Print the result\nprint(result)"}
{"solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    T = int(data[0])\n    index = 1\n\n    results = []\n\n    for _ in range(T):\n        n = int(data[index])\n        x = int(data[index + 1])\n        s = data[index + 2]\n        index += 3\n\n        balance_s = s.count('0') - s.count('1')\n        prefix_balances = [0] * (n + 1)\n\n        for i in range(n):\n            prefix_balances[i + 1] = prefix_balances[i] + (1 if s[i] == '0' else -1)\n\n        if balance_s == 0:\n            if x in prefix_balances:\n                results.append(-1)\n            else:\n                results.append(0)\n        else:\n            count = 0\n            for b in prefix_balances:\n                if (x - b) % balance_s == 0 and (x - b) // balance_s >= 0:\n                    count += 1\n            results.append(count)\n\n    for result in results:\n        print(result)\n\nsolve()"}
{"solution": "# Get the input\nn, k = map(int, input().split())\n\n# Convert the number to string\nn = str(n)\n\n# Find the index of the first digit that is not zero and is at least k digits from the end\nindex = len(n) - k\nwhile index > 0 and n[index] == '0':\n    index -= 1\n\n# Count the number of digits to delete\ncount = len(n) - index - k\n\n# Print the result\nprint(count)"}
{"solution": "def calculate_questions(n, m, k, x, y):\n    # Calculate total number of questions asked in one cycle\n    cycle = 2 * (n - 1) * m if n > 1 else m\n\n    # Calculate number of full cycles and remaining questions\n    full_cycles = k // cycle\n    remaining_questions = k % cycle\n\n    # Calculate maximum and minimum questions asked\n    max_questions = full_cycles * m + min(remaining_questions, y) + (1 if remaining_questions >= y else 0)\n    min_questions = full_cycles * m + max(0, min(remaining_questions - m + 1, y) - 1)\n\n    # Calculate Sergei's questions\n    sergei_questions = full_cycles * m\n    if remaining_questions >= (x - 1) * m + y:\n        sergei_questions += min(remaining_questions - (x - 1) * m, y)\n\n    return max_questions, min_questions, sergei_questions\n\n# Read input\nn, m, k, x, y = map(int, input().split())\n\n# Calculate and print output\nmax_questions, min_questions, sergei_questions = calculate_questions(n, m, k, x, y)\nprint(max_questions, min_questions, sergei_questions)"}
{"solution": "def max_beauty(ribbon, n):\n    # Calculate the current beauty of the ribbon\n    max_subribbon_count = 0\n    for i in range(len(ribbon)):\n        for j in range(i, len(ribbon)):\n            subribbon = ribbon[i:j+1]\n            count = ribbon.count(subribbon)\n            max_subribbon_count = max(max_subribbon_count, count)\n\n    # Determine the most frequent character\n    most_frequent_char = max(set(ribbon), key=ribbon.count)\n\n    # Calculate the potential beauty after making changes\n    potential_beauty = min(n, len(ribbon)) * max_subribbon_count\n    if most_frequent_char * len(ribbon) not in ribbon:\n        potential_beauty = max(potential_beauty, len(ribbon))\n\n    return potential_beauty\n\n# Read the input\nn = int(input())\nkuro_ribbon = input()\nshiro_ribbon = input()\nkatie_ribbon = input()\n\n# Calculate the potential beauty for each ribbon\nkuro_beauty = max_beauty(kuro_ribbon, n)\nshiro_beauty = max_beauty(shiro_ribbon, n)\nkatie_beauty = max_beauty(katie_ribbon, n)\n\n# Determine the winner\nwinner = max([(kuro_beauty, \"Kuro\"), (shiro_beauty, \"Shiro\"), (katie_beauty, \"Katie\")])\nif winner[0] == kuro_beauty == shiro_beauty or winner[0] == kuro_beauty == katie_beauty or winner[0] == shiro_beauty == katie_beauty:\n    print(\"Draw\")\nelse:\n    print(winner[1])"}
{"solution": "def calculate_days(c, v_0, v_1, a, l):\n    days = 1\n    pages_read = v_0\n    while pages_read < c:\n        pages_read -= l\n        if pages_read < 0:\n            pages_read = 0\n        v_0 = min(v_0 + a, v_1)\n        pages_read += v_0\n        days += 1\n    return days\n\nc, v_0, v_1, a, l = map(int, input().split())\nprint(calculate_days(c, v_0, v_1, a, l))"}
{"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_prime_sum(n):\n    primes = [i for i in range(2, n) if is_prime(i)]\n    for i in range(len(primes)):\n        for j in range(i, len(primes)):\n            for k in range(j, len(primes)):\n                if primes[i] + primes[j] + primes[k] == n:\n                    return [primes[i], primes[j], primes[k]]\n    return [n]\n\nn = int(input())\nresult = find_prime_sum(n)\nprint(len(result))\nprint(' '.join(map(str, result)))"}
{"solution": "# Read input\nn, m = map(int, input().split())\ngrid = [list(input()) for _ in range(n)]\n\n# Count walls in each row and column\nrow_walls = [row.count('*') for row in grid]\ncol_walls = [col.count('*') for col in zip(*grid)]\n\n# Total number of walls\ntotal_walls = sum(row_walls)\n\n# Check each cell\nfor i in range(n):\n    for j in range(m):\n        # If the sum of walls in row i and column j minus the overlap at (i, j) equals the total number of walls\n        if row_walls[i] + col_walls[j] - (grid[i][j] == '*') == total_walls:\n            print('YES')\n            print(i + 1, j + 1)\n            exit()\n\n# If no such cell is found\nprint('NO')"}
{"solution": "def min_burles(n, m, a, b):\n    # Calculate the remainder of n divided by m\n    remainder = n % m\n\n    # If the remainder is 0, no action is needed\n    if remainder == 0:\n        return 0\n\n    # Calculate the number of boxes to add and remove\n    add_boxes = m - remainder\n    remove_boxes = remainder\n\n    # Calculate the cost of adding and removing boxes\n    add_cost = add_boxes * a\n    remove_cost = remove_boxes * b\n\n    # Return the minimum cost\n    return min(add_cost, remove_cost)\n\n# Get the input\nn, m, a, b = map(int, input().split())\n\n# Print the output\nprint(min_burles(n, m, a, b))"}
{"solution": "# Read the input\nn = int(input())\nseq = list(map(int, input().split()))\n\n# Separate the odd and even numbers\nodd_nums = [num for num in seq if num % 2 != 0]\neven_nums = [num for num in seq if num % 2 == 0]\n\n# Sort the odd numbers in descending order\nodd_nums.sort(reverse=True)\n\n# If there are odd numbers, the maximum odd sum is the sum of all odd numbers\nif odd_nums:\n    print(sum(odd_nums))\n# If there are no odd numbers, the maximum odd sum is the largest odd number in the sequence\nelse:\n    print(max(even_nums))"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(n, T, songs):\n    dp = [[[0] * 4 for _ in range(4)] for _ in range(T + 1)]\n    dp[0][0][0] = 1\n\n    for i in range(1, T + 1):\n        for j in range(1, 4):\n            for k in range(1, 4):\n                for l in range(n):\n                    if i >= songs[l][0] and k != songs[l][1]:\n                        dp[i][j][k] = (dp[i][j][k] + dp[i - songs[l][0]][j - 1][songs[l][1]]) % MOD\n\n    return sum(dp[T][3]) % MOD\n\nn, T = map(int, input().split())\nsongs = [list(map(int, input().split())) for _ in range(n)]\nprint(solve(n, T, songs))"}
{"solution": "import math\n\ndef expected_length(m):\n    MOD = 10**9 + 7\n    phi = [i for i in range(m + 1)]\n    for i in range(2, m + 1):\n        if phi[i] == i:\n            for j in range(i, m + 1, i):\n                phi[j] -= phi[j] // i\n    inv = [0] * (m + 1)\n    inv[1] = 1\n    for i in range(2, m + 1):\n        inv[i] = (MOD - MOD // i) * inv[MOD % i] % MOD\n    dp = [0] * (m + 1)\n    dp[1] = 1\n    for i in range(2, m + 1):\n        dp[i] = (dp[i - 1] + phi[i]) * inv[i] % MOD\n    return dp[m]\n\nm = int(input())\nresult = expected_length(m)\nprint(result)"}
{"solution": "import math\n\ndef count_good_pairs(l, r, x, y):\n    # Check if the given x and y are valid\n    if x * y != l * r or y % x != 0:\n        return 0\n\n    # Count the number of good pairs\n    count = 0\n    for a in range(max(x, l), min(r, y) + 1):\n        if a % x == 0:\n            b = y * a // math.gcd(a, y)\n            if l <= b <= r and a != b:\n                count += 2\n\n    return count\n\n# Read the input\nl, r, x, y = map(int, input().split())\n\n# Print the result\nprint(count_good_pairs(l, r, x, y))"}
{"solution": "import math\n\n# Function to calculate the greatest common divisor (GCD)\ndef gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\n# Function to calculate the least common multiple (LCM)\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\n# Function to find the smallest non-negative integer k\ndef find_k(a, b):\n    min_lcm = float('inf')\n    k = 0\n    while True:\n        current_lcm = lcm(a + k, b + k)\n        if current_lcm < min_lcm:\n            min_lcm = current_lcm\n        else:\n            return k - 1\n        k += 1\n\n# Read input\na, b = map(int, input().split())\n\n# Find and print the result\nresult = find_k(a, b)\nprint(result)"}
{"solution": "# Read the input\nn, k = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Calculate the current average\ncurrent_avg = sum(marks) / n\n\n# Calculate the difference between the desired average and the current average\ndiff = k - current_avg\n\n# Calculate the number of additional marks needed\n# If the difference is less than 1, it means that Noora already has an average of k or more\n# In this case, no additional marks are needed\nif diff < 1:\n    print(0)\nelse:\n    # Otherwise, calculate the number of additional marks needed\n    # This is equal to the difference between the desired average and the current average,\n    # rounded up to the nearest integer\n    # This is because the additional marks must be integers from 1 to k\n    # Multiply the number of additional marks needed by n to get the total number of additional marks\n    # that need to be added to the register\n    print(n * int(diff + 0.999))"}
{"solution": "# Read the input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Initialize the count of positive numbers\npositive_count = 0\n\n# Iterate through possible values of d\nfor d in range(-10**3, 10**3 + 1):\n    if d == 0:\n        continue\n\n    # Count the number of positive numbers after division\n    positive_count = sum(1 for num in arr if num / d > 0)\n\n    # Check if the condition is satisfied\n    if positive_count >= (n + 1) // 2:\n        print(d)\n        break\n\n# If no such d is found, print 0\nelse:\n    print(0)"}
{"solution": "def max_nines_pairs(n):\n    # Calculate the maximum possible number of nines at the end of the sum\n    max_nines = n // 10\n\n    # Calculate the number of pairs that sum to a number ending in max_nines\n    # This is equal to the number of ways to choose 2 numbers from 1 to n that add up to max_nines + 1\n    # Since the sum is even, we can divide it by 2 and find the number of pairs that add up to that\n    target = (max_nines + 1) // 2\n\n    # If the target is greater than n, there are no such pairs\n    if target > n:\n        return 0\n\n    # If the sum is odd, there are n - target pairs that add up to the target\n    # If the sum is even, there are n - target - 1 pairs that add up to the target (excluding the pair (target, target))\n    if (max_nines + 1) % 2 == 1:\n        return n - target\n    else:\n        return max(0, n - target - 1)\n\n# Read the input\nn = int(input())\n\n# Print the output\nprint(max_nines_pairs(n))"}
{"solution": "def gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef solve(a, b):\n    if a > b:\n        a, b = b, a\n    if a == 1 and b == 1:\n        return -1\n    if a == 1:\n        if b % 3 == 0:\n            return 1, (1, b//3), (1, 2*b//3)\n        if b % 2 == 0:\n            return 1, (1, b//2), (1, b//2)\n        return -1\n    if 2*a > b:\n        return -1\n    if 2*a == b:\n        return 1, (a, a), (a, a)\n    if 3*a > b:\n        if b % 3 == 0:\n            return 2, (a, b//3), (2*a, b//3)\n        return -1\n    if 3*a == b:\n        return 2, (a, a), (2*a, a)\n    if 4*a > b:\n        if b % 2 == 0:\n            return 2, (2*a, b//2), (2*a, b//2)\n        return -1\n    if 4*a == b:\n        return 2, (2*a, 2*a), (2*a, 2*a)\n    return -1\n\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\n\nif a1*b1 > a2*b2:\n    a1, b1, a2, b2 = a2, b2, a1, b1\n\ng = gcd(a1*b1, a2*b2)\na1 //= g\nb1 //= g\na2 //= g\nb2 //= g\n\nif a1*b1 == a2*b2:\n    print(0)\n    print(a1, b1)\n    print(a2, b2)\nelse:\n    res = solve(a1, a2)\n    if res == -1:\n        print(-1)\n    else:\n        m, (a1, b1), (a2, b2) = res\n        print(m)\n        print(a1*g, b1*g)\n        print(a2*g, b2*g)"}
{"solution": "def determine_winner(x_p, y_p, x_v, y_v):\n    # If Polycarp's pawn is already at (0, 0), he wins\n    if x_p == 0 and y_p == 0:\n        return \"Polycarp\"\n    # If Vasiliy's pawn is already at (0, 0), he wins\n    if x_v == 0 and y_v == 0:\n        return \"Vasiliy\"\n    # If both pawns are in the same row or column, Polycarp wins\n    if x_p == x_v or y_p == y_v:\n        return \"Polycarp\"\n    # If Vasiliy's pawn is diagonally above Polycarp's pawn, Vasiliy wins\n    if x_v < x_p and y_v < y_p:\n        return \"Vasiliy\"\n    # Otherwise, Polycarp wins\n    return \"Polycarp\"\n\n# Get the starting coordinates of both pawns\nx_p, y_p, x_v, y_v = map(int, input().split())\n\n# Determine the winner\nwinner = determine_winner(x_p, y_p, x_v, y_v)\n\n# Print the winner\nprint(winner)"}
{"solution": "# Get the input\nm, d = map(int, input().split())\n\n# Define the number of days in each month\ndays_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n# Calculate the number of days in the first partial week\nfirst_partial_week = 7 - d + 1\n\n# Calculate the number of full weeks\nfull_weeks = (days_in_month[m - 1] - first_partial_week) // 7\n\n# Calculate the number of days in the last partial week\nlast_partial_week = (days_in_month[m - 1] - first_partial_week) % 7\n\n# Calculate the total number of columns\nif last_partial_week > 0:\n    total_columns = full_weeks + 2\nelse:\n    total_columns = full_weeks + 1\n\n# Print the result\nprint(total_columns)"}
{"solution": "def count_years(a, b):\n    def count_zeros(n):\n        return bin(n).count('1') == len(bin(n)) - 3\n\n    def count_in_range(n):\n        if n < 10:\n            return 1 if count_zeros(n) else 0\n        power = 1\n        while power * 2 <= n:\n            power *= 2\n        power //= 2\n        left = count_in_range(power - 1)\n        right = count_in_range(n - power)\n        return left + right + (1 if count_zeros(power) else 0)\n\n    return count_in_range(b) - count_in_range(a - 1)\n\na, b = map(int, input().split())\nprint(count_years(a, b))"}
{"solution": "def minimal_layers(N):\n    return (N * (N + 1)) // 2\n\n# Get input\nN = int(input())\n\n# Print output\nprint(minimal_layers(N))"}
{"solution": "import sys\nfrom math import factorial\n\ndef solve(n, k, S, a):\n    dp = [[0] * (S + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(S + 1):\n            dp[i][j] = dp[i - 1][j]\n            if a[i - 1] <= j:\n                dp[i][j] += dp[i - 1][j - a[i - 1]]\n            if k > 0 and a[i - 1] <= 20 and factorial(a[i - 1]) <= j:\n                dp[i][j] += dp[i - 1][j - factorial(a[i - 1])]\n\n    return dp[n][S]\n\ndef main():\n    n, k, S = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    print(solve(n, k, S, a))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def can_transform(n, k, a):\n    # Create a set to store the possible values that can be obtained\n    possible_values = set()\n\n    # Iterate through the array\n    for i in range(n):\n        # If the current value is not in the set of possible values,\n        # and it's not zero, then it's impossible to transform the array\n        if a[i] not in possible_values and a[i] != 0:\n            return False\n\n        # Add the current value and the value that can be obtained by skipping this step\n        # to the set of possible values\n        possible_values.add(a[i])\n        possible_values.add(a[i] - k**i)\n\n    # If we've made it through the entire array, then it's possible to transform the array\n    return True\n\n# Read the number of test cases\nT = int(input())\n\n# Iterate through the test cases\nfor _ in range(T):\n    # Read the size of the array and the value of k\n    n, k = map(int, input().split())\n\n    # Read the array\n    a = list(map(int, input().split()))\n\n    # Print the result\n    print('YES' if can_transform(n, k, a) else 'NO')"}
{"solution": "def count_divisors(n):\n    count = 0\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n        i += 1\n    return count\n\ndef sum_of_divisors(a, b, c):\n    mod = 1073741824\n    total = 0\n    for i in range(1, a + 1):\n        for j in range(1, b + 1):\n            for k in range(1, c + 1):\n                total = (total + count_divisors(i * j * k)) % mod\n    return total\n\na, b, c = map(int, input().split())\nprint(sum_of_divisors(a, b, c))"}
{"solution": "from collections import deque\n\ndef get_neighbors(state):\n    neighbors = []\n    idx = state.index('X')\n    if idx == 0:\n        neighbors.append(swap(state, 0, 1))\n        neighbors.append(swap(state, 0, 2))\n    elif idx == 1:\n        neighbors.append(swap(state, 1, 0))\n        neighbors.append(swap(state, 1, 3))\n    elif idx == 2:\n        neighbors.append(swap(state, 2, 0))\n        neighbors.append(swap(state, 2, 3))\n    elif idx == 3:\n        neighbors.append(swap(state, 3, 1))\n        neighbors.append(swap(state, 3, 2))\n    return neighbors\n\ndef swap(state, i, j):\n    state = list(state)\n    state[i], state[j] = state[j], state[i]\n    return ''.join(state)\n\ndef bfs(start):\n    queue = deque([start])\n    visited = set([start])\n    while queue:\n        current = queue.popleft()\n        for neighbor in get_neighbors(current):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    return visited\n\ndef can_be_same_configuration(bessie, elsie):\n    bessie_start = ''.join(bessie)\n    elsie_start = ''.join(elsie)\n\n    bessie_reachable = bfs(bessie_start)\n    elsie_reachable = bfs(elsie_start)\n\n    return not bessie_reachable.isdisjoint(elsie_reachable)\n\n# Input reading\nbessie = [input().strip() for _ in range(2)]\nelsie = [input().strip() for _ in range(2)]\n\nif can_be_same_configuration(bessie, elsie):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def convert_to_decimal(n, k):\n    decimal = 0\n    power = 0\n    while k > 0:\n        decimal += (k % 10) * (n ** power)\n        k //= 10\n        power += 1\n    return decimal\n\ndef find_min_decimal(n, k):\n    decimal = convert_to_decimal(n, k)\n    i = 0\n    while True:\n        if str(decimal) == str(decimal)[::-1]:\n            return decimal\n        decimal = convert_to_decimal(n, k + i)\n        i += 1\n\nn = int(input())\nk = int(input())\nprint(find_min_decimal(n, k))"}
{"solution": "# Read the number of elements\nn = int(input())\n\n# Read the elements of the array\narr = list(map(int, input().split()))\n\n# Initialize variables to track the state of the array\nincreasing = True\ndecreasing = False\n\n# Iterate through the array\nfor i in range(1, n):\n    # If the array is still increasing\n    if increasing:\n        # If the current element is less than the previous one\n        if arr[i] < arr[i - 1]:\n            # The array is no longer increasing\n            increasing = False\n            # The array is now decreasing\n            decreasing = True\n        # If the current element is equal to the previous one\n        elif arr[i] == arr[i - 1]:\n            # The array is still increasing\n            increasing = True\n            # The array is not decreasing yet\n            decreasing = False\n        # If the current element is greater than the previous one\n        else:\n            # The array is still increasing\n            increasing = True\n            # The array is not decreasing yet\n            decreasing = False\n    # If the array is decreasing\n    elif decreasing:\n        # If the current element is greater than or equal to the previous one\n        if arr[i] >= arr[i - 1]:\n            # The array is no longer unimodal\n            print(\"NO\")\n            # Exit the program\n            exit()\n\n# If the array is unimodal\nprint(\"YES\")"}
{"solution": "def count_paths(n, k):\n    left = 1\n    right = n\n    result = 0\n\n    while left <= right:\n        mid = (left + right) // 2\n        count = 0\n\n        # Count the number of paths that contain the mid value\n        x = mid\n        while x <= n:\n            count += (n - x + 1)\n            x = (x << 1) + 1\n\n        if count >= k:\n            result = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return result\n\n# Read input\nn, k = map(int, input().split())\n\n# Find the maximum value that appears in at least k paths\nmax_value = count_paths(n, k)\n\n# Print the result\nprint(max_value)"}
{"solution": "def find_pocket(n, m, x, y, vx, vy):\n    # If the ball is moving vertically\n    if vx == 0:\n        if vy > 0:\n            return -1, m\n        else:\n            return -1, 0\n    # If the ball is moving horizontally\n    elif vy == 0:\n        if vx > 0:\n            return n, -1\n        else:\n            return 0, -1\n    # If the ball is moving diagonally\n    else:\n        # Calculate the time it takes for the ball to reach the vertical boundaries\n        t_vertical = (n - x) / vx if vx > 0 else x / -vx\n        # Calculate the time it takes for the ball to reach the horizontal boundaries\n        t_horizontal = (m - y) / vy if vy > 0 else y / -vy\n\n        # If the ball reaches the vertical boundaries first\n        if t_vertical < t_horizontal:\n            # Calculate the y-coordinate of the intersection point\n            y_intersect = y + vy * t_vertical\n            # If the y-coordinate is within the table's boundaries\n            if 0 <= y_intersect <= m:\n                # Return the corresponding pocket\n                return (n, y_intersect) if vx > 0 else (0, y_intersect)\n            else:\n                return -1, -1\n        # If the ball reaches the horizontal boundaries first\n        else:\n            # Calculate the x-coordinate of the intersection point\n            x_intersect = x + vx * t_horizontal\n            # If the x-coordinate is within the table's boundaries\n            if 0 <= x_intersect <= n:\n                # Return the corresponding pocket\n                return (x_intersect, m) if vy > 0 else (x_intersect, 0)\n            else:\n                return -1, -1\n\n# Read the input\nn, m, x, y, vx, vy = map(int, input().split())\n# Find the pocket\npocket = find_pocket(n, m, x, y, vx, vy)\n# Print the output\nprint(*pocket)"}
{"solution": "def can_place_paintings(a1, b1, a2, b2, a3, b3):\n    def fits(w1, h1, w2, h2, W, H):\n        return (w1 + w2 <= W and max(h1, h2) <= H) or (h1 + h2 <= H and max(w1, w2) <= W)\n\n    if (fits(a2, b2, a3, b3, a1, b1) or fits(b2, a2, a3, b3, a1, b1) or\n        fits(a2, b2, b3, a3, a1, b1) or fits(b2, a2, b3, a3, a1, b1) or\n        fits(a3, b3, a2, b2, a1, b1) or fits(b3, a3, a2, b2, a1, b1) or\n        fits(a3, b3, b2, a2, a1, b1) or fits(b3, a3, b2, a2, a1, b1)):\n        return \"YES\"\n    else:\n        return \"NO\"\n\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\na3, b3 = map(int, input().split())\nprint(can_place_paintings(a1, b1, a2, b2, a3, b3))"}
{"solution": "def calculate_terms(b1, q, l, m, bad_integers):\n    count = 0\n    term = b1\n\n    while abs(term) <= l:\n        if term not in bad_integers:\n            count += 1\n        term *= q\n\n    if count == 0 and b1 != 0:\n        return \"inf\"\n    else:\n        return count\n\n# Read input\nb1, q, l, m = map(int, input().split())\nbad_integers = set(map(int, input().split()))\n\n# Calculate and print the result\nresult = calculate_terms(b1, q, l, m, bad_integers)\nprint(result)"}
{"solution": "def find_smallest_frame(grid):\n    rows, cols = len(grid), len(grid[0])\n    min_size = float('inf')\n    min_frame = None\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == 'w':\n                size = min(r, c, rows - r - 1, cols - c - 1)\n                if size < min_size:\n                    min_size = size\n                    min_frame = (r, c, size)\n\n    return min_frame\n\ndef draw_frame(grid, frame):\n    r, c, size = frame\n    for i in range(c - size, c + size + 1):\n        grid[r - size] = grid[r - size][:i] + '+' + grid[r - size][i + 1:]\n        grid[r + size] = grid[r + size][:i] + '+' + grid[r + size][i + 1:]\n    for i in range(r - size + 1, r + size):\n        grid[i] = grid[i][:c - size] + '+' + grid[i][c - size + 1:]\n        grid[i] = grid[i][:c + size + 1] + '+' + grid[i][c + size + 2:]\n\nn, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\n\nframe = find_smallest_frame(grid)\nif frame is None:\n    print(-1)\nelse:\n    draw_frame(grid, frame)\n    for row in grid:\n        print(row)"}
{"solution": "def find_solution(n, a, b):\n    for x in range(n // a + 1):\n        for y in range(n // b + 1):\n            if x * a + y * b == n:\n                return x, y\n    return None\n\nn = int(input())\na = int(input())\nb = int(input())\n\nsolution = find_solution(n, a, b)\n\nif solution is None:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(*solution)"}
{"solution": "def number_to_words(s):\n    ones = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n\n    if 0 <= s <= 9:\n        return ones[s]\n    elif 10 <= s <= 19:\n        return teens[s - 10]\n    elif 20 <= s <= 99:\n        if s % 10 == 0:\n            return tens[s // 10]\n        else:\n            return tens[s // 10] + \"-\" + ones[s % 10]\n\n# Get the input\ns = int(input())\n\n# Print the output\nprint(number_to_words(s))"}
{"solution": "# Read the input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Initialize the maximum number of consecutive elements that can be erased\nmax_erase = 0\n\n# Iterate over the array\nfor i in range(n):\n    # Check if the current element can be erased\n    if (i == 0 or arr[i] - arr[i - 1] > 1) and (i == n - 1 or arr[i + 1] - arr[i] > 1):\n        # Calculate the number of consecutive elements that can be erased\n        erase = 0\n        j = i + 1\n        while j < n and arr[j] - arr[j - 1] == 1:\n            erase += 1\n            j += 1\n        # Update the maximum number of consecutive elements that can be erased\n        max_erase = max(max_erase, erase)\n\n# Print the result\nprint(max_erase)"}
{"solution": "# Read the input\nn = int(input())\nproblems = list(map(int, input().split()))\n\n# Calculate the total number of problems\ntotal_problems = sum(problems)\n\n# Calculate the half of the total problems\nhalf_problems = total_problems // 2\n\n# Initialize the cumulative sum of problems solved\ncumulative_sum = 0\n\n# Iterate over the days\nfor i in range(n):\n    # Add the problems solved on the current day to the cumulative sum\n    cumulative_sum += problems[i]\n\n    # Check if the cumulative sum is greater than or equal to half of the total problems\n    if cumulative_sum >= half_problems:\n        # Print the index of the current day\n        print(i + 1)\n        break"}
{"solution": "import sys\n\ndef min_steps(n, board):\n    # Initialize the 3D array with maximum possible values\n    dp = [[[sys.maxsize for _ in range(3)] for _ in range(n*n+1)] for _ in range(3)]\n\n    # Define the possible moves for each piece\n    moves = [\n        [(2, 1), (1, 2)],\n        [(1, 1), (-1, 1), (1, -1), (-1, -1)],\n        [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    ]\n\n    # Define the pieces\n    pieces = ['knight', 'bishop', 'rook']\n\n    # Define the starting position\n    start = (0, 0)\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                start = (i, j)\n                break\n\n    # Initialize the dp array for the starting position\n    for i in range(3):\n        dp[i][1][i] = 0\n\n    # Fill the dp array\n    for num in range(2, n*n+1):\n        for i in range(n):\n            for j in range(n):\n                if board[i][j] == num:\n                    for k in range(3):\n                        for move in moves[k]:\n                            ni, nj = i + move[0], j + move[1]\n                            if 0 <= ni < n and 0 <= nj < n and board[ni][nj] < num:\n                                for l in range(3):\n                                    dp[k][num][l] = min(dp[k][num][l], dp[l][board[ni][nj]][k] + 1)\n\n    # Find the minimum number of steps and replacements\n    min_steps = sys.maxsize\n    min_replacements = sys.maxsize\n    for i in range(3):\n        for j in range(3):\n            min_steps = min(min_steps, dp[i][n*n][j])\n            if dp[i][n*n][j] == min_steps:\n                min_replacements = min(min_replacements, sum(dp[i][num][j] != dp[i][num-1][j] for num in range(2, n*n+1)))\n\n    return min_steps, min_replacements\n\n# Read the input\nn = int(input())\nboard = [list(map(int, input().split())) for _ in range(n)]\n\n# Print the output\nprint(*min_steps(n, board))"}
{"solution": "def min_time(n, m, k, a, b):\n    # Calculate the positions of Edward's and Natasha's apartments\n    a_pos = (a - 1) // (m * k), (a - 1) % (m * k) // k\n    b_pos = (b - 1) // (m * k), (b - 1) % (m * k) // k\n\n    # Calculate the distance between the apartments in terms of apartments and floors\n    dist_apartments = min(abs(a_pos[0] - b_pos[0]), n - abs(a_pos[0] - b_pos[0]))\n    dist_floors = abs(a_pos[1] - b_pos[1])\n\n    # Calculate the time it takes to move between apartments using the elevator\n    time_elevator = 10 + dist_floors\n\n    # Calculate the time it takes to move between apartments using the stairs\n    time_stairs = dist_apartments * 15 + dist_floors * 5\n\n    # Return the minimum time\n    return min(time_elevator, time_stairs)\n\n# Read the input\nn, m, k = map(int, input().split())\na, b = map(int, input().split())\n\n# Print the result\nprint(min_time(n, m, k, a, b))"}
{"solution": "def is_divisible_by_64(binary_string):\n    # Count the number of 1s in the binary string\n    count_ones = binary_string.count('1')\n\n    # If the count of 1s is less than 6, it's not possible to form a number divisible by 64\n    if count_ones < 6:\n        return False\n\n    # Find the position of the 6th last 1 in the binary string\n    position_sixth_last_one = len(binary_string) - binary_string[::-1].index('1') - 1\n\n    # Check if there are at least 6 zeros after the 6th last 1\n    if '1' in binary_string[position_sixth_last_one + 1:position_sixth_last_one + 7]:\n        return False\n\n    return True\n\n# Read the binary string from input\nbinary_string = input()\n\n# Check if it's possible to remove digits to form a number divisible by 64\nif is_divisible_by_64(binary_string):\n    print('yes')\nelse:\n    print('no')"}
{"solution": "def transform_string(s):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    i = 0\n    result = ''\n    for char in s:\n        while i < 26 and char > alphabet[i]:\n            result += alphabet[i]\n            i += 1\n        if i < 26 and char == alphabet[i]:\n            result += char\n            i += 1\n    if i == 26:\n        return result\n    else:\n        return -1\n\ns = input()\nprint(transform_string(s))"}
{"solution": "def calculate_expected_value(n, m, r, k):\n    total_cells = n * m\n    total_scoop_positions = (n - r + 1) * (m - r + 1)\n    max_fish_per_scoop = r * r\n\n    # If the number of fishes is greater than the total number of cells,\n    # then all fishes will be caught in every scoop position.\n    if k >= total_cells:\n        return total_cells\n\n    # If the scoop size is greater than or equal to the pond size,\n    # then all fishes will be caught in every scoop position.\n    if r >= n or r >= m:\n        return k\n\n    # Calculate the expected value using the formula:\n    # expected_value = (number_of_fishes * max_fish_per_scoop) / total_scoop_positions\n    expected_value = (k * max_fish_per_scoop) / total_scoop_positions\n    return expected_value\n\n# Read the input values\nn, m, r, k = map(int, input().split())\n\n# Calculate the maximum possible expected number of caught fishes\nresult = calculate_expected_value(n, m, r, k)\n\n# Print the result\nprint(result)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\n# Count the number of negative numbers\nneg_count = sum(1 for num in a if num < 0)\n\n# If there are an odd number of negative numbers, we need to flip the smallest absolute value\nif neg_count % 2 != 0:\n    min_abs = min(abs(num) for num in a)\n    for i in range(n):\n        if abs(a[i]) == min_abs:\n            a[i] = -a[i] - 1\n            break\n\n# Flip all the numbers to get the maximum product\nfor i in range(n):\n    a[i] = -a[i] - 1\n\nprint(*a)"}
{"solution": "import math\n\ndef find_kth_divisor(n, k):\n    divisors = []\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    divisors.sort()\n    if k > len(divisors):\n        return -1\n    else:\n        return divisors[k - 1]\n\nn, k = map(int, input().split())\nprint(find_kth_divisor(n, k))"}
{"solution": "from itertools import permutations, product\n\ndef is_valid(cubes, num):\n    num_str = str(num)\n    for i in range(len(num_str)):\n        found = False\n        for cube in cubes:\n            if int(num_str[i]) in cube:\n                found = True\n                break\n        if not found:\n            return False\n    return True\n\ndef solve(cubes):\n    for i in range(1000, 0, -1):\n        if is_valid(cubes, i):\n            return i\n    return 0\n\nn = int(input())\ncubes = [list(map(int, input().split())) for _ in range(n)]\n\nprint(solve(cubes))"}
{"solution": "def k_rounding(n, k):\n    # Calculate the multiplier required to make n end with k or more zeros\n    multiplier = 10 ** k\n    # Calculate the k-rounding of n\n    k_rounded = ((n + multiplier - 1) // multiplier) * multiplier\n    return k_rounded\n\n# Read the input\nn, k = map(int, input().split())\n# Calculate the k-rounding of n\nresult = k_rounding(n, k)\n# Print the result\nprint(result)"}
{"solution": "def transform_matrix(n, m, A):\n    operations = []\n    B = [[0] * m for _ in range(n)]\n\n    for i in range(n - 1):\n        for j in range(m - 1):\n            if A[i][j] == 1 and A[i][j + 1] == 1 and A[i + 1][j] == 1 and A[i + 1][j + 1] == 1:\n                operations.append((i + 1, j + 1))\n                B[i][j] = B[i][j + 1] = B[i + 1][j] = B[i + 1][j + 1] = 1\n\n    for i in range(n):\n        for j in range(m):\n            if A[i][j] != B[i][j]:\n                return -1\n\n    return operations\n\n# Input reading\nn, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\n\n# Process the transformation\nresult = transform_matrix(n, m, A)\n\n# Output the result\nif result == -1:\n    print(-1)\nelse:\n    print(len(result))\n    for x, y in result:\n        print(x, y)"}
{"solution": "def calculate_probabilities(r, s, p):\n    dp = [[[0.0] * (p + 1) for _ in range(s + 1)] for _ in range(r + 1)]\n    dp[r][s][p] = 1.0\n\n    for i in range(r, -1, -1):\n        for j in range(s, -1, -1):\n            for k in range(p, -1, -1):\n                if i == 0 and j == 0 and k == 0:\n                    continue\n\n                total = i * j + i * k + j * k\n\n                if i > 0:\n                    dp[i - 1][j][k] += dp[i][j][k] * i * j / total\n                    dp[i - 1][j][k] += dp[i][j][k] * i * k / total\n\n                if j > 0:\n                    dp[i][j - 1][k] += dp[i][j][k] * i * j / total\n                    dp[i][j - 1][k] += dp[i][j][k] * j * k / total\n\n                if k > 0:\n                    dp[i][j][k - 1] += dp[i][j][k] * i * k / total\n                    dp[i][j][k - 1] += dp[i][j][k] * j * k / total\n\n    rock_prob = sum(dp[i][0][0] for i in range(1, r + 1))\n    scissors_prob = sum(dp[0][i][0] for i in range(1, s + 1))\n    paper_prob = sum(dp[0][0][i] for i in range(1, p + 1))\n\n    return rock_prob, scissors_prob, paper_prob\n\nr, s, p = map(int, input().split())\nrock_prob, scissors_prob, paper_prob = calculate_probabilities(r, s, p)\nprint(rock_prob, scissors_prob, paper_prob)"}
{"solution": "# Get the input\nl_1, r_1, l_2, r_2, k = map(int, input().split())\n\n# Calculate the overlapping time\noverlap = max(0, min(r_1, r_2) - max(l_1, l_2) + 1)\n\n# If Sonya prinks during the overlapping time, subtract one minute\nif l_2 <= k <= r_2 and l_1 <= k <= r_1:\n    overlap -= 1\n\n# Print the result\nprint(overlap)"}
{"solution": "import sys\nfrom bisect import bisect_left, bisect_right\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    ns = sorted([tuple(map(int, sys.stdin.readline().split())) for _ in range(n)])\n    ms = sorted([tuple(map(int, sys.stdin.readline().split())) for _ in range(m)])\n\n    xs = [0] * (2 * n + 1)\n    ys = [0] * (2 * m + 1)\n    for i, (a, b, c) in enumerate(ns):\n        xs[i * 2] = c\n        xs[i * 2 + 1] = c\n    for i, (d, e, f) in enumerate(ms):\n        ys[i * 2] = d\n        ys[i * 2 + 1] = d\n    xs.sort()\n    ys.sort()\n\n    def get_area(xs, ys):\n        area = 0\n        prev = 0\n        for x in xs:\n            i = bisect_left(ys, x)\n            j = bisect_right(ys, x)\n            if i % 2 == 1:\n                if j < len(ys) and ys[j] == x:\n                    j += 1\n                if j == len(ys) or ys[j] > x:\n                    return float('inf')\n            if i > 0 and ys[i - 1] == x:\n                i -= 1\n            if i < j:\n                area += ys[j - 1] - ys[i]\n            prev = x\n        return area\n\n    x_area = get_area(xs, [p for a, b, p in ns])\n    y_area = get_area(ys, [p for d, p, f in ms])\n    if x_area == float('inf') or y_area == float('inf'):\n        print('INF')\n    else:\n        print(x_area + y_area)\n\nif __name__ == '__main__':\n    main()"}
{"solution": "# Get the input values\nt, s, x = map(int, input().split())\n\n# Calculate the number of barking cycles before time x\ncycles = (x - t) // s\n\n# Calculate the time of the last bark in the previous cycle\nlast_bark_prev_cycle = t + cycles * s\n\n# Check if the pineapple will bark at time x\nif x == last_bark_prev_cycle or x == last_bark_prev_cycle + 1:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def find_segments(n, segments):\n    # Sort the segments based on their left endpoints\n    segments.sort(key=lambda x: x[0])\n\n    # Initialize the stack with the first segment\n    stack = [segments[0]]\n\n    # Iterate through the remaining segments\n    for i in range(1, n):\n        # If the current segment lies within the top segment of the stack, return the indices\n        if segments[i][0] >= stack[-1][0] and segments[i][1] <= stack[-1][1]:\n            return stack[-1][2], segments[i][2]\n\n        # If the current segment doesn't overlap with the top segment of the stack, push it onto the stack\n        if segments[i][0] > stack[-1][1]:\n            stack.append(segments[i])\n\n        # If the current segment overlaps with the top segment of the stack, update the top segment\n        else:\n            stack[-1] = (stack[-1][0], max(stack[-1][1], segments[i][1]), stack[-1][2])\n\n    # If no answer exists, return -1 -1\n    return -1, -1\n\n# Read the input\nn = int(input())\nsegments = [tuple(map(int, input().split())) + (i+1,) for i in range(n)]\n\n# Find the indices and print the output\ni, j = find_segments(n, segments)\nprint(i, j)"}
{"solution": "# Read the input\nn = int(input())\ns = input()\n\n# Count the occurrences of each nucleotide\ncounts = {'A': 0, 'C': 0, 'G': 0, 'T': 0}\nfor nucleotide in s:\n    if nucleotide != '?':\n        counts[nucleotide] += 1\n\n# Check if it's possible to decode the genome\nif max(counts.values()) - min(counts.values()) > n // 4:\n    print(\"===\")\nelse:\n    # Decode the genome\n    decoded = list(s)\n    for i in range(n):\n        if decoded[i] == '?':\n            for nucleotide in 'ACGT':\n                if counts[nucleotide] < n // 4:\n                    decoded[i] = nucleotide\n                    counts[nucleotide] += 1\n                    break\n    print(''.join(decoded))"}
{"solution": "def check_win(board):\n    # Check rows\n    for row in board:\n        if row.count('x') == 3 and row.count('.') == 1:\n            return True\n\n    # Check columns\n    for col in range(4):\n        if [board[row][col] for row in range(4)].count('x') == 3 and [board[row][col] for row in range(4)].count('.') == 1:\n            return True\n\n    # Check diagonals\n    if [board[i][i] for i in range(4)].count('x') == 3 and [board[i][i] for i in range(4)].count('.') == 1:\n        return True\n    if [board[i][3-i] for i in range(4)].count('x') == 3 and [board[i][3-i] for i in range(4)].count('.') == 1:\n        return True\n\n    return False\n\n# Read the board\nboard = [input() for _ in range(4)]\n\n# Check if Ilya could have won\nif check_win(board):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\ntotal_sum = sum(a)\nleft_sum = 0\n\nfor i in range(n):\n    right_sum = total_sum - left_sum - a[i]\n    left_sum += a[i]\n\n    if left_sum == right_sum:\n        print(\"YES\")\n        exit()\n\n    for j in range(n):\n        if i == j:\n            continue\n\n        new_left_sum = left_sum - a[i] + a[j]\n        new_right_sum = right_sum + a[i] - a[j]\n\n        if new_left_sum == new_right_sum:\n            print(\"YES\")\n            exit()\n\nprint(\"NO\")"}
{"solution": "def solve(n, k, a, b):\n    a_zeros = [i for i, x in enumerate(a) if x == 0]\n    b.sort()\n\n    def backtrack(i=0):\n        if i == len(a_zeros):\n            return True\n        for j in range(len(b)):\n            if (i == 0 or b[j] < a[a_zeros[i] - 1]) and (i == len(a_zeros) - 1 or b[j] > a[a_zeros[i] + 1]):\n                a[a_zeros[i]] = b[j]\n                del b[j]\n                if backtrack(i + 1):\n                    return True\n                b.insert(j, a[a_zeros[i]])\n                a[a_zeros[i]] = 0\n        return False\n\n    return 'Yes' if backtrack() else 'No'\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nprint(solve(n, k, a, b))"}
{"solution": "# Get the input\nx, y, z = map(int, input().split())\na, b, c = map(int, input().split())\n\n# Check if Andrew can eat enough green grapes\nif x > a:\n    print(\"NO\")\nelse:\n    # Subtract the green grapes Andrew will eat from the total\n    a -= x\n    # Check if Dmitry can eat enough non-black grapes\n    if y > a + b:\n        print(\"NO\")\n    else:\n        # Subtract the non-black grapes Dmitry will eat from the total\n        y -= min(y, a)\n        a -= min(y, a)\n        # Check if Michal can eat the remaining grapes\n        if z > a + b + c:\n            print(\"NO\")\n        else:\n            print(\"YES\")"}
{"solution": "# Get the input\nroad_parts = [list(map(int, input().split())) for _ in range(4)]\n\n# Check for possible accidents\nfor i in range(4):\n    if road_parts[i][3] == 1:  # If pedestrian light is green\n        for j in range(4):\n            if road_parts[j][(i-j)%4] == 1:  # If a lane can get to or from that part and its light is green\n                print(\"YES\")\n                exit()\n\n# If no accident is possible\nprint(\"NO\")"}
{"solution": "def get_coordinates(digit):\n    keypad = {\n        '1': (0, 0), '2': (0, 1), '3': (0, 2),\n        '4': (1, 0), '5': (1, 1), '6': (1, 2),\n        '7': (2, 0), '8': (2, 1), '9': (2, 2),\n        '0': (3, 1)\n    }\n    return keypad[digit]\n\ndef get_vectors(number):\n    vectors = []\n    for i in range(len(number) - 1):\n        x1, y1 = get_coordinates(number[i])\n        x2, y2 = get_coordinates(number[i + 1])\n        vectors.append((x2 - x1, y2 - y1))\n    return vectors\n\ndef is_unique_finger_movement(n, number):\n    original_vectors = get_vectors(number)\n    for i in range(10**(n-1), 10**n):\n        candidate = str(i).zfill(n)\n        if candidate != number:\n            if get_vectors(candidate) == original_vectors:\n                return 'NO'\n    return 'YES'\n\n# Input reading\nn = int(input())\nnumber = input().strip()\n\n# Output the result\nprint(is_unique_finger_movement(n, number))"}
{"solution": "def max_sold_products(n, f, plans):\n    # Calculate the number of products that can be sold on each day\n    def sold_products(k, l):\n        return min(k, l)\n\n    # Calculate the number of products that can be sold on each day with a sell-out\n    def sold_products_sellout(k, l):\n        return min(2 * k, l)\n\n    # Sort the plans by the difference between the number of clients and products\n    plans.sort(key=lambda x: x[1] - x[0])\n\n    # Calculate the total number of products that can be sold without sell-outs\n    total = sum(sold_products(k, l) for k, l in plans)\n\n    # Calculate the additional number of products that can be sold with sell-outs\n    for _ in range(f):\n        k, l = plans.pop()\n        total += sold_products_sellout(k, l) - sold_products(k, l)\n\n    return total\n\n# Read the input\nn, f = map(int, input().split())\nplans = [list(map(int, input().split())) for _ in range(n)]\n\n# Print the output\nprint(max_sold_products(n, f, plans))"}
{"solution": "def max_messiness(n, k):\n    # The maximum messiness is achieved by swapping the first and last cows,\n    # then the second and second-last cows, and so on.\n    # The number of swaps we can make is limited by k.\n    swaps = min(k, n // 2)\n\n    # The maximum messiness is the sum of the first swaps pairs of (i, j)\n    # where i < j and p_i > p_j.\n    # This is equal to the sum of the first swaps numbers from n to 1.\n    messiness = swaps * (n - swaps)\n\n    return messiness\n\nn, k = map(int, input().split())\nprint(max_messiness(n, k))"}
{"solution": "# Get the input values\nn, m, k, l = map(int, input().split())\n\n# Calculate the number of coins each friend needs to gift\ncoins_per_friend = (k + l) // m\n\n# Check if it's possible to meet all the conditions\nif coins_per_friend > n or m > n or l > n - k:\n    print(-1)\nelse:\n    print(coins_per_friend)"}
{"solution": "def min_cells_to_paint(n, m, grid):\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n\n    # Find the bounds of the black cells\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'B':\n                min_row = min(min_row, i)\n                max_row = max(max_row, i)\n                min_col = min(min_col, j)\n                max_col = max(max_col, j)\n\n    # If no black cells are found\n    if min_row == n:\n        return 1\n\n    # Calculate the side length of the square\n    side_length = max(max_row - min_row + 1, max_col - min_col + 1)\n\n    # Check if the square can fit within the grid\n    if side_length > n or side_length > m:\n        return -1\n\n    # Count the number of white cells within the square\n    min_paint = float('inf')\n    for i in range(n - side_length + 1):\n        for j in range(m - side_length + 1):\n            paint_count = 0\n            for x in range(i, i + side_length):\n                for y in range(j, j + side_length):\n                    if grid[x][y] == 'W':\n                        paint_count += 1\n            min_paint = min(min_paint, paint_count)\n\n    return min_paint\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\n\n# Print output\nprint(min_cells_to_paint(n, m, grid))"}
{"solution": "# Read the number of piles\nn = int(input())\n\n# Read the initial number of stones in each pile\nx = list(map(int, input().split()))\n\n# Read the final number of stones in each pile\ny = list(map(int, input().split()))\n\n# Calculate the total number of stones in the initial and final states\ntotal_x = sum(x)\ntotal_y = sum(y)\n\n# Check if the total number of stones is equal in both states\nif total_x != total_y:\n    print(\"No\")\nelse:\n    # Calculate the difference between the initial and final states\n    diff = [y[i] - x[i] for i in range(n)]\n\n    # Check if the difference can be achieved by moving stones between piles\n    if all(d >= 0 for d in diff) or all(d <= 0 for d in diff):\n        print(\"Yes\")\n    else:\n        print(\"No\")"}
{"solution": "# Read the input\nn = int(input())\nangles = list(map(int, input().split()))\n\n# Initialize the total sum of angles and the minimum difference\ntotal_sum = sum(angles)\nmin_diff = total_sum\n\n# Initialize the sum of the first sector\nsector_sum = 0\n\n# Iterate through the angles\nfor i in range(n):\n    # Add the current angle to the sector sum\n    sector_sum += angles[i]\n\n    # Calculate the difference between the sector sum and half of the total sum\n    diff = abs(sector_sum - total_sum // 2)\n\n    # Update the minimum difference\n    min_diff = min(min_diff, diff)\n\n# Print the minimum difference\nprint(min_diff)"}
{"solution": "def calculate_ways(n, m):\n    MOD = 10**9 + 7\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j > 0:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD\n\n    return dp[n][m]\n\nn, m = map(int, input().split())\nresult = calculate_ways(n, m)\nprint(result)"}
{"solution": "def find_pythagorean_triple(n):\n    # Check if n is even\n    if n % 2 == 0:\n        m = n // 2\n        k = (m**2 + n**2) ** 0.5\n        # Check if k is an integer\n        if k.is_integer():\n            return m, int(k)\n    else:\n        # Iterate through possible values of m\n        for m in range(1, n, 2):\n            k = (m**2 + n**2) ** 0.5\n            # Check if k is an integer\n            if k.is_integer():\n                return m, int(k)\n    # No Pythagorean triple found\n    return -1\n\n# Read the input\nn = int(input())\n# Find the Pythagorean triple\nresult = find_pythagorean_triple(n)\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(*result)"}
{"solution": "def check_distinct_remainders(n, k):\n    # Create a set to store remainders\n    remainders = set()\n\n    # Check each integer i from 1 to k\n    for i in range(1, k + 1):\n        # Calculate the remainder of n divided by i\n        remainder = n % i\n\n        # If the remainder is already in the set, return False\n        if remainder in remainders:\n            return False\n\n        # Otherwise, add the remainder to the set\n        remainders.add(remainder)\n\n    # If we've checked all integers and found no duplicates, return True\n    return True\n\n# Get input\nn, k = map(int, input().split())\n\n# Check if all remainders are distinct\nif check_distinct_remainders(n, k):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "# Read input efficiently\na = raw_input().strip('0')\nb = raw_input().strip('0')\n\n# Compare lengths\nif len(a) < len(b):\n    print(\"<\")\nelif len(a) > len(b):\n    print(\">\")\nelse:\n    # Lexicographical comparison if lengths are equal\n    if a < b:\n        print(\"<\")\n    elif a > b:\n        print(\">\")\n    else:\n        print(\"=\")"}
{"solution": "MOD = 10**9 + 7\n\ndef count_ways(n, p, colors):\n    # Initialize a 2D dynamic programming array dp\n    dp = [[0] * 2 for _ in range(n)]\n\n    # Base case: if there is only one piece, there is only one way to color it\n    dp[0][colors[0] == -1] = 1\n\n    # Iterate through the pieces\n    for i in range(1, n):\n        # If the current piece is already colored\n        if colors[i] != -1:\n            # Copy the previous state\n            dp[i][colors[i]] = dp[i - 1][1 - colors[i]]\n        else:\n            # If the current piece is not colored, try both colors\n            dp[i][0] = dp[i - 1][1]\n            dp[i][1] = dp[i - 1][0]\n\n        # If there is a valid arrow from the current piece to the previous piece,\n        # add the number of ways to the current state\n        if i > 1 and colors[i - 2] != -1 and colors[i - 2] != colors[i]:\n            dp[i][colors[i] if colors[i] != -1 else 0] += dp[i - 2][colors[i - 2]]\n            dp[i][colors[i] if colors[i] != -1 else 1] += dp[i - 2][colors[i - 2]]\n\n        # Take the modulo to avoid overflow\n        dp[i][0] %= MOD\n        dp[i][1] %= MOD\n\n    # Return the number of ways to achieve the desired parity\n    return dp[n - 1][p]\n\n# Read the input\nn, p = map(int, input().split())\ncolors = list(map(int, input().split()))\n\n# Print the result\nprint(count_ways(n, p, colors))"}
{"solution": "def min_cost(n, a, b, c):\n    # Calculate the number of copybooks Alyona needs to buy\n    k = (4 - n % 4) % 4\n\n    # Calculate the cost of buying k copybooks using the most cost-effective packs\n    cost = 0\n    while k > 0:\n        if k >= 3 and c <= 2 * a:\n            cost += c\n            k -= 3\n        elif k >= 2 and b <= 2 * a:\n            cost += b\n            k -= 2\n        else:\n            cost += a\n            k -= 1\n\n    return cost\n\n# Read the input\nn, a, b, c = map(int, input().split())\n\n# Print the minimum amount of rubles Alyona should pay\nprint(min_cost(n, a, b, c))"}
{"solution": "import sys\n\ndef dfs(node, graph, visited, recursion_stack):\n    visited[node] = True\n    recursion_stack[node] = True\n\n    for neighbor in graph[node]:\n        if not visited[neighbor] and dfs(neighbor, graph, visited, recursion_stack):\n            return True\n        elif recursion_stack[neighbor]:\n            return True\n\n    recursion_stack[node] = False\n    return False\n\ndef is_cyclic(graph):\n    visited = [False] * len(graph)\n    recursion_stack = [False] * len(graph)\n\n    for node in range(len(graph)):\n        if not visited[node] and dfs(node, graph, visited, recursion_stack):\n            return True\n    return False\n\ndef can_make_acyclic(graph, edges):\n    for edge in edges:\n        u, v = edge\n        graph[u].remove(v)\n        if not is_cyclic(graph):\n            return True\n        graph[u].add(v)\n    return False\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    graph = [set() for _ in range(n)]\n    edges = []\n\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        u -= 1\n        v -= 1\n        graph[u].add(v)\n        edges.append((u, v))\n\n    if can_make_acyclic(graph, edges):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef min_coins(n, m, antennas):\n    # Sort antennas by their position\n    antennas.sort()\n\n    # Initialize the minimum number of coins needed\n    coins = 0\n\n    # Initialize the rightmost position covered by an antenna\n    right = 0\n\n    # Iterate over the antennas\n    for i in range(n):\n        # If the current antenna doesn't cover the rightmost position\n        if antennas[i][0] - antennas[i][1] > right:\n            # Calculate the number of coins needed to cover the gap\n            coins += antennas[i][0] - antennas[i][1] - right\n\n            # Update the rightmost position covered by an antenna\n            right = antennas[i][0] + antennas[i][1]\n\n        # Update the rightmost position covered by an antenna\n        right = max(right, antennas[i][0] + antennas[i][1])\n\n    # If the rightmost position covered by an antenna is less than m\n    if right < m:\n        # Calculate the number of coins needed to cover the remaining gap\n        coins += m - right\n\n    return coins\n\n# Read the input\nn, m = map(int, sys.stdin.readline().split())\nantennas = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n\n# Print the minimum number of coins needed\nprint(min_coins(n, m, antennas))"}
{"solution": "def max_weight_subset(W, cnt):\n    # Initialize the dynamic programming table\n    dp = [0] * (W + 1)\n\n    # Iterate over each weight from 1 to 8\n    for i in range(1, 9):\n        # Iterate over each possible weight from W to i\n        for j in range(W, i - 1, -1):\n            # Iterate over each count of the current weight\n            for k in range(1, cnt[i - 1] + 1):\n                # If the current weight is less than or equal to j\n                if i * k <= j:\n                    # Update the maximum possible weight\n                    dp[j] = max(dp[j], dp[j - i * k] + i * k)\n\n    # Return the maximum possible weight of a good subset\n    return dp[W]\n\n# Read the input\nW = int(input())\ncnt = list(map(int, input().split()))\n\n# Print the output\nprint(max_weight_subset(W, cnt))"}
{"solution": "def min_cost(n, L, costs):\n    # Create a list of tuples, where each tuple contains the volume and cost of a bottle\n    bottles = [(2**i - 1, costs[i]) for i in range(n)]\n\n    # Sort the bottles in descending order of volume\n    bottles.sort(key=lambda x: x[0], reverse=True)\n\n    # Initialize the total cost\n    total_cost = 0\n\n    # Iterate over the bottles\n    for volume, cost in bottles:\n        # If the required amount of lemonade is not yet reached\n        if L > 0:\n            # Calculate the number of bottles needed to reach the required amount\n            num_bottles = min(L // volume, len(bottles))\n\n            # Update the total cost\n            total_cost += num_bottles * cost\n\n            # Update the required amount of lemonade\n            L -= num_bottles * volume\n\n    # Return the total cost\n    return total_cost\n\n# Read the input\nn, L = map(int, input().split())\ncosts = list(map(int, input().split()))\n\n# Print the minimum cost\nprint(min_cost(n, L, costs))"}
{"solution": "def max_mex(n, a):\n    a.sort()\n    mex = 1\n    for num in a:\n        if num >= mex:\n            mex += 1\n    return mex\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result\nresult = max_mex(n, a)\n\n# Print the result\nprint(result)"}
{"solution": "def is_lucky_ticket(n, digits):\n    total_sum = sum(int(digit) for digit in digits)\n\n    # Try every possible segment sum from 1 to total_sum\n    for segment_sum in range(1, total_sum + 1):\n        if total_sum % segment_sum == 0:\n            current_sum = 0\n            valid_partition = True\n            for digit in digits:\n                current_sum += int(digit)\n                if current_sum > segment_sum:\n                    valid_partition = False\n                    break\n                elif current_sum == segment_sum:\n                    current_sum = 0\n            if valid_partition and current_sum == 0:\n                return \"YES\"\n\n    return \"NO\"\n\n# Read input\nn = int(input())\ndigits = input().strip()\n\n# Print output\nprint(is_lucky_ticket(n, digits))"}
{"solution": "def determine_gender(username):\n    distinct_characters = set(username)\n    if len(distinct_characters) % 2 == 0:\n        return \"CHAT WITH HER!\"\n    else:\n        return \"IGNORE HIM!\"\n\n# Take the username as input\nusername = input().strip()\n# Print the result\nprint(determine_gender(username))"}
{"solution": "# Read input\nn, k = map(int, input().split())\ntabs = list(map(int, input().split()))\n\n# Initialize maximum difference\nmax_diff = 0\n\n# Iterate over all possible starting points for closing tabs\nfor b in range(1, n + 1):\n    # Initialize counts of test and social network tabs\n    e, s = 0, 0\n\n    # Iterate over all tabs\n    for i in range(n):\n        # If tab is not closed\n        if (i + 1 - b) % k != 0:\n            # If tab contains test information\n            if tabs[i] == 1:\n                e += 1\n            # If tab contains social network\n            else:\n                s += 1\n\n    # Update maximum difference\n    max_diff = max(max_diff, abs(e - s))\n\n# Print maximum difference\nprint(max_diff)"}
{"solution": "import heapq\n\ndef huffman_encoding(n, c0, c1):\n    # Create a priority queue with the costs of '0' and '1'\n    heap = [(c0, '0'), (c1, '1')]\n    heapq.heapify(heap)\n\n    # Build the Huffman coding tree\n    for _ in range(n - 2):\n        # Pop two nodes with the smallest costs\n        cost1, code1 = heapq.heappop(heap)\n        cost2, code2 = heapq.heappop(heap)\n\n        # Create a new node with the sum of the costs and append '0' and '1' to the codes\n        new_cost = cost1 + cost2\n        new_code = '0' + code1, '1' + code2\n\n        # Push the new nodes back into the priority queue\n        heapq.heappush(heap, (new_cost, new_code[0]))\n        heapq.heappush(heap, (new_cost, new_code[1]))\n\n    # Calculate the total cost\n    total_cost = 0\n    while heap:\n        cost, code = heapq.heappop(heap)\n        total_cost += cost * len(code)\n\n    return total_cost\n\n# Read the input\nn, c0, c1 = map(int, input().split())\n\n# Print the output\nprint(huffman_encoding(n, c0, c1))"}
{"solution": "def will_meet(n, a, x, b, y):\n    while a != x and b != y:\n        if a == b:\n            return \"YES\"\n        a = a + 1 if a < n else 1\n        b = b - 1 if b > 1 else n\n    return \"YES\" if a == b else \"NO\"\n\nn, a, x, b, y = map(int, input().split())\nprint(will_meet(n, a, x, b, y))"}
{"solution": "def generate_unlucky_years(x, y):\n    unlucky_years = set()\n    powers_x = [x**i for i in range(40)]\n    powers_y = [y**i for i in range(40)]\n\n    for i in range(40):\n        for j in range(40):\n            unlucky_year = powers_x[i] + powers_y[j]\n            if unlucky_year > 10**18:\n                break\n            unlucky_years.add(unlucky_year)\n\n    return unlucky_years\n\ndef find_max_golden_age(unlucky_years, l, r):\n    max_length = 0\n    current_length = 0\n    last_unlucky_year = l - 1\n\n    for year in range(l, r + 1):\n        if year in unlucky_years:\n            max_length = max(max_length, current_length)\n            current_length = 0\n            last_unlucky_year = year\n        else:\n            current_length = year - last_unlucky_year\n\n    max_length = max(max_length, current_length)\n\n    return max_length\n\nx, y, l, r = map(int, input().split())\nunlucky_years = generate_unlucky_years(x, y)\nmax_length = find_max_golden_age(unlucky_years, l, r)\nprint(max_length)"}
{"solution": "def min_tax(n):\n    # If n is even, it can be split into two equal parts to minimize tax\n    if n % 2 == 0:\n        return n // 2\n    # If n is of the form 4k + 1, it can be split into two parts: 2 and n-2\n    elif (n - 1) % 4 == 0:\n        return 2 + (n - 2) // 2\n    # Otherwise, the maximum divisor of n is the smallest prime factor of n\n    else:\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                return i\n        return n - 1\n\nn = int(input())\nprint(min_tax(n))"}
{"solution": "def fix_typos(word):\n    vowels = set('aeiou')\n    n = len(word)\n    result = []\n    i = 0\n\n    while i < n:\n        result.append(word[i])\n        if word[i] not in vowels:\n            start = i\n            while i < n and word[i] not in vowels:\n                i += 1\n            if i - start >= 3:\n                block = word[start:i]\n                if len(set(block)) > 1:\n                    result.append(' ')\n        i += 1\n\n    return ''.join(result)\n\nword = input()\nprint(fix_typos(word))"}
{"solution": "def min_time(n, m, k, x, s, a, b, c, d):\n    # Initialize the minimum time to prepare n potions as the time required to prepare n potions without any spell\n    min_time = n * x\n\n    # Check all possible combinations of spells\n    for i in range(m + 1):\n        for j in range(k + 1):\n            # If the total manapoints spent is less than or equal to s\n            if i < m and b[i] <= s or j < k and d[j] <= s:\n                # Calculate the number of potions that can be prepared using the spells\n                potions = 0\n                if i < m:\n                    potions += n * x // a[i]\n                if j < k:\n                    potions += c[j]\n\n                # If the number of potions is enough\n                if potions >= n:\n                    # Calculate the time required to prepare the potions\n                    time = 0\n                    if i < m:\n                        time += (n * x - 1) // a[i]\n                    if j < k:\n                        time += max(0, n - c[j]) * x\n\n                    # Update the minimum time\n                    min_time = min(min_time, time)\n\n    return min_time\n\n# Read the input\nn, m, k = map(int, input().split())\nx, s = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\nd = list(map(int, input().split()))\n\n# Print the minimum time required to prepare n potions\nprint(min_time(n, m, k, x, s, a, b, c, d))"}
{"solution": "def max_points(n, k, M, t):\n    # Sort the subtasks in ascending order of time\n    t.sort()\n\n    # Initialize the maximum points to 0\n    max_points = 0\n\n    # Iterate over the number of tasks that can be completed\n    for i in range(n + 1):\n        # Calculate the time left after completing i tasks\n        time_left = M - i * sum(t[:k])\n\n        # If time left is negative, break the loop\n        if time_left < 0:\n            break\n\n        # Calculate the number of additional subtasks that can be solved\n        additional_subtasks = time_left // t[k - 1]\n\n        # Update the maximum points\n        max_points = max(max_points, i * k + min(k, additional_subtasks))\n\n    return max_points\n\n# Read the input\nn, k, M = map(int, input().split())\nt = list(map(int, input().split()))\n\n# Print the maximum points\nprint(max_points(n, k, M, t))"}
{"solution": "MOD = 998244353\n\ndef solve(n):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        for j in range(i):\n            dp[i] = (dp[i] + dp[j] * dp[i - j - 1]) % MOD\n    return dp[n]\n\nn = int(input())\nprint(solve(n))"}
{"solution": "def find_position(n, m, k):\n    # Lara moves down k times first\n    row = k % n + 1\n    k -= min(k, n)\n\n    # Then she moves in the snake fashion\n    while k > 0:\n        # If she is in an odd row, she moves right\n        if row % 2 == 1:\n            col = min(k, m - 1)\n            k -= col\n        # If she is in an even row, she moves left\n        else:\n            col = min(k, m - 1)\n            k -= col\n            col = m - col\n        # Move one cell up\n        row -= 1\n\n    return row, col\n\nn, m, k = map(int, input().split())\nrow, col = find_position(n, m, k)\nprint(row, col)"}
{"solution": "import math\n\ndef find_min_max_ab(X):\n    # Find the factors of X\n    factors = []\n    for i in range(1, int(math.sqrt(X)) + 1):\n        if X % i == 0:\n            factors.append(i)\n            if X // i != i:\n                factors.append(X // i)\n\n    # Sort the factors\n    factors.sort()\n\n    # Iterate through the factors to find the pair (a, b) that minimizes max(a, b)\n    for i in range(len(factors)):\n        for j in range(i, len(factors)):\n            if math.lcm(factors[i], factors[j]) == X:\n                return factors[i], factors[j]\n\n# Read the input\nX = int(input())\n\n# Find the pair (a, b)\na, b = find_min_max_ab(X)\n\n# Print the output\nprint(a, b)"}
{"solution": "def max_fruits_for_compote(a, b, c):\n    # Calculate the maximum number of complete sets for each fruit type\n    max_sets_lemons = a // 1\n    max_sets_apples = b // 2\n    max_sets_pears = c // 4\n\n    # Find the limiting factor (minimum number of complete sets)\n    max_complete_sets = min(max_sets_lemons, max_sets_apples, max_sets_pears)\n\n    # Calculate the total number of fruits used in the compote\n    total_fruits = max_complete_sets * (1 + 2 + 4)\n\n    return total_fruits\n\n# Read the input\na = int(input())\nb = int(input())\nc = int(input())\n\n# Print the result\nprint(max_fruits_for_compote(a, b, c))"}
{"solution": "def can_divide_teams(n, ratings):\n    ratings.sort()\n    for i in range(n):\n        if ratings[i] >= ratings[i + n]:\n            return \"NO\"\n    return \"YES\"\n\nn = int(input())\nratings = list(map(int, input().split()))\nprint(can_divide_teams(n, ratings))"}
{"solution": "from math import gcd\n\ndef make_coprime(arr):\n    coprime_arr = [arr[0]]\n    insertions = 0\n\n    for i in range(1, len(arr)):\n        if gcd(coprime_arr[-1], arr[i]) != 1:\n            coprime_arr.append(find_coprime(coprime_arr[-1]))\n            insertions += 1\n        coprime_arr.append(arr[i])\n\n    return insertions, coprime_arr\n\ndef find_coprime(n):\n    for i in range(2, n + 1):\n        if gcd(n, i) == 1:\n            return i\n\nn = int(input())\narr = list(map(int, input().split()))\n\ninsertions, coprime_arr = make_coprime(arr)\n\nprint(insertions)\nprint(*coprime_arr)"}
{"solution": "import math\nfrom functools import reduce\nfrom math import gcd\n\ndef compute_gcd_of_list(lst):\n    return reduce(gcd, lst)\n\ndef max_divisor_after_operations(N, K, A):\n    if N == 1:\n        return A[0]\n\n    # Compute the GCD of the differences between all pairs\n    diffs = [abs(A[i] - A[j]) for i in range(N) for j in range(i + 1, N)]\n    initial_gcd = compute_gcd_of_list(diffs)\n\n    # Check all divisors of the initial GCD\n    max_divisor = 1\n    for d in range(1, initial_gcd + 1):\n        if initial_gcd % d == 0:\n            # Check if we can make all elements divisible by d\n            if all((a % d) <= K for a in A):\n                max_divisor = d\n\n    return max_divisor\n\n# Read input\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Compute and print the result\nprint(max_divisor_after_operations(N, K, A))"}
{"solution": "def cat_furrier_transform(x):\n    operations = []\n    n = 0\n    while x != 2**n - 1 and len(operations) < 40:\n        # Operation A: XOR with 2^n - 1\n        x = x ^ (2**n - 1)\n        operations.append(n)\n\n        # Operation B: Increment by 1\n        x += 1\n\n        # Update n\n        n = n + 1 if x & (x + 1) else n\n\n    return operations\n\n# Read input\nx = int(input())\n\n# Get operations\noperations = cat_furrier_transform(x)\n\n# Print output\nprint(len(operations))\nfor i in range(0, len(operations), 2):\n    print(operations[i], end=' ')"}
{"solution": "# Read the input\nn, k = map(int, input().split())\nbuckets = list(map(int, input().split()))\n\n# Initialize the minimum number of hours to a large value\nmin_hours = float('inf')\n\n# Iterate through each bucket\nfor bucket in buckets:\n    # Check if the bucket can water the garden in integer number of hours\n    if k % bucket == 0:\n        # Calculate the number of hours required\n        hours = k // bucket\n        # Update the minimum number of hours if necessary\n        min_hours = min(min_hours, hours)\n\n# Print the minimum number of hours required\nprint(min_hours)"}
{"solution": "def can_reach_insect(n, k, positions):\n    # Find the indices of the grasshopper and the insect\n    grasshopper_index = positions.index('G')\n    insect_index = positions.index('T')\n\n    # If the grasshopper is to the right of the insect, swap their indices\n    if grasshopper_index > insect_index:\n        grasshopper_index, insect_index = insect_index, grasshopper_index\n\n    # Check if the grasshopper can reach the insect by jumping over obstacles\n    while grasshopper_index < insect_index:\n        # Calculate the next possible position of the grasshopper\n        next_position = grasshopper_index + k\n\n        # If the next position is an obstacle, return False\n        if next_position >= n or positions[next_position] == '#':\n            return False\n\n        # If the next position is the insect, return True\n        if next_position == insect_index:\n            return True\n\n        # Move the grasshopper to the next position\n        grasshopper_index = next_position\n\n    # If the grasshopper couldn't reach the insect, return False\n    return False\n\n# Read the input\nn, k = map(int, input().split())\npositions = input()\n\n# Check if the grasshopper can reach the insect\nif can_reach_insect(n, k, positions):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import math\n\ndef calculate_x_coordinate(y1, y2, yw, xb, yb, r):\n    # Calculate the slope of the line from the ball to the goal\n    m = (y2 - y1) / (0 - xb)\n\n    # Calculate the y-coordinate of the intersection point of the line and the wall\n    y_intersect = m * (yw - yb) + yb\n\n    # Check if the intersection point is within the goal posts\n    if y_intersect < y1 or y_intersect > y2:\n        return -1\n\n    # Calculate the distance from the ball to the intersection point\n    distance = math.sqrt((y_intersect - yb) ** 2 + (yw - yb) ** 2)\n\n    # Check if the ball can reach the intersection point\n    if distance > 2 * r:\n        return -1\n\n    # Calculate the x-coordinate of the point on the wall to which the ball should be kicked\n    x_w = xb + (yw - yb) / m\n\n    return x_w\n\n# Read the input\ny1, y2, yw, xb, yb, r = map(int, input().split())\n\n# Calculate the x-coordinate\nx_coordinate = calculate_x_coordinate(y1, y2, yw, xb, yb, r)\n\n# Print the result\nprint(x_coordinate)"}
{"solution": "# Get the input\nb, d, s = map(int, input().split())\n\n# Calculate the total number of meals\ntotal_meals = b + d + s\n\n# Calculate the minimum number of days Vasiliy was in the sanatorium\nmin_days = max(b, d, s)\n\n# Calculate the minimum number of meals Vasiliy could have missed\nmissed_meals = max(0, 3 * min_days - total_meals)\n\n# Print the result\nprint(missed_meals)"}
{"solution": "def find_matrix_dimensions(sequence):\n    n = len(sequence)\n    x, y = 1, 1\n    direction = None\n\n    for i in range(1, n):\n        diff = sequence[i] - sequence[i - 1]\n\n        if diff == 1:\n            if direction == \"down\":\n                return None\n            direction = \"right\"\n            y += 1\n        elif diff == -1:\n            if direction == \"up\":\n                return None\n            direction = \"left\"\n            y += 1\n        elif diff > 0:\n            if direction == \"left\" or direction == \"right\":\n                return None\n            direction = \"down\"\n            x += 1\n        else:\n            if direction == \"left\" or direction == \"right\":\n                return None\n            direction = \"up\"\n            x += 1\n\n    return x, y\n\ndef main():\n    n = int(input())\n    sequence = list(map(int, input().split()))\n\n    dimensions = find_matrix_dimensions(sequence)\n\n    if dimensions is None:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(*dimensions)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def longest_common_subsequence(a, b):\n    m, n = len(a), len(b)\n    dp = [['' for _ in range(n+1)] for _ in range(m+1)]\n\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if a[i-1] == b[j-1]:\n                dp[i][j] = dp[i-1][j-1] + a[i-1]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1], key=len)\n\n    return dp[m][n]\n\na = input()\nb = input()\n\nresult = longest_common_subsequence(a, b)\n\nif len(result) == 0:\n    print('-')\nelse:\n    print(result)"}
{"solution": "def minimal_stones(n, s):\n    current_stones = 0\n    min_stones = 0\n\n    for char in s:\n        if char == '+':\n            current_stones += 1\n        elif char == '-':\n            current_stones -= 1\n        min_stones = min(min_stones, current_stones)\n\n    return max(0, -min_stones)\n\n# Example usage:\nn = int(input())\ns = input().strip()\nprint(minimal_stones(n, s))"}
{"solution": "def max_kefir_liters(n, a, b, c):\n    # Calculate the maximum number of plastic bottles Kolya can buy\n    max_plastic_bottles = n // a\n\n    # Calculate the maximum number of glass bottles Kolya can buy and return\n    max_glass_bottles = (n // (b - c)) * 2\n\n    # If Kolya can buy more glass bottles than plastic bottles, return the maximum number of glass bottles\n    # Otherwise, return the maximum number of plastic bottles\n    return max(max_plastic_bottles, max_glass_bottles)\n\n# Get the input\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# Print the output\nprint(max_kefir_liters(n, a, b, c))"}
{"solution": "def card_game(n, deck1, deck2):\n    fights = 0\n    while deck1 and deck2:\n        card1 = deck1.pop(0)\n        card2 = deck2.pop(0)\n        fights += 1\n        if card1 > card2:\n            deck1.append(card2)\n            deck1.append(card1)\n        else:\n            deck2.append(card1)\n            deck2.append(card2)\n        if fights > 10000:\n            return -1, -1\n    if deck1:\n        return fights, 1\n    else:\n        return fights, 2\n\nn = int(input())\nk1 = int(input())\ndeck1 = list(map(int, input().split()))\nk2 = n - k1\ndeck2 = list(map(int, input().split()))\n\nfights, winner = card_game(n, deck1, deck2)\nprint(fights, winner)"}
{"solution": "def check_password_complexity(password):\n    if len(password) < 5:\n        return \"Too weak\"\n\n    has_upper = False\n    has_lower = False\n    has_digit = False\n\n    for char in password:\n        if char.isupper():\n            has_upper = True\n        elif char.islower():\n            has_lower = True\n        elif char.isdigit():\n            has_digit = True\n\n    if has_upper and has_lower and has_digit:\n        return \"Correct\"\n    else:\n        return \"Too weak\"\n\n# Get user input\npassword = input().strip()\n# Print the result of the password complexity check\nprint(check_password_complexity(password))"}
{"solution": "n = int(input())\ngroup_a = list(map(int, input().split()))\ngroup_b = list(map(int, input().split()))\n\n# Count the number of students with each academic performance in both groups\ncount_a = [0] * 6\ncount_b = [0] * 6\n\nfor i in group_a:\n    count_a[i] += 1\n\nfor i in group_b:\n    count_b[i] += 1\n\n# Calculate the difference in the number of students with each academic performance\ndiff = [abs(count_a[i] - count_b[i]) for i in range(1, 6)]\n\n# Check if it's possible to redistribute students\nif any(d % 2 != 0 for d in diff):\n    print(-1)\nelse:\n    # Calculate the minimum number of exchanges needed\n    exchanges = sum(d // 2 for d in diff)\n    print(exchanges)"}
{"solution": "import sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(i, j):\n    visited[i][j] = True\n    for di, dj in directions:\n        ni, nj = i + di, j + dj\n        if 0 <= ni < n and 0 <= nj < m and not visited[ni][nj] and graph[ni][nj]:\n            dfs(ni, nj)\n\nn, m = map(int, input().split())\nhorizontal = input()\nvertical = input()\n\ngraph = [[False] * m for _ in range(n)]\nvisited = [[False] * m for _ in range(n)]\n\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\nfor i in range(n - 1):\n    if horizontal[i] == '<':\n        for j in range(m):\n            graph[i][j] = graph[i + 1][j] = True\n    else:\n        for j in range(m):\n            graph[i][j] = graph[i + 1][j] = True\n\nfor j in range(m - 1):\n    if vertical[j] == '^':\n        for i in range(n):\n            graph[i][j] = graph[i][j + 1] = True\n    else:\n        for i in range(n):\n            graph[i][j] = graph[i][j + 1] = True\n\nfor i in range(n):\n    for j in range(m):\n        if not visited[i][j]:\n            dfs(i, j)\n\nprint(\"YES\" if all(all(row) for row in visited) else \"NO\")"}
{"solution": "def solve_logical_expression(n, a):\n    # If there's only one argument, it's impossible to make the expression false\n    if n == 1:\n        return \"NO\"\n\n    # If there's at least one '0' in the arguments, it's possible to make the expression false\n    if 0 in a:\n        # Find the index of the first '0'\n        first_zero_index = a.index(0)\n\n        # If the first '0' is not the last argument, place brackets to make the expression false\n        if first_zero_index < n - 1:\n            expression = \"(\" * first_zero_index + \"->\".join(map(str, a)) + \")\" * (first_zero_index - 1)\n            return \"YES\\n\" + expression\n\n    # If there are no '0's in the arguments, it's impossible to make the expression false\n    return \"NO\"\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Print output\nprint(solve_logical_expression(n, a))"}
{"solution": "def process_values(a, b):\n    while a != 0 and b != 0:\n        if a >= 2 * b:\n            a = a - 2 * b\n        elif b >= 2 * a:\n            b = b - 2 * a\n        else:\n            break\n    return a, b\n\n# Get input values\nn, m = map(int, input().split())\n\n# Process the values\nresult_a, result_b = process_values(n, m)\n\n# Print the result\nprint(result_a, result_b)"}
{"solution": "def count_k_divisible_numbers(k, a, b):\n    # Calculate the first and last multiples of k in the segment [a, b]\n    first_multiple = (a + k - 1) // k\n    last_multiple = b // k\n\n    # The number of k-divisible numbers in the segment [a, b] is the difference between the last and first multiples, plus one\n    return last_multiple - first_multiple + 1\n\n# Read the input\nk, a, b = map(int, input().split())\n\n# Print the result\nprint(count_k_divisible_numbers(k, a, b))"}
{"solution": "def find_kth_digit(k):\n    if k <= 9:\n        return k\n\n    count = 9\n    length = 1\n    while k > count * length:\n        k -= count * length\n        length += 1\n        count *= 10\n\n    start_number = 10 ** (length - 1)\n    number = start_number + (k - 1) // length\n    position = (k - 1) % length\n\n    return int(str(number)[position])\n\nk = int(input())\nprint(find_kth_digit(k))"}
{"solution": "def can_vasya_win(n, s):\n    # Calculate the number of moves each player will make\n    moves_each = (n - 11) // 2\n\n    # Count the number of '8's in the first n - 10 characters\n    count_8s = s[:n - 10].count('8')\n\n    # Vasya wins if there are more '8's than the number of moves Petya can make\n    if count_8s > moves_each:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Determine if Vasya has a winning strategy\nresult = can_vasya_win(n, s)\nprint(result)"}
{"solution": "MOD = 10**9 + 7\n\ndef count_permutations(n, x, pos):\n    # dp[i][j][k] represents the number of permutations of length i\n    # with x at position j and k elements less than x to the left of x\n    dp = [[[0] * (n + 1) for _ in range(n)] for _ in range(n + 1)]\n\n    # Base case: when n = 1, there is only one permutation\n    dp[1][0][0] = 1\n\n    # Iterate through all possible lengths of the permutation\n    for i in range(2, n + 1):\n        # Iterate through all possible positions of x\n        for j in range(i):\n            # Iterate through all possible number of elements less than x to the left of x\n            for k in range(i):\n                # If x is not at the required position, skip this case\n                if j != pos:\n                    continue\n\n                # If there are k elements less than x to the left of x,\n                # there are i - k - 1 elements greater than x to the right of x\n                # We can place x at position j and arrange the remaining elements in (i - 1)! ways\n                # However, we need to ensure that the binary search algorithm finds x\n                # This means that the number of elements less than x should be greater than or equal to j\n                # and the number of elements greater than x should be greater than or equal to i - j - 1\n                if k >= j and i - k - 1 >= i - j - 1:\n                    # Calculate the number of permutations for this case\n                    dp[i][j][k] = (dp[j][j - 1][k - 1] * dp[i - j - 1][i - j - 1][i - k - 1]) % MOD\n\n    # Calculate the total number of permutations that satisfy the given conditions\n    total = 0\n    for k in range(n):\n        total = (total + dp[n][pos][k]) % MOD\n\n    return total\n\n# Read the input\nn, x, pos = map(int, input().split())\n\n# Calculate and print the result\nresult = count_permutations(n, x, pos)\nprint(result)"}
{"solution": "def decode_string(s, k):\n    n = len(s)\n    dp = [[False] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            if s[i - 1].isalpha():\n                if j > 0:\n                    dp[i][j] = dp[i - 1][j - 1]\n            elif s[i - 1] == '?':\n                if j > 0:\n                    dp[i][j] = dp[i - 1][j - 1]\n                dp[i][j] = dp[i][j] or dp[i - 1][j]\n            elif s[i - 1] == '*':\n                if j > 0:\n                    dp[i][j] = dp[i - 1][j - 1]\n                for l in range(j):\n                    dp[i][j] = dp[i][j] or dp[i - 1][j - l]\n\n    if not dp[n][k]:\n        return \"Impossible\"\n\n    result = [''] * k\n    i, j = n, k\n    while i > 0 and j > 0:\n        if s[i - 1].isalpha():\n            result[j - 1] = s[i - 1]\n            i -= 1\n            j -= 1\n        elif s[i - 1] == '?':\n            if j > 0 and dp[i - 1][j - 1]:\n                result[j - 1] = s[i - 2]\n                i -= 2\n                j -= 1\n            else:\n                i -= 1\n        elif s[i - 1] == '*':\n            if j > 0 and dp[i - 1][j - 1]:\n                result[j - 1] = s[i - 2]\n                i -= 2\n                j -= 1\n            else:\n                l = 1\n                while j - l >= 0 and dp[i - 1][j - l]:\n                    l += 1\n                l -= 1\n                result[j - l:j] = [s[i - 2]] * l\n                i -= 1\n                j -= l\n\n    return ''.join(result)\n\ns = input()\nk = int(input())\nprint(decode_string(s, k))"}
{"solution": "def min_turns(angle):\n    # Normalize the angle to be in the range [0, 360)\n    angle = angle % 360\n\n    # If the angle is negative, convert it to positive equivalent\n    if angle < 0:\n        angle += 360\n\n    # Calculate the minimum number of 90-degree turns needed\n    turns = min(angle // 90, 4 - angle // 90)\n\n    return turns\n\n# Read the input angle\nangle = int(input())\n\n# Print the minimum number of 90-degree turns needed\nprint(min_turns(angle))"}
{"solution": "# Get the input\na, b, c = map(int, input().split())\nx, y, z = map(int, input().split())\n\n# Calculate the difference between the required and available spheres\ndiff_blue = a - x\ndiff_violet = b - y\ndiff_orange = c - z\n\n# Check if it's possible to transform the spheres\nif diff_blue >= 0 and diff_violet >= 0 and diff_orange >= 0:\n    if diff_blue % 2 == 0 and diff_violet % 2 == 0 and diff_orange % 2 == 0:\n        print(\"Yes\")\n    elif (diff_blue % 2 == 0 and diff_violet >= 0 and diff_orange >= 0) or (diff_blue >= 0 and diff_violet % 2 == 0 and diff_orange >= 0) or (diff_blue >= 0 and diff_violet >= 0 and diff_orange % 2 == 0):\n        print(\"Yes\")\n    elif (diff_blue >= 2 and diff_violet >= 2 and diff_orange >= 0) or (diff_blue >= 2 and diff_violet >= 0 and diff_orange >= 2) or (diff_blue >= 0 and diff_violet >= 2 and diff_orange >= 2):\n        print(\"Yes\")\n    else:\n        print(\"No\")\nelse:\n    print(\"No\")"}
{"solution": "def solve(n, k, m):\n    # dp[i][j] is the number of valid numbers of length i that end in j\n    dp = [[0] * k for _ in range(n + 1)]\n    # base case: dp[1][j] = 1 for all j\n    for j in range(k):\n        dp[1][j] = 1\n    # iterate over length\n    for i in range(2, n + 1):\n        # iterate over last digit\n        for j in range(k):\n            # iterate over possible last digits of y\n            for l in range(k):\n                if (l * pow(10, i - 1, k) + j) % k == 0:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][l]) % m\n    # return the sum of dp[n][j] for all j\n    return sum(dp[n]) % m\n\n# read input\nn, k, m = map(int, input().split())\n# print output\nprint(solve(n, k, m))"}
{"solution": "def max_team_size(l, r, a):\n    if l > r:\n        l, r = r, l  # Ensure l is always the smaller or equal group\n\n    # Use ambidexters to balance the difference\n    d = r - l\n    if a >= d:\n        l += d\n        a -= d\n        # Now l == r, distribute remaining ambidexters equally\n        l += a // 2\n        r += a // 2\n    else:\n        l += a\n        # Not enough ambidexters to balance completely, r remains larger\n\n    # The maximum team size is twice the smaller group\n    return 2 * min(l, r)\n\n# Get input\nl, r, a = map(int, input().split())\n\n# Print output\nprint(max_team_size(l, r, a))"}
{"solution": "def min_moves(n, k):\n    # Initialize the number of moves\n    moves = 0\n\n    # Throw stones to the first manhole\n    moves += k - 1\n\n    # Open the first manhole and pick the coin\n    moves += 1\n\n    # Move to the next manhole and throw stones to the last manhole\n    moves += n - k\n\n    # Open the last manhole and pick the coin\n    moves += 1\n\n    # Move back to the first manhole\n    moves += n - k - 1\n\n    # Throw stones to the last manhole\n    moves += n - k - 1\n\n    # Open the first manhole and pick the coin\n    moves += 1\n\n    # Move to the last manhole\n    moves += 1\n\n    # For each remaining manhole, throw a stone to the last manhole, open it, and pick the coin\n    for i in range(2, n):\n        moves += 2\n        moves += 1\n        moves += 1\n\n    return moves\n\n# Read the input\nn, k = map(int, input().split())\n\n# Print the minimum number of moves\nprint(min_moves(n, k))"}
{"solution": "def min_tallest_tower(n, m):\n    # Calculate the total number of blocks available\n    total_blocks = 2 * n + 3 * m\n\n    # Initialize the height of the tallest tower\n    tallest_tower = 0\n\n    # Initialize the number of blocks used\n    blocks_used = 0\n\n    # Initialize the height of the current tower\n    current_height = 1\n\n    # While there are still blocks available\n    while blocks_used < total_blocks:\n        # Calculate the number of towers that can be made with the current height\n        num_towers = min(n, m, (total_blocks - blocks_used) // current_height)\n\n        # Update the number of blocks used\n        blocks_used += num_towers * current_height\n\n        # Update the height of the tallest tower\n        tallest_tower = current_height\n\n        # Increment the height of the current tower\n        current_height += 1\n\n    # Return the height of the tallest tower\n    return tallest_tower\n\n# Read the input\nn, m = map(int, input().split())\n\n# Print the minimum possible height of the tallest tower\nprint(min_tallest_tower(n, m))"}
{"solution": "from collections import Counter\n\n# Get the number of cards\nn = int(input())\n\n# Get the numbers on the cards\ncards = [int(input()) for _ in range(n)]\n\n# Count the occurrences of each number\ncounts = Counter(cards)\n\n# Check if it's possible to split the cards evenly\nfor num, count in counts.items():\n    if count == n // 2 and cards.count(num) == count:\n        print(\"YES\")\n        print(num, num)\n        break\nelse:\n    print(\"NO\")"}
{"solution": "def can_arrange_soldiers(n, k, soldiers):\n    # Calculate total number of soldiers\n    total_soldiers = sum(soldiers)\n\n    # If total soldiers exceed available seats, return False\n    if total_soldiers > 8 * n:\n        return False\n\n    # Sort the soldiers in descending order\n    soldiers.sort(reverse=True)\n\n    # Initialize seating arrangement\n    seating = [0] * (8 * n)\n\n    # Function to check if a soldier can be seated at a position\n    def can_seat(pos, group):\n        # Check neighboring seats\n        if pos % 8 != 0 and seating[pos - 1] == group:\n            return False\n        if pos % 8 != 7 and seating[pos + 1] == group:\n            return False\n        if pos >= 8 and seating[pos - 8] == group:\n            return False\n        if pos < 8 * n - 8 and seating[pos + 8] == group:\n            return False\n        return True\n\n    # Function to seat soldiers\n    def seat_soldiers(pos, group):\n        nonlocal soldiers\n        if soldiers[group] == 0:\n            return True\n        for i in range(pos, 8 * n):\n            if can_seat(i, group):\n                seating[i] = group\n                soldiers[group] -= 1\n                if seat_soldiers(i + 1, group):\n                    return True\n                seating[i] = 0\n                soldiers[group] += 1\n        return False\n\n    # Start seating soldiers\n    return seat_soldiers(0, 0)\n\n# Read input\nn, k = map(int, input().split())\nsoldiers = list(map(int, input().split()))\n\n# Check if soldiers can be arranged\nif can_arrange_soldiers(n, k, soldiers):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def calculate_min_cost(n, sticks):\n    min_cost = float('inf')\n    optimal_t = 0\n\n    for t in range(1, 101):\n        cost = 0\n        for stick in sticks:\n            cost += min(abs(stick - t), abs(stick - t - 1), abs(stick - t + 1))\n        if cost < min_cost:\n            min_cost = cost\n            optimal_t = t\n\n    return optimal_t, min_cost\n\nn = int(input())\nsticks = list(map(int, input().split()))\n\nt, min_cost = calculate_min_cost(n, sticks)\nprint(t, min_cost)"}
{"solution": "# Read the dimensions of the star map\nn, m = map(int, input().split())\n\n# Initialize the star map and the boundaries of the square\nstar_map = []\nmin_x, max_x, min_y, max_y = float('inf'), float('-inf'), float('inf'), float('-inf')\n\n# Read the star map and find the boundaries of the square\nfor i in range(n):\n    row = input()\n    star_map.append(row)\n    for j in range(m):\n        if row[j] == '*':\n            min_x = min(min_x, j)\n            max_x = max(max_x, j)\n            min_y = min(min_y, i)\n            max_y = max(max_y, i)\n\n# Calculate the side length of the square\nside_length = max(max_x - min_x + 1, max_y - min_y + 1)\n\n# Print the result\nprint(side_length)"}
{"solution": "MOD = 10**9 + 7\n\ndef factorial(n):\n    fact = [1]\n    for i in range(1, n + 1):\n        fact.append((fact[-1] * i) % MOD)\n    return fact\n\ndef inverse(n):\n    return pow(n, MOD - 2, MOD)\n\ndef nCr(n, r, fact):\n    return (fact[n] * inverse(fact[r]) * inverse(fact[n - r])) % MOD\n\ndef solve(n, k, a):\n    fact = factorial(n)\n    ones = a.count(1)\n    zeros = n - ones\n\n    if k >= ones * zeros:\n        return 0\n\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= i:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - i]) % MOD\n\n    ans = 0\n    for i in range(ones, n + 1):\n        ans = (ans + dp[i][k]) % MOD\n\n    for i in range(ones + 1, n + 1):\n        ans = (ans * inverse(i - ones)) % MOD\n\n    for i in range(1, zeros + 1):\n        ans = (ans * inverse(i)) % MOD\n\n    return ans\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nprint(solve(n, k, a))"}
{"solution": "def min_operations(x, y):\n    # Initialize the number of operations\n    operations = 0\n\n    # While the side length is greater than y\n    while x > y:\n        # If x is divisible by 3, divide it by 3\n        if x % 3 == 0:\n            x //= 3\n        # Otherwise, subtract 1 from x\n        else:\n            x -= 1\n        # Increment the number of operations\n        operations += 1\n\n    # Return the number of operations\n    return operations\n\n# Get the input\nx, y = map(int, input().split())\n\n# Print the minimum number of operations\nprint(min_operations(x, y))"}
{"solution": "# Read input\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Calculate the determinant of matrix A\ndet_A = a * d - b * c\n\n# If matrix A is already degenerate, the minimum possible norm is 0\nif det_A == 0:\n    print(0)\nelse:\n    # Calculate the coefficients of the line that passes through (a, b) and (c, d)\n    m = (d - b) / (a - c)\n    n = b - m * a\n\n    # Find the point on the line that is closest to the origin\n    x = -m * n / (m**2 + 1)\n    y = -n / (m**2 + 1)\n\n    # Calculate the minimum possible norm\n    norm = ((a - x)**2 + (b - y)**2 + (c - y)**2 + (d - x)**2)**0.5\n    print(norm)"}
{"solution": "# Read input\nn, a, b = map(int, input().split())\ngroups = list(map(int, input().split()))\n\n# Initialize variables\none_seaters = a\ntwo_seaters_full = 0\ntwo_seaters_single = 0\ndenied_service = 0\n\n# Iterate over groups\nfor group in groups:\n    # If group is of one person\n    if group == 1:\n        # If there is a vacant one-seater\n        if one_seaters > 0:\n            one_seaters -= 1\n        # If there is a vacant two-seater\n        elif two_seaters_full < b:\n            two_seaters_single += 1\n        # If there is a two-seater with a single person\n        elif two_seaters_single > 0:\n            two_seaters_single -= 1\n            two_seaters_full += 1\n        # If no table is available\n        else:\n            denied_service += 1\n    # If group is of two persons\n    else:\n        # If there is a vacant two-seater\n        if two_seaters_full < b:\n            two_seaters_full += 1\n        # If no table is available\n        else:\n            denied_service += 2\n\n# Print the result\nprint(denied_service)"}
{"solution": "# Read the input\nA, B, C, N = map(int, input().split())\n\n# Check if the data contradicts itself\nif A + B - C > N or A + C > N or B + C > N or A + B - C < 0 or A + C < 0 or B + C < 0:\n    print(-1)\nelse:\n    # Calculate the number of students who didn't pass the exam\n    didnt_pass = N - A - B + C\n    # Check if at least one student stayed home\n    if didnt_pass > 0:\n        print(didnt_pass)\n    else:\n        print(-1)"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(x, k):\n    # Base case: if there's only one month, the number of dresses doesn't change\n    if k == 0:\n        return x\n\n    # Recursive case: double the number of dresses and possibly lose one\n    next_x = (2 * x) % MOD\n    if next_x % 2 == 1:\n        # If the number of dresses is odd, it will be halved to an even number\n        # with 50% probability and remain odd with 50% probability\n        return (solve(next_x // 2, k - 1) + solve(next_x // 2 + 1, k - 1)) % MOD\n    else:\n        # If the number of dresses is even, it will remain even with 100% probability\n        return solve(next_x // 2, k - 1)\n\n# Read input\nx, k = map(int, input().split())\n\n# Print output\nprint(solve(x, k))"}
{"solution": "MOD = 998244353\n\ndef power(x, y):\n    result = 1\n    x = x % MOD\n    while y > 0:\n        if y % 2 == 1:\n            result = (result * x) % MOD\n        y = y // 2\n        x = (x * x) % MOD\n    return result\n\ndef calculate_probability(n, l, r):\n    total_ways = 1\n    for i in range(n):\n        total_ways = (total_ways * (r[i] - l[i] + 1)) % MOD\n\n    good_ways = 1\n    for i in range(1, n):\n        if l[i] > r[i-1]:\n            good_ways = (good_ways * (r[i] - l[i] + 1)) % MOD\n        elif r[i] > r[i-1]:\n            good_ways = (good_ways * (r[i] - r[i-1])) % MOD\n\n    probability = (good_ways * power(total_ways, MOD - 2)) % MOD\n    return probability\n\nn = int(input())\nl = []\nr = []\nfor _ in range(n):\n    li, ri = map(int, input().split())\n    l.append(li)\n    r.append(ri)\n\nresult = calculate_probability(n, l, r)\nprint(result)"}
{"solution": "def count_rectangles(n):\n    # INTJs prefer a systematic approach, so we'll iterate through all possible lengths\n    count = 0\n    for a in range(1, n // 4 + 1):\n        for b in range(a, (n - a) // 3 + 1):\n            # INTJs are logical thinkers, so we'll check if the remaining length can form a rectangle\n            c = n - a - b\n            if c > b and c % 2 == 0:\n                count += 1\n    return count\n\n# INTJs are decisive, so we'll get the input and print the output immediately\nn = int(input())\nprint(count_rectangles(n))"}
{"solution": "def find_min_kvass(n, s, kegs):\n    # Sort the kegs in descending order\n    kegs.sort(reverse=True)\n\n    # Calculate the total volume of kvass\n    total_volume = sum(kegs)\n\n    # Check if it's possible to pour s liters of kvass\n    if total_volume < s:\n        return -1\n\n    # Calculate the average volume per keg\n    avg_volume = s // n\n\n    # Calculate the remaining volume to be distributed\n    remaining_volume = s % n\n\n    # Distribute the remaining volume to the kegs with the highest volume\n    for i in range(remaining_volume):\n        kegs[i] -= 1\n\n    # Return the minimum volume in the kegs\n    return min(kegs) - avg_volume\n\n# Read the input\nn, s = map(int, input().split())\nkegs = list(map(int, input().split()))\n\n# Find the minimum volume in the least keg\nresult = find_min_kvass(n, s, kegs)\n\n# Print the result\nprint(result)"}
{"solution": "def days_to_apple(h1, h2, a, b):\n    day_height = a * 12 - b * 10\n    night_height = -b * 10\n\n    if day_height <= 0:\n        return -1\n\n    if h1 >= h2:\n        return 0\n\n    distance_to_apple = h2 - h1\n    days = 0\n\n    while distance_to_apple > 0:\n        distance_to_apple += night_height\n        if distance_to_apple <= 0:\n            break\n        distance_to_apple -= day_height\n        days += 1\n\n    if distance_to_apple > 0:\n        return -1\n    else:\n        return days\n\nh1, h2 = map(int, input().split())\na, b = map(int, input().split())\n\nprint(days_to_apple(h1, h2, a, b))"}
{"solution": "# Get the input values\nC, Hr, Hb, Wr, Wb = map(int, input().split())\n\n# Calculate the maximum number of red candies Om Nom can eat\nmax_red_candies = min(C // Wr, C // Wb * Hr // Hb)\n\n# Calculate the maximum number of blue candies Om Nom can eat\nmax_blue_candies = min(C // Wb, C // Wr * Hb // Hr)\n\n# Calculate the maximum number of joy units Om Nom can get\nmax_joy_units = max_red_candies * Hr + max_blue_candies * Hb\n\n# Print the result\nprint(max_joy_units)"}
{"solution": "def min_steps_to_reach_destination(x1, y1, x2, y2):\n    dx = abs(x2 - x1)\n    dy = abs(y2 - y1)\n    return max(dx, dy)\n\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\n\nmin_steps = min_steps_to_reach_destination(x1, y1, x2, y2)\nprint(min_steps)"}
{"solution": "def predict_vote_outcome(n, employees):\n    # Create a list to keep track of eligible employees\n    eligible = [True] * n\n\n    # Continue the voting process until only one employee is eligible\n    while eligible.count(True) > 1:\n        for i in range(n):\n            # If the employee is eligible to vote\n            if eligible[i]:\n                # Check if there are any employees of the opposite faction left\n                opposite_faction = 'R' if employees[i] == 'D' else 'D'\n                if opposite_faction in employees[i+1:]:\n                    # Deny the next employee of the opposite faction the right to vote\n                    j = employees[i+1:].index(opposite_faction) + i + 1\n                    eligible[j] = False\n\n    # Return the faction of the remaining eligible employee\n    return employees[eligible.index(True)]\n\n# Read input\nn = int(input())\nemployees = input()\n\n# Print the outcome of the vote\nprint(predict_vote_outcome(n, employees))"}
{"solution": "# Read the input values\na, b, x, y = map(int, input().split())\n\n# Initialize the counter for valid combinations\ncount = 0\n\n# Iterate through all possible screen widths\nfor w in range(1, a + 1):\n    # Calculate the corresponding screen height\n    h = w * y // x\n    # Check if the screen height meets the constraints\n    if h <= b and w * y == h * x:\n        # Increment the counter for valid combinations\n        count += 1\n\n# Print the number of valid combinations\nprint(count)"}
{"solution": "def factorial_trailing_zeros(n, b):\n    # Function to calculate the power of a number in a given base\n    def power_in_base(num, base):\n        count = 0\n        while num % base == 0:\n            num //= base\n            count += 1\n        return count\n\n    # Calculate the number of times each prime factor of the base appears in the factorial\n    prime_factors = []\n    i = 2\n    while i * i <= b:\n        if b % i:\n            i += 1\n        else:\n            b //= i\n            prime_factors.append(i)\n    if b > 1:\n        prime_factors.append(b)\n\n    # Calculate the number of trailing zeros in the base-b representation of the factorial\n    trailing_zeros = float('inf')\n    for p in prime_factors:\n        count = 0\n        i = p\n        while i <= n:\n            count += n // i\n            i *= p\n        trailing_zeros = min(trailing_zeros, count // power_in_base(p, b))\n\n    return trailing_zeros\n\n# Read the input\nn, b = map(int, input().split())\n\n# Calculate the number of trailing zeros and print the result\nresult = factorial_trailing_zeros(n, b)\nprint(result)"}
{"solution": "def frog_jumps(m, a, b):\n    # Initialize an array to store the number of distinct integers the frog can reach\n    f = [0] * (m + 1)\n    f[0] = 1  # The frog can reach position 0\n\n    # Initialize a variable to store the sum of all f(i)\n    total = 1\n\n    # Iterate through all positions from 1 to m\n    for i in range(1, m + 1):\n        # The frog can reach position i by jumping from i-a or i+b\n        if i >= a:\n            f[i] += f[i - a]\n        if i >= b:\n            f[i] += f[i + b]\n\n        # Update the total sum\n        total += f[i]\n\n    return total\n\n# Read the input\nm, a, b = map(int, input().split())\n\n# Print the result\nprint(frog_jumps(m, a, b))"}
{"solution": "# Read the length of the sequence\nn = int(input())\n\n# Read the elements of the sequence\nsequence = list(map(int, input().split()))\n\n# Check if the length of the sequence is odd\nif n % 2 == 0:\n    print(\"No\")\nelse:\n    # Check if the first and last elements of the sequence are odd\n    if sequence[0] % 2 == 0 or sequence[-1] % 2 == 0:\n        print(\"No\")\n    else:\n        # Check if all elements in the sequence have odd indices and are odd\n        for i in range(1, n - 1, 2):\n            if sequence[i] % 2 == 0:\n                print(\"No\")\n                break\n        else:\n            print(\"Yes\")"}
{"solution": "# Get the coordinates of the two known trees\nx1, y1, x2, y2 = map(int, input().split())\n\n# Check if the given points form a square\nif abs(x1 - x2) == abs(y1 - y2):\n    # Calculate the coordinates of the remaining trees\n    if x1 == x2:\n        # The trees are on the same x-coordinate\n        x3, y3 = x1 + abs(y1 - y2), y1\n        x4, y4 = x2 + abs(y1 - y2), y2\n    else:\n        # The trees are on the same y-coordinate\n        x3, y3 = x1, y1 + abs(x1 - x2)\n        x4, y4 = x2, y2 + abs(x1 - x2)\n    # Print the coordinates of the remaining trees\n    print(x3, y3, x4, y4)\nelse:\n    # If the given points do not form a square, there is no solution\n    print(-1)"}
{"solution": "MOD = 10**9 + 7\n\ndef matrix_multiply(a, b):\n    c = [[0, 0], [0, 0]]\n    for i in range(2):\n        for j in range(2):\n            for k in range(2):\n                c[i][j] = (c[i][j] + a[i][k] * b[k][j]) % MOD\n    return c\n\ndef matrix_power(matrix, n):\n    result = [[1, 0], [0, 1]]\n    while n > 0:\n        if n % 2 == 1:\n            result = matrix_multiply(result, matrix)\n        matrix = matrix_multiply(matrix, matrix)\n        n //= 2\n    return result\n\ndef solve(x, y, n):\n    if n == 1:\n        return x % MOD\n    if n == 2:\n        return y % MOD\n\n    matrix = [[1, 1], [1, 0]]\n    powered_matrix = matrix_power(matrix, n - 2)\n    return (powered_matrix[0][0] * y + powered_matrix[0][1] * x) % MOD\n\nx, y = map(int, input().split())\nn = int(input())\nprint(solve(x, y, n))"}
{"solution": "def split_array(n, arr):\n    subarrays = []\n    start = 0\n    for i in range(n):\n        if arr[i] == 0:\n            continue\n        if start != i:\n            subarrays.append((start, i))\n        start = i + 1\n        while start < n and arr[start] == 0:\n            start += 1\n    if start != n:\n        subarrays.append((start, n))\n    return subarrays\n\ndef main():\n    n = int(input())\n    arr = list(map(int, input().split()))\n    subarrays = split_array(n, arr)\n    if not subarrays:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(len(subarrays))\n        for subarray in subarrays:\n            print(*subarray)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_score(n, m, k):\n    mod = 1000000009\n    score = m\n    doubles = 0\n    for i in range(1, m + 1):\n        if i % k == 0:\n            doubles += 1\n            score -= 2 ** doubles - 1\n    return score % mod\n\nn, m, k = map(int, input().split())\nprint(min_score(n, m, k))"}
{"solution": "def find_divisible_by_eight(n):\n    # Convert the number to a string for easy manipulation\n    n = str(n)\n\n    # Iterate over all possible lengths of the substring\n    for length in range(1, len(n) + 1):\n        # Generate all possible substrings of the given length\n        for start in range(len(n) - length + 1):\n            # Extract the substring\n            substring = n[start:start + length]\n            # Check if the substring is divisible by 8\n            if int(substring) % 8 == 0:\n                # If it is, return it\n                return substring\n\n    # If no substring is divisible by 8, return None\n    return None\n\n# Read the input\nn = int(input())\n\n# Find a substring that is divisible by 8\nresult = find_divisible_by_eight(n)\n\n# Print the result\nif result is None:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(result)"}
{"solution": "# Read input\nn, m = map(int, input().split())\nmemory = [list(map(int, input().split())) for _ in range(m)]\n\n# Check all possible numbers of flats per floor\nfor flats_per_floor in range(1, 101):\n    floors = {}\n    for flat, floor in memory:\n        if (flat - 1) // flats_per_floor + 1 != floor:\n            break\n        floors[flat] = floor\n    else:\n        if len(floors) == len(memory) and (n - 1) // flats_per_floor + 1 in floors.values():\n            print((n - 1) // flats_per_floor + 1)\n            break\nelse:\n    print(-1)"}
{"solution": "def max_bishwocks(board1, board2):\n    n = len(board1)\n    board = [[board1[i], board2[i]] for i in range(n)]\n\n    # Define the four possible shapes of the bishwock\n    bishwock_shapes = [\n        [(0, 0), (0, 1), (1, 0)],  # Original L shape\n        [(0, 0), (0, 1), (1, 1)],  # Rotated 90 degrees\n        [(0, 1), (1, 0), (1, 1)],  # Rotated 180 degrees\n        [(0, 0), (1, 0), (1, 1)]   # Rotated 270 degrees\n    ]\n\n    def can_place_bishwock(x, y, shape):\n        for dx, dy in shape:\n            nx, ny = x + dx, y + dy\n            if nx >= 2 or ny >= n or board[ny][nx] == 'X':\n                return False\n        return True\n\n    def place_bishwock(x, y, shape):\n        for dx, dy in shape:\n            nx, ny = x + dx, y + dy\n            board[ny][nx] = 'X'\n\n    count = 0\n    for y in range(n):\n        for x in range(2):\n            for shape in bishwock_shapes:\n                if can_place_bishwock(x, y, shape):\n                    place_bishwock(x, y, shape)\n                    count += 1\n                    break\n\n    return count"}
{"solution": "def max_pretty_set_length(n, s):\n    max_length = 0\n    current_set = set()\n\n    for char in s:\n        if char.islower():\n            current_set.add(char)\n        else:\n            max_length = max(max_length, len(current_set))\n            current_set.clear()\n\n    # Check the last segment\n    max_length = max(max_length, len(current_set))\n\n    return max_length\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Get the result\nresult = max_pretty_set_length(n, s)\n\n# Print the result\nprint(result)"}
{"solution": "# Read the number of elements in the sequence\nn = int(input())\n\n# Read the elements of the sequence\na = list(map(int, input().split()))\n\n# Initialize the sum of elements in sequence b and c\nB = 0\nC = 0\n\n# Iterate over the elements of the sequence\nfor i in range(n):\n    # If the current element is positive, add it to sequence b\n    if a[i] > 0:\n        B += a[i]\n    # If the current element is negative or zero, add it to sequence c\n    else:\n        C += a[i]\n\n# Print the maximum possible value of B - C\nprint(B - C)"}
{"solution": "def min_refuels(a, b, f, k):\n    # Calculate the distance the bus can travel without refueling\n    max_distance = b\n\n    # Calculate the distance the bus travels in one journey\n    journey_distance = 2 * a\n\n    # Check if the bus can make a single journey without refueling\n    if journey_distance > max_distance:\n        return -1\n\n    # Calculate the number of refuels needed in one journey\n    refuels_per_journey = 1 if journey_distance > f else 0\n\n    # Calculate the total number of refuels needed\n    total_refuels = refuels_per_journey * k\n\n    return total_refuels\n\n# Read the input\na, b, f, k = map(int, input().split())\n\n# Print the result\nprint(min_refuels(a, b, f, k))"}
{"solution": "def split_string(n, p, q, s):\n    for i in range(0, n, p):\n        if (n - i) % q == 0:\n            return [s[i:i+p], s[i+p:]]\n    for i in range(0, n, q):\n        if (n - i) % p == 0:\n            return [s[i:i+q], s[i+q:]]\n    return [-1]\n\nn, p, q = map(int, input().split())\ns = input()\nresult = split_string(n, p, q, s)\n\nif result[0] == -1:\n    print(-1)\nelse:\n    print(len(result))\n    for part in result:\n        print(part)"}
{"solution": "def solve_problem():\n    n, m, s, d = map(int, input().split())\n    obstacles = sorted(map(int, input().split()))\n\n    # Initialize the current position\n    current_position = 0\n\n    # Iterate over the obstacles\n    for obstacle in obstacles:\n        # Calculate the distance to the obstacle\n        distance_to_obstacle = obstacle - current_position\n\n        # Check if the athlete can reach the obstacle\n        if distance_to_obstacle < s:\n            print(\"IMPOSSIBLE\")\n            return\n\n        # Calculate the jump distance\n        jump_distance = min(d, obstacle - current_position - s)\n\n        # Print the run and jump commands\n        print(f\"RUN {s}\")\n        print(f\"JUMP {jump_distance}\")\n\n        # Update the current position\n        current_position = obstacle + jump_distance\n\n    # Check if the athlete can reach the finish point\n    if m - current_position < s:\n        print(\"IMPOSSIBLE\")\n        return\n\n    # Print the run command to reach the finish point\n    print(f\"RUN {m - current_position}\")\n\nsolve_problem()"}
{"solution": "# Read input\ns, x = map(int, input().split())\n\n# Calculate b\nb = (s - x) // 2\n\n# Check if b is a valid solution\nif (s - x) % 2 == 0 and b > 0:\n    # Calculate a\n    a = s - b\n\n    # Check if a is a valid solution\n    if a > 0:\n        # Each valid pair can be ordered in two ways\n        print(2)\n    else:\n        print(0)\nelse:\n    print(0)"}
{"solution": "n, k = map(int, input().split())\n\n# Calculate the minimum number of actions needed\nl = (n + 2 * k) // (2 * k + 1)\n\n# Print the minimum number of actions needed\nprint(l)\n\n# Print the number of the skewer that is to be turned over at the corresponding step\nfor i in range(1, l + 1):\n    print(i * (2 * k + 1) - k, end=' ')"}
{"solution": "def min_operations_to_square(n):\n    import math\n\n    n_str = str(n)\n    n_len = len(n_str)\n\n    # Generate all possible squares up to the maximum possible value\n    max_square_root = int(math.sqrt(2 * 10**9)) + 1\n    squares = [str(i * i) for i in range(1, max_square_root + 1)]\n\n    def is_subsequence(small, large):\n        it = iter(large)\n        return all(char in it for char in small)\n\n    min_deletions = float('inf')\n\n    for square in squares:\n        if is_subsequence(square, n_str):\n            deletions = n_len - len(square)\n            min_deletions = min(min_deletions, deletions)\n\n    return min_deletions if min_deletions != float('inf') else -1\n\n# Read input\nn = int(input())\n\n# Print output\nprint(min_operations_to_square(n))"}
{"solution": "import math\n\nMOD = 10**9 + 7\nMAXN = 10**6 + 1\n\ndef sieve_of_eratosthenes(n):\n    primes = [True for i in range(n+1)]\n    p = 2\n    while p * p <= n:\n        if primes[p] == True:\n            for i in range(p * p, n+1, p):\n                primes[i] = False\n        p += 1\n    return primes\n\ndef count_permutations(n):\n    primes = sieve_of_eratosthenes(n)\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        if primes[i]:\n            dp[i] = dp[i - 1]\n        else:\n            dp[i] = (dp[i - 1] + dp[i - 2]) % MOD\n    return dp[n]\n\nn = int(input())\nprint(count_permutations(n))"}
{"solution": "def minimum_jump_ability(s):\n    vowels = {'A', 'E', 'I', 'O', 'U', 'Y'}\n    positions = [-1]  # Start position before the first character\n\n    # Collect positions of all vowels\n    for i, char in enumerate(s):\n        if char in vowels:\n            positions.append(i)\n\n    positions.append(len(s))  # End position after the last character\n\n    # Calculate maximum distance between consecutive positions\n    max_distance = 0\n    for i in range(1, len(positions)):\n        max_distance = max(max_distance, positions[i] - positions[i - 1])\n\n    return max_distance\n\n# Read input string\ns = input()\n\n# Print the minimum jump ability required\nprint(minimum_jump_ability(s))"}
{"solution": "# Get the input\na1, a2, a3, a4 = map(int, input().split())\n\n# Calculate the total sum of candies\ntotal_sum = a1 + a2 + a3 + a4\n\n# Check if the total sum is odd or if any bag contains more than half of the total sum\nif total_sum % 2 != 0 or max(a1, a2, a3, a4) > total_sum / 2:\n    print(\"NO\")\nelse:\n    # Check all possible combinations to see if it's possible to distribute the candies equally\n    if a1 + a2 == total_sum / 2 or a1 + a3 == total_sum / 2 or a1 + a4 == total_sum / 2 or a2 + a3 == total_sum / 2 or a2 + a4 == total_sum / 2 or a3 + a4 == total_sum / 2:\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "# Read input\nn = int(input())\nslices = list(map(int, input().split()))\n\n# Initialize dp array\ndp = [[[0, 0] for _ in range(n)] for _ in range(n)]\n\n# Calculate total pie\ntotal_pie = sum(slices)\n\n# Fill dp array\nfor length in range(1, n + 1):\n    for i in range(n - length + 1):\n        j = i + length - 1\n        # If only one slice is left, the current player takes it\n        if i == j:\n            dp[i][j][0] = slices[i]\n            dp[i][j][1] = 0\n        else:\n            # Take the first slice\n            first_slice = slices[i] + dp[i + 1][j][1]\n            # Take the last slice\n            last_slice = slices[j] + dp[i][j - 1][1]\n            # Choose the maximum\n            if first_slice > last_slice:\n                dp[i][j][0] = first_slice\n                dp[i][j][1] = dp[i + 1][j][0]\n            else:\n                dp[i][j][0] = last_slice\n                dp[i][j][1] = dp[i][j - 1][0]\n\n# Print output\nalice_pie = dp[0][n - 1][0]\nbob_pie = total_pie - alice_pie\nprint(alice_pie, bob_pie)"}
{"solution": "def min_variables(n, a):\n    dp = [0] * (1 << n)\n    for i in range(1, n):\n        dp[1 << i] = 1\n    for mask in range(1, 1 << n):\n        if dp[mask] == 0:\n            continue\n        for i in range(n):\n            if (mask & (1 << i)) == 0:\n                new_mask = mask | (1 << i)\n                for j in range(n):\n                    if (mask & (1 << j)) != 0:\n                        for k in range(n):\n                            if (mask & (1 << k)) != 0 and j != k:\n                                if a[i] == a[j] + a[k]:\n                                    if dp[new_mask] == 0 or dp[new_mask] > dp[mask]:\n                                        dp[new_mask] = dp[mask]\n                if dp[new_mask] == 0:\n                    dp[new_mask] = dp[mask] + 1\n    return dp[(1 << n) - 1] if dp[(1 << n) - 1] != 0 else -1\n\nn = int(input())\na = list(map(int, input().split()))\nprint(min_variables(n, a))"}
{"solution": "def determine_winner(n, piles):\n    odd_count = sum(1 for pile in piles if pile % 2 != 0)\n    if odd_count % 2 == 0:\n        return \"Alice\"\n    else:\n        return \"Bob\"\n\n# Read input\nn = int(input())\npiles = list(map(int, input().split()))\n\n# Determine and print the winner\nprint(determine_winner(n, piles))"}
{"solution": "def can_make_equal(arr):\n    n = len(arr)\n    if n == 1:\n        return True\n    if n == 2:\n        return (arr[1] - arr[0]) % 2 == 0\n    diff = [arr[i] - arr[i - 1] for i in range(1, n)]\n    gcd_val = diff[0]\n    for i in range(1, n - 1):\n        gcd_val = gcd(gcd_val, diff[i])\n    return gcd_val > 0 and (arr[-1] - arr[0]) % gcd_val == 0\n\nn = int(input())\narr = list(map(int, input().split()))\narr.sort()\nif can_make_equal(arr):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def longest_repeated_substring(n, s):\n    # Initialize the maximum length of repeated substring\n    max_len = 0\n\n    # Iterate over all possible substring lengths\n    for length in range(n, 0, -1):\n        # Create a set to store unique substrings\n        substrings = set()\n\n        # Iterate over all possible starting positions for the current substring length\n        for start in range(n - length + 1):\n            # Extract the current substring\n            substring = s[start:start + length]\n\n            # If the substring is already in the set, we have found a repeated substring\n            if substring in substrings:\n                return length\n\n            # Add the substring to the set\n            substrings.add(substring)\n\n    # If no repeated substring is found, return 0\n    return max_len\n\n# Read the input\nn = int(input())\ns = input()\n\n# Print the result\nprint(longest_repeated_substring(n, s))"}
{"solution": "def minimum_time_to_house(n, a):\n    if a % 2 == 1:\n        # a is odd\n        return (a + 1) // 2\n    else:\n        # a is even\n        return (n - a + 2) // 2\n\n# Read input\nn, a = map(int, input().split())\n\n# Calculate and print the result\nprint(minimum_time_to_house(n, a))"}
{"solution": "def find_subarray(n, m, colors, counts):\n    color_count = [0] * (m + 1)\n    left = 0\n    for right in range(n):\n        color_count[colors[right]] += 1\n        while all(color_count[i] >= counts[i] for i in range(1, m + 1)):\n            if all(color_count[i] == counts[i] for i in range(1, m + 1)):\n                return 'YES'\n            color_count[colors[left]] -= 1\n            left += 1\n    return 'NO'\n\nn, m = map(int, input().split())\ncolors = list(map(int, input().split()))\ncounts = list(map(int, input().split()))\n\nprint(find_subarray(n, m, colors, counts))"}
{"solution": "def determine_winner(n, rounds):\n    mishka_wins = 0\n    chris_wins = 0\n\n    for round in rounds:\n        m, c = round\n        if m > c:\n            mishka_wins += 1\n        elif c > m:\n            chris_wins += 1\n\n    if mishka_wins > chris_wins:\n        return \"Mishka\"\n    elif chris_wins > mishka_wins:\n        return \"Chris\"\n    else:\n        return \"Friendship is magic!^^\"\n\n# Read the number of rounds\nn = int(input())\n\n# Read the results of each round\nrounds = []\nfor _ in range(n):\n    m, c = map(int, input().split())\n    rounds.append((m, c))\n\n# Determine the winner and print the result\nprint(determine_winner(n, rounds))"}
{"solution": "def is_valid(field, n, m):\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                continue\n            elif field[i][j] == '.':\n                if not is_empty_cell_valid(field, i, j, n, m):\n                    return False\n            else:\n                if not is_digit_cell_valid(field, i, j, n, m):\n                    return False\n    return True\n\ndef is_empty_cell_valid(field, i, j, n, m):\n    for x in range(max(0, i-1), min(n, i+2)):\n        for y in range(max(0, j-1), min(m, j+2)):\n            if field[x][y] == '*':\n                return False\n    return True\n\ndef is_digit_cell_valid(field, i, j, n, m):\n    bomb_count = 0\n    for x in range(max(0, i-1), min(n, i+2)):\n        for y in range(max(0, j-1), min(m, j+2)):\n            if field[x][y] == '*':\n                bomb_count += 1\n    return bomb_count == int(field[i][j])\n\nn, m = map(int, input().split())\nfield = [input() for _ in range(n)]\nprint('YES' if is_valid(field, n, m) else 'NO')"}
{"solution": "def can_vasya_eat_half(n, k):\n    total_candies = n\n    vasya_eaten = 0\n\n    while total_candies > 0:\n        # Vasya eats k candies\n        vasya_eaten += min(k, total_candies)\n        total_candies -= min(k, total_candies)\n\n        # Petya eats 10% of the remaining candies\n        petya_eaten = total_candies // 10\n        total_candies -= petya_eaten\n\n    return vasya_eaten >= (n + 1) // 2\n\ndef find_min_k(n):\n    left, right = 1, n\n    while left < right:\n        mid = (left + right) // 2\n        if can_vasya_eat_half(n, mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\n# Read input\nn = int(input().strip())\n\n# Find and print the minimal k\nprint(find_min_k(n))"}
{"solution": "def can_rearrange_necklace(s):\n    p = s.count('o')\n    l = s.count('-')\n\n    if p == 0 or p == 1:\n        return \"YES\"\n    if l % p == 0:\n        return \"YES\"\n    return \"NO\"\n\n# Get input from the user\ns = input()\n\n# Print the result\nprint(can_rearrange_necklace(s))"}
{"solution": "# Get the input\nn, m, k = map(int, input().split())\n\n# Calculate the maximum number of pillows Frodo can have\nmax_pillows = min(m - n + 1, k, n - k + 1)\n\n# Print the result\nprint(max_pillows)"}
{"solution": "import math\n\ndef max_subarray_cost(n, m, k, a):\n    prefix_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + a[i - 1]\n\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = max(dp[i - 1], prefix_sum[i] - k * math.ceil(i / m))\n        for j in range(i - 1, 0, -1):\n            dp[i] = max(dp[i], (prefix_sum[i] - prefix_sum[j - 1]) - k * math.ceil((i - j + 1) / m))\n\n    return max(dp)\n\nn, m, k = map(int, input().split())\na = list(map(int, input().split()))\nprint(max_subarray_cost(n, m, k, a))"}
{"solution": "def calculate_distance(point1, point2):\n    return ((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)**0.5\n\ndef find_longest_polyline(n, m):\n    # INTJs prefer to work with the big picture and abstract concepts\n    # They look at patterns and possibilities to find the optimal solution\n    # In this case, the optimal solution is to choose the corners of the rectangle\n    # This will always result in the longest possible polyline\n\n    points = [(0, 0), (n, 0), (n, m), (0, m)]\n    max_distance = 0\n    max_points = []\n\n    # INTJs are systematic and methodical\n    # They evaluate different configurations of points to determine the optimal solution\n    for i in range(4):\n        for j in range(i+1, 4):\n            for k in range(j+1, 4):\n                for l in range(k+1, 4):\n                    distance = calculate_distance(points[i], points[j]) + calculate_distance(points[j], points[k]) + calculate_distance(points[k], points[l])\n                    if distance > max_distance:\n                        max_distance = distance\n                        max_points = [points[i], points[j], points[k], points[l]]\n\n    return max_points\n\nn, m = map(int, input().split())\npoints = find_longest_polyline(n, m)\nfor point in points:\n    print(point[0], point[1])"}
{"solution": "def find_smallest_number(shuffled, substring):\n    # Count the frequency of each digit in the shuffled string and substring\n    shuffled_count = [0] * 10\n    substring_count = [0] * 10\n    for digit in shuffled:\n        shuffled_count[int(digit)] += 1\n    for digit in substring:\n        substring_count[int(digit)] += 1\n\n    # Calculate the excess frequency of each digit in the shuffled string\n    excess_count = [shuffled_count[i] - substring_count[i] for i in range(10)]\n\n    # Initialize the result string with the substring\n    result = substring\n\n    # Iterate through the digits in reverse order\n    for i in range(9, -1, -1):\n        # Add the excess of the current digit to the result string\n        result = str(i) * excess_count[i] + result\n\n    # Remove leading zeros, except for the case of zero itself\n    result = result.lstrip('0')\n    if result == '':\n        result = '0'\n\n    return result\n\n# Read the input\nshuffled = input()\nsubstring = input()\n\n# Find and print the smallest possible initial integer n\nprint(find_smallest_number(shuffled, substring))"}
{"solution": "# Read input\nn, m, min_temp, max_temp = map(int, input().split())\ntemperatures = list(map(int, input().split()))\n\n# Check if it is possible to extend the set of temperatures\nif min(temperatures) < min_temp or max(temperatures) > max_temp:\n    print(\"Incorrect\")\nelif len(set(temperatures)) == 1 and temperatures[0] != min_temp and temperatures[0] != max_temp:\n    print(\"Incorrect\")\nelse:\n    # Count the number of occurrences of the minimum and maximum temperatures\n    min_count = temperatures.count(min_temp)\n    max_count = temperatures.count(max_temp)\n\n    # Check if it is possible to add the required number of temperatures\n    if min_count + max_count > n or min_count > m or max_count > m:\n        print(\"Incorrect\")\n    else:\n        print(\"Correct\")"}
{"solution": "def find_numbers_with_m_trailing_zeroes(m):\n    # Function to count the number of trailing zeroes in a factorial\n    def count_trailing_zeroes(n):\n        count = 0\n        i = 5\n        while n / i >= 1:\n            count += n // i\n            i *= 5\n        return count\n\n    # Binary search to find the range of numbers with m trailing zeroes\n    low = 0\n    high = 5 * m\n    while low < high:\n        mid = (low + high) // 2\n        if count_trailing_zeroes(mid) < m:\n            low = mid + 1\n        else:\n            high = mid\n\n    # Find the numbers in the range with exactly m trailing zeroes\n    numbers = []\n    while count_trailing_zeroes(low) == m:\n        numbers.append(low)\n        low += 1\n\n    return numbers\n\n# Read input\nm = int(input())\n\n# Find numbers with m trailing zeroes\nnumbers = find_numbers_with_m_trailing_zeroes(m)\n\n# Print output\nprint(len(numbers))\nprint(' '.join(map(str, numbers)))"}
{"solution": "import heapq\n\ndef dijkstra(graph, start):\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n\n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node].items():\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n\n    return distances\n\ndef solve(n, m, k, special_vertices, edges):\n    graph = {i: {} for i in range(1, n + 1)}\n\n    for u, v, w in edges:\n        graph[u][v] = graph[v][u] = min(graph[u].get(v, float('infinity')), w)\n\n    results = []\n\n    for start in special_vertices:\n        distances = dijkstra(graph, start)\n        max_distance = max(distances[v] for v in special_vertices if v != start)\n        results.append(max_distance)\n\n    return results\n\nn, m, k = map(int, input().split())\nspecial_vertices = list(map(int, input().split()))\nedges = [list(map(int, input().split())) for _ in range(m)]\n\nprint(*solve(n, m, k, special_vertices, edges))"}
{"solution": "# Read the input\nn = int(input())\nx = int(input())\n\n# Simulate the movements in reverse order\nfor i in range(n, 0, -1):\n    if i % 2 == 1:  # Odd move\n        if x == 0:\n            x = 1\n        elif x == 1:\n            x = 0\n    else:  # Even move\n        if x == 1:\n            x = 2\n        elif x == 2:\n            x = 1\n\n# Print the initial position of the ball\nprint(x)"}
{"solution": "def is_square(rectangles):\n    # Identify the Bounding Box\n    min_x = min(x1 for x1, _, _, _ in rectangles)\n    max_x = max(x2 for _, x2, _, _ in rectangles)\n    min_y = min(y1 for _, _, y1, _ in rectangles)\n    max_y = max(y2 for _, _, _, y2 in rectangles)\n\n    # Check for Square Dimensions\n    if max_x - min_x != max_y - min_y:\n        return False\n\n    # Verify Coverage\n    area = (max_x - min_x) * (max_y - min_y)\n    total_rectangle_area = sum((x2 - x1) * (y2 - y1) for x1, x2, y1, y2 in rectangles)\n\n    if area != total_rectangle_area:\n        return False\n\n    return True\n\n# Read input\nn = int(input())\nrectangles = [list(map(int, input().split())) for _ in range(n)]\n\n# Print output\nprint(\"YES\" if is_square(rectangles) else \"NO\")"}
{"solution": "def solve(n, s):\n    dp = [[0] * 10 for _ in range(19)]\n    dp[0] = [1] * 10\n\n    for i in range(1, 19):\n        for j in range(10):\n            for k in range(10):\n                if j - k >= 0:\n                    dp[i][j] += dp[i - 1][j - k]\n\n    def count(num):\n        if num < 0:\n            return 0\n        if num < 10:\n            return max(0, num - s + 1)\n\n        num_str = str(num)\n        length = len(num_str)\n        res = 0\n        for i in range(1, length):\n            for j in range(1, 10):\n                res += dp[i - 1][j]\n\n        last = int(num_str[-1])\n        for i in range(1, last):\n            if num - i * (length - 1) >= s:\n                res += dp[length - 1][i]\n\n        res += count(num - last * (length - 1))\n        return res\n\n    return count(n)\n\nn, s = map(int, input().split())\nprint(solve(n, s))"}
{"solution": "def can_cover_points(points):\n    # Check if there are less than or equal to 2 points\n    if len(points) <= 2:\n        return True\n\n    # Check if all points have the same x-coordinate\n    if all(point[0] == points[0][0] for point in points):\n        return True\n\n    # Check if all points have the same y-coordinate\n    if all(point[1] == points[0][1] for point in points):\n        return True\n\n    # Check if all points lie on the same line\n    if all((points[i][1] - points[0][1]) * (points[j][0] - points[0][0]) == (points[j][1] - points[0][1]) * (points[i][0] - points[0][0]) for i in range(1, len(points)) for j in range(i+1, len(points))):\n        return True\n\n    # Check if there are any two points that can form a line and cover all other points\n    for i in range(len(points)):\n        for j in range(i+1, len(points)):\n            line1 = set([i, j])\n            line2 = set()\n\n            # Check if the remaining points lie on the line formed by points i and j\n            for k in range(len(points)):\n                if k not in line1:\n                    if (points[k][1] - points[i][1]) * (points[j][0] - points[i][0]) == (points[j][1] - points[i][1]) * (points[k][0] - points[i][0]):\n                        line1.add(k)\n                    else:\n                        line2.add(k)\n\n            # Check if both lines cover all points\n            if len(line1) > 0 and len(line2) > 0 and len(line1 | line2) == len(points):\n                return True\n\n    return False\n\n# Read the input\nn = int(input())\npoints = []\nfor _ in range(n):\n    x, y = map(int, input().split())\n    points.append((x, y))\n\n# Check if it is possible to cover all points with two lines\nif can_cover_points(points):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(a, b, k, t):\n    dp = [[0] * (2 * k + 1) for _ in range(t + 1)]\n    dp[0][a - b + k] = 1\n\n    for i in range(1, t + 1):\n        for j in range(2 * k + 1):\n            for x in range(-k, k + 1):\n                for y in range(-k, k + 1):\n                    if j - x + k >= 0 and j - x + k < 2 * k + 1:\n                        dp[i][j] = (dp[i][j] + dp[i - 1][j - x + k]) % MOD\n\n    return sum(dp[t][k + 1:]) % MOD\n\na, b, k, t = map(int, input().split())\nprint(solve(a, b, k, t))"}
{"solution": "def min_marks(n, l, x, y, marks):\n    marks_set = set(marks)\n    add_marks = []\n\n    if x not in marks_set:\n        add_marks.append(x)\n    if y not in marks_set:\n        add_marks.append(y)\n\n    for mark in marks:\n        if mark + x <= l and mark + x not in marks_set:\n            add_marks.append(mark + x)\n        if mark + y <= l and mark + y not in marks_set:\n            add_marks.append(y + mark)\n\n    return len(add_marks), add_marks\n\nn, l, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\n\nv, p = min_marks(n, l, x, y, marks)\nprint(v)\nprint(' '.join(map(str, p)))"}
{"solution": "import math\n\ndef max_volume(n, cakes):\n    # Sort the cakes based on their radius\n    cakes.sort(key=lambda x: x[0])\n\n    # Initialize the maximum volume array\n    max_volumes = [0] * n\n\n    # Calculate the maximum volume for each cake\n    for i in range(n):\n        max_volumes[i] = math.pi * cakes[i][0]**2 * cakes[i][1]\n        for j in range(i):\n            if cakes[i][0] > cakes[j][0]:\n                max_volumes[i] = max(max_volumes[i], max_volumes[j] + math.pi * cakes[i][0]**2 * cakes[i][1])\n\n    # Return the maximum volume\n    return max(max_volumes)\n\n# Read the input\nn = int(input())\ncakes = []\nfor _ in range(n):\n    r, h = map(int, input().split())\n    cakes.append((r, h))\n\n# Print the maximum volume\nprint(max_volume(n, cakes))"}
{"solution": "def min_slices(n, k, h):\n    h.sort()\n    min_height = h[0]\n    slices = 0\n    while h[-1] > min_height:\n        cost = 0\n        for i in range(n):\n            if h[i] > min_height:\n                cost += h[i] - min_height\n        if cost > k:\n            break\n        slices += 1\n        min_height += 1\n    return slices\n\nn, k = map(int, input().split())\nh = list(map(int, input().split()))\nprint(min_slices(n, k, h))"}
{"solution": "def max_score(n, a):\n    # Calculate prefix sums\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + a[i]\n\n    max_score = float('-inf')\n\n    # Iterate over all possible segments [l, r]\n    for l in range(n):\n        max_in_segment = float('-inf')\n        for r in range(l, n):\n            # Update the maximum value in the current segment\n            max_in_segment = max(max_in_segment, a[r])\n            # Calculate the sum of the current segment\n            segment_sum = prefix_sum[r + 1] - prefix_sum[l]\n            # Calculate the score after Bob removes the max value\n            score = segment_sum - max_in_segment\n            # Update the maximum score\n            max_score = max(max_score, score)\n\n    return max_score\n\n# Get input\nn = int(input())\na = list(map(int, input().split()))\n\n# Print output\nprint(max_score(n, a))"}
{"solution": "def gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef solve(k1, k2, k3):\n    lcm12 = lcm(k1, k2)\n    lcm13 = lcm(k1, k3)\n    lcm23 = lcm(k2, k3)\n    lcm123 = lcm(lcm12, k3)\n\n    if lcm123 <= max(k1, k2, k3):\n        return \"YES\"\n    elif lcm12 <= max(k1, k2, k3) or lcm13 <= max(k1, k2, k3) or lcm23 <= max(k1, k2, k3):\n        return \"YES\"\n    else:\n        return \"NO\"\n\nk1, k2, k3 = map(int, input().split())\nprint(solve(k1, k2, k3))"}
{"solution": "def min_operations_to_delete_string(n, s):\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(n)]\n\n    # Base case: single character substrings\n    for i in range(n):\n        dp[i][i] = 1\n\n    # Fill the DP table for substrings of length greater than 1\n    for length in range(2, n + 1):  # length of the substring\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                dp[i][j] = dp[i][j-1]\n            else:\n                dp[i][j] = float('inf')\n                for k in range(i, j):\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n\n    # The result for the entire string\n    return dp[0][n-1]\n\n# Get input\nn = int(input())\ns = input().strip()\n\n# Print the result\nprint(min_operations_to_delete_string(n, s))"}
{"solution": "# Read the number of boys\nn = int(input())\n# Read the boys' dancing skills and sort them\nboys = sorted(list(map(int, input().split())))\n\n# Read the number of girls\nm = int(input())\n# Read the girls' dancing skills and sort them\ngirls = sorted(list(map(int, input().split())))\n\n# Initialize the count of pairs\npairs = 0\n\n# Iterate over the boys and girls\ni = 0\nj = 0\nwhile i < n and j < m:\n    # If the current boy and girl can form a pair\n    if abs(boys[i] - girls[j]) <= 1:\n        # Increment the count of pairs\n        pairs += 1\n        # Move to the next boy and girl\n        i += 1\n        j += 1\n    # If the current boy's skill is less than the current girl's skill\n    elif boys[i] < girls[j]:\n        # Move to the next boy\n        i += 1\n    # If the current girl's skill is less than the current boy's skill\n    else:\n        # Move to the next girl\n        j += 1\n\n# Print the maximum possible number of pairs\nprint(pairs)"}
{"solution": "# Read the input\nplayer1 = list(map(int, input().split()))\nplayer2 = list(map(int, input().split()))\nplayer3 = list(map(int, input().split()))\nplayer4 = list(map(int, input().split()))\n\n# Determine the optimal arrangement for each team\nteam1_defence = max(player1[0], player2[0])\nteam1_attack = max(player1[1], player2[1])\nteam2_defence = max(player3[0], player4[0])\nteam2_attack = max(player3[1], player4[1])\n\n# Determine the winner\nif team1_defence > team2_attack and team1_attack > team2_defence:\n    print(\"Team 1\")\nelif team2_defence > team1_attack and team2_attack > team1_defence:\n    print(\"Team 2\")\nelse:\n    print(\"Draw\")"}
{"solution": "import math\n\n# Read input\nn, k = map(int, input().split())\nmeat = []\nfor i in range(n):\n    x, y, c = map(int, input().split())\n    meat.append((x, y, c))\n\n# Binary search for minimum time\nleft = 0\nright = 1000 * math.sqrt(2 * 1000**2)\nwhile right - left > 1e-6:\n    mid = (left + right) / 2\n    # Count number of meat pieces that can be grilled within mid seconds\n    count = 0\n    for x, y, c in meat:\n        if mid >= c * math.sqrt(x**2 + y**2):\n            count += 1\n    if count >= k:\n        right = mid\n    else:\n        left = mid\n\n# Brute force search for optimal position of heat source\noptimal_time = right\noptimal_x = optimal_y = 0\nfor dx in range(-1000, 1001):\n    for dy in range(-1000, 1001):\n        time = 0\n        for x, y, c in meat:\n            time = max(time, c * math.sqrt((x - dx)**2 + (y - dy)**2))\n        if time < optimal_time:\n            optimal_time = time\n            optimal_x = dx\n            optimal_y = dy\n\n# Print output\nprint(optimal_time)"}
{"solution": "def determine_winner(n, ticket):\n    left_sum = 0\n    right_sum = 0\n    left_question_marks = 0\n    right_question_marks = 0\n\n    for i in range(n // 2):\n        if ticket[i] == '?':\n            left_question_marks += 1\n        else:\n            left_sum += int(ticket[i])\n\n    for i in range(n // 2, n):\n        if ticket[i] == '?':\n            right_question_marks += 1\n        else:\n            right_sum += int(ticket[i])\n\n    if left_question_marks % 2 == 1 and right_question_marks % 2 == 1:\n        return \"Monocarp\"\n    elif left_question_marks % 2 == 0 and right_question_marks % 2 == 0:\n        return \"Bicarp\" if left_sum == right_sum else \"Monocarp\"\n    else:\n        if left_question_marks % 2 == 1:\n            return \"Bicarp\" if (left_sum + 45) % 9 == right_sum % 9 else \"Monocarp\"\n        else:\n            return \"Bicarp\" if left_sum % 9 == (right_sum + 45) % 9 else \"Monocarp\"\n\nn = int(input())\nticket = input()\nprint(determine_winner(n, ticket))"}
{"solution": "def find_bus_route(n, t, bus_routes):\n    earliest_time = float('inf')\n    chosen_route = -1\n\n    for i in range(n):\n        s_i, d_i = bus_routes[i]\n\n        if s_i >= t:\n            next_bus_time = s_i\n        else:\n            # Calculate the next bus time after t\n            if (t - s_i) % d_i == 0:\n                next_bus_time = t\n            else:\n                next_bus_time = s_i + ((t - s_i) // d_i + 1) * d_i\n\n        if next_bus_time < earliest_time:\n            earliest_time = next_bus_time\n            chosen_route = i + 1\n\n    return chosen_route\n\n# Read input\nn, t = map(int, input().split())\nbus_routes = [list(map(int, input().split())) for _ in range(n)]\n\n# Print output\nprint(find_bus_route(n, t, bus_routes))"}
{"solution": "import math\n\ndef count_numbers_with_k_ones(n, k):\n    # Count the number of binary representations of numbers from 1 to n that have exactly k ones\n    count = 0\n    for i in range(1, n + 1):\n        if bin(i).count('1') == k:\n            count += 1\n    return count\n\ndef find_n(m, k):\n    # Find the smallest positive integer n such that among numbers n + 1, n + 2, ..., 2\u00b7n\n    # there are exactly m numbers which binary representation contains exactly k digits one\n    left = 1\n    right = 10 ** 18\n    while left < right:\n        mid = (left + right) // 2\n        if count_numbers_with_k_ones(2 * mid, k) - count_numbers_with_k_ones(mid, k) >= m:\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\nm, k = map(int, input().split())\nprint(find_n(m, k))"}
{"solution": "def is_good_level(level):\n    platform_positions = [i for i, segment in enumerate(level) if segment == '*']\n    for i in range(len(platform_positions) - 4):\n        if platform_positions[i+4] - platform_positions[i+3] == platform_positions[i+3] - platform_positions[i+2] == platform_positions[i+2] - platform_positions[i+1] == platform_positions[i+1] - platform_positions[i]:\n            return True\n    return False\n\nn = int(input())\nlevel = input()\nprint('yes' if is_good_level(level) else 'no')"}
{"solution": "def find_missing_number(grid):\n    n = len(grid)\n    total_sum = sum(grid[0])\n\n    # Check rows\n    for i in range(1, n):\n        if sum(grid[i]) != total_sum:\n            return -1\n\n    # Check columns\n    for j in range(n):\n        col_sum = sum(grid[i][j] for i in range(n))\n        if col_sum != total_sum:\n            return -1\n\n    # Check diagonals\n    main_diag_sum = sum(grid[i][i] for i in range(n))\n    secondary_diag_sum = sum(grid[i][n - i - 1] for i in range(n))\n    if main_diag_sum != total_sum or secondary_diag_sum != total_sum:\n        return -1\n\n    # Find missing number\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 0:\n                row_sum = sum(grid[i])\n                col_sum = sum(grid[k][j] for k in range(n))\n                diag_sum = grid[i][j]\n                if i == j:\n                    diag_sum += sum(grid[k][k] for k in range(n))\n                if i == n - j - 1:\n                    diag_sum += sum(grid[k][n - k - 1] for k in range(n))\n                missing_number = total_sum - max(row_sum, col_sum, diag_sum)\n                return missing_number\n\n    return -1\n\n# Read input\nn = int(input())\ngrid = [list(map(int, input().split())) for _ in range(n)]\n\n# Find missing number\nresult = find_missing_number(grid)\n\n# Print output\nprint(result)"}
{"solution": "import math\n\n# Get the number of benches\nn = int(input())\n\n# Get the number of additional people\nm = int(input())\n\n# Initialize a list to store the number of people on each bench\na = []\n\n# Get the number of people on each bench\nfor i in range(n):\n    a.append(int(input()))\n\n# Calculate the maximum possible k\nmax_k = max(a) + m\n\n# Calculate the total number of people after adding m\ntotal_people = sum(a) + m\n\n# Calculate the minimum possible k\nmin_k = math.ceil(total_people / n)\n\n# Print the minimum and maximum possible k\nprint(min_k, max_k)"}
{"solution": "MOD = 10**9 + 7\n\ndef power(base, exponent):\n    result = 1\n    base %= MOD\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % MOD\n        base = (base * base) % MOD\n        exponent //= 2\n    return result\n\ndef factorial(n):\n    fact = [1]\n    for i in range(1, n+1):\n        fact.append((fact[-1] * i) % MOD)\n    return fact\n\ndef count_ways(n, m):\n    fact = factorial(n)\n    inv_fact = [power(f, MOD-2) for f in fact]\n    ways = 0\n    for i in range(m, n+1):\n        ways = (ways + (fact[i] * inv_fact[m] * inv_fact[i-m]) % MOD) % MOD\n    return (ways * power(2, m)) % MOD\n\nn, m = map(int, input().split())\nresult = count_ways(n, m)\nprint(result)"}
{"solution": "from itertools import combinations\n\n# Read input\nn, m = map(int, input().split())\nfriends = [set(map(int, input().split()[1:])) for _ in range(n)]\npizzas = [(set(map(int, input().split()[2:])), int(input().split()[0])) for _ in range(m)]\n\n# Calculate the number of friends that each pair of pizzas can please\npleased_friends = []\nfor pair in combinations(pizzas, 2):\n    union = pair[0][0] | pair[1][0]\n    count = sum(union >= friend for friend in friends)\n    pleased_friends.append((count, pair[0][1] + pair[1][1], pair))\n\n# Find the pair of pizzas that pleases the maximum number of friends and has the minimum total price\nmax_pleased, min_price, result = max(pleased_friends)\nfor count, price, pair in pleased_friends:\n    if count == max_pleased and price < min_price:\n        min_price = price\n        result = pair\n\n# Print the indices of the chosen pizzas\nprint(pizzas.index(result[0]) + 1, pizzas.index(result[1]) + 1)"}
{"solution": "def find_numbers(m, s):\n    # If sum is 0 and length is more than 1, no such numbers exist\n    if s == 0 and m > 1:\n        return -1, -1\n\n    # If sum is 0 and length is 1, the number is 0\n    if s == 0 and m == 1:\n        return 0, 0\n\n    # Initialize smallest and largest number with 0\n    smallest = [0] * m\n    largest = [0] * m\n\n    # Start from the most significant digit\n    for i in range(m):\n        # If sum is greater than 9, put 9 in the current digit\n        if s > 9:\n            smallest[i] = 9\n            largest[i] = 9\n            s -= 9\n        # Else, put the remaining sum in the current digit\n        else:\n            smallest[i] = s\n            largest[i] = s\n            s = 0\n\n    # If there is still sum left, no such numbers exist\n    if s > 0:\n        return -1, -1\n\n    # If the smallest number has leading zeroes, no such numbers exist\n    if smallest[0] == 0:\n        return -1, -1\n\n    # Swap the first non-zero digit of the smallest number with the first digit\n    for i in range(1, m):\n        if smallest[i] != 0:\n            smallest[i], smallest[0] = smallest[0], smallest[i]\n            break\n\n    # Convert the lists to integers\n    smallest = int(''.join(map(str, smallest)))\n    largest = int(''.join(map(str, largest)))\n\n    return smallest, largest\n\n# Read input\nm, s = map(int, input().split())\n\n# Find and print the numbers\nsmallest, largest = find_numbers(m, s)\nprint(smallest, largest)"}
{"solution": "def solve(l, r, k):\n    MOD = 998244353\n\n    def count_numbers(n):\n        dp = [[0] * (1 << 10) for _ in range(20)]\n        dp[0][0] = 1\n\n        for i in range(1, 20):\n            for mask in range(1 << 10):\n                for digit in range(10):\n                    if (mask >> digit) & 1:\n                        dp[i][mask] = (dp[i][mask] + dp[i - 1][mask]) % MOD\n                    else:\n                        dp[i][mask | (1 << digit)] = (dp[i][mask | (1 << digit)] + dp[i - 1][mask]) % MOD\n\n        res = 0\n        for mask in range(1 << 10):\n            if bin(mask).count('1') <= k:\n                res = (res + dp[-1][mask]) % MOD\n\n        return res\n\n    return (count_numbers(r) - count_numbers(l - 1)) % MOD\n\nl, r, k = map(int, input().split())\nprint(solve(l, r, k))"}
{"solution": "def can_distribute_pencils(n, k, d, pencils):\n    pencils.sort()\n    i = 0\n    while i < n:\n        count = 1\n        while i + count < n and pencils[i + count] - pencils[i] <= d:\n            count += 1\n        if count < k:\n            return False\n        i += count\n    return True\n\nn, k, d = map(int, input().split())\npencils = list(map(int, input().split()))\n\nif can_distribute_pencils(n, k, d, pencils):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "# Get the input string\ns = input()\n\n# Initialize the count of dead light bulbs for each color\ncount_r, count_b, count_y, count_g = 0, 0, 0, 0\n\n# Iterate over the string\nfor i in range(len(s)):\n    # If the current light bulb is dead\n    if s[i] == '!':\n        # Check the previous and next light bulbs to determine the color\n        if i > 0 and i < len(s) - 1:\n            if s[i-1] != s[i+1]:\n                if s[i-1] == 'R' or s[i+1] == 'R':\n                    count_r += 1\n                elif s[i-1] == 'B' or s[i+1] == 'B':\n                    count_b += 1\n                elif s[i-1] == 'Y' or s[i+1] == 'Y':\n                    count_y += 1\n                elif s[i-1] == 'G' or s[i+1] == 'G':\n                    count_g += 1\n        # If the current light bulb is at the beginning or end of the string\n        else:\n            # Check the next light bulb\n            if i < len(s) - 1:\n                if s[i+1] == 'R':\n                    count_r += 1\n                elif s[i+1] == 'B':\n                    count_b += 1\n                elif s[i+1] == 'Y':\n                    count_y += 1\n                elif s[i+1] == 'G':\n                    count_g += 1\n            # Check the previous light bulb\n            elif i > 0:\n                if s[i-1] == 'R':\n                    count_r += 1\n                elif s[i-1] == 'B':\n                    count_b += 1\n                elif s[i-1] == 'Y':\n                    count_y += 1\n                elif s[i-1] == 'G':\n                    count_g += 1\n\n# Print the count of dead light bulbs for each color\nprint(count_r, count_b, count_y, count_g)"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef read_input():\n    return sys.stdin.readline\n\ndef main():\n    n, m = map(int, read_input().split())\n    graph = defaultdict(list)\n    for _ in range(m):\n        s, t = map(int, read_input().split())\n        graph[s].append(t)\n\n    dp = [0] * (n + 1)\n    dp[n] = 0\n    for i in range(n - 1, 0, -1):\n        total = 0\n        for j in graph[i]:\n            total += dp[j]\n        dp[i] = total / len(graph[i]) + 1\n\n    min_expected_passages = float('inf')\n    for j in graph[1]:\n        if j == n:\n            continue\n        expected_passages = (dp[j] + 1) * len(graph[1]) / (len(graph[1]) - 1)\n        min_expected_passages = min(min_expected_passages, expected_passages)\n\n    print(min(min_expected_passages, dp[1]))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Get the input number from the user\nn = int(input())\n\n# Check if the number already ends in 0\nif n % 10 == 0:\n    # If it does, print the number as it is\n    print(n)\nelse:\n    # If it doesn't, calculate the nearest lower and higher multiples of 10\n    lower_multiple = n // 10 * 10\n    higher_multiple = lower_multiple + 10\n\n    # Determine which multiple is closer to the number\n    if n - lower_multiple < higher_multiple - n:\n        # If the lower multiple is closer, print it\n        print(lower_multiple)\n    else:\n        # If the higher multiple is closer, print it\n        print(higher_multiple)"}
{"solution": "def find_swaps(s, t):\n    if len(s) != len(t):\n        return -1\n\n    mismatches = {}\n\n    for i in range(len(s)):\n        if s[i] != t[i]:\n            if s[i] in mismatches and mismatches[s[i]] != t[i]:\n                return -1\n            if t[i] in mismatches and mismatches[t[i]] != s[i]:\n                return -1\n            mismatches[s[i]] = t[i]\n            mismatches[t[i]] = s[i]\n\n    visited = set()\n    swaps = []\n\n    for key in mismatches:\n        if key not in visited:\n            cycle = []\n            current = key\n            while current not in visited:\n                visited.add(current)\n                cycle.append(current)\n                current = mismatches[current]\n            if len(cycle) != 2:\n                return -1\n            swaps.append((cycle[0], cycle[1]))\n\n    print(len(swaps))\n    for swap in swaps:\n        print(swap[0], swap[1])\n\n# Example usage:\ns = \"helloworld\"\nt = \"ehoolwlroz\"\nfind_swaps(s, t)"}
{"solution": "def earliest_login(first_name, last_name):\n    # Generate all possible prefixes for first and last names\n    first_prefixes = [first_name[:i] for i in range(1, len(first_name) + 1)]\n    last_prefixes = [last_name[:i] for i in range(1, len(last_name) + 1)]\n\n    # Generate all possible combinations of first and last name prefixes\n    combinations = [f + l for f in first_prefixes for l in last_prefixes]\n\n    # Sort the combinations alphabetically and return the first one\n    return sorted(combinations)[0]\n\n# Get input\nfirst_name, last_name = input().split()\n\n# Print the earliest possible login\nprint(earliest_login(first_name, last_name))"}
{"solution": "def draw_brackets(sequence):\n    n = len(sequence)\n    height = n // 2\n    width = 2 * height + 1\n    grid = [[' ' for _ in range(width)] for _ in range(height)]\n\n    def draw(start, end, row):\n        if start > end:\n            return\n        mid = (start + end) // 2\n        grid[row][mid] = '+'\n        grid[row + 1][mid] = '|'\n        i = start\n        while i < mid:\n            if sequence[i] == '[':\n                grid[row][i] = '-'\n                grid[row + 1][i] = '+'\n                j = i + 1\n                balance = 1\n                while balance > 0:\n                    if sequence[j] == '[':\n                        balance += 1\n                    else:\n                        balance -= 1\n                    j += 1\n                draw(i + 1, j - 1, row + 1)\n                i = j - 1\n            i += 1\n        i = mid + 1\n        while i < end:\n            if sequence[i] == ']':\n                grid[row][i] = '-'\n                grid[row + 1][i] = '+'\n                j = i - 1\n                balance = 1\n                while balance > 0:\n                    if sequence[j] == ']':\n                        balance += 1\n                    else:\n                        balance -= 1\n                    j -= 1\n                draw(j + 1, i - 1, row + 1)\n                i = j + 1\n            i += 1\n\n    draw(0, n - 1, 0)\n    return [''.join(row) for row in grid]\n\nn = int(input())\nsequence = input()\nresult = draw_brackets(sequence)\nfor row in result:\n    print(row)"}
{"solution": "def normalize_golden_number(golden_number):\n    golden_number = list(map(int, golden_number))\n    n = len(golden_number)\n\n    for i in range(n - 1, 0, -1):\n        if golden_number[i] > 1:\n            golden_number[i] -= 2\n            golden_number[i - 1] += 1\n            if i - 2 >= 0:\n                golden_number[i - 2] += 1\n\n    while len(golden_number) > 1 and golden_number[0] == 0:\n        golden_number.pop(0)\n\n    return golden_number\n\ndef compare_golden_numbers(num1, num2):\n    norm_num1 = normalize_golden_number(num1)\n    norm_num2 = normalize_golden_number(num2)\n\n    if len(norm_num1) > len(norm_num2):\n        return \">\"\n    elif len(norm_num1) < len(norm_num2):\n        return \"<\"\n\n    for digit1, digit2 in zip(norm_num1, norm_num2):\n        if digit1 > digit2:\n            return \">\"\n        elif digit1 < digit2:\n            return \"<\"\n\n    return \"=\"\n\nnum1 = input().strip()\nnum2 = input().strip()\n\nresult = compare_golden_numbers(num1, num2)\nprint(result)"}
{"solution": "# Define the dictionary of Infinity Gems and their colors\ninfinity_gems = {\n    'Purple': 'Power',\n    'Green': 'Time',\n    'Blue': 'Space',\n    'Orange': 'Soul',\n    'Red': 'Reality',\n    'Yellow': 'Mind'\n}\n\n# Get the number of Gems in Infinity Gauntlet\nn = int(input())\n\n# Initialize an empty list to store the present Gems\npresent_gems = []\n\n# Get the colors of the Gems in Infinity Gauntlet\nfor _ in range(n):\n    color = input()\n    present_gems.append(infinity_gems[color.capitalize()])\n\n# Initialize an empty list to store the absent Gems\nabsent_gems = []\n\n# Check for the absence of each Gem\nfor gem in infinity_gems.values():\n    if gem not in present_gems:\n        absent_gems.append(gem)\n\n# Print the number of absent Gems\nprint(len(absent_gems))\n\n# Print the names of absent Gems\nfor gem in absent_gems:\n    print(gem)"}
{"solution": "def find_round(n, a, b):\n    round = 1\n    while n > 1:\n        if a % 2 == 1 and a + 1 == b:\n            return round\n        if b % 2 == 1 and b + 1 == a:\n            return round\n        a = (a + 1) // 2\n        b = (b + 1) // 2\n        n //= 2\n        round += 1\n    return \"Final!\"\n\nn, a, b = map(int, input().split())\nprint(find_round(n, a, b))"}
{"solution": "def min_changes(n, p, b):\n    # Create a list to store the visited positions for each skewer\n    visited = [set() for _ in range(n)]\n\n    # Simulate the movement of skewers for k seconds\n    for k in range(2 * n):\n        # Create a list to store the new positions of skewers\n        new_positions = [0] * n\n\n        # Calculate the new positions of skewers\n        for i in range(n):\n            new_positions[i] = p[new_positions[i]]\n            if b[new_positions[i]] == 1:\n                new_positions[i] = n - new_positions[i] - 1\n\n        # Update the visited positions for each skewer\n        for i in range(n):\n            visited[i].add(new_positions[i])\n\n        # Check if every skewer has visited every position\n        if all(len(visited[i]) == 2 * n for i in range(n)):\n            return 0\n\n    # Calculate the minimum total number of changes needed\n    changes = 0\n    for i in range(n):\n        if len(visited[i]) < 2 * n:\n            changes += 2 * n - len(visited[i])\n    return changes\n\n# Read the input\nn = int(input())\np = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Calculate the minimum total number of changes needed\nresult = min_changes(n, p, b)\n\n# Print the result\nprint(result)"}
{"solution": "# Get the input values\nv1, v2 = map(int, input().split())\nt, d = map(int, input().split())\n\n# Initialize the maximum possible length of the path section\nmax_length = 0\n\n# Initialize the current speed\ncurrent_speed = v1\n\n# Iterate through each second of the time\nfor _ in range(t):\n    # Add the current speed to the maximum possible length\n    max_length += current_speed\n\n    # If the current speed is less than v2, increase it by d\n    if current_speed < v2:\n        current_speed = min(current_speed + d, v2)\n    # If the current speed is greater than v2, decrease it by d\n    elif current_speed > v2:\n        current_speed = max(current_speed - d, v2)\n\n# Print the maximum possible length of the path section\nprint(max_length)"}
{"solution": "import sys\n\ndef can_cross_bridge(mid, weights, lengths, capacities):\n    n = len(weights)\n    m = len(lengths)\n    prefix_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + weights[i - 1]\n\n    j = 0\n    for i in range(1, n):\n        while j < m and lengths[j] < mid * (i / n):\n            j += 1\n        if j == m or capacities[j] < prefix_sum[i]:\n            return False\n\n    return True\n\ndef find_min_distance(weights, lengths, capacities):\n    left = 0\n    right = 10 ** 16\n    while left < right:\n        mid = (left + right) // 2\n        if can_cross_bridge(mid, weights, lengths, capacities):\n            right = mid\n        else:\n            left = mid + 1\n\n    return left\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    weights = list(map(int, sys.stdin.readline().split()))\n    lengths = []\n    capacities = []\n    for _ in range(m):\n        l, v = map(int, sys.stdin.readline().split())\n        lengths.append(l)\n        capacities.append(v)\n\n    min_distance = find_min_distance(weights, lengths, capacities)\n    if min_distance == 10 ** 16:\n        print(-1)\n    else:\n        print(min_distance)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def last_digit_factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    elif n >= 5:\n        return 0\n    else:\n        result = 1\n        for i in range(2, n + 1):\n            result = (result * i) % 10\n        return result\n\ndef last_digit_division(a, b):\n    if a == b:\n        return 1\n    else:\n        return (last_digit_factorial(b) * pow(last_digit_factorial(a), 10 - 2, 10)) % 10\n\na, b = map(int, input().split())\nprint(last_digit_division(a, b))"}
{"solution": "from collections import deque\n\ndef min_jumps(n, d, lilies):\n    visited = [False] * n\n    queue = deque([(0, 0)])  # (position, jumps)\n\n    while queue:\n        pos, jumps = queue.popleft()\n\n        if pos == n - 1:\n            return jumps\n\n        for i in range(1, d + 1):\n            next_pos = pos + i\n\n            if next_pos < n and lilies[next_pos] == '1' and not visited[next_pos]:\n                visited[next_pos] = True\n                queue.append((next_pos, jumps + 1))\n\n    return -1\n\nn, d = map(int, input().split())\nlilies = input()\n\nprint(min_jumps(n, d, lilies))"}
{"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_counterexample(n):\n    for m in range(1, 1001):\n        if not is_prime(n * m + 1):\n            return m\n\n# Read input\nn = int(input().strip())\n\n# Find and print the counterexample\nprint(find_counterexample(n))"}
{"solution": "def can_spend_all_coins(n):\n    for a in range(n // 1234567 + 1):\n        for b in range((n - a * 1234567) // 123456 + 1):\n            c = (n - a * 1234567 - b * 123456) // 1234\n            if a * 1234567 + b * 123456 + c * 1234 == n:\n                return True\n    return False\n\nn = int(input())\nif can_spend_all_coins(n):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def check_intersection(lines, x1, x2):\n    # Sort lines based on their slopes\n    lines.sort(key=lambda x: x[0])\n\n    # Check for intersection with the next line\n    for i in range(len(lines) - 1):\n        k1, b1 = lines[i]\n        k2, b2 = lines[i + 1]\n\n        # If slopes are equal, lines are parallel and do not intersect\n        if k1 == k2:\n            continue\n\n        # Calculate intersection point\n        x = (b2 - b1) / (k1 - k2)\n\n        # Check if intersection point is within the strip\n        if x1 < x < x2:\n            return True\n\n    return False\n\n# Read input\nn = int(input())\nx1, x2 = map(int, input().split())\nlines = [list(map(int, input().split())) for _ in range(n)]\n\n# Check for intersection\nif check_intersection(lines, x1, x2):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def count_different_weights(n):\n    # Initialize the count of different weights\n    count = 0\n\n    # Iterate through all possible first elements of the split\n    for i in range(1, n + 1):\n        # Calculate the remaining sum after subtracting the first element\n        remaining = n - i\n\n        # Calculate the number of ways to split the remaining sum into equal parts\n        # This is equivalent to finding the number of times `i` can be subtracted from `remaining`\n        # until `remaining` becomes less than `i`\n        num_ways = remaining // i\n\n        # Update the count of different weights\n        count += num_ways\n\n    # Return the count of different weights\n    return count\n\n# Read the input value of `n`\nn = int(input())\n\n# Call the function to count the number of different weights\nresult = count_different_weights(n)\n\n# Print the result\nprint(result)"}
{"solution": "def find_good_apartments(n, k):\n    if k == 0:\n        min_good = 0\n        max_good = 0\n    else:\n        min_good = 1\n        max_good = min(n - k, 2 * k)\n\n    return min_good, max_good\n\n# Get input\nn, k = map(int, input().split())\n\n# Find good apartments\nmin_good, max_good = find_good_apartments(n, k)\n\n# Print output\nprint(min_good, max_good)"}
{"solution": "import math\n\n# Get the input\nn = int(input())\n\n# Calculate the maximum number of games the winner can play\nmax_games = math.floor(math.log2(n))\n\n# Print the result\nprint(max_games)"}
{"solution": "def max_vk_occurrences(s):\n    # Initialize the count of VK occurrences\n    count = 0\n\n    # Iterate through the string\n    for i in range(len(s) - 1):\n        # If we find a VK pair, increment the count\n        if s[i] == 'V' and s[i + 1] == 'K':\n            count += 1\n        # If we find a V not followed by a K, check if changing it to a K would create a VK pair\n        elif s[i] == 'V' and s[i + 1] != 'K':\n            if i + 2 < len(s) and s[i + 2] == 'K':\n                count += 1\n            # If changing it to a K would not create a VK pair, check if changing the next K to a V would create a VK pair\n            elif i + 2 < len(s) and s[i + 2] == 'V':\n                count += 1\n\n    # If the last character is a V and it's not part of a VK pair, check if changing it to a K would create a VK pair\n    if s[-1] == 'V' and s[-2] != 'K':\n        count += 1\n\n    return count\n\n# Get the input string\ns = input()\n\n# Print the maximum number of VK occurrences\nprint(max_vk_occurrences(s))"}
{"solution": "import math\n\ndef min_segments(n):\n    a = int(math.sqrt(n))\n    b = (n + a - 1) // a\n    return a + b + 2\n\nn = int(input().strip())\nprint(min_segments(n))"}
{"solution": "def years_to_become_larger(a, b):\n    years = 0\n    while a <= b:\n        a *= 3\n        b *= 2\n        years += 1\n    return years\n\na, b = map(int, input().split())\nprint(years_to_become_larger(a, b))"}
{"solution": "def solve(h, n):\n    visited = [False] * (2 ** h)\n    current = 0\n    visited[current] = True\n    count = 0\n    i = 0\n    while True:\n        if i % 2 == 0:  # 'L' command\n            next = 2 * current + 1\n        else:  # 'R' command\n            next = 2 * current + 2\n        if next >= 2 ** h or visited[next]:  # destination node is out of bounds or already visited\n            if current == 0:  # if we're at the root, we're done\n                break\n            else:\n                current = (current - 1) // 2  # go back to the parent\n                i += 1\n                continue\n        current = next\n        visited[current] = True\n        count += 1\n        if current >= 2 ** (h - 1) and current != n - 1:  # if we're at a leaf that's not the exit\n            current = (current - 1) // 2  # go back to the parent\n        elif current == n - 1:  # if we're at the exit\n            break\n        i += 1\n    return count\n\nh, n = map(int, input().split())\nprint(solve(h, n))"}
{"solution": "def count_tables(x):\n    tables = []\n    for n in range(1, int(x**0.5) + 1):\n        if x % n == 0:\n            m = x // n\n            if n <= m:\n                tables.append((n, m))\n            if n != m:\n                tables.append((m, n))\n    return tables\n\ndef main():\n    x = int(input())\n    tables = count_tables(x)\n    print(len(tables))\n    for table in tables:\n        print(*table)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# List of days in each month\nmonth_days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n# Number of inputs\nn = int(input())\n\n# List of inputs\ninputs = list(map(int, input().split()))\n\n# Check if the inputs can be a sequence of months\nfor i in range(12):\n    if month_days[i:i+n] == inputs:\n        print(\"YES\")\n        break\nelse:\n    print(\"NO\")"}
{"solution": "def find_fractions(n):\n    # Initialize an empty list to store the fractions\n    fractions = []\n\n    # Iterate through all possible divisors of n\n    for b in range(2, n):\n        if n % b == 0:\n            # Calculate the corresponding a value\n            a = 1\n            while a < b and (a / b) >= (1 / n - sum(fractions)):\n                # Check if adding the fraction to the sequence still satisfies the conditions\n                if (1 / n - sum(fractions) - a / b) > 0 and (1 / n - sum(fractions) - a / b) < (1 / b):\n                    # Add the fraction to the sequence\n                    fractions.append(a / b)\n                    break\n                a += 1\n\n    # Check if the sequence sums to 1 - 1/n\n    if sum(fractions) == 1 - (1 / n):\n        return \"YES\\n\" + str(len(fractions)) + \"\\n\" + \"\\n\".join([f\"{int(f.numerator)} {int(f.denominator)}\" for f in fractions])\n    else:\n        return \"NO\"\n\n# Read the input\nn = int(input())\n\n# Print the result\nprint(find_fractions(n))"}
{"solution": "def min_unattractiveness(n, a, b, h):\n    # Initialize a 2D dp array to store the minimum unattractiveness values\n    dp = [[float('inf')] * (b + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    # Iterate through each board\n    for i in range(1, n + 1):\n        # Iterate through each possible amount of red paint\n        for j in range(a + 1):\n            # Iterate through each possible amount of green paint\n            for k in range(b + 1):\n                # If the current board can be painted red\n                if j >= h[i - 1]:\n                    # Update the minimum unattractiveness value\n                    dp[i][k] = min(dp[i][k], dp[i - 1][j - h[i - 1]])\n                # If the current board can be painted green\n                if k >= h[i - 1]:\n                    # Update the minimum unattractiveness value\n                    dp[i][k] = min(dp[i][k], dp[i - 1][j] + (h[i - 1] if j > 0 else 0))\n\n    # Find the minimum unattractiveness value\n    min_unattractiveness = min(dp[n])\n    return min_unattractiveness if min_unattractiveness != float('inf') else -1\n\n# Read input\nn = int(input())\na, b = map(int, input().split())\nh = list(map(int, input().split()))\n\n# Print output\nprint(min_unattractiveness(n, a, b, h))"}
{"solution": "def find_triangle_points(n, m, k):\n    # Check if a solution is possible\n    if n * m < k or n < 2 or m < 2:\n        print(\"NO\")\n        return\n\n    # Calculate the target area\n    target_area = n * m / k\n\n    # Iterate through all possible points\n    for x1 in range(n + 1):\n        for y1 in range(m + 1):\n            for x2 in range(x1 + 1, n + 1):\n                for y2 in range(m + 1):\n                    # Calculate the area of the triangle formed by (x1, y1) and (x2, y2)\n                    area = abs(x1 * y2 - x2 * y1) / 2\n\n                    # Check if the area matches the target area\n                    if area == target_area:\n                        # Calculate the third point (x3, y3)\n                        x3 = x2\n                        y3 = y1 + (target_area * 2) // (x2 - x1)\n\n                        # Check if the third point is valid\n                        if 0 <= y3 <= m:\n                            print(\"YES\")\n                            print(x1, y1)\n                            print(x2, y2)\n                            print(x3, y3)\n                            return\n\n    # If no solution is found\n    print(\"NO\")\n\n# Read the input\nn, m, k = map(int, input().split())\n\n# Call the function to find the triangle points\nfind_triangle_points(n, m, k)"}
{"solution": "# Read input\nn, k = map(int, input().split())\n\n# Check if Sasha wins\nif n % (2 * k) != 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "# Read and parse input\nn = int(input())\nrepetitions = list(map(int, input().split()))\n\n# Initialize counters for each muscle group\nchest = 0\nbiceps = 0\nback = 0\n\n# Iterate through the exercises\nfor i in range(n):\n    # Determine the muscle group based on the cyclic pattern\n    if i % 3 == 0:\n        chest += repetitions[i]\n    elif i % 3 == 1:\n        biceps += repetitions[i]\n    else:\n        back += repetitions[i]\n\n# Compare totals and output the result\nif chest > biceps and chest > back:\n    print(\"chest\")\nelif biceps > chest and biceps > back:\n    print(\"biceps\")\nelse:\n    print(\"back\")"}
{"solution": "def min_redos_to_get_five(n, grades):\n    current_sum = sum(grades)\n    target_sum = n * 4.5\n\n    if current_sum >= target_sum:\n        return 0\n\n    grades.sort()\n    redos = 0\n\n    for grade in grades:\n        if current_sum >= target_sum:\n            break\n        current_sum += (5 - grade)\n        redos += 1\n\n    return redos\n\n# Example usage:\nn = int(input())\ngrades = list(map(int, input().split()))\nprint(min_redos_to_get_five(n, grades))"}
{"solution": "def solve(u, v):\n    # If u and v are equal, return an array of length 1 with the value u\n    if u == v:\n        return [u]\n\n    # If u is greater than v, it's impossible to find a valid array\n    if u > v:\n        return -1\n\n    # If u is 0, it's only possible to find a valid array if v is also 0\n    if u == 0:\n        return [0] if v == 0 else -1\n\n    # Initialize an empty array\n    result = []\n\n    # While u is not 0\n    while u != 0:\n        # Find the largest possible value that can be added to the array\n        # such that the sum of the array does not exceed v\n        # and the bitwise XOR of the array does not exceed u\n        val = min(u, v)\n\n        # Update u and v\n        u ^= val\n        v -= val\n\n        # Add the value to the array\n        result.append(val)\n\n    # If v is not 0, it's impossible to find a valid array\n    if v != 0:\n        return -1\n\n    # Return the array\n    return result\n\n# Read the input\nu, v = map(int, input().split())\n\n# Solve the problem\nresult = solve(u, v)\n\n# Print the output\nif result == -1:\n    print(-1)\nelse:\n    print(len(result))\n    print(' '.join(map(str, result)))"}
{"solution": "def min_digits_1(n):\n    # Initialize the count of '1' digits\n    count = 0\n\n    # While n is greater than 0\n    while n > 0:\n        # If n is divisible by 10, subtract 10 from n\n        if n % 10 == 0:\n            n -= 10\n        # Otherwise, subtract the remainder of n divided by 10 from n\n        else:\n            n -= n % 10\n        # Increment the count of '1' digits\n        count += n // 10\n\n    # Return the count of '1' digits\n    return count\n\n# Read the input\nn = int(input())\n\n# Print the expected minimal number of digits '1'\nprint(min_digits_1(n))"}
{"solution": "def can_reach_treasure(x1, y1, x2, y2, x, y):\n    # If the starting point is the ending point, return True\n    if x1 == x2 and y1 == y2:\n        return True\n\n    # If the moves are not possible, return False\n    if (x2 - x1) % x != 0 or (y2 - y1) % y != 0:\n        return False\n\n    # If the moves are possible, return True\n    return True\n\n# Get the input\nx1, y1, x2, y2 = map(int, input().split())\nx, y = map(int, input().split())\n\n# Check if the treasure can be reached\nif can_reach_treasure(x1, y1, x2, y2, x, y):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "from itertools import permutations\n\ndef count_valid_bus_numbers(n):\n    # Convert the number to a string to extract digits\n    digits = list(str(n))\n\n    # Generate all unique permutations of the digits\n    all_permutations = set(permutations(digits))\n\n    # Filter out permutations that start with '0'\n    valid_permutations = set()\n    for perm in all_permutations:\n        if perm[0] != '0':\n            valid_permutations.add(perm)\n\n    # Return the count of valid permutations\n    return len(valid_permutations)\n\n# Read input\nn = int(input().strip())\n\n# Get the count of valid bus numbers\nresult = count_valid_bus_numbers(n)\n\n# Print the result\nprint(result)"}
{"solution": "# Read the input\na = int(input())  # number of ties\nb = int(input())  # number of scarves\nc = int(input())  # number of vests\nd = int(input())  # number of jackets\ne = int(input())  # cost of one suit of the first type\nf = int(input())  # cost of one suit of the second type\n\n# Calculate the maximum number of suits of the first type that can be made\nsuits_first_type = min(a, d)\n\n# Calculate the maximum number of suits of the second type that can be made\nsuits_second_type = min(b, c, d)\n\n# Calculate the maximum possible cost of a set of suits\nmax_cost = suits_first_type * e + suits_second_type * f\n\n# Print the maximum possible cost\nprint(max_cost)"}
{"solution": "def modular_power(base, exponent, modulus):\n    result = 1\n    base = base % modulus\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % modulus\n        exponent = exponent // 2\n        base = (base * base) % modulus\n    return result\n\ndef modular_inverse(a, m):\n    g = gcd(a, m)\n    if g != 1:\n        return None\n    else:\n        return pow(a, m - 2, m)\n\ndef solve(a, b, p, x):\n    count = 0\n    b_inv = modular_inverse(b, p)\n    for n in range(1, x + 1):\n        n_inv = modular_inverse(n, p)\n        if n_inv is not None:\n            rhs = (b_inv * n_inv) % p\n            lhs = modular_power(a, n, p)\n            if lhs == rhs:\n                count += 1\n    return count\n\ndef main():\n    a, b, p, x = map(int, input().split())\n    result = solve(a, b, p, x)\n    print(result)\n\nif __name__ == '__main__':\n    main()"}
{"solution": "# Get the input\nk_2, k_3, k_5, k_6 = map(int, input().split())\n\n# Calculate the maximum number of 256 that can be formed\nmax_256 = min(k_2, k_5, k_6)\n\n# Calculate the remaining 2's after forming 256\nremaining_2 = k_2 - max_256\n\n# Calculate the maximum number of 32 that can be formed\nmax_32 = min(k_3, remaining_2)\n\n# Calculate the final sum\nfinal_sum = max_256 * 256 + max_32 * 32\n\n# Print the final sum\nprint(final_sum)"}
{"solution": "def bender_happy(n, x, y, c):\n    # If the initial cell is already enough to make Bender happy, return 0\n    if c == 1:\n        return 0\n\n    # Initialize the grid with all cells off\n    grid = [[0] * n for _ in range(n)]\n\n    # Switch on the initial cell\n    grid[x - 1][y - 1] = 1\n\n    # Initialize the count of switched on cells and the time\n    count = 1\n    time = 0\n\n    # While there are not enough switched on cells\n    while count < c:\n        # Increment the time\n        time += 1\n\n        # Create a copy of the grid to avoid changing it while iterating over it\n        new_grid = [row[:] for row in grid]\n\n        # Iterate over each cell in the grid\n        for i in range(n):\n            for j in range(n):\n                # If the cell is off but has a side-adjacent cell that is on\n                if grid[i][j] == 0 and (\n                    (i > 0 and grid[i - 1][j] == 1) or\n                    (i < n - 1 and grid[i + 1][j] == 1) or\n                    (j > 0 and grid[i][j - 1] == 1) or\n                    (j < n - 1 and grid[i][j + 1] == 1)\n                ):\n                    # Switch on the cell\n                    new_grid[i][j] = 1\n                    # Increment the count of switched on cells\n                    count += 1\n\n        # Update the grid\n        grid = new_grid\n\n    # Return the time\n    return time\n\n# Get the input\nn, x, y, c = map(int, input().split())\n\n# Print the output\nprint(bender_happy(n, x, y, c))"}
{"solution": "def max_xor(l, r):\n    # If the range is a single number, return 0\n    if l == r:\n        return 0\n\n    # If the range is two numbers, return the XOR of those numbers\n    elif l + 1 == r:\n        return l ^ r\n\n    # If the range is larger, the maximum XOR value will be the largest possible number within that range\n    # To find this number, we can calculate the number of bits in the largest number of the range\n    # and then create a number with that many bits set to 1\n    else:\n        # Calculate the number of bits in the largest number of the range\n        bits = len(bin(r)) - 2\n\n        # Create a number with that many bits set to 1\n        max_num = (1 << bits) - 1\n\n        # If the largest number in the range is greater than the maximum possible number,\n        # then the maximum XOR value will be the maximum possible number\n        if r > max_num:\n            return max_num\n\n        # Otherwise, the maximum XOR value will be the maximum possible number XORed with the largest number in the range minus 1\n        else:\n            return max_num ^ (r - 1)\n\n# Read the input\nl, r = map(int, input().split())\n\n# Print the maximum XOR value\nprint(max_xor(l, r))"}
{"solution": "def minimum_height(n, k):\n    left, right = 1, k\n\n    while left < right:\n        mid = (left + right) // 2\n        if n * mid >= k:\n            right = mid\n        else:\n            left = mid + 1\n\n    return left\n\nn, k = map(int, input().split())\nprint(minimum_height(n, k))"}
{"solution": "def should_use_elevator(x, y, z, t1, t2, t3):\n    stairs_time = abs(x - y) * t1\n    elevator_to_masha_time = abs(z - x) * t2 + t3\n    elevator_to_egor_time = abs(x - y) * t2 + 2 * t3\n    elevator_time = elevator_to_masha_time + elevator_to_egor_time\n    if stairs_time < elevator_time:\n        return \"NO\"\n    else:\n        return \"YES\"\n\nx, y, z, t1, t2, t3 = map(int, input().split())\nprint(should_use_elevator(x, y, z, t1, t2, t3))"}
{"solution": "# Read the input\nn, m = map(int, input().split())\n\n# Calculate the optimal value of a\nif m <= n // 2:\n    a = n\nelse:\n    a = 1\n\n# Print the result\nprint(a)"}
{"solution": "# Read the number of lessons\nn = int(input())\n\n# Read the schedule\nschedule = list(map(int, input().split()))\n\n# Initialize the count of pairs Alena stays at the university\ncount = 0\n\n# Initialize the flag to check if Alena is at the university\nat_university = False\n\n# Iterate over the schedule\nfor i in range(n):\n    # If Alena has a pair\n    if schedule[i] == 1:\n        # Increment the count\n        count += 1\n        # Set the flag to True\n        at_university = True\n    # If Alena doesn't have a pair and she is at the university\n    elif at_university:\n        # Check if the next pair is also a break\n        if i < n - 1 and schedule[i + 1] == 0:\n            # If it is, then Alena goes home\n            at_university = False\n        else:\n            # Otherwise, Alena stays at the university\n            count += 1\n\n# Print the result\nprint(count)"}
{"solution": "# Read input\nn, k = map(int, input().split())\ncandies = list(map(int, input().split()))\n\n# Initialize variables\nbran_candies = 0\ndays = 0\n\n# Iterate through each day\nfor i in range(n):\n    # Arya gives Bran at most 8 candies per day\n    bran_candies += min(8, candies[i])\n    candies[i] -= min(8, candies[i])\n\n    # If Bran has enough candies, break the loop\n    if bran_candies >= k:\n        days = i + 1\n        break\n\n# If Bran doesn't have enough candies, print -1\nif bran_candies < k:\n    print(-1)\nelse:\n    print(days)"}
{"solution": "def minimum_additional_walks(n, k, a):\n    b = a[:]\n    additional_walks = 0\n\n    for i in range(n - 1):\n        if b[i] + b[i + 1] < k:\n            needed_walks = k - (b[i] + b[i + 1])\n            b[i + 1] += needed_walks\n            additional_walks += needed_walks\n\n    return additional_walks, b\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Get the result\nadditional_walks, b = minimum_additional_walks(n, k, a)\n\n# Print the result\nprint(additional_walks)\nprint(' '.join(map(str, b)))"}
{"solution": "# Get the order of the rhombus from the user\nn = int(input())\n\n# Calculate the number of cells in the rhombus using the formula: (2n^2) - (2n) + 1\nnum_cells = (2 * n * n) - (2 * n) + 1\n\n# Print the result\nprint(num_cells)"}
{"solution": "# Read the input\nn = int(input())\ns = input()\n\n# Convert the string to lowercase for simplicity\ns = s.lower()\n\n# Create a set to track the unique letters found in the string\nletters_found = set()\n\n# Iterate through the string and add each letter to the set\nfor char in s:\n    letters_found.add(char)\n\n# Check if the set contains all 26 letters of the alphabet\nif len(letters_found) == 26:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "# Get the current time and the number of minutes passed\ncurrent_time = input()\nminutes_passed = int(input())\n\n# Split the current time into hours and minutes\nhours, minutes = map(int, current_time.split(':'))\n\n# Calculate the total minutes\ntotal_minutes = hours * 60 + minutes + minutes_passed\n\n# Calculate the new hours and minutes\nnew_hours = total_minutes // 60 % 24\nnew_minutes = total_minutes % 60\n\n# Print the new time in the format hh:mm\nprint(f'{new_hours:02d}:{new_minutes:02d}')"}
{"solution": "# Read input\nn, m = map(int, input().split())\nmatrix = [list(map(int, input())) for _ in range(n)]\n\n# Function to check if all lamps are on\ndef all_lamps_on(switches):\n    lamps = [0] * m\n    for i in switches:\n        for j in range(m):\n            if matrix[i][j] == 1:\n                lamps[j] = 1\n    return all(lamps)\n\n# Check each switch\nfor i in range(n):\n    if all_lamps_on(list(range(n))[:i] + list(range(n))[i+1:]):\n        print(\"YES\")\n        break\nelse:\n    print(\"NO\")"}
{"solution": "# Read the number of dominoes\nn = int(input())\n\n# Initialize the sums of the upper and lower halves\nupper_sum = 0\nlower_sum = 0\n\n# Read the numbers on the upper and lower halves of each domino\nfor _ in range(n):\n    x, y = map(int, input().split())\n    upper_sum += x\n    lower_sum += y\n\n# Calculate the minimum number of rotations needed\nif upper_sum % 2 == lower_sum % 2:\n    # If both sums are even or both sums are odd, no rotations are needed\n    print(0)\nelif (upper_sum + lower_sum) % 2 == 1:\n    # If the total sum is odd, it's impossible to make both sums even\n    print(-1)\nelse:\n    # If one sum is even and the other is odd, one rotation is needed\n    print(1)"}
{"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef calculate_area(a, b):\n    return (a - b) * (a + b)\n\ndef solve():\n    t = int(input())\n    for _ in range(t):\n        a, b = map(int, input().split())\n        area = calculate_area(a, b)\n        if is_prime(area):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nsolve()"}
{"solution": "def can_remove_one_point(n, points):\n    positive_count = 0\n    negative_count = 0\n\n    for x, y in points:\n        if x > 0:\n            positive_count += 1\n        else:\n            negative_count += 1\n\n    if positive_count <= 1 or negative_count <= 1:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Reading input\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(can_remove_one_point(n, points))"}
{"solution": "import math\n\ndef factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)\n\nA, B = map(int, input().split())\n\n# Calculate factorials\nA_factorial = factorial(A)\nB_factorial = factorial(B)\n\n# Calculate and print the GCD\ngcd = math.gcd(A_factorial, B_factorial)\nprint(gcd)"}
{"solution": "def is_composite(num):\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return True\n    return False\n\ndef find_composites(n):\n    a = n + 4\n    while not is_composite(a):\n        a += 1\n    b = a - n\n    return a, b\n\nn = int(input())\na, b = find_composites(n)\nprint(a, b)"}
{"solution": "import sys\n\ndef max_score(N, M, P, edges):\n    # Initialize the maximum score array\n    max_scores = [0] * (N + 1)\n\n    # Iterate over the edges\n    for _ in range(M):\n        A, B, C = map(int, sys.stdin.readline().split())\n\n        # Update the maximum score for Vertex B\n        max_scores[B] = max(max_scores[B], max_scores[A] + C)\n\n    # Calculate the maximum score that can be obtained\n    max_score = max_scores[N] - P * (N - 1)\n\n    # Return the maximum score if it is non-negative, otherwise return -1\n    return max_score if max_score >= 0 else -1\n\n# Read the input\nN, M, P = map(int, sys.stdin.readline().split())\n\n# Call the max_score function and print the result\nresult = max_score(N, M, P, [])\nprint(result)"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef min_palindrome_cost():\n    n = int(sys.stdin.readline())\n    strings = []\n    costs = []\n    for _ in range(n):\n        s, c = sys.stdin.readline().split()\n        strings.append(s)\n        costs.append(int(c))\n\n    # Create a dictionary to store the cost of each string\n    string_cost = {s: c for s, c in zip(strings, costs)}\n\n    # Create a dictionary to store the cost of each reversed string\n    rev_string_cost = defaultdict(int)\n    for s, c in zip(strings, costs):\n        rev_string_cost[s[::-1]] = min(rev_string_cost[s[::-1]], c)\n\n    # Initialize the minimum cost to a large number\n    min_cost = float('inf')\n\n    # Iterate through all strings\n    for s in strings:\n        # If the reversed string is in the dictionary, add its cost to the current string's cost\n        if s[::-1] in rev_string_cost:\n            min_cost = min(min_cost, string_cost[s] + rev_string_cost[s[::-1]])\n\n        # If the string is a palindrome, update the minimum cost\n        if s == s[::-1]:\n            min_cost = min(min_cost, string_cost[s])\n\n    # If the minimum cost is still a large number, return -1\n    if min_cost == float('inf'):\n        return -1\n    else:\n        return min_cost\n\nprint(min_palindrome_cost())"}
{"solution": "def largest_xor_sum(n, k):\n    # Find the number of bits in n\n    num_bits = n.bit_length()\n    # The largest possible xor-sum\n    max_xor_sum = (1 << num_bits) - 1\n    return max_xor_sum\n\n# Get input\nn, k = map(int, input().split())\n# Print output\nprint(largest_xor_sum(n, k))"}
{"solution": "import sys\n\ndef calculate_min_shorter_side():\n    n = int(sys.stdin.readline())\n    points = []\n\n    for _ in range(n):\n        x, y = map(int, sys.stdin.readline().split())\n        points.append((x, y))\n\n    points.sort()\n\n    max_y = 0\n    min_shorter_side = float('inf')\n\n    for i in range(n):\n        max_y = max(max_y, points[i][1])\n        min_shorter_side = min(min_shorter_side, max_y - points[i][1])\n\n    return min_shorter_side\n\nmin_shorter_side = calculate_min_shorter_side()\nprint(min_shorter_side)"}
{"solution": "def max_nineteens(s):\n    from collections import Counter\n\n    # Count the frequency of each character in the string\n    char_count = Counter(s)\n\n    # Define the required frequency of each character in the word \"nineteen\"\n    required_counts = {'n': 3, 'i': 1, 'e': 3, 't': 1}\n\n    # Calculate the maximum number of \"nineteen\" words that can be formed\n    max_nineteens = float('inf')\n    for char, required in required_counts.items():\n        if char in char_count:\n            max_nineteens = min(max_nineteens, char_count[char] // required)\n        else:\n            return 0  # If any required character is missing, we can't form \"nineteen\"\n\n    return max_nineteens\n\n# Read the input string\ns = input()\n\n# Print the maximum number of \"nineteen\" words that can be formed\nprint(max_nineteens(s))"}
{"solution": "def highest_branch(p, y):\n    # Start from the highest branch and go down\n    for branch in range(y, 1, -1):\n        # Check if the branch is reachable by any grasshopper\n        for grasshopper in range(2, p + 1):\n            if branch % grasshopper == 0 and branch // grasshopper <= y:\n                # If the branch is reachable, break the inner loop\n                break\n        else:\n            # If no grasshopper can reach the branch, return it\n            return branch\n    # If no suitable branch is found, return -1\n    return -1\n\n# Read the input\np, y = map(int, input().split())\n# Print the output\nprint(highest_branch(p, y))"}
{"solution": "# Read input\nn, m, k = map(int, input().split())\nhouses = list(map(int, input().split()))\n\n# Initialize minimum distance to infinity\nmin_distance = float('inf')\n\n# Iterate over all houses\nfor i in range(n):\n    # If the house is affordable\n    if houses[i] <= k:\n        # Calculate the distance to the girl's house\n        distance = abs(i - m + 1) * 10\n        # Update the minimum distance\n        min_distance = min(min_distance, distance)\n\n# Print the minimum distance\nprint(min_distance)"}
{"solution": "def transpose_submatrix(matrix, x, y, k):\n    for i in range(x, x + k):\n        for j in range(y, y + k):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\ndef can_transform(A, B):\n    n = len(A)\n    m = len(A[0])\n\n    for k in range(min(n, m), 0, -1):\n        for i in range(n - k + 1):\n            for j in range(m - k + 1):\n                if A[i][j] != B[i][j]:\n                    transpose_submatrix(A, i, j, k)\n\n    return A == B\n\n# Read input\nn, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\nB = [list(map(int, input().split())) for _ in range(n)]\n\n# Check if transformation is possible\nif can_transform(A, B):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "# Get the input strings\na = input()\nb = input()\n\n# If the strings are equal, there's no uncommon subsequence\nif a == b:\n    print(-1)\nelse:\n    # Otherwise, the longest uncommon subsequence is the length of the longer string\n    print(max(len(a), len(b)))"}
{"solution": "def find_intersection(a, b, c, d):\n    # If Rick and Morty's first scream times are equal, they will scream at the same time\n    if b == d:\n        return b\n\n    # Calculate the difference between Rick and Morty's scream intervals\n    diff = abs(a - c)\n\n    # If Rick and Morty's scream intervals are the same, they will never scream at the same time\n    if diff == 0:\n        return -1\n\n    # Calculate the relative first scream times of Rick and Morty\n    rick_rel = b % diff\n    morty_rel = d % diff\n\n    # If Rick and Morty's relative first scream times are equal, they will scream at the same time\n    if rick_rel == morty_rel:\n        # Calculate the least common multiple of a and c\n        lcm = a * c // gcd(a, c)\n        # Calculate the time when they will scream at the same time\n        return b + (lcm - rick_rel) % lcm\n\n    # If Rick and Morty's relative first scream times are not equal, they will never scream at the same time\n    return -1\n\n# Calculate the greatest common divisor of two numbers\ndef gcd(x, y):\n    while(y):\n        x, y = y, x % y\n    return x\n\n# Get the input\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Print the output\nprint(find_intersection(a, b, c, d))"}
{"solution": "def split_number(n):\n    # Start with the smallest possible number that is not a multiple of 3\n    a = 1\n    b = 2\n    c = n - a - b\n\n    # Check if any of the numbers is a multiple of 3\n    while a % 3 == 0 or b % 3 == 0 or c % 3 == 0:\n        # If a is a multiple of 3, increase b and decrease c\n        if a % 3 == 0:\n            b += 1\n            c -= 1\n        # If b is a multiple of 3, increase c and decrease a\n        elif b % 3 == 0:\n            c += 1\n            a -= 1\n        # If c is a multiple of 3, increase a and decrease b\n        else:\n            a += 1\n            b -= 1\n\n    return a, b, c\n\nn = int(input())\na, b, c = split_number(n)\nprint(a, b, c)"}
{"solution": "def find_distinct_squares(n, a, b, c, d):\n    # Calculate the sum of the top left 2x2 square\n    target_sum = a + b + c + d\n\n    # Initialize the count of distinct squares\n    count = 0\n\n    # Iterate through all possible values for the unknown cells\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            for k in range(1, n + 1):\n                # Calculate the value of the missing cell\n                l = target_sum - a - b - i - j\n                # Check if the value is within the valid range and forms a distinct square\n                if 1 <= l <= n and l != i and l != j:\n                    count += 1\n\n    # Return the count of distinct squares\n    return count\n\n# Read the input\nn, a, b, c, d = map(int, input().split())\n\n# Print the result\nprint(find_distinct_squares(n, a, b, c, d))"}
{"solution": "# Get the initial weight and height of the snowball\nw, h = map(int, input().split())\n\n# Get the weight and height of the first stone\nu1, d1 = map(int, input().split())\n\n# Get the weight and height of the second stone\nu2, d2 = map(int, input().split())\n\n# Simulate the snowball's descent\nwhile h > 0:\n    # Increase the weight of the snowball by its current height\n    w += h\n\n    # Check if the snowball hits a stone\n    if h == d1:\n        # Decrease the weight of the snowball by the weight of the stone\n        w = max(0, w - u1)\n    elif h == d2:\n        # Decrease the weight of the snowball by the weight of the stone\n        w = max(0, w - u2)\n\n    # Move the snowball one meter down\n    h -= 1\n\n# Print the final weight of the snowball\nprint(w)"}
{"solution": "# Read input\nm = int(input())\nscores = list(map(int, input().split()))\nx, y = map(int, input().split())\n\n# Initialize variables\nbeginners = 0\nintermediates = 0\npassing_rate = 0\n\n# Iterate through possible passing rates\nfor k in range(1, m + 1):\n    beginners = sum(scores[:k])\n    intermediates = sum(scores[k:])\n\n    # Check if the size of each group is within the specified range\n    if x <= beginners <= y and x <= intermediates <= y:\n        passing_rate = k\n        break\n\n# Print the result\nprint(passing_rate)"}
{"solution": "def min_coins(n, k, A, B):\n    dp = [0] * (n + 1)\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + A\n        if i % k == 0:\n            dp[i] = min(dp[i], dp[i // k] + B)\n    return dp[n]\n\nn = int(input())\nk = int(input())\nA = int(input())\nB = int(input())\n\nprint(min_coins(n, k, A, B))"}
{"solution": "import math\n\ndef min_operations(n):\n    operations = 0\n    while n % 2 == 0:\n        n = math.sqrt(n)\n        operations += 1\n    while n % 4 == 1:\n        n *= 2\n        operations += 1\n    return n, operations\n\nn = int(input())\nmin_n, min_operations = min_operations(n)\nprint(min_n, min_operations)"}
{"solution": "# Read input\nN, K = map(int, input().split())\nR, S, P = map(int, input().split())\nT = input()\n\n# Initialize score and previous_hands list\nscore = 0\nprevious_hands = []\n\n# Iterate through each round\nfor i in range(N):\n    # Get the machine's hand for the current round\n    machine_hand = T[i]\n\n    # Check if the current round is within the K-round restriction\n    if i >= K:\n        # Get the hand used K rounds ago\n        k_rounds_ago_hand = previous_hands[i - K]\n\n        # Determine the best hand to play based on the machine's hand and the restriction\n        if machine_hand == 'r':\n            if k_rounds_ago_hand != 'p':\n                score += P\n                previous_hands.append('p')\n            else:\n                previous_hands.append('')\n        elif machine_hand == 'p':\n            if k_rounds_ago_hand != 's':\n                score += S\n                previous_hands.append('s')\n            else:\n                previous_hands.append('')\n        elif machine_hand == 's':\n            if k_rounds_ago_hand != 'r':\n                score += R\n                previous_hands.append('r')\n            else:\n                previous_hands.append('')\n    else:\n        # If the current round is within the K-round restriction, play the hand that earns the most points\n        if machine_hand == 'r':\n            score += P\n            previous_hands.append('p')\n        elif machine_hand == 'p':\n            score += S\n            previous_hands.append('s')\n        elif machine_hand == 's':\n            score += R\n            previous_hands.append('r')\n\n# Print the maximum total score\nprint(score)"}
{"solution": "# Read input\na, b, c = map(int, input().split())\n\n# Calculate the maximum possible length of the good string\n# The idea is to use as many 'ab' strings as possible,\n# then use 'a' and 'b' strings to extend the good string\n# on both ends if possible\nmax_length = 2 * c\nif a > 0 and b > 0:\n    max_length += min(a, b) * 2\nelif a > 0 or b > 0:\n    max_length += 1\n\nprint(max_length)"}
{"solution": "# Read input\nn, k, p, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Calculate the sum of marks Vova has so far\nsum_marks = sum(marks)\n\n# Calculate the number of remaining tests\nremaining_tests = n - k\n\n# Calculate the maximum total sum Vova can get without being disturbed\nmax_sum = x - sum_marks\n\n# Calculate the minimum total sum Vova needs to maintain to keep his mom happy\nmin_sum = y * remaining_tests\n\n# If the maximum total sum is less than the minimum total sum, it's impossible to achieve the desired result\nif max_sum < min_sum:\n    print(-1)\nelse:\n    # Calculate the number of tests Vova needs to get the minimum median mark\n    num_min_median = (remaining_tests + 1) // 2\n\n    # Calculate the number of tests Vova needs to get the maximum possible mark\n    num_max_marks = min(remaining_tests, max_sum // p)\n\n    # Calculate the number of tests Vova needs to get the minimum possible mark\n    num_min_marks = max(0, remaining_tests - max_sum // y)\n\n    # If the number of tests Vova needs to get the minimum median mark is less than the number of tests he needs to get the minimum possible mark, it's impossible to achieve the desired result\n    if num_min_median < num_min_marks:\n        print(-1)\n    else:\n        # Calculate the number of tests Vova needs to get the minimum possible mark and the maximum possible mark\n        num_min_marks = max(num_min_marks, num_min_median)\n        num_max_marks = min(num_max_marks, remaining_tests - num_min_marks)\n\n        # Calculate the marks Vova needs to get for the remaining tests\n        marks = [y] * num_min_marks + [p] * num_max_marks + [1] * (remaining_tests - num_min_marks - num_max_marks)\n\n        # Print the marks Vova needs to get for the remaining tests\n        print(*marks)"}
{"solution": "def is_berlanese(word):\n    vowels = ['a', 'o', 'u', 'i', 'e']\n    prev_char = ''\n\n    for char in word:\n        if char not in vowels and prev_char != 'n' and prev_char not in vowels:\n            return False\n        prev_char = char\n\n    if prev_char not in vowels and prev_char != 'n':\n        return False\n\n    return True\n\nword = input()\nprint(\"YES\" if is_berlanese(word) else \"NO\")"}
{"solution": "def max_dominoes(n, m, edges):\n    # Create an adjacency list to represent the graph\n    graph = [[] for _ in range(n + 1)]\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    # Function to check if it's possible to place dominoes on the graph\n    def is_possible(k):\n        # Create a list to store the number of dots on the halves of dominoes directed towards each vertex\n        dots = [0] * (n + 1)\n\n        # Function to perform depth-first search\n        def dfs(node, dot):\n            if dots[node] != 0 and dots[node] != dot:\n                return False\n            dots[node] = dot\n            for neighbor in graph[node]:\n                if not dfs(neighbor, 6 - dot):\n                    return False\n            return True\n\n        # Check if it's possible to place k dominoes on the graph\n        for i in range(1, n + 1):\n            if dots[i] == 0 and not dfs(i, 1):\n                return False\n        return True\n\n    # Binary search to find the maximum number of dominoes that can be placed\n    left, right = 0, m\n    while left < right:\n        mid = (left + right + 1) // 2\n        if is_possible(mid):\n            left = mid\n        else:\n            right = mid - 1\n\n    return left\n\n# Read input\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Calculate the maximum number of dominoes that can be placed\nresult = max_dominoes(n, m, edges)\n\n# Print the result\nprint(result)"}
{"solution": "def max_points(n, m, a, b):\n    dp = [0] * (n + 1)\n    b = set(b)\n\n    for i in range(1, n + 1):\n        dp[i] = dp[i - 1] + a[i - 1]\n        if i in b:\n            dp[i] = max(dp[i], dp[i - 1] + a[i - 1] * 2)\n        for j in range(i - 1, 0, -1):\n            if dp[j - 1] + a[i - 1] <= dp[i]:\n                break\n            if i in b and dp[j - 1] + a[i - 1] * 2 > dp[i]:\n                dp[i] = dp[j - 1] + a[i - 1] * 2\n            elif dp[j - 1] + a[i - 1] > dp[i]:\n                dp[i] = dp[j - 1] + a[i - 1]\n\n    return dp[n]\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nprint(max_points(n, m, a, b))"}
{"solution": "# Get the input\nm = list(map(int, input().split()))\nw = list(map(int, input().split()))\nh = list(map(int, input().split()))\n\n# Define the maximum point values for each problem\nmax_points = [500, 1000, 1500, 2000, 2500]\n\n# Calculate the score for each problem\nscores = [max(0.3 * max_points[i], (1 - m[i] / 250) * max_points[i] - 50 * w[i]) for i in range(5)]\n\n# Calculate the total score\ntotal_score = sum(scores) + 100 * h[0] - 50 * h[1]\n\n# Print the final score\nprint(int(total_score))"}
{"solution": "MOD = 998244353\n\ndef power(base, exponent):\n    result = 1\n    base %= MOD\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % MOD\n        base = (base * base) % MOD\n        exponent //= 2\n    return result\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef count_grids(n, m, L, R):\n    if L == R:\n        return 1\n    if n == 1 or m == 1:\n        return (R - L + 1) % MOD\n    if n == 2 and m == 2:\n        return (R - L + 1) * (R - L + 2) // 2 % MOD\n    if n == 2 or m == 2:\n        return (R - L + 1) * power(2, (n * m) // 2 - 2) % MOD\n    if n % 2 == 0 or m % 2 == 0:\n        return (R - L + 1) * power(2, (n * m) // 2 - 1) % MOD\n    return (R - L + 1) * power(2, (n * m) // 2) % MOD\n\nn, m, L, R = map(int, input().split())\nresult = count_grids(n, m, L, R)\nprint(result)"}
{"solution": "def is_possible_to_make_increasing(n, m, matrix_a, matrix_b):\n    for i in range(n):\n        for j in range(m):\n            # Ensure that matrix_a[i][j] is the smaller or equal element\n            if matrix_a[i][j] > matrix_b[i][j]:\n                matrix_a[i][j], matrix_b[i][j] = matrix_b[i][j], matrix_a[i][j]\n\n    # Check rows for strictly increasing property\n    for i in range(n):\n        for j in range(1, m):\n            if matrix_a[i][j] <= matrix_a[i][j-1] or matrix_b[i][j] <= matrix_b[i][j-1]:\n                return \"Impossible\"\n\n    # Check columns for strictly increasing property\n    for j in range(m):\n        for i in range(1, n):\n            if matrix_a[i][j] <= matrix_a[i-1][j] or matrix_b[i][j] <= matrix_b[i-1][j]:\n                return \"Impossible\"\n\n    return \"Possible\"\n\n# Read input\nn, m = map(int, input().split())\nmatrix_a = [list(map(int, input().split())) for _ in range(n)]\nmatrix_b = [list(map(int, input().split())) for _ in range(n)]\n\n# Print output\nprint(is_possible_to_make_increasing(n, m, matrix_a, matrix_b))"}
{"solution": "def max_string_length(n, a):\n    # Sort the list of occurrences in descending order\n    a.sort(reverse=True)\n\n    # Initialize the maximum length of the string\n    max_length = 0\n\n    # Iterate through the sorted list\n    for i in range(n):\n        # The number of occurrences of the current letter is the minimum of the current value and the remaining unique values\n        occurrences = min(a[i], n - i)\n\n        # Add the occurrences to the maximum length\n        max_length += occurrences\n\n    return max_length\n\n# Read the input\nn = int(input())\na = list(map(int, input().split()))\n\n# Print the maximum length of the string\nprint(max_string_length(n, a))"}
{"solution": "n, k = map(int, input().split())\nproblems = list(map(int, input().split()))\nproblems.sort()\n\nadditional_problems = 0\nfor problem in problems:\n    if problem > k:\n        if k * 2 < problem:\n            additional_problems += 1\n            k = problem\n        else:\n            k = problem\n\nprint(additional_problems)"}
{"solution": "def distribute_diplomas(n, min1, max1, min2, max2, min3, max3):\n    # Initialize the number of diplomas for each degree\n    diplomas = [0, 0, 0]\n\n    # Distribute the minimum number of diplomas for each degree\n    diplomas[0] = min1\n    diplomas[1] = min2\n    diplomas[2] = min3\n\n    # Calculate the remaining diplomas to be distributed\n    remaining = n - sum(diplomas)\n\n    # Distribute the remaining diplomas to maximize the first degree diplomas\n    diplomas[0] = min(max1, diplomas[0] + remaining)\n    remaining -= diplomas[0] - min1\n\n    # Distribute the remaining diplomas to maximize the second degree diplomas\n    diplomas[1] = min(max2, diplomas[1] + remaining)\n    remaining -= diplomas[1] - min2\n\n    # Distribute the remaining diplomas to maximize the third degree diplomas\n    diplomas[2] = min(max3, diplomas[2] + remaining)\n\n    return diplomas\n\n# Read the input\nn = int(input())\nmin1, max1 = map(int, input().split())\nmin2, max2 = map(int, input().split())\nmin3, max3 = map(int, input().split())\n\n# Distribute the diplomas\ndiplomas = distribute_diplomas(n, min1, max1, min2, max2, min3, max3)\n\n# Print the output\nprint(*diplomas)"}
{"solution": "# Get the number of days Vitya was watching the moon\nn = int(input())\n\n# Get Vitya's records\nrecords = list(map(int, input().split()))\n\n# Check if the last two days' records are increasing\nif n > 1 and records[-1] > records[-2]:\n    print(\"UP\")\n# Check if the last two days' records are decreasing\nelif n > 1 and records[-1] < records[-2]:\n    print(\"DOWN\")\n# If there's only one day's record or the last two days' records are the same\nelse:\n    print(\"-1\")"}
{"solution": "def can_transform(s, t):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n\n    # Check if lengths are the same\n    if len(s) != len(t):\n        return \"No\"\n\n    # Check each character\n    for char_s, char_t in zip(s, t):\n        if (char_s in vowels) != (char_t in vowels):\n            return \"No\"\n\n    return \"Yes\"\n\n# Read input\ns = input().strip()\nt = input().strip()\n\n# Output the result\nprint(can_transform(s, t))"}
{"solution": "def evaluate(board):\n    white_moves = float('inf')\n    black_moves = float('inf')\n\n    for i in range(8):\n        for j in range(8):\n            if board[i][j] == 'W':\n                white_moves = min(white_moves, 8 - i)\n            elif board[i][j] == 'B':\n                black_moves = min(black_moves, i + 1)\n\n    return white_moves - black_moves\n\ndef minimax(board, depth, is_maximizing):\n    score = evaluate(board)\n\n    if score == 0 or depth == 0:\n        return score\n\n    if is_maximizing:\n        best_score = float('-inf')\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'W':\n                    board[i][j] = '.'\n                    board[i - 1][j] = 'W'\n                    best_score = max(best_score, minimax(board, depth - 1, False))\n                    board[i][j] = 'W'\n                    board[i - 1][j] = '.'\n        return best_score\n    else:\n        best_score = float('inf')\n        for i in range(8):\n            for j in range(8):\n                if board[i][j] == 'B':\n                    board[i][j] = '.'\n                    board[i + 1][j] = 'B'\n                    best_score = min(best_score, minimax(board, depth - 1, True))\n                    board[i][j] = 'B'\n                    board[i + 1][j] = '.'\n        return best_score\n\ndef find_best_move(board):\n    best_score = float('-inf')\n    move = None\n\n    for i in range(8):\n        for j in range(8):\n            if board[i][j] == 'W':\n                board[i][j] = '.'\n                board[i - 1][j] = 'W'\n                score = minimax(board, 9, False)\n                board[i][j] = 'W'\n                board[i - 1][j] = '.'\n                if score > best_score:\n                    best_score = score\n                    move = (i, j)\n\n    return move\n\nboard = []\nfor _ in range(8):\n    board.append(list(input()))\n\nmove = find_best_move(board)\nif move is not None:\n    print('A')\nelse:\n    print('B')"}
{"solution": "def max_equal_length(n, A, m, B):\n    if sum(A) != sum(B):\n        return -1\n\n    i, j = 0, 0\n    sumA, sumB = 0, 0\n    count = 0\n\n    while i < n and j < m:\n        sumA += A[i]\n        sumB += B[j]\n\n        if sumA == sumB:\n            count += 1\n            sumA = 0\n            sumB = 0\n            i += 1\n            j += 1\n        elif sumA < sumB:\n            i += 1\n        else:\n            j += 1\n\n    return count\n\nn = int(input())\nA = list(map(int, input().split()))\nm = int(input())\nB = list(map(int, input().split()))\n\nprint(max_equal_length(n, A, m, B))"}
{"solution": "def is_contest_problem(problem_name):\n    friends = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\n    count = 0\n    for friend in friends:\n        if friend in problem_name:\n            count += problem_name.count(friend)\n    return \"YES\" if count == 1 else \"NO\"\n\nproblem_name = input()\nprint(is_contest_problem(problem_name))"}
{"solution": "def sieve(n):\n    is_prime = [True] * (n + 1)\n    p = 2\n    while (p * p <= n):\n        if (is_prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                is_prime[i] = False\n        p += 1\n    is_prime[0], is_prime[1] = False, False  # 0 and 1 are not primes\n    return is_prime\n\ndef count_primes_in_range(is_prime, a, b):\n    prime_count = [0] * (b + 1)\n    for i in range(a, b + 1):\n        prime_count[i] = prime_count[i - 1] + (1 if is_prime[i] else 0)\n    return prime_count\n\ndef min_length_with_k_primes(a, b, k):\n    is_prime = sieve(b)\n    prime_count = count_primes_in_range(is_prime, a, b)\n\n    def has_k_primes_in_length(l):\n        for x in range(a, b - l + 2):\n            if prime_count[x + l - 1] - prime_count[x - 1] >= k:\n                return True\n        return False\n\n    left, right = 1, b - a + 1\n    result = -1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if has_k_primes_in_length(mid):\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return result\n\n# Input\na, b, k = map(int, input().split())\n\n# Output\nprint(min_length_with_k_primes(a, b, k))"}
{"solution": "def calculate_min_distance(a, h, w):\n    # Check if it's possible to put at least one photo on the wall\n    if a > h or a > w:\n        return -1\n\n    # Calculate the maximum number of photos that can be placed horizontally and vertically\n    max_photos_horizontally = w // a\n    max_photos_vertically = h // a\n\n    # Calculate the minimum distance between photos\n    min_distance_horizontally = (w - max_photos_horizontally * a) / (max_photos_horizontally + 1)\n    min_distance_vertically = (h - max_photos_vertically * a) / (max_photos_vertically + 1)\n\n    # Return the minimum distance\n    return min(min_distance_horizontally, min_distance_vertically)\n\n# Read the input\na, h, w = map(int, input().split())\n\n# Calculate and print the minimum distance\nresult = calculate_min_distance(a, h, w)\nprint(result)"}
{"solution": "# Read the number of chapters\nn = int(input())\n\n# Initialize variables to store the last read page and the number of unread chapters\nlast_read_page = 0\nunread_chapters = 0\n\n# Iterate through each chapter\nfor _ in range(n):\n    # Read the first and last page of the chapter\n    l, r = map(int, input().split())\n\n    # If the last read page is less than the first page of the chapter, increment the number of unread chapters\n    if last_read_page < l:\n        unread_chapters += 1\n\n    # Update the last read page\n    last_read_page = max(last_read_page, r)\n\n# Read the marked page\nk = int(input())\n\n# If the marked page is not the last page of the last chapter, increment the number of unread chapters\nif k < last_read_page:\n    unread_chapters += 1\n\n# Print the number of unread chapters\nprint(unread_chapters)"}
{"solution": "def can_form_codeforces(word):\n    target = \"CODEFORCES\"\n    n = len(word)\n    m = len(target)\n\n    if n < m:\n        return \"NO\"\n\n    for i in range(m + 1):\n        if word[:i] == target[:i] and word[n - (m - i):] == target[i:]:\n            return \"YES\"\n\n    return \"NO\"\n\n# Get the input word\nword = input()\n\n# Check if it is possible to cut out a substring from the given word such that the remaining parts form the word \"CODEFORCES\"\nresult = can_form_codeforces(word)\n\n# Print the result\nprint(result)"}
{"solution": "def min_weight_triangulation(n):\n    # Create a table to store the minimum weight triangulation for each subpolygon\n    dp = [[0] * n for _ in range(n)]\n\n    # Iterate through the subpolygons in reverse order\n    for gap in range(2, n):\n        for i in range(n - gap):\n            j = i + gap\n            dp[i][j] = float('inf')\n\n            # Try all possible triangles to divide the subpolygon\n            for k in range(i + 1, j):\n                # Calculate the weight of the triangulation\n                weight = dp[i][k] + dp[k][j] + (i + 1) * (k + 1) * (j + 1)\n                dp[i][j] = min(dp[i][j], weight)\n\n    # Return the minimum weight triangulation of the entire polygon\n    return dp[0][n - 1]\n\n# Read the input\nn = int(input())\n\n# Calculate the minimum weight triangulation\nresult = min_weight_triangulation(n)\n\n# Print the output\nprint(result)"}
{"solution": "# Get the input\nn = int(input())\n\n# Initialize the total number of digits\ntotal_digits = 0\n\n# Calculate the total number of digits needed\n# For numbers from 1 to 9, there is 1 digit for each number\n# For numbers from 10 to 99, there are 2 digits for each number\n# For numbers from 100 to 999, there are 3 digits for each number\n# And so on...\n\n# Calculate the number of digits for each range of numbers\nfor i in range(1, len(str(n)) + 1):\n    # The number of numbers in the current range\n    num_in_range = 9 * 10 ** (i - 1)\n\n    # The number of digits used for the current range\n    digits_in_range = num_in_range * i\n\n    # Add the number of digits in the current range to the total\n    total_digits += digits_in_range\n\n# For the remaining numbers (less than n)\n# Calculate the number of digits used for these numbers\nremaining_numbers = n - 10 ** len(str(n)) + 1\nremaining_digits = remaining_numbers * len(str(n))\n\n# Add the remaining digits to the total\ntotal_digits += remaining_digits\n\n# Print the total number of digits\nprint(total_digits)"}
{"solution": "def find_winning_color(n, A, car_colors):\n    count_A = 0\n    count_B = 0\n    max_count_B = 0\n    winning_color = -1\n\n    for color in car_colors:\n        if color == A:\n            count_A += 1\n        else:\n            temp_count_B = count_B + 1\n            if temp_count_B >= count_A and temp_count_B > max_count_B:\n                max_count_B = temp_count_B\n                winning_color = color\n\n    return winning_color\n\nn, A = map(int, input().split())\ncar_colors = list(map(int, input().split()))\n\nprint(find_winning_color(n, A, car_colors))"}
{"solution": "# Read input\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculate the total length of segments and the number of gaps\ntotal_length = sum(a)\nnum_gaps = n - 1\n\n# Check if the total length of segments and the number of gaps is equal to the length of the crossword\nif total_length + num_gaps == x:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "# Read input\nn, S = map(int, input().split())\n\n# Initialize count of coins\ncount = 0\n\n# Find the largest coin value less than or equal to S\nwhile n <= S:\n    # Add the maximum number of coins of value n to the count\n    count += S // n\n    # Update the remaining sum\n    S %= n\n    # Move to the next coin value\n    n -= 1\n\n# Print the result\nprint(count)"}
{"solution": "def min_changes_palindrome(s):\n    # Count the frequency of each character\n    freq = [0] * 26\n    for c in s:\n        freq[ord(c) - ord('a')] += 1\n\n    # Find the middle character (if any)\n    mid = ''\n    for i in range(26):\n        if freq[i] % 2 == 1:\n            mid = chr(i + ord('a'))\n            freq[i] -= 1\n            break\n\n    # Build the first half of the palindrome\n    first_half = []\n    for i in range(26):\n        first_half.extend([chr(i + ord('a'))] * (freq[i] // 2))\n\n    # Combine the first half, middle character, and reversed first half\n    return ''.join(first_half + [mid] + first_half[::-1])\n\n# Read input\ns = input()\n\n# Print output\nprint(min_changes_palindrome(s))"}
{"solution": "def calculate_weight(board):\n    piece_weights = {\n        'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'P': 1,\n        'q': 9, 'r': 5, 'b': 3, 'n': 3, 'p': 1\n    }\n\n    white_weight = 0\n    black_weight = 0\n\n    for row in board:\n        for piece in row:\n            if piece in piece_weights:\n                if piece.isupper():\n                    white_weight += piece_weights[piece]\n                else:\n                    black_weight += piece_weights[piece]\n\n    if white_weight > black_weight:\n        return \"White\"\n    elif black_weight > white_weight:\n        return \"Black\"\n    else:\n        return \"Draw\"\n\n# Example usage:\nboard = [\n    \"...QK...\",\n    \"........\",\n    \"........\",\n    \"........\",\n    \"........\",\n    \"........\",\n    \"........\",\n    \"...rk...\"\n]\n\ncalculate_weight(board)"}
{"solution": "import heapq\n\ndef shortest_path(n, m, s):\n    # Initialize the distance list with infinity values\n    dist = [float('inf')] * (n + 1)\n    dist[n] = 0\n\n    # Initialize the previous list to store the previous step\n    prev = [-1] * (n + 1)\n\n    # Initialize the queue with the final square\n    queue = [(0, n)]\n\n    while queue:\n        # Get the square with the smallest distance\n        d, u = heapq.heappop(queue)\n\n        # If the distance is already smaller, skip\n        if d > dist[u]:\n            continue\n\n        # Check all possible moves\n        for x in range(1, m + 1):\n            v = u - x\n\n            # If the move is valid and results in a shorter path, update the distance and previous step\n            if v >= 0 and s[v] == '0' and dist[v] > dist[u] + 1:\n                dist[v] = dist[u] + 1\n                prev[v] = x\n                heapq.heappush(queue, (dist[v], v))\n\n    # If Takahashi cannot reach the final square, return -1\n    if dist[0] == float('inf'):\n        return -1\n\n    # Otherwise, reconstruct the path\n    path = []\n    u = 0\n    while u < n:\n        path.append(prev[u])\n        u += prev[u]\n\n    return ' '.join(map(str, path))\n\n# Read the input\nn, m = map(int, input().split())\ns = input()\n\n# Print the output\nprint(shortest_path(n, m, s))"}
{"solution": "def calculate_manhattan_distance(x1, y1, x2, y2):\n    return abs(x1 - x2) + abs(y1 - y2)\n\ndef find_optimal_path(k, x, y):\n    path = []\n    current_x, current_y = 0, 0\n\n    while calculate_manhattan_distance(current_x, current_y, x, y) > k:\n        # Find the closest point with Manhattan distance k\n        if abs(x - current_x) >= k:\n            current_x += k if x > current_x else -k\n        elif abs(y - current_y) >= k:\n            current_y += k if y > current_y else -k\n\n        path.append((current_x, current_y))\n\n    # Move to the goal point\n    path.append((x, y))\n\n    return path\n\nk = int(input())\nx, y = map(int, input().split())\n\noptimal_path = find_optimal_path(k, x, y)\n\nif optimal_path:\n    print(len(optimal_path))\n    for point in optimal_path:\n        print(*point)\nelse:\n    print(-1)"}
{"solution": "def calculate_ways(n, k, thieves):\n    ways = 0\n    for i in range(1, n + 1):\n        chocolates = i\n        valid = True\n        for j in range(thieves):\n            if chocolates > n:\n                valid = False\n                break\n            chocolates *= k\n        if valid:\n            ways += 1\n    return ways\n\ndef find_smallest_n(m, k, thieves):\n    left, right = 1, m * k ** (thieves - 1)\n    while left < right:\n        mid = (left + right) // 2\n        ways = calculate_ways(mid, k, thieves)\n        if ways < m:\n            left = mid + 1\n        else:\n            right = mid\n    return left if calculate_ways(left, k, thieves) == m else -1\n\nm = int(input())\nk = 2  # The problem statement does not provide k, so we assume k = 2 for the example cases\nthieves = 4\nprint(find_smallest_n(m, k, thieves))"}
{"solution": "import math\n\ndef circle_intersection_area(x1, y1, r1, x2, y2, r2):\n    d = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n\n    if d >= r1 + r2:\n        return 0\n    elif d <= abs(r1 - r2):\n        return min(r1, r2)**2 * math.pi\n    else:\n        theta1 = 2 * math.acos((r1**2 + d**2 - r2**2) / (2 * r1 * d))\n        theta2 = 2 * math.acos((r2**2 + d**2 - r1**2) / (2 * r2 * d))\n\n        area1 = 0.5 * r1**2 * (theta1 - math.sin(theta1))\n        area2 = 0.5 * r2**2 * (theta2 - math.sin(theta2))\n\n        return area1 + area2\n\nx1, y1, r1 = map(int, input().split())\nx2, y2, r2 = map(int, input().split())\n\narea = circle_intersection_area(x1, y1, r1, x2, y2, r2)\nprint(\"{:.16f}\".format(area))"}
{"solution": "def min_value(n):\n    if n == 1:\n        return 1\n    elif n % 2 == 1:\n        return 1\n    else:\n        return 2\n\nv = int(input())\nprint(min_value(v))"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef read_input():\n    return sys.stdin.readline().strip()\n\ndef dfs(node, parent, graph, values, dp):\n    for child in graph[node]:\n        if child != parent:\n            dfs(child, node, graph, values, dp)\n            values[node] += values[child]\n            dp[node] = max(dp[node], dp[child] + values[node])\n\ndef solve():\n    n = int(read_input())\n    parents = list(map(int, read_input().split()))\n    values = list(map(int, read_input().split()))\n\n    graph = defaultdict(list)\n    for i in range(2, n + 1):\n        graph[parents[i - 1]].append(i)\n\n    dp = [0] * (n + 1)\n    dfs(1, 0, graph, values, dp)\n\n    print(dp[1])\n\nsolve()"}
{"solution": "def count_typo_words(n, S, T):\n    count = 0\n    for i in range(n + 1):\n        # Construct W by inserting a character at position i in both S and T\n        if i == 0:\n            W1 = S[0] + S\n            W2 = T[0] + T\n        elif i == n:\n            W1 = S + S[-1]\n            W2 = T + T[-1]\n        else:\n            W1 = S[:i] + S[i] + S[i:]\n            W2 = T[:i] + T[i] + T[i:]\n\n        # Check if the constructed words are the same\n        if W1 == W2:\n            count += 1\n\n    return count\n\n# Read input\nn = int(input())\nS = input().strip()\nT = input().strip()\n\n# Print output\nprint(count_typo_words(n, S, T))"}
{"solution": "import sys\n\ndef dfs(node, parent, graph, strengths):\n    max_child_strength = 0\n    for child in graph[node]:\n        if child != parent:\n            child_strength = dfs(child, node, graph, strengths)\n            max_child_strength = max(max_child_strength, child_strength)\n    return max(strengths[node], max_child_strength + 1)\n\ndef find_min_strength(n, strengths, edges):\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n\n    min_strength = float('inf')\n    for i in range(n):\n        min_strength = min(min_strength, dfs(i, -1, graph, strengths))\n\n    return min_strength\n\ndef main():\n    n = int(sys.stdin.readline())\n    strengths = list(map(int, sys.stdin.readline().split()))\n    edges = [tuple(map(int, sys.stdin.readline().split())) for _ in range(n - 1)]\n\n    min_strength = find_min_strength(n, strengths, edges)\n    print(min_strength)\n\nif __name__ == '__main__':\n    main()"}
{"solution": "def max_groups(n, m):\n    return min(m, n - m)\n\nn, m = map(int, input().split())\nprint(max_groups(n, m))"}
{"solution": "def min_shovels(k, r):\n    # Start with 1 shovel\n    shovels = 1\n    # Calculate the total cost\n    total_cost = shovels * k\n    # While the total cost is not divisible by 10 or the remainder is not equal to r\n    while total_cost % 10 != r and total_cost % 10 != 0:\n        # Increment the number of shovels\n        shovels += 1\n        # Recalculate the total cost\n        total_cost = shovels * k\n    # Return the minimum number of shovels\n    return shovels\n\n# Get the input\nk, r = map(int, input().split())\n# Print the output\nprint(min_shovels(k, r))"}
{"solution": "def can_form_rectangle(n, m, grid):\n    # Find the bounding box of the 'X' characters\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'X':\n                min_row = min(min_row, i)\n                max_row = max(max_row, i)\n                min_col = min(min_col, j)\n                max_col = max(max_col, j)\n\n    # Dimensions of the bounding box\n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n\n    # Extract the bounding box\n    piece = []\n    for i in range(min_row, max_row + 1):\n        piece.append(grid[i][min_col:max_col + 1])\n\n    # Check horizontal placement\n    if width * 2 == m:\n        valid = True\n        for i in range(height):\n            for j in range(width):\n                if piece[i][j] != piece[i][j + width]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return \"YES\"\n\n    # Check vertical placement\n    if height * 2 == n:\n        valid = True\n        for i in range(height):\n            for j in range(width):\n                if piece[i][j] != piece[i + height][j]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return \"YES\"\n\n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(can_form_rectangle(n, m, grid))"}
{"solution": "# Read the coordinates of the three points\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\nx3, y3 = map(int, input().split())\n\n# Check if all three points share the same x-coordinate or the same y-coordinate\nif x1 == x2 == x3 or y1 == y2 == y3:\n    print(1)\n# Check if two points share the same x-coordinate or y-coordinate\nelif x1 == x2 or x1 == x3 or x2 == x3 or y1 == y2 or y1 == y3 or y2 == y3:\n    print(2)\n# If no two points share the same x-coordinate or y-coordinate\nelse:\n    print(3)"}
{"solution": "def construct_graph(k):\n    if k % 2 != 0:\n        print(\"NO\")\n        return\n\n    print(\"YES\")\n    n = 2 * k\n    m = k * k\n    print(n, m)\n\n    # Construct a cycle of 2k vertices\n    for i in range(1, k):\n        print(i, i + 1)\n    print(k, 1)\n\n    # Add k edges to create a bridge\n    for i in range(k + 1, 2 * k + 1):\n        print(i, i - k)\n\n    # Add remaining edges to make the graph k-regular\n    for i in range(2, k + 1):\n        for j in range(i + 1, k + i):\n            print(j, j - i + 1)\n\nk = int(input())\nconstruct_graph(k)"}
{"solution": "def count_occurrences(s, t):\n    n, m = len(s), len(t)\n    prefix_count = [0] * (n + 1)\n\n    for i in range(n - m + 1):\n        if s[i:i + m] == t:\n            prefix_count[i + m] = prefix_count[i + m - 1] + 1\n        else:\n            prefix_count[i + m] = prefix_count[i + m - 1]\n\n    return prefix_count\n\ndef solve_queries(s, t, queries):\n    prefix_count = count_occurrences(s, t)\n    results = []\n\n    for l, r in queries:\n        results.append(prefix_count[r] - prefix_count[l - 1])\n\n    return results\n\ndef main():\n    n, m, q = map(int, input().split())\n    s = input()\n    t = input()\n    queries = [list(map(int, input().split())) for _ in range(q)]\n\n    results = solve_queries(s, t, queries)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "MOD = 1000000007\n\ndef count_paths(n, k, d):\n    dp = [[0] * (n + 1) for _ in range(k + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, k + 1):\n        for j in range(n + 1):\n            for l in range(1, min(j, i) + 1):\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - l]) % MOD\n\n    return sum(dp[k][n - d + i] for i in range(1, n - d + 1)) % MOD\n\nn, k, d = map(int, input().split())\nprint(count_paths(n, k, d))"}
{"solution": "def encrypt_japanese_crossword(n, row):\n    groups = []\n    count = 0\n\n    for char in row:\n        if char == 'B':\n            count += 1\n        else:\n            if count > 0:\n                groups.append(count)\n                count = 0\n\n    if count > 0:\n        groups.append(count)\n\n    print(len(groups))\n    if groups:\n        print(\" \".join(map(str, groups)))\n\nn = int(input())\nrow = input().strip()\nencrypt_japanese_crossword(n, row)"}
{"solution": "def process_editor(n, m, p, sequence, operations):\n    # Create a stack to store the indices of the opening brackets\n    stack = []\n\n    # Initialize the cursor position\n    cursor = p - 1\n\n    # Process each operation\n    for op in operations:\n        if op == 'L':\n            # Move the cursor one position to the left\n            cursor -= 1\n        elif op == 'R':\n            # Move the cursor one position to the right\n            cursor += 1\n        elif op == 'D':\n            # Delete the bracket in which the cursor is located, its pair, and all brackets between them\n            if sequence[cursor] == '(':\n                # Find the index of the closing bracket\n                closing_bracket = stack.pop()\n                # Delete the brackets between the cursor and the closing bracket\n                sequence = sequence[:cursor] + sequence[closing_bracket + 1:]\n                # Update the cursor position\n                cursor = min(cursor, len(sequence) - 1)\n            else:\n                # Find the index of the opening bracket\n                opening_bracket = stack.pop()\n                # Delete the brackets between the opening bracket and the cursor\n                sequence = sequence[:opening_bracket] + sequence[cursor + 1:]\n                # Update the cursor position\n                cursor = max(0, opening_bracket)\n\n        # Update the stack with the current cursor position\n        if sequence[cursor] == '(':\n            stack.append(cursor)\n        else:\n            stack.pop()\n\n    return sequence\n\n# Read the input\nn, m, p = map(int, input().split())\nsequence = input()\noperations = input()\n\n# Process the editor operations\nresult = process_editor(n, m, p, sequence, operations)\n\n# Print the result\nprint(result)"}
{"solution": "def find_number(n, queries):\n    lower_bound = -2 * (10 ** 9)\n    upper_bound = 2 * (10 ** 9)\n\n    for _ in range(n):\n        sign, x, answer = queries[_]\n        x = int(x)\n\n        if answer == 'Y':\n            if sign == '>':\n                lower_bound = max(lower_bound, x + 1)\n            elif sign == '<':\n                upper_bound = min(upper_bound, x - 1)\n            elif sign == '>=':\n                lower_bound = max(lower_bound, x)\n            elif sign == '<=':\n                upper_bound = min(upper_bound, x)\n        else:\n            if sign == '>':\n                upper_bound = min(upper_bound, x)\n            elif sign == '<':\n                lower_bound = max(lower_bound, x)\n            elif sign == '>=':\n                upper_bound = min(upper_bound, x - 1)\n            elif sign == '<=':\n                lower_bound = max(lower_bound, x + 1)\n\n    if lower_bound <= upper_bound:\n        return lower_bound\n    else:\n        return \"Impossible\"\n\nn = int(input())\nqueries = [input().split() for _ in range(n)]\nprint(find_number(n, queries))"}
{"solution": "import math\ndef count_periods(a, b):\n    g = math.gcd(a, b)\n    count = 0\n    for i in range(1, int(math.sqrt(g)) + 1):\n        if g % i == 0:\n            count += 1\n            if i != g // i:\n                count += 1\n    return count\na, b = map(int, input().split())\nprint(count_periods(a, b))"}
{"solution": "def generate_names(n, k, conditions):\n    # Predefined list of unique names\n    names = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"]\n\n    # Initialize the result list with the first k names\n    result = names[:k]\n\n    for i in range(1, n - k + 1):\n        if conditions[i - 1] == \"YES\":\n            # If the group should be effective, add a new unique name\n            result.append(names[k + i - 1])\n        else:\n            # If the group should not be effective, repeat the last name\n            result.append(result[-1])\n\n    return result\n\n# Read input\nn, k = map(int, input().split())\nconditions = input().split()\n\n# Generate and print the names\nnames = generate_names(n, k, conditions)\nprint(\" \".join(names))"}
{"solution": "def min_operations_to_equal(a, b):\n    def count_factors(n, factor):\n        count = 0\n        while n % factor == 0:\n            n //= factor\n            count += 1\n        return count, n\n\n    # Count the number of times we can divide by 2, 3, and 5\n    a2, a = count_factors(a, 2)\n    a3, a = count_factors(a, 3)\n    a5, a = count_factors(a, 5)\n\n    b2, b = count_factors(b, 2)\n    b3, b = count_factors(b, 3)\n    b5, b = count_factors(b, 5)\n\n    # If the remaining parts are not equal, return -1\n    if a != b:\n        return -1\n\n    # Calculate the total number of operations needed\n    operations = abs(a2 - b2) + abs(a3 - b3) + abs(a5 - b5)\n\n    return operations\n\n# Get input from the user\na, b = map(int, input().split())\n\n# Print the minimum number of operations required to make the two pieces of cheese equal\nprint(min_operations_to_equal(a, b))"}
{"solution": "def min_cost(n, a, b, suits):\n    cost = 0\n    for i in range(n // 2):\n        if suits[i] == suits[n - i - 1]:\n            continue\n        elif suits[i] == 2:\n            suits[i] = suits[n - i - 1]\n            cost += a if suits[i] == 0 else b\n        elif suits[n - i - 1] == 2:\n            suits[n - i - 1] = suits[i]\n            cost += a if suits[n - i - 1] == 0 else b\n        else:\n            return -1\n    if n % 2 == 1 and suits[n // 2] == 2:\n        cost += min(a, b)\n    return cost\n\nn, a, b = map(int, input().split())\nsuits = list(map(int, input().split()))\nprint(min_cost(n, a, b, suits))"}
{"solution": "def print_cube(k):\n    if k % 2 != 0:\n        print(-1)\n        return\n\n    for i in range(k):\n        for j in range(k):\n            if (i + j) % 2 == 0:\n                print(\"w\", end=\"\")\n            else:\n                print(\"b\", end=\"\")\n        print()\n\nk = int(input())\nprint_cube(k)"}
{"solution": "def largest_lovely_number(n):\n    import math\n    from collections import Counter\n\n    def prime_factors(n):\n        i = 2\n        factors = []\n        while i * i <= n:\n            while (n % i) == 0:\n                factors.append(i)\n                n //= i\n            i += 1\n        if n > 1:\n            factors.append(n)\n        return factors\n\n    factors = prime_factors(n)\n    factor_counts = Counter(factors)\n\n    lovely_number = 1\n    for prime, count in factor_counts.items():\n        lovely_number *= prime\n\n    return lovely_number\n\nn = int(input())\nprint(largest_lovely_number(n))"}
{"solution": "def is_maximal_seating(n, seating):\n    # Check for adjacent occupied seats\n    for i in range(n - 1):\n        if seating[i] == '1' and seating[i + 1] == '1':\n            return \"No\"\n\n    # Check for possible additional seating\n    for i in range(n):\n        if seating[i] == '0':\n            if (i == 0 or seating[i - 1] == '0') and (i == n - 1 or seating[i + 1] == '0'):\n                return \"No\"\n\n    return \"Yes\"\n\n# Read input\nn = int(input())\nseating = input().strip()\n\n# Print output\nprint(is_maximal_seating(n, seating))"}
{"solution": "# Read the input\nn = int(input())\na = list(map(int, input().split()))\n\n# Initialize a list to store possible lengths of the lost array\npossible_lengths = []\n\n# Iterate through all possible values of k\nfor k in range(1, n + 1):\n    # Initialize the lost array x with zeros\n    x = [0] * k\n\n    # Initialize a flag to check if the current k is valid\n    valid = True\n\n    # Iterate through the given array a\n    for i in range(1, n + 1):\n        # Calculate the expected value of a[i]\n        expected_value = x[(i - 1) % k] + a[i - 1]\n\n        # Check if the expected value matches the given value\n        if a[i - 1] != expected_value:\n            # If not, set the flag to False and break the loop\n            valid = False\n            break\n\n        # Update the value of x[(i - 1) % k]\n        x[(i - 1) % k] = expected_value\n\n    # If the current k is valid, add it to the list of possible lengths\n    if valid:\n        possible_lengths.append(k)\n\n# Print the number of possible lengths\nprint(len(possible_lengths))\n\n# Print the possible lengths in increasing order\nprint(*possible_lengths)"}
{"solution": "# Get the input scores\nscores = list(map(int, input().split()))\n\n# Calculate the total sum of scores\ntotal_sum = sum(scores)\n\n# If the total sum is odd, it's impossible to form two teams with equal scores\nif total_sum % 2 != 0:\n    print(\"NO\")\nelse:\n    # If the total sum is even, check if it's possible to form two teams with equal scores\n    target_sum = total_sum // 2\n    for i in range(6):\n        for j in range(i+1, 6):\n            for k in range(j+1, 6):\n                # If we find a combination of three scores that sum up to the target sum, it's possible to form two teams with equal scores\n                if scores[i] + scores[j] + scores[k] == target_sum:\n                    print(\"YES\")\n                    exit()\n    # If no combination is found, it's impossible to form two teams with equal scores\n    print(\"NO\")"}
{"solution": "def count_2_3_integers(l, r):\n    # Initialize the count of 2-3 integers\n    count = 0\n\n    # Generate all 2-3 integers up to r\n    i = 1\n    while i <= r:\n        j = i\n        # Check if j is a 2-3 integer and within the range [l, r]\n        while j <= r:\n            if l <= j <= r:\n                count += 1\n            j *= 2\n        i *= 3\n\n    return count\n\n# Read the input\nl, r = map(int, input().split())\n\n# Print the result\nprint(count_2_3_integers(l, r))"}
{"solution": "def calculate_candies_eaten(n, k):\n    # Initialize the number of candies eaten\n    candies_eaten = 0\n\n    # Initialize the number of candies in the box\n    candies_in_box = 0\n\n    # Perform each action\n    for i in range(1, n + 1):\n        # If the box is empty, put i candies into the box\n        if candies_in_box == 0:\n            candies_in_box += i\n        # If the box contains at least one candy, take one candy out and eat it\n        else:\n            candies_in_box -= 1\n            candies_eaten += 1\n\n        # If this is the last action, break the loop\n        if i == n:\n            break\n\n    # Calculate the number of candies Alya ate\n    candies_eaten += candies_in_box - k\n\n    return candies_eaten\n\n# Read the input\nn, k = map(int, input().split())\n\n# Calculate the number of candies Alya ate\nresult = calculate_candies_eaten(n, k)\n\n# Print the result\nprint(result)"}
{"solution": "# Read the input\nn = int(input())\nsegments = list(map(int, input().split()))\n\n# Sort the segments in ascending order\nsegments.sort()\n\n# Iterate through the segments\nfor i in range(n - 2):\n    # Check if the sum of the lengths of the two smaller segments is greater than the length of the largest segment\n    if segments[i] + segments[i + 1] > segments[i + 2]:\n        print(\"YES\")\n        exit()\n\n# If no three segments can form a triangle, print \"NO\"\nprint(\"NO\")"}
{"solution": "def can_achieve_toys(x, y):\n    # Initial number of original toys\n    original = 1\n    # Number of copied toys\n    copied = 0\n\n    # While there are still original toys to use the machine on\n    while original > 0:\n        # If the desired number of copied toys has been achieved, return True\n        if copied == x:\n            return True\n        # If using the machine on an original toy would exceed the desired number of copied toys, break the loop\n        elif copied + original > x:\n            break\n        # Use the machine on an original toy\n        copied += original\n        original += 1\n\n    # While there are still copied toys to use the machine on\n    while copied > 0:\n        # If the desired number of copied toys has been achieved and the desired number of original toys has been achieved, return True\n        if copied == x and original == y:\n            return True\n        # If using the machine on a copied toy would exceed the desired number of copied toys, break the loop\n        elif copied * 2 > x:\n            break\n        # Use the machine on a copied toy\n        copied *= 2\n\n    # If the desired configuration is not possible, return False\n    return False\n\n# Get the input\nx, y = map(int, input().split())\n\n# Print the result\nif can_achieve_toys(x, y):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "# Read input\nn, k = map(int, input().split())\nskills = list(map(int, input().split()))\n\n# Calculate initial total rating\ntotal_rating = sum(skill // 10 for skill in skills)\n\n# Identify improvement opportunities\nimprovements = [(10 - skill % 10) if skill < 100 else 0 for skill in skills]\n\n# Prioritize improvements\nimprovements.sort()\n\n# Allocate units\nfor i in range(n):\n    if k >= improvements[i]:\n        k -= improvements[i]\n        total_rating += 1\n    else:\n        break\n\n# Print the maximum total rating\nprint(total_rating)"}
{"solution": "def find_smallest_pretty_integer(n, m, list1, list2):\n    set1 = set(list1)\n    set2 = set(list2)\n\n    common_digits = set1.intersection(set2)\n    if common_digits:\n        return min(common_digits)\n\n    min1 = min(list1)\n    min2 = min(list2)\n\n    smallest_pretty = min(int(str(min1) + str(min2)), int(str(min2) + str(min1)))\n    return smallest_pretty\n\nn, m = map(int, input().split())\nlist1 = list(map(int, input().split()))\nlist2 = list(map(int, input().split()))\n\nprint(find_smallest_pretty_integer(n, m, list1, list2))"}
{"solution": "# Get the input\nn, k = map(int, input().split())\n\n# Calculate the total time available for solving problems\ntotal_time = 240 - k\n\n# Initialize the time needed to solve problems and the number of problems solved\ntime_needed = 0\nproblems_solved = 0\n\n# Loop through the problems\nfor i in range(1, n + 1):\n    # Calculate the time needed to solve the current problem\n    time_needed += 5 * i\n\n    # If the time needed to solve the current problem is less than or equal to the total time available\n    if time_needed <= total_time:\n        # Increment the number of problems solved\n        problems_solved += 1\n    else:\n        # Break the loop\n        break\n\n# Print the maximum possible number of problems Limak can solve\nprint(problems_solved)"}
{"solution": "def max_teams(n, x, y, a):\n    a.sort()\n    double_sided = x\n    single_sided = y\n    count = 0\n\n    for pages in a:\n        double_needed = pages // 2\n        single_needed = pages % 2\n\n        if double_needed <= double_sided:\n            double_sided -= double_needed\n            if single_needed <= single_sided:\n                single_sided -= single_needed\n                count += 1\n            else:\n                double_sided += double_needed\n                break\n        else:\n            remaining_pages = pages - 2 * double_sided\n            if remaining_pages <= single_sided:\n                single_sided -= remaining_pages\n                double_sided = 0\n                count += 1\n            else:\n                break\n\n    return count\n\nn, x, y = map(int, input().split())\na = list(map(int, input().split()))\nprint(max_teams(n, x, y, a))"}
{"solution": "def count_divisors(n):\n    divisors = set()\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n        i += 1\n    return len(divisors)\n\n# Read input\nb = int(input().strip())\n\n# Calculate the number of distinct values\nresult = count_divisors(b)\n\n# Print the result\nprint(result)"}
{"solution": "def calculate_falling_positions(n, bumpers):\n    falling_positions = 0\n    for i in range(n):\n        position = i\n        visited = set()\n        while 0 < position < n:\n            if position in visited:\n                break\n            visited.add(position)\n            if bumpers[position] == '<':\n                position -= 1\n            else:\n                position += 1\n        else:\n            falling_positions += 1\n    return falling_positions\n\nn = int(input())\nbumpers = input()\nprint(calculate_falling_positions(n, bumpers))"}
{"solution": "from collections import Counter\n\ndef max_rectangle_area(n, sticks):\n    # Count the frequency of each stick length\n    freq = Counter(sticks)\n\n    # Initialize the maximum total area\n    max_area = 0\n\n    # Iterate over the stick lengths\n    for length in freq:\n        # If there are at least 4 sticks of the same length,\n        # we can make a rectangle with this length as the side\n        if freq[length] >= 4:\n            # Calculate the number of rectangles we can make\n            num_rectangles = freq[length] // 4\n            # Add the area of these rectangles to the maximum total area\n            max_area += num_rectangles * length * length\n            # Update the frequency of this stick length\n            freq[length] -= num_rectangles * 4\n\n        # If there are at least 2 sticks of the same length,\n        # we can try to make a rectangle with this length as the side\n        # and another length as the other side\n        if freq[length] >= 2:\n            # Iterate over the possible other lengths\n            for other_length in range(length + 1, length + 2):\n                # If there are at least 2 sticks of the other length,\n                # we can make a rectangle\n                if freq[other_length] >= 2:\n                    # Calculate the number of rectangles we can make\n                    num_rectangles = min(freq[length] // 2, freq[other_length] // 2)\n                    # Add the area of these rectangles to the maximum total area\n                    max_area += num_rectangles * length * other_length\n                    # Update the frequencies of these stick lengths\n                    freq[length] -= num_rectangles * 2\n                    freq[other_length] -= num_rectangles * 2\n\n    # Return the maximum total area\n    return max_area\n\n# Read the input\nn = int(input())\nsticks = list(map(int, input().split()))\n\n# Print the maximum total area\nprint(max_rectangle_area(n, sticks))"}
{"solution": "from collections import Counter\n\n# Get the number of inputs\nn = int(input())\n\n# Initialize a counter to store the frequency of each character\nchar_counter = Counter()\n\n# Initialize a list to store the encoded numbers\nencoded_numbers = []\n\n# Get the encoded numbers and update the character counter\nfor _ in range(n):\n    encoded_number = input()\n    encoded_numbers.append(encoded_number)\n    char_counter.update(encoded_number)\n\n# Sort the characters by their frequency in descending order\nsorted_chars = sorted(char_counter.keys(), key=lambda x: char_counter[x], reverse=True)\n\n# Initialize a dictionary to store the mapping of characters to digits\nchar_to_digit = {}\n\n# Assign the digits to the characters in the order of their frequency\nfor i, char in enumerate(sorted_chars):\n    char_to_digit[char] = str(i)\n\n# Initialize a variable to store the total sum of the restored numbers\ntotal_sum = 0\n\n# Restore the numbers and calculate their sum\nfor encoded_number in encoded_numbers:\n    # Replace the characters with digits\n    restored_number = ''.join(char_to_digit[char] for char in encoded_number)\n    # Convert the restored number to an integer and add it to the total sum\n    total_sum += int(restored_number)\n\n# Print the total sum\nprint(total_sum)"}
{"solution": "def max_teams(n, m):\n    # Binary search to find the maximum number of teams\n    low, high = 0, min(n, m, (n + m) // 3)\n\n    while low < high:\n        mid = (low + high + 1) // 2\n        if mid <= n and mid <= m and 2 * mid <= n + m:\n            low = mid\n        else:\n            high = mid - 1\n\n    return low\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the maximum number of teams\nprint(max_teams(n, m))"}
{"solution": "def check_substrings(s):\n    n = len(s)\n\n    # Check for \"AB\" followed by \"BA\"\n    found_AB = False\n    for i in range(n - 1):\n        if s[i:i+2] == \"AB\":\n            found_AB = True\n            for j in range(i + 2, n - 1):\n                if s[j:j+2] == \"BA\":\n                    print(\"YES\")\n                    return\n            break\n\n    # Check for \"BA\" followed by \"AB\"\n    found_BA = False\n    for i in range(n - 1):\n        if s[i:i+2] == \"BA\":\n            found_BA = True\n            for j in range(i + 2, n - 1):\n                if s[j:j+2] == \"AB\":\n                    print(\"YES\")\n                    return\n            break\n\n    # If neither condition is met\n    print(\"NO\")\n\n# Example usage\ns = input().strip()\ncheck_substrings(s)"}
{"solution": "def can_eat(a, b):\n    return a > b\n\ndef eat_monsters(initial_queue, final_queue):\n    actions = []\n    while initial_queue != final_queue:\n        for i in range(len(initial_queue)):\n            if i > 0 and can_eat(initial_queue[i], initial_queue[i-1]):\n                actions.append(f\"{i+1} L\")\n                initial_queue[i] += initial_queue[i-1]\n                initial_queue.pop(i-1)\n                break\n            elif i < len(initial_queue) - 1 and can_eat(initial_queue[i], initial_queue[i+1]):\n                actions.append(f\"{i+1} R\")\n                initial_queue[i] += initial_queue[i+1]\n                initial_queue.pop(i+1)\n                break\n        else:\n            return \"NO\"\n    return \"YES\\n\" + \"\\n\".join(actions)\n\nn = int(input())\ninitial_queue = list(map(int, input().split()))\nk = int(input())\nfinal_queue = list(map(int, input().split()))\n\nresult = eat_monsters(initial_queue, final_queue)\nprint(result)"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef hopcroft_karp(graph):\n    pair_u = [-1] * len(graph)\n    pair_v = [-1] * len(graph[0])\n\n    def bfs():\n        queue = []\n        for i in range(len(graph)):\n            if pair_u[i] == -1:\n                queue.append(i)\n                dist[i] = 0\n            else:\n                dist[i] = float('inf')\n        dist[-1] = float('inf')\n\n        while queue:\n            u = queue.pop(0)\n            for v in graph[u]:\n                if pair_v[v] == -1:\n                    return True\n                if dist[pair_v[v]] == float('inf'):\n                    dist[pair_v[v]] = dist[u] + 1\n                    queue.append(pair_v[v])\n        return False\n\n    def dfs(u):\n        if u != -1:\n            for v in graph[u]:\n                if dist[pair_v[v]] == dist[u] + 1 and dfs(pair_v[v]):\n                    pair_v[v] = u\n                    pair_u[u] = v\n                    return True\n            dist[u] = float('inf')\n            return False\n        return True\n\n    matching = 0\n    while bfs():\n        for i in range(len(graph)):\n            if pair_u[i] == -1 and dfs(i):\n                matching += 1\n    return matching\n\ndef line_intersect(line1, line2):\n    def ccw(p1, p2, p3):\n        return (p2[0] - p1[0]) * (p3[1] - p1[1]) > (p2[1] - p1[1]) * (p3[0] - p1[0])\n\n    return ccw(line1[0], line1[1], line2[0]) != ccw(line1[0], line1[1], line2[1]) and ccw(line2[0], line2[1], line1[0]) != ccw(line2[0], line2[1], line1[1])\n\ndef solve():\n    R, B = map(int, sys.stdin.readline().split())\n    rebels = [tuple(map(int, sys.stdin.readline().split())) for _ in range(R)]\n    bases = [tuple(map(int, sys.stdin.readline().split())) for _ in range(B)]\n\n    graph = [[] for _ in range(R)]\n    for i in range(R):\n        for j in range(B):\n            if not any(line_intersect((rebels[i], bases[j]), (rebels[k], bases[graph[i][l]])) for l in range(len(graph[i]))):\n                graph[i].append(j)\n\n    return hopcroft_karp(graph) == min(R, B)\n\nprint('Yes' if solve() else 'No')"}
{"solution": "# Read the input\nn = int(input())\nnumbers = list(map(int, input().split()))\n\n# Initialize the maximum power of 2 and the count of numbers that divide by it\nmax_power = 0\ncount = 0\n\n# Iterate over the numbers\nfor num in numbers:\n    # Calculate the power of 2 for the current number\n    power = 0\n    while num % 2 == 0:\n        num //= 2\n        power += 1\n    # Update the maximum power and count\n    if power > max_power:\n        max_power = power\n        count = 1\n    elif power == max_power:\n        count += 1\n\n# Print the result\nprint(2**max_power, count)"}
{"solution": "def min_clicks(n, m):\n    clicks = 0\n    while n != m:\n        if n < m and m % 2 == 0:\n            n *= 2\n        else:\n            n -= 1\n        clicks += 1\n    return clicks\n\nn, m = map(int, input().split())\nprint(min_clicks(n, m))"}
{"solution": "import sys\n\ndef read_input():\n    n = int(sys.stdin.readline())\n    segments = []\n    for _ in range(n):\n        l, r = map(int, sys.stdin.readline().split())\n        segments.append((l, r))\n    return n, segments\n\ndef create_graph(n, segments):\n    graph = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            if segments[i][0] < segments[j][1] and segments[i][1] > segments[j][0]:\n                graph[i].append(j)\n                graph[j].append(i)\n    return graph\n\ndef is_tree(graph):\n    n = len(graph)\n    parent = [-1] * n\n    visited = [False] * n\n\n    def dfs(node, parent_node):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                parent[neighbor] = node\n                dfs(neighbor, node)\n            elif neighbor != parent_node:\n                return False\n        return True\n\n    if not dfs(0, -1):\n        return False\n\n    return all(visited)\n\ndef main():\n    n, segments = read_input()\n    graph = create_graph(n, segments)\n    if is_tree(graph):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Read the input\nn = int(input())\nrequests = list(map(int, input().split()))\n\n# Initialize variables\nmax_length = 0\ncurrent_length = 0\ncurrent_sum = 0\n\n# Iterate over the requests\nfor i in range(n):\n    # Add the current request to the sum\n    current_sum += requests[i]\n\n    # Check if the sum exceeds the threshold\n    if current_sum > 100 * (i - current_length + 1):\n        # If it does, reset the sum and length\n        current_sum = requests[i]\n        current_length = 0\n\n    # Update the maximum length\n    max_length = max(max_length, i - current_length + 1)\n\n    # Increment the current length\n    current_length += 1\n\n# Print the result\nprint(max_length)"}
{"solution": "def check_dissatisfaction(n, k, sequence):\n    max_consecutive_n = 0\n    current_consecutive_n = 0\n\n    for i in range(n):\n        if sequence[i] == 'N':\n            current_consecutive_n += 1\n        else:\n            max_consecutive_n = max(max_consecutive_n, current_consecutive_n)\n            current_consecutive_n = 0\n\n    max_consecutive_n = max(max_consecutive_n, current_consecutive_n)\n\n    if max_consecutive_n >= k:\n        return \"NO\"\n\n    sequence = sequence.replace('?', 'N')\n    max_consecutive_n = 0\n    current_consecutive_n = 0\n\n    for i in range(n):\n        if sequence[i] == 'N':\n            current_consecutive_n += 1\n        else:\n            max_consecutive_n = max(max_consecutive_n, current_consecutive_n)\n            current_consecutive_n = 0\n\n    max_consecutive_n = max(max_consecutive_n, current_consecutive_n)\n\n    if max_consecutive_n == k:\n        return \"YES\"\n    else:\n        return \"NO\"\n\nn, k = map(int, input().split())\nsequence = input()\nprint(check_dissatisfaction(n, k, sequence))"}
{"solution": "# Read the input\nN, X, D = map(int, input().split())\n\n# Calculate the possible sums that Takahashi can obtain\ntakahashi_sums = set()\ncurrent_sum = 0\nfor i in range(N + 1):\n    takahashi_sums.add(current_sum)\n    current_sum += X + i * D\n\n# Calculate the possible sums that Aoki can obtain\naoki_sums = set()\ncurrent_sum = 0\nfor i in range(N, -1, -1):\n    aoki_sums.add(current_sum)\n    current_sum += X + i * D\n\n# Calculate the number of possible values of S - T\npossible_values = 0\nfor takahashi_sum in takahashi_sums:\n    for aoki_sum in aoki_sums:\n        if takahashi_sum - aoki_sum not in takahashi_sums:\n            possible_values += 1\n\n# Print the result\nprint(possible_values)"}
{"solution": "def did_anton_perform_good(n, participants):\n    for participant in participants:\n        handle, before, after = participant\n        if before >= 2400 and after > before:\n            return \"YES\"\n    return \"NO\"\n\nn = int(input())\nparticipants = [input().split() for _ in range(n)]\nparticipants = [(handle, int(before), int(after)) for handle, before, after in participants]\n\nprint(did_anton_perform_good(n, participants))"}
{"solution": "# Get the binary input from the user\nbinary_input = input()\n\n# Convert the binary input to decimal\ndecimal_input = int(binary_input, 2)\n\n# Initialize the count of missed trains\nmissed_trains = 0\n\n# Initialize the train departure time\ntrain_departure_time = 1\n\n# Count the number of trains that have departed before the given time\nwhile train_departure_time < decimal_input:\n    missed_trains += 1\n    train_departure_time *= 4\n\n# Print the number of missed trains\nprint(missed_trains)"}
{"solution": "def find_min_rows(matrix):\n    n, m = len(matrix), len(matrix[0])\n\n    # Check for symmetrical patterns\n    for i in range(1, n // 2 + 1):\n        if n % i != 0:\n            continue\n        is_symmetrical = True\n        for j in range(i):\n            if matrix[j] != matrix[i + j]:\n                is_symmetrical = False\n                break\n        if is_symmetrical:\n            return i\n\n    # If no symmetrical pattern is found, return the number of rows\n    return n\n\n# Read input\nn, m = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# Find minimum number of rows\nmin_rows = find_min_rows(matrix)\n\n# Print output\nprint(min_rows)"}
{"solution": "# Read the number of orders\nn = int(input())\n\n# Create a list to store the orders\norders = []\n\n# Read the orders and store them in the list\nfor _ in range(n):\n    l, r = map(int, input().split())\n    orders.append((l, r))\n\n# Sort the orders by their end times\norders.sort(key=lambda x: x[1])\n\n# Initialize the count of accepted orders\ncount = 0\n\n# Initialize the end time of the last accepted order\nlast_end = float('-inf')\n\n# Iterate through the orders\nfor order in orders:\n    # If the current order does not intersect with the last accepted order\n    if order[0] >= last_end:\n        # Accept the order\n        count += 1\n        # Update the end time of the last accepted order\n        last_end = order[1]\n\n# Print the maximal number of orders that can be accepted\nprint(count)"}
{"solution": "def solve(n, k, x, y):\n    tables = 0\n    formulas = 0\n    for i in range(n):\n        if tables + x[i] > k or formulas + y[i] > k:\n            return False\n        tables = min(k, tables + x[i])\n        formulas = min(k, formulas + y[i])\n        if i < n - 1:\n            tables = min(k, tables - y[i + 1])\n            formulas = min(k, formulas - x[i + 1])\n    return True\n\nn, k = map(int, input().split())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\nif solve(n, k, x, y):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "# Read input\nn, k = map(int, input().split())\ncoefficients = [int(input()) if input() != '?' else None for _ in range(n + 1)]\n\n# Check if the human can guarantee a victory\ndef can_guarantee_victory(coefficients, k):\n    # Calculate the remainder of the polynomial division by Q(x) = x - k\n    remainder = 0\n    for i in range(n, -1, -1):\n        remainder = (remainder * k + coefficients[i]) % (i + 1)\n\n    # If the remainder is 0, the human has already won\n    if remainder == 0:\n        return True\n\n    # If there are undefined coefficients, the human can set them to guarantee a victory\n    if None in coefficients:\n        # Calculate the value that the human needs to set the undefined coefficient to\n        undefined_index = coefficients.index(None)\n        target = (-remainder * pow(k, n - undefined_index, undefined_index + 1)) % (undefined_index + 1)\n\n        # Check if the target value is valid\n        if -10000 <= target <= 10000:\n            return True\n\n    # If no strategy is found, the human cannot guarantee a victory\n    return False\n\n# Print the result\nif can_guarantee_victory(coefficients, k):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "def smallest_starting_number(X_2):\n    # Generate all prime numbers up to X_2\n    primes = [True] * (X_2 + 1)\n    p = 2\n    while p * p <= X_2:\n        if primes[p]:\n            for i in range(p * p, X_2 + 1, p):\n                primes[i] = False\n        p += 1\n\n    # Find the smallest starting number\n    for X_0 in range(X_2, 2, -1):\n        if not primes[X_0]:\n            for p in range(2, X_0):\n                if primes[p]:\n                    X_1 = X_0\n                    while X_1 < X_0 + p:\n                        X_1 += p\n                    if X_1 == X_2:\n                        return X_0\n    return 3\n\n# Read the input\nX_2 = int(input())\n\n# Print the output\nprint(smallest_starting_number(X_2))"}
{"solution": "def smallest_p_binary_numbers(n, p):\n    # Initialize the count of summands\n    count = 0\n\n    # While n is greater than or equal to p\n    while n >= p:\n        # Find the largest power of 2 that is less than or equal to n - p\n        power = 0\n        while (1 << power) <= n - p:\n            power += 1\n\n        # Subtract the largest possible power of 2 from n\n        n -= 1 << (power - 1)\n\n        # Increment the count of summands\n        count += 1\n\n    # If n is equal to 0, return the count of summands\n    if n == 0:\n        return count\n\n    # If n is not equal to 0, check if it is a power of 2\n    power = 0\n    while (1 << power) <= n:\n        if (1 << power) == n:\n            return count + 1\n        power += 1\n\n    # If n is not a power of 2, return -1\n    return -1\n\n# Read the input\nn, p = map(int, input().split())\n\n# Print the result\nprint(smallest_p_binary_numbers(n, p))"}
{"solution": "# Read input\nn, k = map(int, input().split())\nS = input()\n\n# Initialize result string\nresult = ''\n\n# Change first digit to 1 if n > 1, otherwise 0\nif n > 1:\n    result += '1'\n    k -= 1\nelse:\n    result += '0'\n\n# Change subsequent digits to 0 until k changes are exhausted or all digits are minimized\nfor i in range(1, n):\n    if k > 0 and S[i] != '0':\n        result += '0'\n        k -= 1\n    else:\n        result += S[i]\n\n# Print the result\nprint(result)"}
{"solution": "def count_numbers(cnt_1, cnt_2, x, y):\n    # Initialize the minimum number v\n    v = 1\n\n    # Count the numbers that are not divisible by x or y\n    count = 0\n\n    # Loop until we find the minimum number v\n    while count < cnt_1 + cnt_2:\n        v += 1\n        if v % x != 0 and v % y != 0:\n            count += 1\n\n    return v\n\n# Read the input\ncnt_1, cnt_2, x, y = map(int, input().split())\n\n# Print the result\nprint(count_numbers(cnt_1, cnt_2, x, y))"}
{"solution": "def bear_position(n, sx, sy, dx, dy, t):\n    # Calculate the number of raspberry bushes eaten by the bear\n    raspberries = (sx + sy) + (t * (t + 1)) // 2\n\n    # Calculate the final speed of the bear\n    final_dx = dx + raspberries\n    final_dy = dy + raspberries\n\n    # Calculate the final position of the bear\n    final_x = ((sx + final_dx - 1 + t) % n) + 1\n    final_y = ((sy + final_dy - 1 + t) % n) + 1\n\n    return final_x, final_y\n\n# Read the input\nn, sx, sy, dx, dy, t = map(int, input().split())\n\n# Calculate the final position of the bear\nfinal_x, final_y = bear_position(n, sx, sy, dx, dy, t)\n\n# Print the output\nprint(final_x, final_y)"}
{"solution": "def solve(s):\n    n = len(s)\n    if n < 26:\n        return -1\n\n    alphabet = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n    missing = alphabet.copy()\n    result = list(s)\n\n    # Check the first 26 characters\n    for i in range(26):\n        if s[i] != '?':\n            missing.discard(s[i])\n\n    if len(missing) == 0:\n        return ''.join(result)\n\n    # Slide the window\n    for i in range(26, n):\n        if s[i-26] != '?':\n            missing.add(s[i-26])\n        if s[i] != '?':\n            missing.discard(s[i])\n        if len(missing) == 0:\n            # Fill in the missing characters\n            j = i - 26\n            for char in alphabet:\n                if s[j] == '?':\n                    result[j] = char\n                j += 1\n            return ''.join(result)\n\n    # Fill in the remaining question marks\n    for i in range(n):\n        if result[i] == '?':\n            result[i] = missing.pop()\n\n    return ''.join(result)\n\ns = input()\nprint(solve(s))"}
{"solution": "# Read the input\nn = int(input())\nweights = list(map(int, input().split()))\n\n# Count the number of apples with weight 100 and 200\ncount_100 = weights.count(100)\ncount_200 = weights.count(200)\n\n# Check if it is possible to divide the apples equally\nif (count_100 + 2 * count_200) % 2 == 1:\n    print(\"NO\")\nelif count_100 == 0:\n    print(\"NO\" if count_200 % 2 == 1 else \"YES\")\nelif count_100 % 2 == 0:\n    print(\"YES\")\nelse:\n    print(\"NO\" if count_200 == 0 else \"YES\")"}
{"solution": "def min_time(building):\n    n = len(building)\n    m = len(building[0]) - 2\n    dp = [[float('inf')] * (m + 2) for _ in range(n)]\n\n    # Base case: ground floor\n    for i in range(m + 2):\n        if building[n - 1][i] == '1':\n            dp[n - 1][i] = min(dp[n - 1][i], i)\n\n    # Dynamic programming\n    for floor in range(n - 2, -1, -1):\n        for room in range(m + 2):\n            if building[floor][room] == '1':\n                # If the light is on, consider all possible previous rooms\n                for prev_room in range(m + 2):\n                    dp[floor][room] = min(dp[floor][room], dp[floor + 1][prev_room] + abs(room - prev_room) + 1)\n            else:\n                # If the light is off, just copy the value from the floor below\n                dp[floor][room] = dp[floor + 1][room]\n\n    return dp[0][0]\n\n# Input\nn, m = map(int, input().split())\nbuilding = [input() for _ in range(n)]\n\n# Output\nprint(min_time(building))"}
{"solution": "def find_min_trap_cost(n, costs, transitions):\n    visited = [False] * n\n    in_stack = [False] * n\n    min_cost = 0\n\n    def dfs(node):\n        stack = []\n        while True:\n            if visited[node]:\n                if in_stack[node]:\n                    # Found a cycle, calculate the minimum cost in this cycle\n                    cycle_min_cost = float('inf')\n                    while stack:\n                        cycle_node = stack.pop()\n                        in_stack[cycle_node] = False\n                        cycle_min_cost = min(cycle_min_cost, costs[cycle_node])\n                        if cycle_node == node:\n                            break\n                    return cycle_min_cost\n                else:\n                    return 0\n            visited[node] = True\n            in_stack[node] = True\n            stack.append(node)\n            node = transitions[node] - 1\n\n    for i in range(n):\n        if not visited[i]:\n            min_cost += dfs(i)\n\n    return min_cost\n\n# Input reading\nn = int(input())\ncosts = list(map(int, input().split()))\ntransitions = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(find_min_trap_cost(n, costs, transitions))"}
{"solution": "# Get the input\nn, a, b = map(int, input().split())\n\n# Calculate the final position\nfinal_position = (a + b - 1) % n + 1\n\n# Print the result\nprint(final_position)"}
{"solution": "def min_arithmetic_progressions(arr):\n    n = len(arr)\n    dp = [0] * n\n    prev = [-1] * n\n\n    for i in range(1, n):\n        dp[i] = dp[i - 1] + 1\n        for j in range(i - 1, -1, -1):\n            if arr[j] != -1 and arr[i] != -1 and (i - j) >= 2:\n                diff = arr[i] - arr[j]\n                step = diff // (i - j)\n                if diff % (i - j) != 0:\n                    continue\n                if j == 0 or prev[j - 1] == -1 or arr[prev[j - 1]] - arr[j] == step:\n                    if dp[i] > dp[j - 1] + 1:\n                        dp[i] = dp[j - 1] + 1\n                        prev[i] = j\n\n    return dp[n - 1]\n\nn = int(input())\narr = list(map(int, input().split()))\nprint(min_arithmetic_progressions(arr))"}
{"solution": "def max_beauty(n, k, s):\n    # Initialize variables\n    max_len = 0\n    curr_len = 1\n    prev_char = s[0]\n    changes = 0\n\n    # Iterate over the string\n    for i in range(1, n):\n        # If the current character is the same as the previous character\n        if s[i] == prev_char:\n            curr_len += 1\n        # If the current character is different from the previous character\n        else:\n            # If we can make a change\n            if changes < k:\n                changes += 1\n                curr_len += 1\n            # If we can't make a change\n            else:\n                max_len = max(max_len, curr_len)\n                curr_len = 1\n            prev_char = s[i]\n\n    # Update max_len for the last substring\n    max_len = max(max_len, curr_len)\n\n    # If we still have changes left, we can change the remaining characters to the most frequent character\n    if changes < k:\n        max_len = max(max_len, n - s.count(min(s, key=s.count)))\n\n    return max_len\n\n# Get input\nn, k = map(int, input().split())\ns = input()\n\n# Print output\nprint(max_beauty(n, k, s))"}
{"solution": "# Get the number of parties and their seats\nn = int(input())\nseats = list(map(int, input().split()))\n\n# Calculate total seats\ntotal_seats = sum(seats)\n\n# Initialize coalition list with Alice's party\ncoalition = [1]\n\n# Calculate initial majority and Alice's seats\nmajority = total_seats // 2 + 1\nalice_seats = seats[0]\n\n# Sort the parties by seats in descending order\nparties = sorted(range(1, n), key=lambda i: seats[i], reverse=True)\n\n# Iterate over the parties\nfor party in parties:\n    # If adding the party to the coalition meets the conditions\n    if seats[party] <= alice_seats // 2 and sum(seats[i] for i in coalition) + seats[party] >= majority:\n        # Add the party to the coalition\n        coalition.append(party + 1)\n\n# If a coalition is possible, print the number of parties and their indices\nif sum(seats[i - 1] for i in coalition) > majority:\n    print(len(coalition))\n    print(' '.join(map(str, coalition)))\n# Otherwise, print 0\nelse:\n    print(0)"}
{"solution": "def max_reward(n):\n    harmonic_sum = 0.0\n    for i in range(1, n + 1):\n        harmonic_sum += 1.0 / i\n    return harmonic_sum\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the maximum reward\nprint(f\"{max_reward(n):.12f}\")"}
{"solution": "def calculate_max_children(n):\n    k = 0\n    while (k * (k + 1)) // 2 <= n:\n        k += 1\n    k -= 1\n    remaining_candies = n - (k * (k + 1)) // 2\n    distribution = [i for i in range(1, k)]\n    distribution.append(remaining_candies)\n    return k, distribution\n\nn = int(input())\nk, distribution = calculate_max_children(n)\nprint(k)\nprint(' '.join(map(str, distribution)))"}
{"solution": "# Read the input\nn = int(input())\nm = int(input())\n\n# Calculate the remainder of m divided by 2^n\nremainder = m & ((1 << n) - 1)\n\n# Print the result\nprint(remainder)"}
{"solution": "def correct_word(word):\n    vowels = 'aeiouy'\n    corrected_word = ''\n    i = 0\n    while i < len(word):\n        if i < len(word) - 1 and word[i] in vowels and word[i + 1] in vowels:\n            i += 1\n        else:\n            corrected_word += word[i]\n        i += 1\n    return corrected_word\n\nn = int(input())\ns = input()\nprint(correct_word(s))"}
{"solution": "def max_students(n, a, b, seats):\n    segments = []\n    i = 0\n\n    # Identify segments of empty seats\n    while i < n:\n        if seats[i] == '.':\n            start = i\n            while i < n and seats[i] == '.':\n                i += 1\n            segments.append(i - start)\n        else:\n            i += 1\n\n    total_students = 0\n\n    # Place students in each segment\n    for length in segments:\n        # Calculate the number of students that can be placed in this segment\n        # We will place students in an alternating fashion\n        if a > b:\n            # Start with a student-programmer if more student-programmers are available\n            programmers = (length + 1) // 2\n            athletes = length // 2\n        else:\n            # Start with a student-athlete if more student-athletes are available\n            athletes = (length + 1) // 2\n            programmers = length // 2\n\n        # Place the students\n        placed_programmers = min(programmers, a)\n        placed_athletes = min(athletes, b)\n\n        total_students += placed_programmers + placed_athletes\n        a -= placed_programmers\n        b -= placed_athletes\n\n    return total_students\n\n# Read input\nn, a, b = map(int, input().split())\nseats = input()\n\n# Print output\nprint(max_students(n, a, b, seats))"}
{"solution": "def find_pair(r):\n    # Iterate through all possible values of x\n    for x in range(1, int(r**0.5) + 1):\n        # Calculate the value of y\n        y = (r - x**2 - x - 1) / (2*x)\n        # Check if y is a positive integer\n        if y == int(y):\n            return x, int(y)\n    # If no pair is found, return \"NO\"\n    return \"NO\"\n\n# Get the input value\nr = int(input())\n# Find the pair\nresult = find_pair(r)\n# Print the result\nif result == \"NO\":\n    print(result)\nelse:\n    print(*result)"}
{"solution": "# Read input\nn = int(input())\nballoons = list(map(int, input().split()))\n\n# Check if it's possible to divide the balloons\nif n < 3 or sum(balloons) % 2 == 0:\n    print(-1)\nelse:\n    # Sort the balloons in descending order\n    balloons.sort(reverse=True)\n\n    # Initialize the total number of balloons for Grigory\n    total_grigory = 0\n\n    # Initialize the list of packets for Grigory\n    grigory_packets = []\n\n    # Iterate over the packets\n    for i in range(n):\n        # If adding the current packet to Grigory's packets does not make the total number of balloons equal to half of the total number of balloons, add it to Grigory's packets\n        if total_grigory + balloons[i] <= sum(balloons) // 2:\n            total_grigory += balloons[i]\n            grigory_packets.append(i + 1)\n\n    # Print the number of packets for Grigory and the indices of those packets\n    print(len(grigory_packets))\n    print(' '.join(map(str, grigory_packets)))"}
{"solution": "# Read the input\nn = int(input())\n\n# Initialize the result list\nresult = []\n\n# Start from the largest possible digit (9)\nfor i in range(9, 0, -1):\n    # While n is greater than or equal to i, subtract i from n and add i to the result\n    while n >= i:\n        n -= i\n        result.append(i)\n\n# Print the number of digits in the partition\nprint(len(result))\n\n# Print the digits in the partition\nprint(' '.join(map(str, result)))"}
{"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef max_simple_subset(arr):\n    n = len(arr)\n    max_size = 0\n    max_subset = []\n    for i in range(1, 1 << n):\n        subset = [arr[j] for j in range(n) if (i & (1 << j)) > 0]\n        is_valid = True\n        for x in subset:\n            for y in subset:\n                if x != y and not is_prime(x + y):\n                    is_valid = False\n                    break\n            if not is_valid:\n                break\n        if is_valid and len(subset) > max_size:\n            max_size = len(subset)\n            max_subset = subset\n    return max_size, max_subset\n\nn = int(input())\narr = list(map(int, input().split()))\nmax_size, max_subset = max_simple_subset(arr)\nprint(max_size)\nprint(*max_subset)"}
{"solution": "def greatest_beautiful_divisor(n):\n    k = 1\n    while (2**k - 1) * (2**(k-1)) <= n:\n        k += 1\n    return (2**(k-1) - 1) * (2**(k-1))\n\nn = int(input())\nprint(greatest_beautiful_divisor(n))"}
{"solution": "MOD = 10**9 + 7\n\ndef count_d_magic_numbers(m, d, a, b):\n    n = len(str(a))\n    dp = [[0] * 2 for _ in range(n)]\n    dp[0][0] = 1 if int(str(a)[0]) % m == 0 else 0\n    dp[0][1] = 1 if int(str(a)[0]) == d and int(str(a)[0]) % m == 0 else 0\n\n    for i in range(1, n):\n        for j in range(10):\n            if j % m == 0:\n                dp[i][0] = (dp[i][0] + dp[i-1][0]) % MOD\n                if j == d and i % 2 == 0:\n                    dp[i][1] = (dp[i][1] + dp[i-1][0]) % MOD\n            if j == d and i % 2 == 0:\n                dp[i][1] = (dp[i][1] + dp[i-1][1]) % MOD\n\n    return dp[n-1][1]\n\nm, d = map(int, input().split())\na = int(input())\nb = int(input())\n\nresult = count_d_magic_numbers(m, d, a, b)\nprint(result)"}
{"solution": "from collections import deque\n\n# Get the input\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\n# Create a queue and a list to store the order of children going home\nqueue = deque([(i, a[i]) for i in range(n)])\norder = []\n\n# Simulate the distribution of candies\nwhile queue:\n    child, candies = queue.popleft()\n    if candies <= m:\n        order.append(child)\n    else:\n        queue.append((child, candies - m))\n\n# Print the number of the last child\nprint(order[-1] + 1)"}
{"solution": "# List of available denominations\ndenominations = [100, 20, 10, 5, 1]\n\n# Input the amount of money\nn = int(input())\n\n# Initialize the number of bills\nnum_bills = 0\n\n# Iterate over each denomination\nfor denomination in denominations:\n    # While the amount is greater than or equal to the denomination\n    while n >= denomination:\n        # Subtract the denomination from the amount\n        n -= denomination\n        # Increment the number of bills\n        num_bills += 1\n\n# Print the minimum number of bills\nprint(num_bills)"}
{"solution": "MOD = 10**9 + 7\n\ndef count_permutations(n, k):\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(min(i, k) + 1):\n            dp[i][j] = dp[i - 1][j] * (i - j) % MOD\n            if j > 0:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1] * (j + 1)) % MOD\n\n    return dp[n][k]\n\nn, k = map(int, input().split())\nprint(count_permutations(n, k))"}
{"solution": "def max_beauty(n, k, b, c):\n    # Separate roses by color\n    white_roses = [b[i] for i in range(n) if c[i] == 'W']\n    orange_roses = [b[i] for i in range(n) if c[i] == 'O']\n    red_roses = [b[i] for i in range(n) if c[i] == 'R']\n\n    # Sort roses by beauty in descending order\n    white_roses.sort(reverse=True)\n    orange_roses.sort(reverse=True)\n    red_roses.sort(reverse=True)\n\n    # Initialize maximum beauty\n    max_beauty = -1\n\n    # Check all possible combinations of white and orange roses\n    for i in range(min(k, len(white_roses)) + 1):\n        for j in range(min(k - i, len(orange_roses)) + 1):\n            # Check if the number of roses is equal to k\n            if i + j == k:\n                # Calculate the total beauty\n                total_beauty = sum(white_roses[:i]) + sum(orange_roses[:j])\n                # Update the maximum beauty\n                max_beauty = max(max_beauty, total_beauty)\n\n    # Check all possible combinations of red roses\n    for i in range(min(k, len(red_roses)) + 1):\n        # Check if the number of roses is equal to k\n        if i == k:\n            # Calculate the total beauty\n            total_beauty = sum(red_roses[:i])\n            # Update the maximum beauty\n            max_beauty = max(max_beauty, total_beauty)\n\n    return max_beauty\n\n# Read input\nn, k = map(int, input().split())\nb = list(map(int, input().split()))\nc = input()\n\n# Print the maximum possible total beauty\nprint(max_beauty(n, k, b, c))"}
{"solution": "def compare_fractions(p, q, n, a):\n    # Convert the continued fraction to a rational number\n    numerator, denominator = a[-1], 1\n    for i in range(n - 2, -1, -1):\n        numerator, denominator = a[i] * numerator + denominator, numerator\n\n    # Check if the two rational numbers are equal\n    return p == numerator and q == denominator\n\n# Read input\np, q = map(int, input().split())\nn = int(input())\na = list(map(int, input().split()))\n\n# Print output\nprint(\"YES\" if compare_fractions(p, q, n, a) else \"NO\")"}
{"solution": "def solve_expression(expression):\n    # Analyzing the Expression\n    A = expression.count('|', 0, expression.index('+'))\n    B = expression.count('|', expression.index('+') + 1, expression.index('='))\n    C = expression.count('|', expression.index('=') + 1)\n\n    # Identifying Possible Moves\n    if A + B == C:\n        return expression\n    elif A + B < C and A > 0:\n        return expression.replace('|=|', '=|', 1)\n    elif A + B > C and A < C:\n        return expression.replace('=|', '|=', 1)\n    else:\n        return \"Impossible\"\n\n# Understanding the Problem\nexpression = input()\n\n# Outputting the Result\nprint(solve_expression(expression))"}
{"solution": "import sys\n\ndef main():\n    n, k = map(int, sys.stdin.readline().split())\n    mod = 10**9 + 7\n\n    # dp[i][j][k] is the number of permutations of {1, 2, ..., i}\n    # with oddness j and k elements greater than their original position\n    dp = [[[0] * (n + 1) for _ in range(k + 1)] for _ in range(n + 1)]\n    dp[0][0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            for l in range(i + 1):\n                if j - 2 * l >= 0:\n                    dp[i][j][l] = (dp[i - 1][j - 2 * l][l - 1] + dp[i - 1][j - 2 * l][l]) % mod\n                if j - 2 * (i - l) >= 0:\n                    dp[i][j][l] = (dp[i][j][l] + dp[i - 1][j - 2 * (i - l)][l]) % mod\n\n    print(sum(dp[n][k]) % mod)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def calculate_robot_arm(points):\n    n = len(points)\n    m = 40  # Maximum number of sections\n    d = [0] * m  # Lengths of sections\n    w = [''] * n  # Modes of sections for each point\n\n    # Calculate the lengths of sections\n    for i in range(m):\n        d[i] = 10**(m-i)\n\n    # Calculate the modes of sections for each point\n    for j in range(n):\n        x, y = points[j]\n        for i in range(m-1, -1, -1):\n            if x >= d[i]:\n                w[j] += 'R'\n                x -= d[i]\n            elif x <= -d[i]:\n                w[j] += 'L'\n                x += d[i]\n            elif y >= d[i]:\n                w[j] += 'U'\n                y -= d[i]\n            elif y <= -d[i]:\n                w[j] += 'D'\n                y += d[i]\n\n    # Check if the condition can be satisfied\n    if all(w[j][-1] == 'R' for j in range(n)):\n        return -1\n\n    return m, d, w\n\n# Read input\nn = int(input())\npoints = [list(map(int, input().split())) for _ in range(n)]\n\n# Calculate robot arm configuration\nresult = calculate_robot_arm(points)\n\n# Print output\nif result == -1:\n    print(-1)\nelse:\n    m, d, w = result\n    print(m)\n    print(' '.join(map(str, d)))\n    for j in range(n):\n        print(w[j])"}
{"solution": "# Read the length of the interview\nn = int(input())\n\n# Read the interview string\ns = input()\n\n# Initialize the result string\nresult = \"\"\n\n# Initialize the filler word\nfiller = \"ogo\"\n\n# Loop through the interview string\ni = 0\nwhile i < n:\n    # Check if the current substring starts with the filler word\n    if s[i:i+len(filler)] == filler:\n        # Replace the filler word with \"***\"\n        result += \"***\"\n        # Move the index to the end of the filler word\n        i += len(filler)\n        # Check if there are more \"go\"s to be replaced\n        while i < n and s[i:i+2] == \"go\":\n            i += 2\n    else:\n        # Add the current character to the result string\n        result += s[i]\n        i += 1\n\n# Print the result string\nprint(result)"}
{"solution": "import math\n\ndef prime_factors(n):\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef g(x, p):\n    k = 0\n    while x % p**k == 0:\n        k += 1\n    return p**(k-1)\n\ndef f(x, y):\n    factors = prime_factors(x)\n    result = 1\n    for p in factors:\n        result *= g(y, p)\n    return result\n\ndef calculate_product(x, n):\n    mod = 10**9 + 7\n    result = 1\n    for i in range(1, n+1):\n        result = (result * f(x, i)) % mod\n    return result\n\nx, n = map(int, input().split())\nprint(calculate_product(x, n))"}
{"solution": "def sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_solutions(a, b, c):\n    solutions = []\n    for s in range(1, 82):  # s(x) can be at most 81\n        x = b * (s ** a) + c\n        if 0 < x < 10**9 and sum_of_digits(x) == s:\n            solutions.append(x)\n    solutions.sort()\n    return solutions\n\n# Read input\na, b, c = map(int, input().split())\n\n# Find solutions\nsolutions = find_solutions(a, b, c)\n\n# Print results\nprint(len(solutions))\nif solutions:\n    print(\" \".join(map(str, solutions)))"}
{"solution": "def solve_cube():\n    colors = list(map(int, input().split()))\n    color_count = {}\n\n    for color in colors:\n        if color in color_count:\n            color_count[color] += 1\n        else:\n            color_count[color] = 1\n\n    if sorted(color_count.values()) == [4, 4, 8, 8]:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nsolve_cube()"}
{"solution": "def calculate_i(s):\n    i = (s // 50) % 475\n    return i\n\ndef generate_tshirt_winners(i):\n    winners = []\n    for _ in range(25):\n        i = (i * 96 + 42) % 475\n        winners.append(26 + i)\n    return winners\n\ndef min_successful_hacks(p, x, y):\n    if p in generate_tshirt_winners(y):\n        return 0\n    else:\n        hacks = 0\n        while p not in generate_tshirt_winners(y + hacks * 100 - hacks * 50):\n            hacks += 1\n        return hacks\n\np, x, y = map(int, input().split())\nprint(min_successful_hacks(p, x, y))"}
{"solution": "# Get the input\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# If Winnie-the-Pooh only needs to have a meal once, he doesn't need to travel\nif n == 1:\n    print(0)\nelse:\n    # Calculate the minimum distance Winnie-the-Pooh needs to travel\n    # He will always alternate between the two houses that are closest together\n    min_distance = min(a, b, c)\n    # If he needs to have a meal an odd number of times, he will end up at one of the houses that is not the closest to Rabbit's house\n    if n % 2 == 1:\n        max_distance = max(a, b, c)\n        # If the closest house is not Rabbit's house, he will need to travel to Rabbit's house once\n        if min_distance != a:\n            print(min_distance + (n - 1) // 2 * 2 * min_distance + a)\n        else:\n            print((n - 1) // 2 * 2 * min_distance)\n    else:\n        print((n - 1) // 2 * 2 * min_distance)"}
{"solution": "# Get the input and convert it to a list of integers\ncoordinates = list(map(int, input().split()))\n\n# Sort the coordinates\ncoordinates.sort()\n\n# Calculate the minimum total distance\nmin_distance = (coordinates[1] - coordinates[0]) + (coordinates[2] - coordinates[1])\n\n# Print the result\nprint(min_distance)"}
{"solution": "def min_operations(n, x, a):\n    # Create a set to store unique elements after bitwise AND operation\n    unique_elements = set()\n\n    # Initialize the number of operations\n    operations = 0\n\n    # Iterate through the array\n    for i in range(n):\n        # Perform bitwise AND operation with x\n        a[i] &= x\n\n        # If the element is already in the set, return the number of operations\n        if a[i] in unique_elements:\n            return operations\n\n        # Add the element to the set\n        unique_elements.add(a[i])\n\n        # Increment the number of operations\n        operations += 1\n\n    # If no two elements are equal, return -1\n    return -1\n\n# Read input\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Print the minimal number of operations\nprint(min_operations(n, x, a))"}
{"solution": "def is_valid_plus_shape(grid):\n    h, w = len(grid), len(grid[0])\n    center = None\n\n    # Scanning the Grid\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == '*':\n                if center is not None:\n                    return False  # More than one center found\n                center = (i, j)\n\n    if center is None:\n        return False  # No center found\n\n    # Checking Conditions\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    for dx, dy in directions:\n        x, y = center[0] + dx, center[1] + dy\n        if not (0 <= x < h and 0 <= y < w and grid[x][y] == '*'):\n            return False  # No consecutive non-empty cells in this direction\n\n        while 0 <= x < h and 0 <= y < w and grid[x][y] == '*':\n            x += dx\n            y += dy\n\n        if not (0 <= x < h and 0 <= y < w and grid[x][y] == '.'):\n            return False  # Extra non-empty cells in this direction\n\n    # Ensuring Uniqueness\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == '*' and (i, j) != center:\n                return False  # Extra non-empty cells outside the \"+\" shape\n\n    return True\n\nh, w = map(int, input().split())\ngrid = [input() for _ in range(h)]\n\nif is_valid_plus_shape(grid):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def create_adjacency_matrix(n, a, b):\n    # Check if it's possible to create the graph\n    if a + b > n + 1 or a * b < n - 1:\n        return \"NO\"\n\n    # Create an empty adjacency matrix\n    matrix = [[0] * n for _ in range(n)]\n\n    # Create a graph with 'a' connected components\n    for i in range(a - 1):\n        matrix[i][i + 1] = matrix[i + 1][i] = 1\n\n    # Create a graph with 'b' connected components in its complement\n    for i in range(n - b, n - 1):\n        matrix[i][i + 1] = matrix[i + 1][i] = 1\n\n    # Connect the last vertex to the first vertex if necessary\n    if a > 1 and b > 1:\n        matrix[0][n - b] = matrix[n - b][0] = 1\n\n    # Convert the matrix to string format\n    matrix_str = \"\\n\".join([\"\".join(map(str, row)) for row in matrix])\n\n    return \"YES\\n\" + matrix_str\n\n# Read input\nn, a, b = map(int, input().split())\n\n# Create the adjacency matrix\nresult = create_adjacency_matrix(n, a, b)\n\n# Print the result\nprint(result)"}
{"solution": "# Read the input\nc, d = map(int, input().split())\nn, m = map(int, input().split())\nk = int(input())\n\n# Calculate the minimum number of main rounds needed\nmain_rounds = max(0, (n * m - k) // n)\n\n# Calculate the minimum number of additional rounds needed\nadditional_rounds = max(0, n * m - k - main_rounds * n)\n\n# Calculate the total number of problems needed\ntotal_problems = main_rounds * c + additional_rounds * d\n\n# Print the result\nprint(total_problems)"}
{"solution": "def find_path(s):\n    # Create a dictionary to store the adjacency of each letter\n    adj = {letter: [] for letter in s}\n\n    # Define the adjacency relationships\n    for i in range(26):\n        adj[chr(ord('A') + i)].append(chr(ord('A') + (i + 1) % 26))\n        adj[chr(ord('A') + i)].append(chr(ord('A') + (i + 13) % 26))\n        adj[chr(ord('A') + i)].append(chr(ord('A') + (i + 14) % 26))\n        adj[chr(ord('A') + i)].append(chr(ord('A') + (i + 25) % 26))\n        adj[chr(ord('A') + i)].append(chr(ord('A') + (i + 23) % 26))\n\n    # Initialize the grid\n    grid = [''] * 2\n\n    # Try to find a path\n    for i in range(26):\n        grid[0] = s[i] + s[i + 1:26] + s[:i]\n        grid[1] = s[26] + s[27:] + s[i + 1]\n\n        # Check if the path is valid\n        for j in range(26):\n            if grid[1][j] not in adj[grid[0][j]]:\n                break\n        else:\n            return grid\n\n    # If no path is found\n    return \"Impossible\"\n\n# Read the input\ns = input()\n\n# Find a path\ngrid = find_path(s)\n\n# Print the output\nprint('\\n'.join(grid))"}
{"solution": "import math\n\ndef compare_powers(x, y):\n    if x == y:\n        return '='\n    elif x == 1:\n        return '<' if y > 1 else '='\n    elif y == 1:\n        return '>' if x > 1 else '='\n    else:\n        # Compute y * log(x) and x * log(y)\n        lhs = y * math.log(x)\n        rhs = x * math.log(y)\n\n        if lhs < rhs:\n            return '<'\n        elif lhs > rhs:\n            return '>'\n        else:\n            return '='\n\n# Read input\nx, y = map(int, input().split())\n\n# Output the result of the comparison\nprint(compare_powers(x, y))"}
{"solution": "import math\n\n# Get the input values for r and h\nr, h = map(int, input().split())\n\n# Calculate the number of balloons that can fit in the semicircular part\nsemicircle_balloons = math.floor(math.pi * r / r)\n\n# Calculate the number of balloons that can fit in the rectangular part\nrectangle_balloons = math.floor((2 * r * h) / r)\n\n# Calculate the total maximum number of balloons\ntotal_balloons = semicircle_balloons + rectangle_balloons\n\n# Print the result\nprint(total_balloons)"}
{"solution": "from collections import Counter\n\n# Get the input and convert it to a list of integers\ncards = list(map(int, input().split()))\n\n# Count the occurrences of each number\ncard_counts = Counter(cards)\n\n# Initialize the minimum sum as the sum of all cards\nmin_sum = sum(cards)\n\n# Iterate through the counts of each number\nfor card, count in card_counts.items():\n    # If there are two or three of the same number,\n    # calculate the sum of removing that number\n    if count >= 2:\n        temp_sum = sum(cards) - min(3, count) * card\n        # Update the minimum sum if the temporary sum is smaller\n        min_sum = min(min_sum, temp_sum)\n\n# Print the minimum sum\nprint(min_sum)"}
{"solution": "def min_distance(n, a, checkpoints):\n    # Sort the checkpoints\n    checkpoints.sort()\n\n    # If Vasya's starting position is between the first and last checkpoints,\n    # he can skip the farthest checkpoint from his starting position\n    if checkpoints[0] < a < checkpoints[-1]:\n        if a - checkpoints[0] < checkpoints[-1] - a:\n            return checkpoints[-1] - checkpoints[0]\n        else:\n            return checkpoints[-2] - checkpoints[0]\n\n    # If Vasya's starting position is not between the first and last checkpoints,\n    # he must visit all checkpoints\n    else:\n        return checkpoints[-1] - checkpoints[0]\n\n# Read input\nn, a = map(int, input().split())\ncheckpoints = list(map(int, input().split()))\n\n# Print output\nprint(min_distance(n, a, checkpoints))"}
{"solution": "def sum_of_digits(n):\n    return sum(int(digit) for digit in str(n))\n\ndef find_root(n):\n    x = 1\n    while True:\n        if x**2 + sum_of_digits(x)*x - n == 0:\n            return x\n        if x**2 + sum_of_digits(x)*x > n:\n            return -1\n        x += 1\n\nn = int(input())\nprint(find_root(n))"}
{"solution": "from datetime import datetime, timedelta\n\n# Get the current time and sleep duration\ncurrent_time = input()\nsleep_duration = input()\n\n# Convert the time strings to datetime objects\ncurrent_time = datetime.strptime(current_time, \"%H:%M\")\nsleep_duration = datetime.strptime(sleep_duration, \"%H:%M\")\n\n# Calculate the bedtime\nbedtime = current_time - timedelta(hours=sleep_duration.hour, minutes=sleep_duration.minute)\n\n# Print the bedtime in the required format\nprint(bedtime.strftime(\"%H:%M\"))"}
{"solution": "# Read the input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Initialize variables\nmax_mean = float('-inf')\nmax_len = 0\ncurr_sum = 0\ncurr_len = 0\n\n# Iterate through the array\nfor i in range(n):\n    curr_sum += arr[i]\n    curr_len += 1\n\n    # Calculate the current mean\n    curr_mean = curr_sum / curr_len\n\n    # Update the maximum mean and length if necessary\n    if curr_mean > max_mean:\n        max_mean = curr_mean\n        max_len = curr_len\n    elif curr_mean == max_mean:\n        max_len = max(max_len, curr_len)\n\n    # Reset the current sum and length if necessary\n    if curr_sum < 0:\n        curr_sum = 0\n        curr_len = 0\n\n# Print the result\nprint(max_len)"}
{"solution": "MOD = 998244353\n\ndef count_ways(n, m, k):\n    dp = [[0] * (k + 1) for _ in range(n)]\n    dp[0] = [m] * (k + 1)\n\n    for i in range(1, n):\n        for j in range(k + 1):\n            dp[i][j] = dp[i - 1][j] * (m - 1) % MOD\n            if j > 0:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD\n\n    return sum(dp[n - 1]) % MOD\n\nn, m, k = map(int, input().split())\nprint(count_ways(n, m, k))"}
{"solution": "import re\n\ndef is_magic_number(n):\n    # Define the regular expression pattern for magic numbers\n    pattern = re.compile(r'^(1|14|144)+$')\n\n    # Check if the entire number matches the pattern\n    if pattern.match(str(n)):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Example usage\nn = int(input())\nprint(is_magic_number(n))"}
{"solution": "def min_moves(n, m, i, j, a, b):\n    # Check if it's possible to reach a corner\n    if (i + j - 1) % a != 0 or (i + m - j) % a != 0 or (n - i + j) % a != 0 or (n - i + m - j) % a != 0:\n        return \"Poor Inna and pony!\"\n\n    # Calculate the minimum number of moves\n    moves = min((i - 1) // a, (j - 1) // b, (n - i) // a, (m - j) // b)\n    return moves\n\n# Read the input\nn, m, i, j, a, b = map(int, input().split())\n\n# Print the result\nprint(min_moves(n, m, i, j, a, b))"}
{"solution": "def max_removable_chars(s):\n    # Create a list from the input string\n    s = list(s)\n    # Initialize a variable to keep track of the number of removals\n    removals = 0\n    # Iterate over the string from the second to the second last character\n    i = 1\n    while i < len(s) - 1:\n        # Check if the current character is one more than the previous character\n        # and one less than the next character in the alphabet\n        if ord(s[i]) - ord(s[i - 1]) == 1 and ord(s[i + 1]) - ord(s[i]) == 1:\n            # Remove the current character\n            s.pop(i)\n            # Increment the number of removals\n            removals += 1\n            # Decrement the index to check the same position again\n            # as the next character might be removable now\n            i -= 1\n        else:\n            # Move to the next character\n            i += 1\n    # Return the maximum possible number of characters that can be removed\n    return removals\n\n# Read the input\nn = int(input())\ns = input()\n# Print the output\nprint(max_removable_chars(s))"}
{"solution": "def min_bills(denominations, max_bills, target):\n    dp = [float('inf')] * (target + 1)\n    dp[0] = 0\n\n    for bill in denominations:\n        for i in range(bill, target + 1):\n            dp[i] = min(dp[i], dp[i - bill] + 1)\n\n    for _ in range(max_bills - 1):\n        new_dp = [float('inf')] * (target + 1)\n        for i in range(target + 1):\n            for bill in denominations:\n                if i >= bill:\n                    new_dp[i] = min(new_dp[i], dp[i - bill] + 1)\n        dp = new_dp\n\n    return dp\n\ndef main():\n    n, k = map(int, input().split())\n    denominations = list(map(int, input().split()))\n    q = int(input())\n    requests = [int(input()) for _ in range(q)]\n\n    max_sum = max(requests)\n    dp = min_bills(denominations, k, max_sum)\n\n    for request in requests:\n        print(-1 if dp[request] == float('inf') else dp[request])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_time(s, x1, x2, t1, t2, p, d):\n    # Calculate the time Igor needs to walk to the nearest tram stop\n    walk_time = min(abs(x1 - p), abs(x1 - s + p)) if d == 1 else min(abs(x1 - p), abs(x1 - s - p))\n    walk_time *= t2\n\n    # Calculate the time Igor needs to wait for the tram\n    wait_time = (abs(x1 - p) / t1) if d == 1 else (abs(x1 - s - p) / t1)\n\n    # Calculate the time Igor needs to ride the tram\n    ride_time = abs(x2 - x1) / t1\n\n    # Calculate the total time for Igor to reach x2\n    total_time = walk_time + wait_time + ride_time\n\n    # Calculate the time Igor needs to walk directly to x2\n    direct_walk_time = abs(x2 - x1) * t2\n\n    # Return the minimum time\n    return min(total_time, direct_walk_time)\n\n# Read the input\ns, x1, x2 = map(int, input().split())\nt1, t2 = map(int, input().split())\np, d = map(int, input().split())\n\n# Print the minimum time\nprint(min_time(s, x1, x2, t1, t2, p, d))"}
{"solution": "# Read the input\nn, x = map(int, input().split())\n\n# Initialize the count of cells containing x\ncount = 0\n\n# Iterate over all possible rows and columns\nfor i in range(1, n + 1):\n    for j in range(1, n + 1):\n        # If the cell contains x, increment the count\n        if i * j == x:\n            count += 1\n\n# Print the result\nprint(count)"}
{"solution": "n, k = map(int, input().split())\n\n# Determine the set of distinct lowercase Latin letters to use\nletters = 'abcdefghijklmnopqrstuvwxyz'\n\n# Develop a strategy to ensure that no two consecutive symbols are the same\npassword = ''\nfor i in range(n):\n    password += letters[i % k]\n    if i % k == k - 1:\n        letters = letters[1:] + letters[0]\n\n# Print the password\nprint(password)"}
{"solution": "def first_collision_time(n, directions, positions):\n    min_time = float('inf')\n    collision_found = False\n\n    for i in range(n - 1):\n        if directions[i] == 'R' and directions[i + 1] == 'L':\n            collision_time = (positions[i + 1] - positions[i]) // 2\n            min_time = min(min_time, collision_time)\n            collision_found = True\n\n    if collision_found:\n        return min_time\n    else:\n        return -1\n\nn = int(input())\ndirections = input()\npositions = list(map(int, input().split()))\nprint(first_collision_time(n, directions, positions))"}
{"solution": "def max_area(n, a, b, seals):\n    # Initialize maximum area\n    max_area = 0\n\n    # Consider all pairs of seals\n    for i in range(n):\n        for j in range(i+1, n):\n            # Consider all orientations of the seals\n            for x1, y1 in [(seals[i][0], seals[i][1]), (seals[i][1], seals[i][0])]:\n                for x2, y2 in [(seals[j][0], seals[j][1]), (seals[j][1], seals[j][0])]:\n                    # Check if the seals can be placed without overlapping\n                    if x1 + x2 <= a and max(y1, y2) <= b:\n                        max_area = max(max_area, x1*y1 + x2*y2)\n                    if max(x1, x2) <= a and y1 + y2 <= b:\n                        max_area = max(max_area, x1*y1 + x2*y2)\n\n    return max_area\n\n# Read input\nn, a, b = map(int, input().split())\nseals = [list(map(int, input().split())) for _ in range(n)]\n\n# Print output\nprint(max_area(n, a, b, seals))"}
{"solution": "# Read the number of points on each side of the square\nn = int(input())\n\n# Initialize lists to store the x and y coordinates\nx_coords = []\ny_coords = []\n\n# Read the coordinates and store them in the lists\nfor _ in range(4 * n + 1):\n    x, y = map(int, input().split())\n    x_coords.append(x)\n    y_coords.append(y)\n\n# Find the unique x and y coordinates\nunique_x = list(set(x_coords))\nunique_y = list(set(y_coords))\n\n# Sort the unique x and y coordinates\nunique_x.sort()\nunique_y.sort()\n\n# The point not on the boundary will have a unique x and y coordinate\n# The square's boundary points will have the minimum and maximum x and y coordinates\n# So, the point not on the boundary will be the one that is not at the minimum or maximum of unique_x and unique_y\n\nnot_on_boundary_x = unique_x[1] if unique_x.count(unique_x[0]) > 1 else unique_x[0]\nnot_on_boundary_y = unique_y[1] if unique_y.count(unique_y[0]) > 1 else unique_y[0]\n\n# Print the coordinates of the point not on the boundary\nprint(not_on_boundary_x, not_on_boundary_y)"}
{"solution": "def max_product(n):\n    if n < 10:\n        return n\n\n    product = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    for i in range(10, n + 1):\n        num = i\n        j = 9\n        temp_product = 1\n        while num > 0:\n            temp_product *= product[j]\n            num //= 10\n            j -= 1\n        product.append(max(i, temp_product))\n\n    return product[n]\n\nn = int(input())\nprint(max_product(n))"}
{"solution": "# Read the number of students\nn = int(input())\n\n# Read the votes for Elodreip\nvotes = list(map(int, input().split()))\n\n# Calculate the total votes for Elodreip\ntotal_elodreip = sum(votes)\n\n# Initialize the minimum number of votes for Awruk\nk = max(votes)\n\n# Calculate the total votes for Awruk\ntotal_awruk = n * k - total_elodreip\n\n# Increment k until Awruk's votes exceed Elodreip's votes\nwhile total_awruk <= total_elodreip:\n    k += 1\n    total_awruk = n * k - total_elodreip\n\n# Print the minimum number of votes for Awruk to win\nprint(k)"}
{"solution": "def count_operations(colors):\n    # Initialize the operation count\n    operations = 0\n\n    # Continue the loop until no more operations can be performed\n    while True:\n        # Initialize a flag to check if any deletion occurred in this iteration\n        deleted = False\n\n        # Iterate over the colors list\n        i = 1\n        while i < len(colors) - 1:\n            # If the current color is different from its neighbors, delete it\n            if colors[i] != colors[i - 1] or colors[i] != colors[i + 1]:\n                colors.pop(i)\n                deleted = True\n            else:\n                i += 1\n\n        # If no deletion occurred in this iteration, break the loop\n        if not deleted:\n            break\n\n        # Increment the operation count\n        operations += 1\n\n    # Return the operation count\n    return operations\n\n# Read the input\ncolors = input()\n\n# Print the output\nprint(count_operations(colors))"}
{"solution": "# Read the input\nn = int(input())\na = list(map(int, input().split()))\n\n# Sort the array\na.sort()\n\n# Initialize the count of triples\ncount = 0\n\n# Find the minimum product\nmin_product = a[0] * a[1] * a[2]\n\n# Iterate through the array to find the triples with minimum product\nfor i in range(n - 2):\n    for j in range(i + 1, n - 1):\n        for k in range(j + 1, n):\n            # If the product is equal to the minimum product, increment the count\n            if a[i] * a[j] * a[k] == min_product:\n                count += 1\n            # If the product is greater than the minimum product, break the loop\n            else:\n                break\n\n# Print the count of triples\nprint(count)"}
{"solution": "# Read the input\nn = int(input())\n\n# Calculate the number of cuts needed\n# This is equal to the number of handshakes in a group of n+1 people\n# Since each handshake creates a new slice, the number of handshakes is equal to the number of cuts needed\ncuts_needed = (n * (n + 1)) // 2\n\n# Print the output\nprint(cuts_needed)"}
{"solution": "def max_bank_account(n):\n    # Convert the number to a list of digits\n    digits = list(map(int, str(abs(n))))\n\n    # If the number is positive, remove the last digit if it's smaller than the second last digit\n    if n > 0:\n        if len(digits) > 1 and digits[-1] < digits[-2]:\n            digits.pop(-1)\n\n    # If the number is negative, remove the last digit if it's larger than the second last digit\n    elif n < 0:\n        if len(digits) > 1 and digits[-1] > digits[-2]:\n            digits.pop(-1)\n\n    # Convert the list of digits back to a number\n    result = int(''.join(map(str, digits)))\n\n    # If the original number was negative, make the result negative as well\n    if n < 0:\n        result = -result\n\n    return result\n\n# Get the input\nn = int(input())\n\n# Print the output\nprint(max_bank_account(n))"}
{"solution": "# Define the spinner positions and their relationships\npositions = ['v', '>', '^', '<']\nrelationships = {\n    'v>': 'cw',\n    '>^': 'cw',\n    '^<': 'cw',\n    '<v': 'cw',\n    'v<': 'ccw',\n    '<^': 'ccw',\n    '^>': 'ccw',\n    '>v': 'ccw'\n}\n\n# Get the input\nstart, end = input().split()\nn = int(input())\n\n# Determine the direction\nif start == end:\n    print('undefined')\nelse:\n    direction = relationships[start + end]\n    # If the number of seconds is even, the direction is undefined\n    if n % 2 == 0:\n        print('undefined')\n    else:\n        print(direction)"}
{"solution": "n = int(input())\ns = input()\n\n# Initialize an array to store the state of each domino\ndominoes = ['S'] * n\n\n# Simulate the process\nfor i in range(n):\n    if s[i] == 'L':\n        j = i - 1\n        while j >= 0 and dominoes[j] != 'R':\n            dominoes[j] = 'L'\n            j -= 1\n    elif s[i] == 'R':\n        j = i + 1\n        while j < n and dominoes[j] != 'L':\n            dominoes[j] = 'R'\n            j += 1\n\n# Count the number of standing dominoes\nstanding = dominoes.count('S')\nprint(standing)"}
{"solution": "def find_permutation(n, m, leaders):\n    permutation = [0] * n\n    current_leader = leaders[0] - 1\n\n    for i in range(m):\n        if permutation[current_leader] != 0:\n            return -1\n\n        if i == m - 1:\n            next_leader = leaders[0] - 1\n        else:\n            next_leader = leaders[i + 1] - 1\n\n        permutation[current_leader] = (next_leader - current_leader) % n\n        if permutation[current_leader] == 0:\n            permutation[current_leader] = n\n\n        current_leader = next_leader\n\n    return permutation\n\nn, m = map(int, input().split())\nleaders = list(map(int, input().split()))\n\nresult = find_permutation(n, m, leaders)\n\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))"}
{"solution": "def max_number(a, k):\n    # Convert the number to a list of digits\n    digits = list(str(a))\n\n    # Iterate through the digits\n    for i in range(len(digits)):\n        # If no more swaps are allowed, break the loop\n        if k == 0:\n            break\n\n        # Find the best possible digit to swap with\n        max_digit = max(digits[i:])\n        max_index = digits[i:].index(max_digit) + i\n\n        # If the best possible digit is not the current digit and swapping is beneficial\n        if max_index != i and digits[max_index] > digits[i]:\n            # Perform the swap\n            digits[i], digits[max_index] = digits[max_index], digits[i]\n            k -= 1\n\n    # Convert the list of digits back to a number\n    return int(''.join(digits))\n\n# Get the input\na, k = map(int, input().split())\n\n# Print the maximum number that Pasha can get\nprint(max_number(a, k))"}
{"solution": "def find_next_number(sequence):\n    # Check if the sequence is arithmetic\n    diff = sequence[1] - sequence[0]\n    if all(sequence[i] - sequence[i - 1] == diff for i in range(2, len(sequence))):\n        return sequence[-1] + diff\n\n    # Check if the sequence is geometric\n    ratio = sequence[1] / sequence[0]\n    if all(sequence[i] / sequence[i - 1] == ratio for i in range(2, len(sequence))):\n        return sequence[-1] * ratio\n\n    # If the sequence is neither arithmetic nor geometric\n    return 42\n\n# Read the input sequence\nsequence = list(map(int, input().split()))\n\n# Find and print the next number in the sequence\nnext_number = find_next_number(sequence)\n\n# Check if the next number is an integer\nif next_number.is_integer():\n    print(int(next_number))\nelse:\n    print(42)"}
{"solution": "def max_distance(n, colors):\n    # Find the first and last occurrence of each color\n    first_occurrence = {}\n    last_occurrence = {}\n\n    for i in range(n):\n        color = colors[i]\n        if color not in first_occurrence:\n            first_occurrence[color] = i\n        last_occurrence[color] = i\n\n    # Get the list of unique colors\n    unique_colors = list(first_occurrence.keys())\n\n    # Calculate the maximum distance\n    max_dist = 0\n\n    # Compare distances from the first house to the last house of a different color\n    for color in unique_colors:\n        if colors[0] != color:\n            max_dist = max(max_dist, last_occurrence[color])\n        if colors[-1] != color:\n            max_dist = max(max_dist, n - 1 - first_occurrence[color])\n\n    return max_dist\n\n# Read input\nn = int(input())\ncolors = list(map(int, input().split()))\n\n# Print output\nprint(max_distance(n, colors))"}
{"solution": "# Get the input\nn, m, k = map(int, input().split())\n\n# Calculate the lane\nlane = (k - 1) // (2 * m) + 1\n\n# Calculate the desk\ndesk = ((k - 1) % (2 * m)) // 2 + 1\n\n# Calculate the side\nside = 'L' if k % 2 == 1 else 'R'\n\n# Print the output\nprint(lane, desk, side)"}
{"solution": "# Read the input\nn = int(input())\ns = input()\n\n# Count the colors\ncounts = {'B': 0, 'G': 0, 'R': 0}\nfor color in s:\n    counts[color] += 1\n\n# Determine parity\nparities = {color: 'even' if count % 2 == 0 else 'odd' for color, count in counts.items()}\n\n# Possible final colors\nfinal_colors = []\nif parities['B'] == 'odd':\n    final_colors.append('B')\nif parities['G'] == 'odd':\n    final_colors.append('G')\nif parities['R'] == 'odd':\n    final_colors.append('R')\nif len(final_colors) == 0:\n    final_colors = ['B', 'G', 'R']\n\n# Print the result\nprint(''.join(sorted(final_colors)))"}
