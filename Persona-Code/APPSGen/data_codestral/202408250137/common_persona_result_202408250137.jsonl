{"solution": "def find_longest_accordion(s):\n    # Initialize variables\n    open_bracket = '['\n    close_bracket = ']'\n    colon = ':'\n    vertical_line = '|'\n    max_length = -1\n    current_length = 0\n    open_bracket_count = 0\n    close_bracket_count = 0\n    colon_count = 0\n    vertical_line_count = 0\n\n    # Iterate through the string\n    for char in s:\n        if char == open_bracket:\n            open_bracket_count += 1\n        elif char == close_bracket:\n            close_bracket_count += 1\n        elif char == colon:\n            colon_count += 1\n        elif char == vertical_line:\n            vertical_line_count += 1\n\n        # Check if an accordion can be formed\n        if open_bracket_count >= 1 and colon_count >= 2 and close_bracket_count >= 1:\n            # Calculate the length of the accordion\n            current_length = 2 + 2 * min(colon_count - 2, vertical_line_count)\n            max_length = max(max_length, current_length)\n\n        # If an invalid character is encountered, reset the counts\n        if char not in [open_bracket, close_bracket, colon, vertical_line]:\n            open_bracket_count = 0\n            close_bracket_count = 0\n            colon_count = 0\n            vertical_line_count = 0\n\n    return max_length\n\n# Read the input string\ns = input()\n\n# Print the maximum possible length of the resulting accordion\nprint(find_longest_accordion(s))"}
{"solution": "def max_sum_digits(x):\n    # Convert the number to a list of digits\n    digits = list(map(int, str(x)))\n\n    # Start from the most significant digit\n    for i in range(len(digits) - 1, 0, -1):\n        # If the current digit is less than 9\n        if digits[i] < 9:\n            # Find the largest digit that is less than or equal to the remaining value\n            j = i - 1\n            while j >= 0 and digits[j] == 9:\n                j -= 1\n            if j >= 0:\n                # Increase the current digit to 9 and decrease the previous digit by 1\n                digits[i] = 9\n                digits[j] -= 1\n\n    # Convert the list of digits back to a number\n    return int(''.join(map(str, digits)))\n\n# Get the input\nx = int(input())\n\n# Print the result\nprint(max_sum_digits(x))"}
{"solution": "def find_next_lucky_year(current_year):\n    while True:\n        current_year += 1\n        if str(current_year).count('0') >= len(str(current_year)) - 1:\n            return current_year\n\ncurrent_year = int(input())\nnext_lucky_year = find_next_lucky_year(current_year)\nprint(next_lucky_year - current_year)"}
{"solution": "def max_painted_sections(n, q, painters):\n    # Create a list to store the painted sections\n    painted = [0] * (n + 1)\n\n    # Sort the painters based on the starting section\n    painters.sort(key=lambda x: x[0])\n\n    # Hire the first painter\n    for i in range(painters[0][0], painters[0][1] + 1):\n        painted[i] = 1\n\n    # Hire the painter who covers the maximum unpainted section\n    max_unpainted = 0\n    max_painter = -1\n    for i in range(1, q):\n        unpainted = 0\n        for j in range(painters[i][0], painters[i][1] + 1):\n            if painted[j] == 0:\n                unpainted += 1\n        if unpainted > max_unpainted:\n            max_unpainted = unpainted\n            max_painter = i\n\n    # Hire the max_painter\n    for i in range(painters[max_painter][0], painters[max_painter][1] + 1):\n        painted[i] = 1\n\n    # Count the painted sections\n    count = 0\n    for i in range(1, n + 1):\n        if painted[i] == 1:\n            count += 1\n\n    return count\n\n# Read the input\nn, q = map(int, input().split())\npainters = []\nfor _ in range(q):\n    l, r = map(int, input().split())\n    painters.append((l, r))\n\n# Print the maximum number of painted sections\nprint(max_painted_sections(n, q, painters))"}
{"solution": "def contains_seven(time):\n    return '7' in str(time)\n\ndef find_lucky_time(x, hh, mm):\n    for y in range(0, 1000):\n        new_mm = (mm - y * x) % 60\n        new_hh = (hh - (mm - new_mm) // 60) % 24\n        if contains_seven(new_hh) or contains_seven(new_mm):\n            return y\n\nx = int(input())\nhh, mm = map(int, input().split())\nprint(find_lucky_time(x, hh, mm))"}
{"solution": "def min_seconds_to_close_tabs(n, pos, l, r):\n    if l == 1 and r == n:\n        return 0\n    elif l == 1:\n        return abs(pos - r) + 1\n    elif r == n:\n        return abs(pos - l) + 1\n    else:\n        return min(abs(pos - l), abs(pos - r)) + (r - l) + 2\n\nn, pos, l, r = map(int, input().split())\nprint(min_seconds_to_close_tabs(n, pos, l, r))"}
{"solution": "def min_blows(n, x, blows):\n    blows.sort(key=lambda b: (-b[0], b[1]))\n    ans = 0\n    while x > 0:\n        found = False\n        for d, h in blows:\n            if d >= x or h < d:\n                x -= d\n                x += h\n                ans += 1\n                found = True\n                break\n        if not found:\n            return -1\n    return ans\n\nt = int(input())\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [list(map(int, input().split())) for _ in range(n)]\n    print(min_blows(n, x, blows))"}
{"solution": "def barn_empty_day(n, m):\n    grains_in_barn = n\n    day = 0\n\n    while grains_in_barn > 0:\n        day += 1\n        grains_in_barn += m\n        if grains_in_barn > n:\n            grains_in_barn = n\n        grains_in_barn -= day\n\n    return day\n\nn, m = map(int, input().split())\nprint(barn_empty_day(n, m))"}
{"solution": "def min_draws_to_win(tiles):\n    # Parse the input tiles\n    tile1, tile2, tile3 = tiles.split()\n\n    # Extract numbers and suits\n    num1, suit1 = int(tile1[0]), tile1[1]\n    num2, suit2 = int(tile2[0]), tile2[1]\n    num3, suit3 = int(tile3[0]), tile3[1]\n\n    # Check for koutsu (triplet)\n    if tile1 == tile2 == tile3:\n        return 0\n\n    # Check for shuntsu (sequence)\n    def is_shuntsu(n1, n2, n3):\n        return sorted([n1, n2, n3]) in [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7], [6, 7, 8], [7, 8, 9]]\n\n    if suit1 == suit2 == suit3 and is_shuntsu(num1, num2, num3):\n        return 0\n\n    # Check for possible koutsu with one more draw\n    if tile1 == tile2 or tile1 == tile3 or tile2 == tile3:\n        return 1\n\n    # Check for possible shuntsu with one more draw\n    def needs_one_for_shuntsu(n1, n2):\n        return abs(n1 - n2) == 1 or abs(n1 - n2) == 2\n\n    if suit1 == suit2 and needs_one_for_shuntsu(num1, num2):\n        return 1\n    if suit1 == suit3 and needs_one_for_shuntsu(num1, num3):\n        return 1\n    if suit2 == suit3 and needs_one_for_shuntsu(num2, num3):\n        return 1\n\n    # If no koutsu or shuntsu can be formed with one more draw, return 2\n    return 2\n\n# Read input\ntiles = input()\n\n# Print output\nprint(min_draws_to_win(tiles))"}
{"solution": "def find_sofa(d, n, m, sofas, cnt_l, cnt_r, cnt_t, cnt_b):\n    # Initialize counters for each sofa\n    left_count = [0] * d\n    right_count = [0] * d\n    top_count = [0] * d\n    bottom_count = [0] * d\n\n    # Calculate the counts for each sofa\n    for i in range(d):\n        for j in range(d):\n            if i == j:\n                continue\n            if sofas[i][0] < sofas[j][0] and sofas[i][1] == sofas[j][1]:\n                right_count[i] += 1\n                left_count[j] += 1\n            elif sofas[i][0] > sofas[j][0] and sofas[i][1] == sofas[j][1]:\n                left_count[i] += 1\n                right_count[j] += 1\n            elif sofas[i][1] < sofas[j][1] and sofas[i][0] == sofas[j][0]:\n                bottom_count[i] += 1\n                top_count[j] += 1\n            elif sofas[i][1] > sofas[j][1] and sofas[i][0] == sofas[j][0]:\n                top_count[i] += 1\n                bottom_count[j] += 1\n\n    # Find the sofa that matches the given conditions\n    for i in range(d):\n        if left_count[i] == cnt_l and right_count[i] == cnt_r and top_count[i] == cnt_t and bottom_count[i] == cnt_b:\n            return i + 1\n\n    # If no sofa matches the conditions, return -1\n    return -1\n\n# Read input\nd = int(input())\nn, m = map(int, input().split())\nsofas = [list(map(int, input().split())) for _ in range(d)]\ncnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\n# Find and print the result\nresult = find_sofa(d, n, m, sofas, cnt_l, cnt_r, cnt_t, cnt_b)\nprint(result)"}
{"solution": "def mars_days_off(n):\n    full_weeks = n // 7\n    remaining_days = n % 7\n\n    min_days_off = full_weeks * 2\n    max_days_off = full_weeks * 2 + min(remaining_days, 2)\n\n    return min_days_off, max_days_off\n\nn = int(input())\nmin_days_off, max_days_off = mars_days_off(n)\nprint(min_days_off, max_days_off)"}
{"solution": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef lcm(a, b):\n    return (a * b) // gcd(a, b)\n\ndef count_tiles(n, a, b):\n    red_tiles = n // a\n    blue_tiles = n // b\n    both_tiles = n // lcm(a, b)\n    return red_tiles, blue_tiles, both_tiles\n\ndef max_chocolates(n, a, b, p, q):\n    red_tiles, blue_tiles, both_tiles = count_tiles(n, a, b)\n    if p > q:\n        max_chocolates = red_tiles * p + (blue_tiles - both_tiles) * q + both_tiles * max(p, q)\n    else:\n        max_chocolates = blue_tiles * q + (red_tiles - both_tiles) * p + both_tiles * max(p, q)\n    return max_chocolates\n\nn, a, b, p, q = map(int, input().split())\nprint(max_chocolates(n, a, b, p, q))"}
{"solution": "def max_golden_subsegment(n, trophies):\n    # Convert the string to a list for easier manipulation\n    trophies = list(trophies)\n\n    # Initialize the maximum possible length of a subsegment of golden trophies\n    max_length = 0\n\n    # Iterate through all possible pairs of trophies to swap\n    for i in range(n):\n        for j in range(i+1, n):\n            # Swap the trophies\n            trophies[i], trophies[j] = trophies[j], trophies[i]\n\n            # Calculate the length of the longest subsegment of golden trophies\n            current_length = 0\n            max_current_length = 0\n            for trophy in trophies:\n                if trophy == 'G':\n                    current_length += 1\n                    max_current_length = max(max_current_length, current_length)\n                else:\n                    current_length = 0\n\n            # Update the maximum possible length\n            max_length = max(max_length, max_current_length)\n\n            # Swap the trophies back to their original positions\n            trophies[i], trophies[j] = trophies[j], trophies[i]\n\n    return max_length\n\n# Read the input\nn = int(input())\ntrophies = input()\n\n# Print the output\nprint(max_golden_subsegment(n, trophies))"}
{"solution": "from collections import deque\n\n# Read input\nn, k = map(int, input().split())\nmain_courses = set(map(int, input().split()))\ndependencies = [set(map(int, input().split()[1:])) for _ in range(n)]\n\n# Initialize in-degree array\nin_degree = [0] * n\nfor course in range(n):\n    for dependency in dependencies[course]:\n        in_degree[dependency - 1] += 1\n\n# Initialize queue with main courses that have no dependencies\nqueue = deque([course - 1 for course in main_courses if in_degree[course - 1] == 0])\n\n# Initialize result list\nresult = []\n\n# Topological sort\nwhile queue:\n    course = queue.popleft()\n    result.append(course + 1)\n    for dependent in range(n):\n        if course + 1 in dependencies[dependent]:\n            in_degree[dependent] -= 1\n            if in_degree[dependent] == 0:\n                queue.append(dependent)\n\n# Check if all main courses were taken\nif len(result) < k:\n    print(-1)\nelse:\n    print(len(result))\n    print(' '.join(map(str, result)))"}
{"solution": "def is_stack_sortable(arr):\n    stack = []\n    sorted_arr = []\n    i = 0\n    while i < len(arr) or stack:\n        if stack and stack[-1] == arr[i]:\n            sorted_arr.append(stack.pop())\n            i += 1\n        elif i < len(arr):\n            stack.append(arr[i])\n            i += 1\n        else:\n            return False\n    return sorted_arr == sorted(sorted_arr)\n\ndef restore_permutation(n, k, arr):\n    remaining_elements = set(range(1, n+1)) - set(arr)\n    for perm in permutations(remaining_elements):\n        new_arr = arr + list(perm)\n        if is_stack_sortable(new_arr):\n            return new_arr\n    return -1\n\nn, k = map(int, input().split())\narr = list(map(int, input().split()))\nresult = restore_permutation(n, k, arr)\nprint(*result)"}
{"solution": "def does_b_appear_in_sequence(a, b, c):\n    if c == 0:\n        return \"YES\" if a == b else \"NO\"\n    else:\n        if (b - a) % c == 0 and (b - a) // c >= 0:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n# Get input from the user\na, b, c = map(int, input().split())\n\n# Print the result\nprint(does_b_appear_in_sequence(a, b, c))"}
{"solution": "def can_form_regular_sequence(cnt_1, cnt_2, cnt_3, cnt_4):\n    if cnt_1 == cnt_4:\n        return 1\n    else:\n        return 0\n\ncnt_1 = int(input())\ncnt_2 = int(input())\ncnt_3 = int(input())\ncnt_4 = int(input())\n\nprint(can_form_regular_sequence(cnt_1, cnt_2, cnt_3, cnt_4))"}
{"solution": "# Get the input values\nn, k, t = map(int, input().split())\n\n# Calculate the number of standing spectators at time t\nif t <= k:\n    # If t is less than or equal to k, the number of standing spectators is equal to t\n    standing = t\nelif t <= n:\n    # If t is greater than k but less than or equal to n, the number of standing spectators is equal to k\n    standing = k\nelse:\n    # If t is greater than n, the number of standing spectators is decreasing\n    standing = max(0, n - (t - n))\n\n# Print the result\nprint(standing)"}
{"solution": "def lexicographically_minimal_string(s):\n    t = []\n    u = []\n    min_char = min(s)\n    s = list(s)\n\n    while s or t:\n        if t and (not s or t[-1] <= min_char):\n            u.append(t.pop())\n        else:\n            char = s.pop(0)\n            t.append(char)\n            if s:\n                min_char = min(s)\n\n    return ''.join(u)\n\ns = input().strip()\nprint(lexicographically_minimal_string(s))"}
{"solution": "def check_records(n, records):\n    prev_plays, prev_clears = records[0]\n    for plays, clears in records[1:]:\n        if plays < prev_plays or clears < prev_clears or clears > plays:\n            return False\n        prev_plays, prev_clears = plays, clears\n    return True\n\ndef solve():\n    T = int(input())\n    for _ in range(T):\n        n = int(input())\n        records = [list(map(int, input().split())) for _ in range(n)]\n        print(\"YES\" if check_records(n, records) else \"NO\")\n\nsolve()"}
{"solution": "def next_palindrome(time):\n    hours, minutes = map(int, time.split(':'))\n    while True:\n        minutes += 1\n        if minutes == 60:\n            minutes = 0\n            hours = (hours + 1) % 24\n        time = f'{hours:02d}:{minutes:02d}'\n        if time == time[::-1]:\n            return minutes\n\ndef main():\n    time = input()\n    minutes = next_palindrome(time)\n    print(minutes)\n\nif __name__ == '__main__':\n    main()"}
{"solution": "# Read the size of the permutation\nn = int(input())\n\n# Read the permutation\na = list(map(int, input().split()))\n\n# Find the indices of the minimum and maximum elements\nmin_index = a.index(1)\nmax_index = a.index(n)\n\n# Calculate the current distance between the minimum and maximum elements\ncurrent_distance = abs(min_index - max_index)\n\n# Calculate the distances if we swap the minimum element with the left or right element\nleft_distance = max_index if min_index > 0 else current_distance\nright_distance = n - min_index - 1 if min_index < n - 1 else current_distance\n\n# Calculate the distances if we swap the maximum element with the left or right element\nswap_left_distance = n - max_index - 1 if max_index > 0 else current_distance\nswap_right_distance = max_index if max_index < n - 1 else current_distance\n\n# Calculate the maximum possible distance\nmax_distance = max(current_distance, left_distance, right_distance, swap_left_distance, swap_right_distance)\n\n# Print the maximum possible distance\nprint(max_distance)"}
{"solution": "def is_s_palindrome(s):\n    n = len(s)\n    mid = n // 2\n    if n % 2 == 0:\n        first_half = s[:mid]\n        second_half = s[mid:]\n    else:\n        first_half = s[:mid]\n        second_half = s[mid+1:]\n\n    if first_half == second_half[::-1]:\n        return \"TAK\"\n    else:\n        return \"NIE\"\n\n# Read the input string\ns = input().strip()\n# Print the result\nprint(is_s_palindrome(s))"}
{"solution": "def max_permutation(a, b):\n    a_str = str(a)\n    b_str = str(b)\n    count_a = [0] * 10\n    count_b = [0] * 10\n\n    # Count the occurrences of each digit in a and b\n    for digit in a_str:\n        count_a[int(digit)] += 1\n    for digit in b_str:\n        count_b[int(digit)] += 1\n\n    # Construct the maximum possible number\n    result = []\n    for digit in range(9, -1, -1):\n        # Add as many occurrences of the current digit as possible\n        while count_a[digit] > 0 and count_b[digit] > 0:\n            result.append(str(digit))\n            count_a[digit] -= 1\n            count_b[digit] -= 1\n\n    # If there are remaining digits in a, add them to the end of the result\n    for digit in range(10):\n        while count_a[digit] > 0:\n            result.append(str(digit))\n            count_a[digit] -= 1\n\n    # Convert the result list to a string and remove leading zeros\n    result = ''.join(result)\n    if result[0] == '0':\n        result = result[1:]\n\n    return result\n\na = int(input())\nb = int(input())\nprint(max_permutation(a, b))"}
{"solution": "def check_win(board, player):\n    for i in range(10):\n        for j in range(10):\n            if board[i][j] == '.':\n                board[i][j] = player\n                if check_row(board, player, i) or check_col(board, player, j) or check_diagonal(board, player, i, j):\n                    return True\n                board[i][j] = '.'\n    return False\n\ndef check_row(board, player, row):\n    count = 0\n    for i in range(10):\n        if board[row][i] == player:\n            count += 1\n            if count == 5:\n                return True\n        else:\n            count = 0\n    return False\n\ndef check_col(board, player, col):\n    count = 0\n    for i in range(10):\n        if board[i][col] == player:\n            count += 1\n            if count == 5:\n                return True\n        else:\n            count = 0\n    return False\n\ndef check_diagonal(board, player, row, col):\n    count = 0\n    for i in range(-4, 5):\n        if 0 <= row + i < 10 and 0 <= col + i < 10:\n            if board[row + i][col + i] == player:\n                count += 1\n                if count == 5:\n                    return True\n            else:\n                count = 0\n    count = 0\n    for i in range(-4, 5):\n        if 0 <= row + i < 10 and 0 <= col - i < 10:\n            if board[row + i][col - i] == player:\n                count += 1\n                if count == 5:\n                    return True\n            else:\n                count = 0\n    return False\n\nboard = [list(input()) for _ in range(10)]\nif check_win(board, 'X'):\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "def solve(n, k):\n    if k > n * n or k < n:\n        return -1\n\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            if k >= 2:\n                matrix[i][j] = matrix[j][i] = 1\n                k -= 2\n            if k == 1 and i == j:\n                matrix[i][j] = 1\n                k -= 1\n\n    return matrix\n\nn, k = map(int, input().split())\nresult = solve(n, k)\nif result == -1:\n    print(-1)\nelse:\n    for row in result:\n        print(' '.join(map(str, row)))"}
{"solution": "from itertools import permutations\n\ndef calculate_expression(x, y, z, order):\n    if order == 'xyz':\n        return x ** (y ** z)\n    elif order == 'xzy':\n        return x ** (z ** y)\n    elif order == 'yxz':\n        return y ** (x ** z)\n    elif order == 'yzx':\n        return y ** (z ** x)\n    elif order == 'zxy':\n        return z ** (x ** y)\n    elif order == 'zyx':\n        return z ** (y ** x)\n\ndef format_expression(x, y, z, order):\n    if order == 'xyz':\n        return f'{x}^{y}^{z}'\n    elif order == 'xzy':\n        return f'{x}^{z}^{y}'\n    elif order == 'yxz':\n        return f'({x}^{y})^{z}'\n    elif order == 'yzx':\n        return f'({x}^{z})^{y}'\n    elif order == 'zxy':\n        return f'({y}^{x})^{z}'\n    elif order == 'zyx':\n        return f'({y}^{z})^{x}'\n\ndef find_max_expression(x, y, z):\n    orders = ['xyz', 'xzy', 'yxz', 'yzx', 'zxy', 'zyx']\n    max_value = float('-inf')\n    max_expression = ''\n\n    for order in permutations(orders):\n        value = calculate_expression(x, y, z, order)\n        if value > max_value:\n            max_value = value\n            max_expression = format_expression(x, y, z, order)\n\n    return max_expression\n\nx, y, z = map(float, input().split())\nprint(find_max_expression(x, y, z))"}
{"solution": "def min_operations(n, s):\n    # Initialize the minimum operations as the length of the string\n    min_ops = n\n\n    # Iterate over all possible prefix lengths\n    for i in range(1, n // 2 + 1):\n        # Check if the prefix repeats to form the string\n        if n % i == 0 and s[:i] * (n // i) == s:\n            # Update the minimum operations\n            min_ops = i + 1 if n // i > 1 else i\n\n    return min_ops\n\n# Read the input\nn = int(input())\ns = input()\n\n# Print the minimum number of operations\nprint(min_operations(n, s))"}
{"solution": "# Read the number of files\nn = int(input())\n\n# Initialize empty lists for examples and regular tests\nexamples = []\nregular_tests = []\n\n# Read the files and their types\nfor _ in range(n):\n    file_name, file_type = input().split()\n    if file_type == '1':\n        examples.append(file_name)\n    else:\n        regular_tests.append(file_name)\n\n# Initialize the script and the counter\nscript = []\ncounter = 1\n\n# Rename the examples\nfor example in examples:\n    script.append(f'move {example} {counter}')\n    counter += 1\n\n# Rename the regular tests\nfor regular_test in regular_tests:\n    script.append(f'move {regular_test} {counter}')\n    counter += 1\n\n# Print the minimum number of lines in the script\nprint(len(script))\n\n# Print the script\nfor line in script:\n    print(line)"}
{"solution": "def min_changes_to_make_lucky(ticket):\n    # Calculate the sum of the first three digits and the last three digits\n    first_half_sum = sum(int(digit) for digit in ticket[:3])\n    second_half_sum = sum(int(digit) for digit in ticket[3:])\n\n    # If the sums are equal, no changes are needed\n    if first_half_sum == second_half_sum:\n        return 0\n\n    # Calculate the difference between the sums\n    diff = abs(first_half_sum - second_half_sum)\n\n    # Calculate the minimum number of changes needed\n    # This is the minimum number of digits that need to be replaced to make the difference a multiple of 9\n    # Since the maximum digit is 9, replacing a digit with 9 will increase the sum by at most 9\n    # Therefore, we need to replace at least ceil(diff / 9) digits\n    return (diff + 8) // 9\n\n# Read the ticket number from the input\nticket = input()\n\n# Print the minimum number of changes needed to make the ticket lucky\nprint(min_changes_to_make_lucky(ticket))"}
{"solution": "def minimum_traps(m, x):\n    return m - 1\n\n# Get input\nm, x = map(int, input().split())\n\n# Print output\nprint(minimum_traps(m, x))"}
{"solution": "def power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1:\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\ndef modInverse(n, p):\n    return power(n, p - 2, p)\n\ndef nCr(n, r, p):\n    num = fact[n]\n    den = (fact[r] * fact[n - r]) % p\n    return (num * modInverse(den, p)) % p\n\ndef solve(n, k):\n    p = 10**6 + 3\n    fact = [0] * (k + 1)\n    fact[0] = 1\n    for i in range(1, k + 1):\n        fact[i] = (fact[i - 1] * i) % p\n    prob = 0\n    for i in range(1, k):\n        prob = (prob + nCr(2**n, i, p)) % p\n    prob = (prob * fact[k]) % p\n    prob = (prob * modInverse(fact[k - 1], p)) % p\n    prob = (prob * modInverse(2**n, p)) % p\n    prob = (1 - prob) % p\n    return prob, 1\n\nn, k = map(int, input().split())\nA, B = solve(n, k)\nprint(A, B)"}
{"solution": "def check_journey(n, journey):\n    position = [0, 0]  # North Pole\n    for i in range(n):\n        distance, direction = journey[i]\n        if direction == 'North':\n            position[1] += distance\n        elif direction == 'South':\n            position[1] -= distance\n        elif direction == 'East':\n            position[0] += distance\n        elif direction == 'West':\n            position[0] -= distance\n\n        # Check conditions\n        if position[1] > 20000 or position[1] < -20000:\n            return 'NO'\n        if position[1] == 20000 and direction != 'South':\n            return 'NO'\n        if position[1] == -20000 and direction != 'North':\n            return 'NO'\n\n    # Check if the journey ends on the North Pole\n    if position[1] == 0:\n        return 'YES'\n    else:\n        return 'NO'\n\n# Read input\nn = int(input())\njourney = []\nfor i in range(n):\n    t, dir = input().split()\n    journey.append((int(t), dir))\n\n# Check and print the result\nprint(check_journey(n, journey))"}
{"solution": "def solve(a1, b1, a2, b2, L, R):\n    if a1 == a2:\n        if b1 == b2:\n            return 1 if L <= b1 <= R else 0\n        elif (b1 - b2) % a1 == 0:\n            return 1 if L <= b1 <= R else 0\n        else:\n            return 0\n    else:\n        diff = (b2 - b1) % a1\n        if diff % a2 != 0:\n            return 0\n        else:\n            k = diff // a2\n            if k < 0:\n                k = -k\n                a2 = -a2\n            b1 = b1 + k * a1\n            if b1 < L:\n                b1 = L + (L - b1) // a1 * a1\n            if b1 > R:\n                return 0\n            return (R - b1) // a1 - (L - b1) // a1 + 1\n\na1, b1, a2, b2, L, R = map(int, input().split())\nprint(solve(a1, b1, a2, b2, L, R))"}
{"solution": "# Read input\nn, a, b = map(int, input().split())\n\n# Initialize the maximum possible number of pieces on a plate\nx = 0\n\n# While it's possible to distribute the cakes according to the conditions\nwhile a >= n and b >= n:\n    # Distribute the larger cake among the plates\n    if a > b:\n        a -= n\n    else:\n        b -= n\n    # Increment the number of pieces on a plate\n    x += 1\n\n# Print the maximum possible number of pieces on a plate\nprint(x)"}
{"solution": "def check_flag(n, m, flag):\n    # Check if the flag can be divided into three equal stripes\n    if n % 3 != 0 or m % 3 != 0:\n        return \"NO\"\n\n    # Divide the flag into three equal stripes\n    stripes = [flag[i*n//3:(i+1)*n//3] for i in range(3)]\n\n    # Check if each stripe has exactly one color\n    colors = set()\n    for stripe in stripes:\n        stripe_colors = set(stripe)\n        if len(stripe_colors) != 1:\n            return \"NO\"\n        colors.add(stripe_colors.pop())\n\n    # Check if each color is used exactly once\n    if len(colors) != 3 or 'R' not in colors or 'G' not in colors or 'B' not in colors:\n        return \"NO\"\n\n    # Check if each row has the same color\n    for row in flag:\n        if len(set(row)) != 1:\n            return \"NO\"\n\n    return \"YES\"\n\n# Read input\nn, m = map(int, input().split())\nflag = [input() for _ in range(n)]\n\n# Print output\nprint(check_flag(n, m, flag))"}
{"solution": "def find_ayrat_location(n):\n    # Define the directions for the spiral movement\n    directions = [(1, 0), (1, -1), (0, -1), (-1, 0), (-1, 1), (0, 1)]\n\n    # Initialize Ayrat's position\n    x, y = 0, 0\n\n    # Initialize the step size and the direction index\n    step_size = 1\n    direction_index = 0\n\n    # Simulate Ayrat's movement\n    for _ in range(n):\n        # Move Ayrat in the current direction\n        x += directions[direction_index][0] * step_size\n        y += directions[direction_index][1] * step_size\n\n        # Update the direction index\n        direction_index = (direction_index + 1) % 6\n\n        # If Ayrat has reached the end of a side, increase the step size and update the direction index\n        if (x, y) == (step_size, -step_size * directions[direction_index][1]) or (x, y) == (-step_size * directions[direction_index][0], step_size):\n            step_size += 1\n            direction_index = (direction_index + 1) % 6\n\n    # Return Ayrat's current position\n    return x, y\n\n# Read the input\nn = int(input())\n\n# Find Ayrat's location\nx, y = find_ayrat_location(n)\n\n# Print the output\nprint(x, y)"}
{"solution": "import math\n\ndef can_break_shield(a, b, c):\n    # Calculate the greatest common divisor of a and b\n    gcd_ab = math.gcd(a, b)\n\n    # Check if c is divisible by the gcd of a and b\n    if c % gcd_ab == 0:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read input values\na, b, c = map(int, input().split())\n\n# Output the result\nprint(can_break_shield(a, b, c))"}
{"solution": "def can_tracks_coincide(n, L, kefa_barriers, sasha_barriers):\n    # Calculate distances between consecutive barriers for Kefa\n    kefa_distances = [(kefa_barriers[(i + 1) % n] - kefa_barriers[i]) % L for i in range(n)]\n    # Calculate distances between consecutive barriers for Sasha\n    sasha_distances = [(sasha_barriers[(i + 1) % n] - sasha_barriers[i]) % L for i in range(n)]\n\n    # Double the kefa_distances to handle circular rotation\n    doubled_kefa_distances = kefa_distances + kefa_distances\n\n    # Check if sasha_distances is a sublist of doubled_kefa_distances\n    for i in range(n):\n        if doubled_kefa_distances[i:i + n] == sasha_distances:\n            return \"YES\"\n\n    return \"NO\"\n\n# Read input\nn, L = map(int, input().split())\nkefa_barriers = list(map(int, input().split()))\nsasha_barriers = list(map(int, input().split()))\n\n# Output the result\nprint(can_tracks_coincide(n, L, kefa_barriers, sasha_barriers))"}
{"solution": "def longest_non_palindrome_substring(s):\n    n = len(s)\n    # Initialize the maximum length of non-palindrome substring as 0\n    max_length = 0\n\n    # Iterate over all possible substrings\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = s[i:j]\n            # Check if the substring is not a palindrome\n            if substring != substring[::-1]:\n                # Update the maximum length\n                max_length = max(max_length, len(substring))\n\n    return max_length\n\n# Read the input string\ns = input()\n# Print the maximum length of non-palindrome substring\nprint(longest_non_palindrome_substring(s))"}
{"solution": "n = int(input())\nparticipants = [list(map(int, input().split())) for _ in range(n)]\n\n# Check if any rating has changed\nif any(a != b for a, b in participants):\n    print(\"rated\")\nelse:\n    # Check if the standings are in non-increasing order of rating\n    if all(a >= b for a, b in zip(participants, participants[1:])):\n        print(\"unrated\")\n    else:\n        print(\"maybe\")"}
{"solution": "# Read the input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Initialize the result list\nresult = [0] * n\n\n# Traverse the array from left to right\nprev_zero = float('-inf')\nfor i in range(n):\n    if arr[i] == 0:\n        prev_zero = i\n    result[i] = i - prev_zero\n\n# Traverse the array from right to left\nprev_zero = float('inf')\nfor i in range(n - 1, -1, -1):\n    if arr[i] == 0:\n        prev_zero = i\n    result[i] = min(result[i], prev_zero - i)\n\n# Print the result\nprint(*result)"}
{"solution": "def count_distinct_cyclical_strings(n, s):\n    from itertools import product\n\n    def is_substring_in_cyclical_shifts(t, s):\n        t_extended = t + t\n        return any(s in t_extended[i:i+len(t)] for i in range(len(t)))\n\n    distinct_cyclical_strings = set()\n\n    for bits in product('01', repeat=n):\n        t = ''.join(bits)\n        if is_substring_in_cyclical_shifts(t, s):\n            distinct_cyclical_strings.add(t)\n\n    return len(distinct_cyclical_strings)\n\nn = int(input())\ns = input().strip()\nprint(count_distinct_cyclical_strings(n, s))"}
{"solution": "import math\n\ndef find_min_angle(vectors):\n    n = len(vectors)\n    angles = [math.atan2(y, x) for x, y in vectors]\n    angles.sort()\n    angles += [angle + 2 * math.pi for angle in angles]\n    min_angle = float('inf')\n    pair = (0, 0)\n    for i in range(n):\n        if angles[i + n] - angles[i] < min_angle:\n            min_angle = angles[i + n] - angles[i]\n            pair = (i + 1, (i + 1) % n + 1)\n    return pair\n\nn = int(input())\nvectors = [tuple(map(int, input().split())) for _ in range(n)]\nprint(*find_min_angle(vectors))"}
{"solution": "def minimal_time(d, k, a, b, t):\n    if d <= k:\n        return d * a\n\n    # Full segments\n    full_segments = d // k\n    remaining_distance = d % k\n\n    # Time for full segments\n    time_for_full_segments = full_segments * k * a + (full_segments - 1) * t\n\n    # Time for remaining distance\n    if remaining_distance == 0:\n        return time_for_full_segments\n    else:\n        # Option 1: Drive the remaining distance\n        time_drive_remaining = remaining_distance * a + t\n        # Option 2: Walk the remaining distance\n        time_walk_remaining = remaining_distance * b\n\n        return time_for_full_segments + min(time_drive_remaining, time_walk_remaining)\n\n# Read input\nd, k, a, b, t = map(int, input().split())\n\n# Calculate and print minimal time\nprint(minimal_time(d, k, a, b, t))"}
{"solution": "def max_gcd_sequence(n, k):\n    # Check if it's possible to create such sequence\n    if k > n or (k * (k + 1)) // 2 > n:\n        return [-1]\n\n    # Start from the maximum possible GCD\n    gcd = (n - k + 1) // k\n\n    # Check if it's possible to create such sequence with this GCD\n    while (n - gcd * k) < (k * (k + 1)) // 2:\n        gcd -= 1\n\n    # Create the sequence\n    sequence = list(range(gcd, gcd + k))\n\n    # Distribute the remaining sum to the sequence\n    remaining = n - sum(sequence)\n    for i in range(k - 1, -1, -1):\n        if remaining == 0:\n            break\n        sequence[i] += min(remaining, gcd)\n        remaining -= min(remaining, gcd)\n\n    return sequence\n\n# Read input\nn, k = map(int, input().split())\n\n# Print output\nprint(*max_gcd_sequence(n, k))"}
{"solution": "def count_pairs(n, m):\n    # Count the number of multiples of 5 in the range [1, n] and [1, m]\n    n_multiples = n // 5\n    m_multiples = m // 5\n\n    # Count the number of pairs that sum to a multiple of 5\n    # This is equal to the product of the number of multiples of 5 in each range\n    # Plus the number of pairs that include a multiple of 5 and a number that leaves a remainder of 0, 1, 2, or 3 when divided by 5\n    pairs = n_multiples * m_multiples + (n % 5) * (m_multiples) + (m % 5) * (n_multiples)\n\n    return pairs\n\n# Get the input\nn, m = map(int, input().split())\n\n# Print the result\nprint(count_pairs(n, m))"}
{"solution": "def max_beauty(n, x, a):\n    max_ending_here = max_so_far = a[0]\n    max_ending_here_prev = max_so_far_prev = 0\n\n    for i in range(1, n):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n\n        if max_ending_here < 0:\n            max_ending_here_prev = max_so_far\n            max_so_far_prev = max_so_far\n        else:\n            max_ending_here_prev = max(max_ending_here_prev + a[i], a[i])\n            max_so_far_prev = max(max_so_far_prev, max_ending_here_prev)\n\n    max_ending_here = max_so_far = a[n - 1]\n    max_ending_here_next = max_so_far_next = 0\n\n    for i in range(n - 2, -1, -1):\n        max_ending_here = max(a[i], max_ending_here + a[i])\n        max_so_far = max(max_so_far, max_ending_here)\n\n        if max_ending_here < 0:\n            max_ending_here_next = max_so_far\n            max_so_far_next = max_so_far\n        else:\n            max_ending_here_next = max(max_ending_here_next + a[i], a[i])\n            max_so_far_next = max(max_so_far_next, max_ending_here_next)\n\n        if max_ending_here < 0 and max_so_far_prev + max_ending_here_next * x > max_so_far:\n            max_so_far = max_so_far_prev + max_ending_here_next * x\n        elif max_ending_here_prev + max_so_far_next * x > max_so_far:\n            max_so_far = max_ending_here_prev + max_so_far_next * x\n\n    return max_so_far\n\nn, x = map(int, input().split())\na = list(map(int, input().split()))\nprint(max_beauty(n, x, a))"}
{"solution": "def find_kth_largest(n, m, k):\n    def count_less_equal(x):\n        count = 0\n        for i in range(1, n + 1):\n            count += min(m, x // i)\n        return count\n\n    low, high = 1, n * m\n    while low < high:\n        mid = (low + high) // 2\n        if count_less_equal(mid) < k:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n\n# Read input\nn, m, k = map(int, input().split())\n# Print output\nprint(find_kth_largest(n, m, k))"}
{"solution": "def find_kth_digit(k):\n    # Initialize variables\n    digit_count = 1\n    start_number = 1\n    base = 9\n\n    # Find the range of numbers that contains the k-th digit\n    while k > digit_count * base:\n        k -= digit_count * base\n        digit_count += 1\n        start_number *= 10\n        base *= 10\n\n    # Find the number that contains the k-th digit\n    number = start_number + (k - 1) // digit_count\n\n    # Find the k-th digit of the number\n    digit = str(number)[(k - 1) % digit_count]\n\n    return int(digit)\n\n# Read the input\nk = int(input())\n\n# Print the k-th digit of the sequence\nprint(find_kth_digit(k))"}
{"solution": "# Read input\nn, m, r = map(int, input().split())\nbuy_prices = list(map(int, input().split()))\nsell_prices = list(map(int, input().split()))\n\n# Find the minimum buying price\nmin_buy_price = min(buy_prices)\n\n# Find the maximum selling price\nmax_sell_price = max(sell_prices)\n\n# Calculate the maximum number of bourles that can be held after the evening\nif min_buy_price < max_sell_price:\n    # Buy shares at the minimum price and sell them at the maximum price\n    max_bourles = r // min_buy_price * max_sell_price + r % min_buy_price\nelse:\n    # Don't take any action\n    max_bourles = r\n\n# Print the result\nprint(max_bourles)"}
{"solution": "def find_original_message(t):\n    n = len(t)\n\n    # \u041f\u0435\u0440\u0435\u0431\u0438\u0440\u0430\u0435\u043c \u0432\u0441\u0435 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u0434\u043b\u0438\u043d\u044b \u043d\u0430\u043b\u043e\u0436\u0435\u043d\u0438\u044f\n    for overlap in range(1, n // 2 + 1):\n        # \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u043c\u043e\u0436\u043d\u043e \u043b\u0438 \u0440\u0430\u0437\u0434\u0435\u043b\u0438\u0442\u044c \u0441\u0442\u0440\u043e\u043a\u0443 t \u043d\u0430 \u0434\u0432\u0435 \u0447\u0430\u0441\u0442\u0438 \u0441 \u043d\u0430\u043b\u043e\u0436\u0435\u043d\u0438\u0435\u043c \u0434\u043b\u0438\u043d\u044b overlap\n        if t[:overlap] == t[-overlap:]:\n            s = t[:-overlap]\n            if s + t[-overlap:] == t:\n                return \"YES\", s\n\n    return \"NO\", None\n\n# \u0427\u0442\u0435\u043d\u0438\u0435 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\nt = input().strip()\n\n# \u041f\u043e\u0438\u0441\u043a \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0433\u043e \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f s\nresult, s = find_original_message(t)\n\n# \u0412\u044b\u0432\u043e\u0434 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430\nprint(result)\nif result == \"YES\":\n    print(s)"}
{"solution": "import math\n\ndef find_teams(n):\n    # Calculate the square root of 8*n + 1\n    root = math.sqrt(8*n + 1)\n\n    # Check if the root is an integer\n    if root.is_integer():\n        # Calculate the possible number of teams\n        teams = (root - 1) / 2\n\n        # Check if the number of teams is even\n        if teams % 2 == 0:\n            return int(teams)\n        else:\n            return int(teams), int(teams + 1)\n    else:\n        return -1\n\n# Read the input\nn = int(input())\n\n# Find the possible number of teams\nteams = find_teams(n)\n\n# Print the output\nif teams == -1:\n    print(-1)\nelse:\n    for team in sorted(teams):\n        print(team)"}
{"solution": "from collections import Counter\n\n# Get the input\nn = int(input())\ns = input()\nb = list(map(int, input().split()))\n\n# Count the frequency of each character in the string\ncounter = Counter(s)\n\n# Initialize the maximum possible beauty\nmax_beauty = 0\n\n# Iterate over the indices of the string\nfor i in range(n // 2):\n    # If the characters at the current index and its corresponding index are not equal\n    if s[i] != s[n - i - 1]:\n        # Add the beauty of the current index and its corresponding index to the maximum possible beauty\n        max_beauty += b[i] + b[n - i - 1]\n    # If the characters at the current index and its corresponding index are equal\n    else:\n        # If the frequency of the character is greater than 2\n        if counter[s[i]] > 2:\n            # Subtract the minimum beauty of the current index and its corresponding index from the total beauty\n            total_beauty = b[i] + b[n - i - 1]\n            min_beauty = min(b[i], b[n - i - 1])\n            max_beauty += total_beauty - min_beauty\n            counter[s[i]] -= 2\n        # If the frequency of the character is equal to 2\n        elif counter[s[i]] == 2:\n            # If the beauty of the current index is greater than the beauty of its corresponding index\n            if b[i] > b[n - i - 1]:\n                # Add the beauty of the current index to the maximum possible beauty\n                max_beauty += b[i]\n            # If the beauty of the current index is less than or equal to the beauty of its corresponding index\n            else:\n                # Add the beauty of its corresponding index to the maximum possible beauty\n                max_beauty += b[n - i - 1]\n            counter[s[i]] = 0\n\n# Print the maximum possible beauty\nprint(max_beauty)"}
{"solution": "def can_weigh(w, m):\n    if m == 0:\n        return True\n    if m < 0 or w == 1:\n        return False\n    if m % w == 0:\n        return True\n    return can_weigh(w, m % w) or can_weigh(w, m // w)\n\nw, m = map(int, input().split())\nif can_weigh(w, m):\n    print('YES')\nelse:\n    print('NO')"}
{"solution": "def solve(n, k):\n    # Initialize the result list\n    result = []\n\n    # Iterate over the powers of 2 in reverse order\n    for i in range(60, -1, -1):\n        # If the current power of 2 is less than or equal to n\n        # and we still need to pick more numbers\n        if (1 << i) <= n and k > 0:\n            # Subtract the current power of 2 from n\n            n -= 1 << i\n            # Add the current power to the result list\n            result.append(i)\n            # Decrease the number of remaining numbers to pick\n            k -= 1\n\n    # If we couldn't pick k numbers, return \"No\"\n    if k > 0:\n        return \"No\"\n    # Otherwise, return \"Yes\" and the result list\n    else:\n        return \"Yes\\n\" + \" \".join(map(str, result[::-1]))\n\n# Read the input\nn, k = map(int, input().split())\n# Print the solution\nprint(solve(n, k))"}
{"solution": "def champagne_pyramid(n, t):\n    # Initialize the pyramid with empty glasses\n    pyramid = [0] * (n * (n + 1) // 2)\n    pyramid[0] = t  # Pour champagne into the top glass\n\n    # Simulate the pouring process\n    for i in range(n * (n + 1) // 2):\n        if pyramid[i] > 1:\n            overflow = (pyramid[i] - 1) / 2\n            pyramid[i] = 1  # Fill the current glass\n            # Distribute the overflow to the two glasses below\n            if i < (n * (n + 1) // 2 - n):\n                pyramid[i + n - 1] += overflow\n                pyramid[i + n] += overflow\n\n    # Count the number of completely full glasses\n    full_glasses = sum(1 for glass in pyramid if glass == 1)\n    return full_glasses\n\n# Read the input\nn, t = map(int, input().split())\n\n# Print the result\nprint(champagne_pyramid(n, t))"}
{"solution": "def calculate_area(n, vertices):\n    if n == 1:\n        return -1\n    elif n == 2:\n        x1, y1 = vertices[0]\n        x2, y2 = vertices[1]\n        if x1 != x2 and y1 != y2:\n            return abs(x1 - x2) * abs(y1 - y2)\n        else:\n            return -1\n    elif n == 3:\n        x_coords = set()\n        y_coords = set()\n        for x, y in vertices:\n            x_coords.add(x)\n            y_coords.add(y)\n        if len(x_coords) == 2 and len(y_coords) == 2:\n            x1, x2 = x_coords\n            y1, y2 = y_coords\n            return abs(x1 - x2) * abs(y1 - y2)\n        else:\n            return -1\n    elif n == 4:\n        x_coords = set()\n        y_coords = set()\n        for x, y in vertices:\n            x_coords.add(x)\n            y_coords.add(y)\n        if len(x_coords) == 2 and len(y_coords) == 2:\n            x1, x2 = x_coords\n            y1, y2 = y_coords\n            return abs(x1 - x2) * abs(y1 - y2)\n        else:\n            return -1\n\nn = int(input())\nvertices = [tuple(map(int, input().split())) for _ in range(n)]\nprint(calculate_area(n, vertices))"}
{"solution": "# Get the input values\nn = int(input())\na = int(input())\nb = int(input())\n\n# Calculate the total length of all six sides of the frames for two doors\ntotal_length = 2 * (2 * a + b)\n\n# Calculate the minimal number of wooden bars needed\nmin_bars = total_length // n\nif total_length % n != 0:\n    min_bars += 1\n\n# Print the result\nprint(min_bars)"}
{"solution": "def check_sorting_feasibility(n, arr, swaps):\n    # Analyzing Constraints\n    segments = []\n    current_segment = [arr[0]]\n    for i in range(1, n):\n        if swaps[i - 1] == '1':\n            current_segment.append(arr[i])\n        else:\n            segments.append(current_segment)\n            current_segment = [arr[i]]\n    segments.append(current_segment)\n\n    # Formulating a Plan\n    sorted_arr = sorted(arr)\n    for segment in segments:\n        segment_sorted = sorted(segment)\n        if segment_sorted != sorted_arr[:len(segment)]:\n            return False\n        sorted_arr = sorted_arr[len(segment):]\n\n    # Testing and Verification\n    return True\n\n# Understanding the Problem\nn = int(input())\narr = list(map(int, input().split()))\nswaps = input()\n\n# Implementing the Solution\nif check_sorting_feasibility(n, arr, swaps):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def calculate_waiting_time(seat):\n    row = int(seat[:-1])\n    seat_type = seat[-1]\n\n    # Calculate the base time for the row\n    base_time = (row - 1) * 6\n\n    # Calculate the time for the seat type\n    if seat_type in ['f', 'e', 'd']:\n        base_time += 3\n    elif seat_type in ['c', 'b']:\n        base_time += 2\n\n    # Calculate the time for the flight attendants' movement\n    if row % 2 == 0:\n        base_time += (row // 2) - 1\n    else:\n        base_time += row // 2\n\n    return base_time\n\n# Get the input\nseat = input()\n\n# Calculate and print the waiting time\nprint(calculate_waiting_time(seat))"}
{"solution": "# Function to convert a number from base b to base 10\ndef convert_to_decimal(number, base):\n    decimal = 0\n    for digit in number:\n        decimal = decimal * base + digit\n    return decimal\n\n# Get input\nn, b_x = map(int, input().split())\nx = list(map(int, input().split()))\nm, b_y = map(int, input().split())\ny = list(map(int, input().split()))\n\n# Convert numbers to base 10\nx_decimal = convert_to_decimal(x, b_x)\ny_decimal = convert_to_decimal(y, b_y)\n\n# Compare numbers\nif x_decimal < y_decimal:\n    print(\"<\")\nelif x_decimal > y_decimal:\n    print(\">\")\nelse:\n    print(\"=\")"}
{"solution": "def determine_winner(n, a):\n    # Calculate the XOR of all elements in the sequence\n    xor_result = 0\n    for num in a:\n        xor_result ^= num\n\n    # If the XOR result is 0, BitAryo wins; otherwise, BitLGM wins\n    if xor_result == 0:\n        return \"BitAryo\"\n    else:\n        return \"BitLGM\"\n\n# Read the input\nn = int(input())\na = list(map(int, input().split()))\n\n# Determine and print the winner\nwinner = determine_winner(n, a)\nprint(winner)"}
{"solution": "import math\n\ndef valid_decks(n, k, deck):\n    # Calculate prefix and suffix products\n    prefix_prod = [1] * (n + 1)\n    suffix_prod = [1] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_prod[i] = prefix_prod[i - 1] * deck[i - 1] % k\n        suffix_prod[n - i] = suffix_prod[n - i + 1] * deck[n - i] % k\n\n    # Calculate the number of valid decks\n    count = 0\n    for i in range(n):\n        if prefix_prod[i] * suffix_prod[i + 1] % k == 0:\n            count += 1\n    return count\n\n# Read input\nn, k = map(int, input().split())\ndeck = list(map(int, input().split()))\n\n# Print the result\nprint(valid_decks(n, k, deck))"}
{"solution": "# Read input\nn, k = map(int, input().split())\ns = input()\n\n# Count the occurrence of each color\ncolor_count = {}\nfor color in s:\n    if color in color_count:\n        color_count[color] += 1\n    else:\n        color_count[color] = 1\n\n# Check if it's possible to distribute the balloons\nfor count in color_count.values():\n    if count > k:\n        print(\"NO\")\n        exit()\n\n# If no friend will be upset, print \"YES\"\nprint(\"YES\")"}
{"solution": "# Read the size of the array\nn = int(input())\n\n# Read the elements of the array\narr = list(map(int, input().split()))\n\n# Initialize variables to store the minimum value and its indices\nmin_val = float('inf')\nmin_indices = []\n\n# Iterate through the array to find the minimum value and its indices\nfor i in range(n):\n    if arr[i] < min_val:\n        min_val = arr[i]\n        min_indices = [i]\n    elif arr[i] == min_val:\n        min_indices.append(i)\n\n# Initialize the minimum distance between two minimum values\nmin_distance = float('inf')\n\n# Iterate through the indices of the minimum values to find the minimum distance\nfor i in range(1, len(min_indices)):\n    min_distance = min(min_distance, min_indices[i] - min_indices[i - 1])\n\n# Print the minimum distance\nprint(min_distance)"}
{"solution": "def gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\nt, w, b = map(int, input().split())\nlcm_wb = lcm(w, b)\nnum_multiples = t // lcm_wb\ndenominator = t\n\nfrom math import gcd\ngcd_val = gcd(num_multiples, denominator)\nnum_multiples //= gcd_val\ndenominator //= gcd_val\n\nprint(f\"{num_multiples}/{denominator}\")"}
{"solution": "# Get the input values\nx, y, z = map(int, input().split())\n\n# Calculate the difference between upvotes and downvotes\ndiff = x - y\n\n# Check if the result is uncertain\nif diff > 0 and z >= diff:\n    print(\"?\")\nelif diff < 0 and z >= -diff:\n    print(\"?\")\n# If the result is not uncertain, print the result\nelif diff > 0:\n    print(\"+\")\nelif diff < 0:\n    print(\"-\")\nelse:\n    print(\"0\")"}
{"solution": "def min_changes(n, operations, x, y):\n    pos = [0, 0]\n    for op in operations:\n        if op == 'U':\n            pos[1] += 1\n        elif op == 'D':\n            pos[1] -= 1\n        elif op == 'R':\n            pos[0] += 1\n        elif op == 'L':\n            pos[0] -= 1\n\n    if pos != [x, y]:\n        return -1\n\n    min_len = n + 1\n    target = [x, y]\n    for i in range(n):\n        curr_pos = [0, 0]\n        for j in range(i, n):\n            if operations[j] == 'U':\n                curr_pos[1] += 1\n            elif operations[j] == 'D':\n                curr_pos[1] -= 1\n            elif operations[j] == 'R':\n                curr_pos[0] += 1\n            elif operations[j] == 'L':\n                curr_pos[0] -= 1\n\n            if curr_pos == target:\n                min_len = min(min_len, j - i + 1)\n\n    return min_len if min_len <= n else -1\n\nn = int(input())\noperations = input()\nx, y = map(int, input().split())\n\nprint(min_changes(n, operations, x, y))"}
{"solution": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    T = int(data[0])\n    index = 1\n\n    results = []\n\n    for _ in range(T):\n        n = int(data[index])\n        x = int(data[index + 1])\n        s = data[index + 2]\n        index += 3\n\n        balance_s = s.count('0') - s.count('1')\n        prefix_balances = [0] * (n + 1)\n\n        for i in range(n):\n            prefix_balances[i + 1] = prefix_balances[i] + (1 if s[i] == '0' else -1)\n\n        if balance_s == 0:\n            if x in prefix_balances:\n                results.append(-1)\n            else:\n                results.append(0)\n        else:\n            count = 0\n            for b in prefix_balances:\n                if (x - b) % balance_s == 0 and (x - b) // balance_s >= 0:\n                    count += 1\n            results.append(count)\n\n    for result in results:\n        print(result)\n\nsolve()"}
{"solution": "# Read input\nn, k = map(int, input().split())\n\n# Convert n to string\nn_str = str(n)\n\n# Calculate the number of digits to delete\ndelete_count = len(n_str) - k - n_str[k:].find('0')\n\n# Print the result\nprint(delete_count)"}
{"solution": "def calculate_questions(n, m, k, x, y):\n    total_students = n * m\n    cycle_length = 2 * (n - 1) if n > 1 else 1\n    full_cycles = k // total_students\n    remaining_questions = k % total_students\n\n    max_questions = full_cycles\n    min_questions = full_cycles\n    sergei_questions = 0\n\n    if remaining_questions > 0:\n        max_questions += 1\n        if remaining_questions >= (x - 1) * m + y:\n            min_questions += 1\n            sergei_questions += 1\n        if remaining_questions >= (x - 1) * m + y + m * n:\n            sergei_questions += 1\n        if remaining_questions >= total_students - m + y:\n            min_questions += 1\n\n    return max_questions, min_questions, sergei_questions\n\nn, m, k, x, y = map(int, input().split())\nmax_questions, min_questions, sergei_questions = calculate_questions(n, m, k, x, y)\nprint(max_questions, min_questions, sergei_questions)"}
{"solution": "def calculate_beauty(ribbon, n):\n    length = len(ribbon)\n    max_beauty = 0\n    for char in set(ribbon):\n        new_ribbon = char * length\n        changes = sum(c1 != c2 for c1, c2 in zip(ribbon, new_ribbon))\n        if changes <= n:\n            max_beauty = max(max_beauty, length)\n        else:\n            max_beauty = max(max_beauty, length * (n // changes))\n    return max_beauty\n\nn = int(input())\nribbons = [input() for _ in range(3)]\nbeauties = [calculate_beauty(ribbon, n) for ribbon in ribbons]\n\nmax_beauty = max(beauties)\nwinners = [\"Kuro\", \"Shiro\", \"Katie\"]\nif beauties.count(max_beauty) > 1:\n    print(\"Draw\")\nelse:\n    print(winners[beauties.index(max_beauty)])"}
{"solution": "def calculate_days(c, v_0, v_1, a, l):\n    days = 0\n    total_pages_read = 0\n    pages_read_today = v_0\n\n    while total_pages_read < c:\n        days += 1\n        total_pages_read += pages_read_today\n\n        # Calculate pages read today considering acceleration and maximum speed\n        pages_read_today = min(v_1, pages_read_today + a)\n\n        # Account for rereading last l pages\n        total_pages_read -= l\n\n    return days\n\n# Read input\nc, v_0, v_1, a, l = map(int, input().split())\n\n# Calculate and print the result\nresult = calculate_days(c, v_0, v_1, a, l)\nprint(result)"}
{"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_primes(n):\n    primes = []\n    while n > 0:\n        for i in range(n, 1, -2):\n            if is_prime(i) and n - i >= 0:\n                primes.append(i)\n                n -= i\n                break\n    return primes\n\nn = int(input())\nprimes = find_primes(n)\nprint(len(primes))\nprint(' '.join(map(str, primes)))"}
{"solution": "# Read input\nn, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\n\n# Count walls in each row and column\nrow_walls = [row.count('*') for row in grid]\ncol_walls = [sum(grid[i][j] == '*' for i in range(n)) for j in range(m)]\n\n# Total number of walls\ntotal_walls = sum(row_walls)\n\n# Check each cell\nfor i in range(n):\n    for j in range(m):\n        # If the sum of walls in row i and column j minus the overlap at (i, j) equals the total number of walls\n        if row_walls[i] + col_walls[j] - (grid[i][j] == '*') == total_walls:\n            print(\"YES\")\n            print(i + 1, j + 1)\n            exit()\n\n# If no such cell exists\nprint(\"NO\")"}
{"solution": "# Get the input\nn, m, a, b = map(int, input().split())\n\n# Calculate the remainder of n divided by m\nremainder = n % m\n\n# If remainder is 0, no action is needed\nif remainder == 0:\n    print(0)\n# If building a box is cheaper than demolishing boxes\nelif a <= b:\n    # Calculate the number of boxes to build\n    boxes_to_build = m - remainder\n    print(boxes_to_build * a)\n# If demolishing a box is cheaper than building boxes\nelse:\n    # Calculate the number of boxes to demolish\n    boxes_to_demolish = remainder\n    # Calculate the cost of demolishing boxes\n    cost_demolish = boxes_to_demolish * b\n    # Calculate the cost of building boxes\n    cost_build = (m - remainder) * a\n    # Print the minimum cost\n    print(min(cost_demolish, cost_build))"}
{"solution": "# Read input\nn = int(input())\nseq = list(map(int, input().split()))\n\n# Separate odd and even numbers\nodd_nums = [num for num in seq if num % 2 != 0]\neven_nums = [num for num in seq if num % 2 == 0]\n\n# Sort odd numbers in descending order\nodd_nums.sort(reverse=True)\n\n# If there are odd numbers, the maximum odd-sum subsequence is the sum of all odd numbers\nif odd_nums:\n    print(sum(odd_nums))\n# If there are no odd numbers, the maximum odd-sum subsequence is the largest even number\nelse:\n    print(max(even_nums))"}
{"solution": "MOD = 10**9 + 7\n\ndef count_playlists(n, T, songs):\n    dp = [[[0] * 4 for _ in range(4)] for _ in range(T + 1)]\n    dp[0][0][0] = 1\n\n    for t in range(1, T + 1):\n        for g1 in range(4):\n            for g2 in range(4):\n                for i in range(n):\n                    if songs[i][0] <= t and songs[i][1] != g1 and songs[i][1] != g2:\n                        dp[t][songs[i][1]][g1] = (dp[t][songs[i][1]][g1] + dp[t - songs[i][0]][g1][g2]) % MOD\n\n    return sum(dp[T][i][j] for i in range(1, 4) for j in range(4)) % MOD\n\ndef main():\n    n, T = map(int, input().split())\n    songs = [list(map(int, input().split())) for _ in range(n)]\n    result = count_playlists(n, T, songs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import math\n\nMOD = 10**9 + 7\n\ndef inverse(n):\n    return pow(n, MOD - 2, MOD)\n\ndef expected_length(m):\n    phi = [i for i in range(m + 1)]\n    for i in range(2, m + 1):\n        if phi[i] == i:\n            for j in range(i, m + 1, i):\n                phi[j] -= phi[j] // i\n\n    dp = [0] * (m + 1)\n    dp[1] = 1\n    for i in range(2, m + 1):\n        for j in range(i, m + 1, i):\n            dp[j] = (dp[j] + dp[j // i] * phi[i]) % MOD\n\n    inv = [0] * (m + 1)\n    inv[1] = 1\n    for i in range(2, m + 1):\n        inv[i] = (-inv[MOD % i] * (MOD // i) % MOD) % MOD\n\n    ans = 0\n    for i in range(1, m + 1):\n        ans = (ans + dp[i] * inv[i]) % MOD\n\n    return ans\n\nm = int(input())\nprint(expected_length(m))"}
{"solution": "import math\n\ndef count_good_pairs(l, r, x, y):\n    # Check if x and y are a valid pair\n    if x * y != math.gcd(x, y) * math.lcm(x, y):\n        return 0\n\n    # Count the number of good pairs\n    count = 0\n    for a in range(l, r + 1):\n        for b in range(l, r + 1):\n            if math.gcd(a, b) == x and math.lcm(a, b) == y:\n                count += 1\n\n    return count\n\n# Read input\nl, r, x, y = map(int, input().split())\n\n# Print output\nprint(count_good_pairs(l, r, x, y))"}
{"solution": "import math\n\ndef smallest_k(a, b):\n    # Calculate the greatest common divisor (GCD) of a and b\n    gcd = math.gcd(a, b)\n\n    # Calculate the least common multiple (LCM) of a and b\n    lcm = a * b // gcd\n\n    # Initialize the smallest possible k\n    k = 0\n\n    # Iterate through all possible values of k\n    while True:\n        # Calculate the new LCM of a+k and b+k\n        new_lcm = (a + k) * (b + k) // math.gcd(a + k, b + k)\n\n        # If the new LCM is smaller than the current LCM, update k\n        if new_lcm < lcm:\n            lcm = new_lcm\n        # If the new LCM is greater than or equal to the current LCM, we've found the smallest possible k\n        else:\n            break\n\n        # Increment k\n        k += 1\n\n    # Return the smallest possible k\n    return k\n\n# Read the input values of a and b\na, b = map(int, input().split())\n\n# Print the smallest possible k\nprint(smallest_k(a, b))"}
{"solution": "# Get the input\nn, k = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Calculate the current average\ncurrent_avg = sum(marks) / n\n\n# Calculate the difference between the current average and the desired average\ndiff = k - current_avg\n\n# Calculate the number of additional marks needed\n# Round up the difference and multiply by the number of marks\nadditional_marks = (diff * n) // current_avg\nif (additional_marks * current_avg + sum(marks)) // (n + additional_marks) != k:\n    additional_marks += 1\n\n# Print the result\nprint(additional_marks)"}
{"solution": "# Read the input\nn = int(input())\nnumbers = list(map(int, input().split()))\n\n# Initialize the count of positive numbers\npositive_count = 0\n\n# Iterate over the possible values of d\nfor d in range(-1000, 1001):\n    # Skip if d is zero\n    if d == 0:\n        continue\n\n    # Reset the count of positive numbers\n    positive_count = 0\n\n    # Iterate over the numbers in the array\n    for num in numbers:\n        # If the number is positive after division, increment the count\n        if num / d > 0:\n            positive_count += 1\n\n    # If the count of positive numbers is greater than or equal to half of the array size, print d and exit\n    if positive_count >= (n + 1) // 2:\n        print(d)\n        break\n\n# If no such d is found, print 0\nelse:\n    print(0)"}
{"solution": "def count_pairs(n):\n    # Calculate the maximum possible number of nines at the end of the sum\n    max_nines = n // 10\n\n    # Initialize the count of pairs\n    count = 0\n\n    # Iterate through possible pairs\n    for i in range(1, n // 2 + 1):\n        j = n - i\n\n        # Check if the sum of the pair ends with max_nines number of nines\n        if (i + j) % (10 ** (max_nines + 1)) // 10 == int('9' * max_nines):\n            count += 1\n\n    return count\n\n# Read the input\nn = int(input())\n\n# Print the output\nprint(count_pairs(n))"}
{"solution": "def solve(a, b):\n    if a > b:\n        a, b = b, a\n    if a == b:\n        return 0, a, a\n    if a * 2 == b or a * 3 == b:\n        return 1, a, b\n    if a * 2 < b:\n        if (b // a) % 2 == 0:\n            return 2, a, b // 2\n        if (b // a) % 3 == 0:\n            return 2, a, b // 3\n    if a * 3 < b:\n        if (b // a) % 2 == 0:\n            return 1, a * 2, b // 2\n        if (b // a) % 3 == 0:\n            return 1, a * 3, b // 3\n    if (b - a) % 2 == 0:\n        return 1, a, (b - a) // 2\n    if (b - a) % 3 == 0:\n        return 1, a, (b - a) // 3\n    return -1, 0, 0\n\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\n\nm1, a1, b1 = solve(a1, b1)\nm2, a2, b2 = solve(a2, b2)\n\nif m1 == -1 or m2 == -1 or a1 * b1 != a2 * b2:\n    print(-1)\nelse:\n    print(m1 + m2)\n    print(a1, b1)\n    print(a2, b2)"}
{"solution": "def determine_winner(x_p, y_p, x_v, y_v):\n    # Calculate the distance to (0, 0) for both players\n    distance_p = x_p + y_p\n    distance_v = x_v + y_v\n\n    # If Polycarp's distance is less than Vasiliy's distance, Polycarp will win\n    if distance_p < distance_v:\n        return \"Polycarp\"\n    # If Vasiliy's distance is less than Polycarp's distance, Vasiliy will win\n    elif distance_v < distance_p:\n        return \"Vasiliy\"\n    # If both players have the same distance to (0, 0), Polycarp will win\n    else:\n        return \"Polycarp\"\n\n# Get the starting coordinates of both pawns as input\nx_p, y_p, x_v, y_v = map(int, input().split())\n\n# Determine the winner\nwinner = determine_winner(x_p, y_p, x_v, y_v)\n\n# Print the winner\nprint(winner)"}
{"solution": "# Get the input\nm, d = map(int, input().split())\n\n# Define the number of days in each month\ndays_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n# Calculate the number of days that fit into the first partial week\nfirst_week_days = 7 - d + 1\n\n# Calculate the number of full weeks\nfull_weeks = (days_in_month[m - 1] - first_week_days) // 7\n\n# Calculate the number of days in the last partial week\nlast_week_days = (days_in_month[m - 1] - first_week_days) % 7\n\n# Calculate the total number of columns needed\nif last_week_days > 0:\n    total_columns = full_weeks + 2\nelse:\n    total_columns = full_weeks + 1\n\n# Print the result\nprint(total_columns)"}
{"solution": "def count_years(a, b, zeros=0, prev='1'):\n    if a > b:\n        return 0\n    if a == b:\n        return 1 if zeros == 1 else 0\n    if a == 0:\n        return count_years(1, b, zeros, '0')\n    power = 1\n    while power <= a:\n        power <<= 1\n    power >>= 1\n    if zeros > 1:\n        return 0\n    if a == power:\n        return count_years(a + 1, b, zeros, prev)\n    if zeros == 1 and prev == '0':\n        return min(b, a + power - 1) - a + 1 + count_years(a + power, b, zeros, prev)\n    return count_years(a + power, b, zeros, prev) + count_years(a + power // 2, min(b, a + power - 1), zeros + (prev == '0'), '0')\n\na, b = map(int, input().split())\nprint(count_years(a, b))"}
{"solution": "def minimal_layers(N):\n    return (N * (N + 1)) // 2\n\n# Get input from user\nN = int(input())\n\n# Print the minimal number of layers\nprint(minimal_layers(N))"}
{"solution": "import sys\nfrom math import factorial\n\ndef solve(n, k, S, cubes):\n    dp = [[0] * (S + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(S + 1):\n            dp[i][j] = dp[i - 1][j]\n            if cubes[i - 1] <= j:\n                dp[i][j] += dp[i - 1][j - cubes[i - 1]]\n            if k > 0 and cubes[i - 1] <= 20 and factorial(cubes[i - 1]) <= j:\n                dp[i][j] += dp[i - 1][j - factorial(cubes[i - 1])]\n\n    return dp[n][S]\n\ndef main():\n    n, k, S = map(int, sys.stdin.readline().split())\n    cubes = list(map(int, sys.stdin.readline().split()))\n    print(solve(n, k, S, cubes))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def can_transform(n, k, a):\n    # Create a set to store the possible values that can be obtained at each step\n    possible_values = set([0])\n\n    # Iterate over the elements in the array a\n    for i in range(n):\n        # Create a new set to store the possible values that can be obtained after the current step\n        new_possible_values = set()\n\n        # Iterate over the possible values that can be obtained before the current step\n        for value in possible_values:\n            # Add the current value to the new set of possible values\n            new_possible_values.add(value)\n\n            # If the current value is less than or equal to a[i], add the value obtained by increasing it by k^i to the new set of possible values\n            if value <= a[i]:\n                new_possible_values.add(value + k**i)\n\n        # Update the set of possible values\n        possible_values = new_possible_values\n\n    # Check if the final value a[n-1] can be obtained\n    return a[n-1] in possible_values\n\n# Read the number of test cases\nT = int(input())\n\n# Iterate over the test cases\nfor _ in range(T):\n    # Read the size of the array and the value of k\n    n, k = map(int, input().split())\n\n    # Read the array a\n    a = list(map(int, input().split()))\n\n    # Check if the array v can be transformed into the array a\n    if can_transform(n, k, a):\n        print('YES')\n    else:\n        print('NO')"}
{"solution": "def divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count\n\ndef solve(a, b, c):\n    mod = 1073741824\n    total = 0\n    for i in range(1, a + 1):\n        for j in range(1, b + 1):\n            for k in range(1, c + 1):\n                total = (total + divisors(i * j * k)) % mod\n    return total\n\na, b, c = map(int, input().split())\nprint(solve(a, b, c))"}
{"solution": "from collections import deque\n\ndef get_neighbors(state):\n    neighbors = []\n    idx = state.index('X')\n    if idx == 0:\n        neighbors.append(swap(state, 0, 1))\n        neighbors.append(swap(state, 0, 2))\n    elif idx == 1:\n        neighbors.append(swap(state, 1, 0))\n        neighbors.append(swap(state, 1, 3))\n    elif idx == 2:\n        neighbors.append(swap(state, 2, 0))\n        neighbors.append(swap(state, 2, 3))\n    elif idx == 3:\n        neighbors.append(swap(state, 3, 1))\n        neighbors.append(swap(state, 3, 2))\n    return neighbors\n\ndef swap(state, i, j):\n    state = list(state)\n    state[i], state[j] = state[j], state[i]\n    return ''.join(state)\n\ndef bfs(start):\n    queue = deque([start])\n    visited = set([start])\n    while queue:\n        current = queue.popleft()\n        for neighbor in get_neighbors(current):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    return visited\n\ndef can_be_same_configuration(bessie, elsie):\n    bessie_start = ''.join(bessie)\n    elsie_start = ''.join(elsie)\n\n    bessie_reachable = bfs(bessie_start)\n    elsie_reachable = bfs(elsie_start)\n\n    return not bessie_reachable.isdisjoint(elsie_reachable)\n\n# Input reading\nbessie = [input().strip() for _ in range(2)]\nelsie = [input().strip() for _ in range(2)]\n\nif can_be_same_configuration(bessie, elsie):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def convert_to_decimal(n, k):\n    decimal = 0\n    power = 0\n    while k > 0:\n        decimal += (k % 10) * (n ** power)\n        k //= 10\n        power += 1\n    return decimal\n\ndef binary_search(n, k):\n    left = 0\n    right = 10 ** 18\n    while left < right:\n        mid = (left + right) // 2\n        if convert_to_decimal(n, mid) < k:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\nn = int(input())\nk = int(input())\nprint(binary_search(n, k))"}
{"solution": "# Read the number of elements in the array\nn = int(input())\n\n# Read the elements of the array\narr = list(map(int, input().split()))\n\n# Initialize variables to track the state of the array\nincreasing = True\ndecreasing = False\n\n# Iterate through the array\nfor i in range(1, n):\n    # If the array is still increasing\n    if increasing:\n        # If the current element is less than the previous one\n        if arr[i] < arr[i - 1]:\n            # The array is no longer increasing\n            increasing = False\n            # The array is now decreasing\n            decreasing = True\n        # If the current element is equal to the previous one\n        elif arr[i] == arr[i - 1]:\n            # The array is still increasing\n            increasing = True\n            # The array is not decreasing\n            decreasing = False\n        # If the current element is greater than the previous one\n        else:\n            # The array is still increasing\n            increasing = True\n            # The array is not decreasing\n            decreasing = False\n    # If the array is decreasing\n    elif decreasing:\n        # If the current element is greater than or equal to the previous one\n        if arr[i] >= arr[i - 1]:\n            # The array is not unimodal\n            print(\"NO\")\n            # Exit the program\n            exit()\n\n# If the array is unimodal\nprint(\"YES\")"}
{"solution": "def count_paths(n, k, value):\n    count = 0\n    i = value\n    while i <= n:\n        count += 1\n        if i % 2 == 0:\n            i //= 2\n        else:\n            i = i * 2 + 1\n        if i == value:\n            break\n    return count\n\ndef binary_search(n, k):\n    low, high = 1, n\n    while low < high:\n        mid = (low + high + 1) // 2\n        if count_paths(n, k, mid) >= k:\n            low = mid\n        else:\n            high = mid - 1\n    return low\n\nn, k = map(int, input().split())\nprint(binary_search(n, k))"}
{"solution": "def simulate_ball_movement(n, m, x, y, vx, vy):\n    # Check if the ball is already in a pocket\n    if (x == 0 and y == 0) or (x == 0 and y == m) or (x == n and y == 0) or (x == n and y == m):\n        return (x, y)\n\n    # Simulate the ball's movement\n    while True:\n        # Calculate the next position of the ball\n        if vx == 0:\n            # Move vertically\n            if vy > 0:\n                y = m\n            else:\n                y = 0\n        elif vy == 0:\n            # Move horizontally\n            if vx > 0:\n                x = n\n            else:\n                x = 0\n        else:\n            # Move diagonally\n            if vx > 0:\n                if vy > 0:\n                    # Move to the top-right corner\n                    dx = n - x\n                    dy = m - y\n                else:\n                    # Move to the bottom-right corner\n                    dx = n - x\n                    dy = y\n            else:\n                if vy > 0:\n                    # Move to the top-left corner\n                    dx = x\n                    dy = m - y\n                else:\n                    # Move to the bottom-left corner\n                    dx = x\n                    dy = y\n\n            # Calculate the time it takes for the ball to reach the corner\n            t = min(dx / abs(vx), dy / abs(vy))\n\n            # Update the ball's position\n            x += vx * t\n            y += vy * t\n\n        # Check if the ball has fallen into a pocket\n        if (x == 0 and y == 0) or (x == 0 and y == m) or (x == n and y == 0) or (x == n and y == m):\n            return (x, y)\n\n    # If the ball has not fallen into a pocket, return -1\n    return -1\n\n# Read the input\nn, m, x, y, vx, vy = map(int, input().split())\n\n# Simulate the ball's movement\nresult = simulate_ball_movement(n, m, x, y, vx, vy)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(*result)"}
{"solution": "def can_place_paintings(a1, b1, a2, b2, a3, b3):\n    def fits(w1, h1, w2, h2, W, H):\n        return (w1 + w2 <= W and max(h1, h2) <= H) or (h1 + h2 <= H and max(w1, w2) <= W)\n\n    if (fits(a2, b2, a3, b3, a1, b1) or fits(b2, a2, a3, b3, a1, b1) or\n        fits(a2, b2, b3, a3, a1, b1) or fits(b2, a2, b3, a3, a1, b1) or\n        fits(a3, b3, a2, b2, a1, b1) or fits(b3, a3, a2, b2, a1, b1) or\n        fits(a3, b3, b2, a2, a1, b1) or fits(b3, a3, b2, a2, a1, b1)):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\na3, b3 = map(int, input().split())\n\n# Print output\nprint(can_place_paintings(a1, b1, a2, b2, a3, b3))"}
{"solution": "def solve(b1, q, l, m, bad_nums):\n    if b1 == 0 and q == 0:\n        return 0 if b1 in bad_nums else 1\n    if b1 == 0 or q == 1:\n        return \"inf\" if abs(b1) <= l and b1 not in bad_nums else 0\n    if abs(b1) > l or b1 in bad_nums:\n        return 0\n    count = 1\n    while True:\n        b1 *= q\n        if abs(b1) > l or b1 in bad_nums:\n            break\n        count += 1\n    return count if q != -1 else \"inf\" if count % 2 == 1 else count // 2\n\nb1, q, l, m = map(int, input().split())\nbad_nums = set(map(int, input().split()))\nprint(solve(b1, q, l, m, bad_nums))"}
{"solution": "def find_frame(screen):\n    n, m = len(screen), len(screen[0])\n    min_size = float('inf')\n    min_frame = None\n\n    for i in range(n):\n        for j in range(m):\n            if screen[i][j] == 'w':\n                size = min(i, j, n - i - 1, m - j - 1)\n                if size < min_size:\n                    min_size = size\n                    min_frame = (i, j, size)\n\n    if min_frame is None:\n        return -1\n\n    i, j, size = min_frame\n    for k in range(j, j + size + 1):\n        screen[i][k] = '+'\n        screen[i + size][k] = '+'\n    for k in range(i, i + size + 1):\n        screen[k][j] = '+'\n        screen[k][j + size] = '+'\n\n    return '\\n'.join(''.join(row) for row in screen)\n\nn, m = map(int, input().split())\nscreen = [input() for _ in range(n)]\nprint(find_frame(screen))"}
{"solution": "def find_solution(n, a, b):\n    for x in range(n // a + 1):\n        for y in range(n // b + 1):\n            if x * a + y * b == n:\n                return x, y\n    return None\n\nn = int(input())\na = int(input())\nb = int(input())\n\nsolution = find_solution(n, a, b)\n\nif solution is None:\n    print('NO')\nelse:\n    print('YES')\n    print(*solution)"}
{"solution": "def number_to_words(s):\n    ones = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n\n    if 0 <= s <= 9:\n        return ones[s]\n    elif 10 <= s <= 19:\n        return teens[s - 10]\n    elif 20 <= s <= 99:\n        if s % 10 == 0:\n            return tens[s // 10]\n        else:\n            return tens[s // 10] + \"-\" + ones[s % 10]\n\n# Get the input\ns = int(input())\n\n# Print the output\nprint(number_to_words(s))"}
{"solution": "# Read the input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Initialize the maximum number of elements that can be erased\nmax_erased = 0\n\n# Iterate over all possible segments to erase\nfor i in range(n):\n    for j in range(i, n):\n        # Check if the segment can be restored\n        if (i == 0 or arr[i - 1] < arr[j] - (j - i)) and (j == n - 1 or arr[j + 1] > arr[i] + (j - i)):\n            # Update the maximum number of elements that can be erased\n            max_erased = max(max_erased, j - i + 1)\n\n# Print the result\nprint(max_erased)"}
{"solution": "# Read the input\nn = int(input())\nproblems = list(map(int, input().split()))\n\n# Calculate the total number of problems\ntotal_problems = sum(problems)\n\n# Calculate the half of the total problems\nhalf_problems = total_problems // 2\n\n# Initialize the cumulative sum of problems and the current sum\ncumulative_sum = 0\nday = 0\n\n# Iterate over the problems\nfor i in range(n):\n    # Add the current problem to the cumulative sum\n    cumulative_sum += problems[i]\n\n    # Check if the cumulative sum is greater than or equal to half of the total problems\n    if cumulative_sum >= half_problems:\n        # If it is, print the current day and break the loop\n        day = i + 1\n        break\n\n# Print the result\nprint(day)"}
{"solution": "def min_steps_and_replacements(N, board):\n    # Initialize a 3D dp array to store the minimum number of steps and replacements\n    dp = [[[float('inf')] * 3 for _ in range(N)] for _ in range(N)]\n\n    # Define the possible moves for each piece\n    knight_moves = [(2, 1), (1, 2), (-2, 1), (-1, 2), (2, -1), (1, -2), (-2, -1), (-1, -2)]\n    bishop_moves = [(1, 1), (1, -1), (-1, 1), (-1, -1)]\n    rook_moves = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    # Define a function to check if a move is valid\n    def is_valid_move(x, y):\n        return 0 <= x < N and 0 <= y < N\n\n    # Define a function to perform a depth-first search to find the minimum number of steps and replacements\n    def dfs(x, y, piece):\n        # Base case: if we have reached the last square, return 0 steps and 0 replacements\n        if board[x][y] == N * N:\n            return 0, 0\n\n        # If we have already computed the minimum number of steps and replacements for this square and piece, return it\n        if dp[x][y][piece] != float('inf'):\n            return dp[x][y][piece]\n\n        # Initialize the minimum number of steps and replacements to infinity\n        min_steps = float('inf')\n        min_replacements = float('inf')\n\n        # Get the possible moves for the current piece\n        moves = []\n        if piece == 0:  # knight\n            moves = knight_moves\n        elif piece == 1:  # bishop\n            moves = bishop_moves\n        else:  # rook\n            moves = rook_moves\n\n        # Try each possible move\n        for dx, dy in moves:\n            nx, ny = x + dx, y + dy\n            if is_valid_move(nx, ny):\n                # Recursively compute the minimum number of steps and replacements for the next square\n                steps, replacements = dfs(nx, ny, piece)\n                # Update the minimum number of steps and replacements\n                min_steps = min(min_steps, steps + 1)\n                min_replacements = min(min_replacements, replacements)\n\n        # Try replacing the current piece with each of the other pieces\n        for new_piece in range(3):\n            if new_piece != piece:\n                # Recursively compute the minimum number of steps and replacements for the next square with the new piece\n                steps, replacements = dfs(x, y, new_piece)\n                # Update the minimum number of steps and replacements\n                min_steps = min(min_steps, steps)\n                min_replacements = min(min_replacements, replacements + 1)\n\n        # Store the minimum number of steps and replacements for this square and piece\n        dp[x][y][piece] = (min_steps, min_replacements)\n        return dp[x][y][piece]\n\n    # Find the starting position\n    start_x, start_y = 0, 0\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 1:\n                start_x, start_y = i, j\n                break\n\n    # Perform a depth-first search to find the minimum number of steps and replacements\n    min_steps, min_replacements = dfs(start_x, start_y, 0)\n\n    return min_steps, min_replacements\n\n# Read the input\nN = int(input())\nboard = []\nfor _ in range(N):\n    row = list(map(int, input().split()))\n    board.append(row)\n\n# Find the minimum number of steps and replacements\nmin_steps, min_replacements = min_steps_and_replacements(N, board)\n\n# Print the output\nprint(min_steps, min_replacements)"}
{"solution": "def min_time(n, m, k, a, b):\n    # Calculate the apartment, floor, and entrance for Edward and Natasha\n    a_entrance = (a - 1) // (m * k) + 1\n    a_floor = ((a - 1) % (m * k)) // k + 1\n    b_entrance = (b - 1) // (m * k) + 1\n    b_floor = ((b - 1) % (m * k)) // k + 1\n\n    # Calculate the time to move between entrances\n    entrance_diff = min(abs(a_entrance - b_entrance), n - abs(a_entrance - b_entrance))\n    entrance_time = entrance_diff * 15\n\n    # Calculate the time to move between floors\n    floor_diff = abs(a_floor - b_floor)\n    floor_time = floor_diff * 5\n\n    # Calculate the time to use the elevator\n    elevator_time = 10 + min(a_floor, b_floor) - 1\n\n    # Return the minimum time\n    return min(entrance_time + floor_time, entrance_time + elevator_time, entrance_time + 2 * (m - 1) + 10)\n\n# Read the input\nn, m, k = map(int, input().split())\na, b = map(int, input().split())\n\n# Print the output\nprint(min_time(n, m, k, a, b))"}
{"solution": "def is_divisible_by_64(binary_string):\n    # Count the number of zeros in the binary string\n    zero_count = binary_string.count('0')\n\n    # If there are less than 6 zeros, it's not possible to form a number divisible by 64\n    if zero_count < 6:\n        return False\n\n    # Count the number of ones in the binary string\n    one_count = binary_string.count('1')\n\n    # If there are no ones, it's not possible to form a number divisible by 64\n    if one_count == 0:\n        return False\n\n    # If there are more than 6 ones, it's not possible to form a number divisible by 64\n    if one_count > 6:\n        return False\n\n    # If there are exactly 6 ones, it's possible to form a number divisible by 64\n    if one_count == 6:\n        return True\n\n    # If there are less than 6 ones, we need to check if there are enough zeros to compensate\n    # A number divisible by 64 in binary ends with at least 6 zeros\n    # So, we check if the last 6 digits of the binary string are zeros\n    return binary_string[-6:] == '0' * 6\n\n# Read the input binary string\nbinary_string = input()\n\n# Check if it's possible to form a number divisible by 64\nif is_divisible_by_64(binary_string):\n    print('yes')\nelse:\n    print('no')"}
{"solution": "def transform_string(s):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    result = []\n    j = 0\n    for i in range(len(s)):\n        if j < 26 and s[i] == alphabet[j]:\n            result.append(s[i])\n            j += 1\n        elif j < 26 and s[i] < alphabet[j]:\n            result.append(alphabet[j])\n            j += 1\n        else:\n            result.append(s[i])\n    if j < 26:\n        return '-1'\n    else:\n        return ''.join(result)\n\ns = input()\nprint(transform_string(s))"}
{"solution": "def calculate_expected_value(n, m, r, k):\n    # Calculate the total number of possible positions for the scoop-net\n    total_positions = (n - r + 1) * (m - r + 1)\n\n    # Calculate the maximum number of fishes that can be caught in a single throw\n    max_fish_caught = min(r * r, k)\n\n    # Calculate the expected value of the number of caught fishes\n    expected_value = (max_fish_caught / total_positions) * k\n\n    return expected_value\n\n# Read the input values\nn, m, r, k = map(int, input().split())\n\n# Calculate and print the maximum possible expected number of caught fishes\nprint(calculate_expected_value(n, m, r, k))"}
{"solution": "def maximize_product(n, arr):\n    # If there is a zero in the array, return the array with all elements as -1 except for the zero\n    if 0 in arr:\n        return [-1 if x != 0 else 0 for x in arr]\n\n    # If there are no negative numbers, return the array with all elements as -x - 1\n    if all(x > 0 for x in arr):\n        return [-x - 1 for x in arr]\n\n    # If there are an odd number of negative numbers, find the smallest number and change it to positive\n    if sum(x < 0 for x in arr) % 2 != 0:\n        min_val = min(arr)\n        arr[arr.index(min_val)] = -min_val - 1\n\n    # Change all numbers to their negative counterparts\n    return [-x - 1 for x in arr]\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Print output\nprint(*maximize_product(n, arr))"}
{"solution": "import math\n\ndef find_kth_divisor(n, k):\n    divisors = []\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    divisors.sort()\n    if k > len(divisors):\n        return -1\n    else:\n        return divisors[k - 1]\n\nn, k = map(int, input().split())\nprint(find_kth_divisor(n, k))"}
{"solution": "from itertools import permutations\n\ndef is_valid(num, cubes):\n    digits = [int(d) for d in str(num)]\n    for cube in cubes:\n        if all(d not in cube for d in digits):\n            return False\n    return True\n\ndef solve(cubes):\n    for num in range(9876, 0, -1):\n        if is_valid(num, cubes):\n            return num\n    return 0\n\nn = int(input())\ncubes = [list(map(int, input().split())) for _ in range(n)]\n\nprint(solve(cubes))"}
{"solution": "def k_rounding(n, k):\n    # Count the number of zeros at the end of n\n    zeros = 0\n    while n % 10 == 0:\n        n //= 10\n        zeros += 1\n\n    # If n already has k or more zeros, return n\n    if zeros >= k:\n        return n * (10 ** zeros)\n\n    # Otherwise, find the smallest multiple of n that has k zeros\n    multiplier = 1\n    while True:\n        temp = n * multiplier\n        if str(temp).endswith('0' * k):\n            return temp\n        multiplier += 1\n\n# Read input\nn, k = map(int, input().split())\n\n# Print output\nprint(k_rounding(n, k))"}
{"solution": "def transform_matrix(n, m, A):\n    operations = []\n    B = [[0] * m for _ in range(n)]\n\n    for i in range(n - 1):\n        for j in range(m - 1):\n            if A[i][j] == 1 and A[i][j + 1] == 1 and A[i + 1][j] == 1 and A[i + 1][j + 1] == 1:\n                operations.append((i + 1, j + 1))\n                B[i][j] = B[i][j + 1] = B[i + 1][j] = B[i + 1][j + 1] = 1\n\n    for i in range(n):\n        for j in range(m):\n            if A[i][j] != B[i][j]:\n                return -1\n\n    return operations\n\n# Input reading\nn, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\n\n# Process the transformation\nresult = transform_matrix(n, m, A)\n\n# Output the result\nif result == -1:\n    print(-1)\nelse:\n    print(len(result))\n    for x, y in result:\n        print(x, y)"}
{"solution": "def calculate_probabilities(r, s, p):\n    # Create a 3D array to store the probabilities\n    dp = [[[0.0 for _ in range(p+1)] for _ in range(s+1)] for _ in range(r+1)]\n\n    # Base case: when there's only one species left\n    for i in range(r+1):\n        for j in range(s+1):\n            for k in range(p+1):\n                if i == r and j == 0 and k == 0:\n                    dp[i][j][k] = 1.0\n                elif i == 0 and j == s and k == 0:\n                    dp[i][j][k] = 1.0\n                elif i == 0 and j == 0 and k == p:\n                    dp[i][j][k] = 1.0\n\n    # Calculate the probabilities using dynamic programming\n    for i in range(r, -1, -1):\n        for j in range(s, -1, -1):\n            for k in range(p, -1, -1):\n                if i == 0 or j == 0 or k == 0:\n                    continue\n\n                total = i * j + i * k + j * k\n                dp[i][j][k] = (i * j * dp[i-1][j][k] + i * k * dp[i-1][j][k-1] + j * k * dp[i][j-1][k]) / total\n\n    # Return the probabilities of each species being the sole survivor\n    return dp[r][s][p], dp[0][s][p], dp[0][0][p]\n\n# Read the input\nr, s, p = map(int, input().split())\n\n# Calculate the probabilities\nrock_prob, scissors_prob, paper_prob = calculate_probabilities(r, s, p)\n\n# Print the output\nprint(rock_prob, scissors_prob, paper_prob)"}
{"solution": "# Get the input\nl_1, r_1, l_2, r_2, k = map(int, input().split())\n\n# Calculate the overlapping time\noverlap = max(0, min(r_1, r_2) - max(l_1, l_2))\n\n# If Sonya prinks during the overlapping time, subtract that minute\nif l_1 <= k <= r_1 and l_2 <= k <= r_2:\n    overlap -= 1\n\n# Print the result\nprint(overlap)"}
{"solution": "import sys\nfrom typing import List\n\nclass SegmentTree:\n    def __init__(self, arr: List[int], default: int, func):\n        self.n = len(arr)\n        self.default = default\n        self.func = func\n        self.tree = [default] * (2 * self.n)\n        self.tree[self.n:self.n + self.n] = arr\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = self.func(self.tree[2 * i], self.tree[2 * i + 1])\n\n    def update(self, index: int, value: int):\n        index += self.n\n        self.tree[index] = value\n        while index > 1:\n            index >>= 1\n            self.tree[index] = self.func(self.tree[2 * index], self.tree[2 * index + 1])\n\n    def query(self, left: int, right: int):\n        result = self.default\n        left += self.n\n        right += self.n\n        while left < right:\n            if left & 1:\n                result = self.func(result, self.tree[left])\n                left += 1\n            if right & 1:\n                right -= 1\n                result = self.func(result, self.tree[right])\n            left >>= 1\n            right >>= 1\n        return result\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    horizontal_lines = []\n    vertical_lines = []\n    for _ in range(n):\n        a, b, c = map(int, sys.stdin.readline().split())\n        horizontal_lines.append((c, a, b))\n    for _ in range(m):\n        d, e, f = map(int, sys.stdin.readline().split())\n        vertical_lines.append((d, e, f))\n    horizontal_lines.sort()\n    vertical_lines.sort()\n\n    max_x = SegmentTree([-10**18] * (2 * m + 1), -10**18, max)\n    min_x = SegmentTree([10**18] * (2 * m + 1), 10**18, min)\n    max_y = SegmentTree([-10**18] * (2 * n + 1), -10**18, max)\n    min_y = SegmentTree([10**18] * (2 * n + 1), 10**18, min)\n\n    for i, (d, e, f) in enumerate(vertical_lines):\n        max_x.update(i * 2, d)\n        max_x.update(i * 2 + 1, d)\n        min_x.update(i * 2, d)\n        min_x.update(i * 2 + 1, d)\n\n    for i, (c, a, b) in enumerate(horizontal_lines):\n        max_y.update(i * 2, c)\n        max_y.update(i * 2 + 1, c)\n        min_y.update(i * 2, c)\n        min_y.update(i * 2 + 1, c)\n\n    prev_x, prev_y = 0, 0\n    area = 0\n    for c, a, b in horizontal_lines:\n        left = 0\n        right = 2 * m\n        while right - left > 1:\n            mid = (left + right) // 2\n            if max_x.query(0, mid) < a:\n                left = mid\n            else:\n                right = mid\n        min_left_x = min_x.query(0, left)\n        max_left_x = max_x.query(0, left)\n        left = 0\n        right = 2 * m\n        while right - left > 1:\n            mid = (left + right) // 2\n            if min_x.query(mid, 2 * m) > b:\n                right = mid\n            else:\n                left = mid\n        min_right_x = min_x.query(right, 2 * m)\n        max_right_x = max_x.query(right, 2 * m)\n        if min_left_x > a or max_right_x < b:\n            print(\"INF\")\n            return\n        area += (max(a, min_left_x) - prev_x) * (c - prev_y)\n        area += (min(b, max_right_x) - max(a, min_left_x)) * (c - prev_y)\n        area += (b - min(b, max_right_x)) * (c - prev_y)\n        prev_x = b\n        prev_y = c\n    print(area)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Get the input\nt, s, x = map(int, input().split())\n\n# Calculate the sequence of barking times\nbark_times = [t + i * s + (i % 2) for i in range((x - t) // s + 1)]\n\n# Check if x is in the sequence\nif x in bark_times:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def find_segments(n, segments):\n    # Sort segments based on their left endpoints\n    segments.sort(key=lambda x: x[0])\n\n    # Initialize stack with the first segment\n    stack = [segments[0]]\n\n    for i in range(1, n):\n        # If the current segment lies within the top segment of the stack, return the indices\n        if segments[i][0] >= stack[-1][0] and segments[i][1] <= stack[-1][1]:\n            return stack[-1][2], segments[i][2]\n\n        # If the current segment does not overlap with the top segment of the stack, push it to the stack\n        if segments[i][0] > stack[-1][1]:\n            stack.append(segments[i])\n\n    # If no answer exists, return -1 -1\n    return -1, -1\n\n# Read input\nn = int(input())\nsegments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r, i+1))\n\n# Find indices\ni, j = find_segments(n, segments)\n\n# Print output\nprint(i, j)"}
{"solution": "# Read the input\nn = int(input())\ns = input()\n\n# Count the occurrences of each nucleotide\ncounts = {'A': 0, 'C': 0, 'G': 0, 'T': 0}\nfor nucleotide in s:\n    if nucleotide != '?':\n        counts[nucleotide] += 1\n\n# Check if it's possible to decode the genome\nif n % 4 != 0 or any(count > n // 4 for count in counts.values()):\n    print(\"===\")\nelse:\n    # Calculate the required number of each nucleotide\n    required = n // 4\n\n    # Replace each unrecognized nucleotide\n    decoded_genome = ''\n    for nucleotide in s:\n        if nucleotide == '?':\n            for key in counts.keys():\n                if counts[key] < required:\n                    decoded_genome += key\n                    counts[key] += 1\n                    break\n        else:\n            decoded_genome += nucleotide\n\n    print(decoded_genome)"}
{"solution": "def check_win(board, player):\n    # Check rows, columns, and diagonals for a win\n    for i in range(4):\n        if all(board[i][j] == player for j in range(4)) or all(board[j][i] == player for j in range(4)):\n            return True\n    if all(board[i][i] == player for i in range(4)) or all(board[i][3-i] == player for i in range(4)):\n        return True\n    return False\n\ndef can_win(board):\n    # Check if Ilya can win in a single turn\n    for i in range(4):\n        for j in range(4):\n            if board[i][j] == '.':\n                board[i][j] = 'x'\n                if check_win(board, 'x'):\n                    return True\n                board[i][j] = '.'\n    return False\n\n# Read the board configuration\nboard = [list(input()) for _ in range(4)]\n\n# Check if Ilya can win in a single turn\nif can_win(board):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def can_balance(arr):\n    total_sum = sum(arr)\n    left_sum = 0\n\n    for i in range(len(arr)):\n        if left_sum == total_sum - left_sum - arr[i]:\n            return True\n        left_sum += arr[i]\n\n    return False\n\ndef find_solution(n, arr):\n    for i in range(n):\n        current_element = arr.pop(i)\n        for j in range(n):\n            arr.insert(j, current_element)\n            if can_balance(arr):\n                return True\n            arr.pop(j)\n\n    return False\n\nn = int(input())\narr = list(map(int, input().split()))\n\nif find_solution(n, arr):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def solve(n, k, a, b):\n    a = [x for x in a if x != 0]\n    b.sort()\n    a.sort()\n\n    if a[-1] <= b[0]:\n        return \"No\"\n\n    i = 0\n    j = 0\n    while i < n - k and j < k:\n        if a[i] < b[j]:\n            i += 1\n        else:\n            a[i] = b[j]\n            j += 1\n            i += 1\n\n    while j < k:\n        a.append(b[j])\n        j += 1\n\n    for i in range(1, n):\n        if a[i] >= a[i - 1]:\n            return \"No\"\n\n    return \"Yes\"\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nprint(solve(n, k, a, b))"}
{"solution": "# Get the input\nx, y, z = map(int, input().split())\na, b, c = map(int, input().split())\n\n# Check if Andrew can eat enough green grapes\nif x > a:\n    print(\"NO\")\nelse:\n    # Subtract the green grapes Andrew will eat from the total\n    a -= x\n    # Check if Dmitry can eat enough non-black grapes\n    if y > a + b:\n        print(\"NO\")\n    else:\n        # Subtract the non-black grapes Dmitry will eat from the total\n        if y <= a:\n            a -= y\n        else:\n            b -= y - a\n            a = 0\n        # Check if Michal can eat enough remaining grapes\n        if z > a + b + c:\n            print(\"NO\")\n        else:\n            print(\"YES\")"}
{"solution": "# Read the input\ntraffic_lights = [list(map(int, input().split())) for _ in range(4)]\n\n# Check for possible accidents\nfor i in range(4):\n    if traffic_lights[i][3] == 1:  # If pedestrian light is green\n        for j in range(4):\n            if traffic_lights[j][:3].count(1) > 0:  # If any car light is green\n                print(\"YES\")\n                exit()\n\n# If no accident is possible\nprint(\"NO\")"}
{"solution": "def get_coordinates(digit):\n    keypad = {\n        '1': (0, 0), '2': (0, 1), '3': (0, 2),\n        '4': (1, 0), '5': (1, 1), '6': (1, 2),\n        '7': (2, 0), '8': (2, 1), '9': (2, 2),\n        '0': (3, 1)\n    }\n    return keypad[digit]\n\ndef get_vectors(number):\n    vectors = []\n    for i in range(len(number) - 1):\n        x1, y1 = get_coordinates(number[i])\n        x2, y2 = get_coordinates(number[i + 1])\n        vectors.append((x2 - x1, y2 - y1))\n    return vectors\n\ndef is_unique_finger_movement(n, number):\n    original_vectors = get_vectors(number)\n    for i in range(10**(n-1), 10**n):\n        candidate = str(i).zfill(n)\n        if candidate != number:\n            if get_vectors(candidate) == original_vectors:\n                return \"NO\"\n    return \"YES\"\n\n# Input reading\nn = int(input())\nnumber = input().strip()\n\n# Output the result\nprint(is_unique_finger_movement(n, number))"}
{"solution": "def max_sold_products(n, f, days):\n    days.sort(key=lambda x: (x[1] - x[0], x[0]), reverse=True)\n    for _ in range(f):\n        days[0] = (days[0][0] * 2, days[0][1])\n    total_sold = 0\n    for k, l in days:\n        total_sold += min(k, l)\n    return total_sold\n\nn, f = map(int, input().split())\ndays = [tuple(map(int, input().split())) for _ in range(n)]\nprint(max_sold_products(n, f, days))"}
{"solution": "def max_messiness(n, k):\n    # The maximum messiness is achieved by swapping the first and last cows,\n    # then the second and second-last cows, and so on.\n    # This creates the maximum number of inversions.\n\n    # Calculate the number of pairs that can be swapped\n    pairs = min(n // 2, k)\n\n    # Calculate the messiness\n    messiness = pairs * (n - pairs)\n\n    return messiness\n\n# Read the input\nn, k = map(int, input().split())\n\n# Print the maximum messiness\nprint(max_messiness(n, k))"}
{"solution": "def min_coins(N, M, K, L):\n    # Calculate the number of coins already in Ivan's collection\n    existing_coins = N - K\n\n    # Calculate the number of coins each friend can gift\n    coins_per_friend = existing_coins // M\n\n    # Calculate the number of new coins required\n    new_coins_required = L - (M - coins_per_friend)\n\n    # Check if it is possible to satisfy all the conditions\n    if new_coins_required > 0:\n        # Calculate the minimum number of coins one friend can gift\n        min_gift = coins_per_friend + 1\n\n        # Check if the minimum number of coins is valid\n        if min_gift * M >= L + K:\n            return min_gift\n        else:\n            return -1\n    else:\n        return coins_per_friend\n\n# Get the input values\nN, M, K, L = map(int, input().split())\n\n# Calculate the minimum number of coins one friend can gift\nresult = min_coins(N, M, K, L)\n\n# Print the result\nprint(result)"}
{"solution": "def min_cells_to_paint(n, m, grid):\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n\n    # Find the bounds of the black cells\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'B':\n                min_row = min(min_row, i)\n                max_row = max(max_row, i)\n                min_col = min(min_col, j)\n                max_col = max(max_col, j)\n\n    # If no black cells are found\n    if min_row == n:\n        return 1\n\n    # Calculate the side length of the square\n    side_length = max(max_row - min_row + 1, max_col - min_col + 1)\n\n    # Check if the square can fit within the grid\n    if side_length > n or side_length > m:\n        return -1\n\n    # Count the number of white cells within the square\n    min_paint = float('inf')\n    for i in range(n - side_length + 1):\n        for j in range(m - side_length + 1):\n            paint_count = 0\n            for x in range(i, i + side_length):\n                for y in range(j, j + side_length):\n                    if grid[x][y] == 'W':\n                        paint_count += 1\n            min_paint = min(min_paint, paint_count)\n\n    return min_paint\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\n\n# Print output\nprint(min_cells_to_paint(n, m, grid))"}
{"solution": "def check_possible_transformation(n, x, y):\n    # Calculate the total number of stones in both sequences\n    total_x = sum(x)\n    total_y = sum(y)\n\n    # If the total number of stones is not equal, return False\n    if total_x != total_y:\n        return False\n\n    # Calculate the difference between the two sequences\n    diff = [y[i] - x[i] for i in range(n)]\n\n    # If the difference is not equal, return False\n    if sum(diff) != 0:\n        return False\n\n    # If the difference is equal and the total number of stones is equal, return True\n    return True\n\n# Read the input\nn = int(input())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\n# Check if the transformation is possible\nif check_possible_transformation(n, x, y):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "# Read the input\nn = int(input())\nangles = list(map(int, input().split()))\n\n# Initialize the total sum of angles, the current sum, and the minimum difference\ntotal_sum = sum(angles)\ncurrent_sum = 0\nmin_diff = total_sum\n\n# Iterate through the angles\nfor angle in angles:\n    # Add the angle to the current sum\n    current_sum += angle\n    # Calculate the difference between the current sum and half of the total sum\n    diff = abs(current_sum - total_sum / 2)\n    # Update the minimum difference if necessary\n    min_diff = min(min_diff, diff)\n\n# Print the minimum difference\nprint(int(min_diff))"}
{"solution": "MOD = 10**9 + 7\n\ndef count_ways(n, m):\n    # Create a 2D array to store the number of ways to pack the presents\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    # Base case: there is only one way to pack presents if there is no present or only one box\n    for i in range(n + 1):\n        dp[i][1] = 1\n\n    # Iterate through each kind of present and each box\n    for i in range(1, n + 1):\n        for j in range(2, m + 1):\n            # Calculate the number of ways to pack the presents considering the given rules\n            dp[i][j] = (dp[i - 1][j - 1] + dp[i][j - 1]) % MOD\n\n    # Return the number of ways to pack the presents for the given number of kinds and boxes\n    return dp[n][m]\n\n# Read the input\nn, m = map(int, input().split())\n\n# Calculate the number of ways to pack the presents\nresult = count_ways(n, m)\n\n# Print the result\nprint(result)"}
{"solution": "def find_pythagorean_triple(n):\n    # Check if n is even, if so, there is no solution\n    if n % 2 == 0:\n        m = n // 2\n        # Check if m is a perfect square\n        if int(m ** 0.5) ** 2 == m:\n            # Calculate k using the Pythagorean theorem\n            k = int((m ** 2 + m ** 2) ** 0.5)\n            return m, k\n    # If n is odd, calculate m and k using the formula\n    else:\n        m = (n * n // 2)\n        k = (m + 1)\n        # Check if m and k form a Pythagorean triple\n        if m ** 2 + k ** 2 == n ** 2:\n            return m, k\n    # If no solution is found, return -1\n    return -1\n\n# Read the input\nn = int(input())\n# Find the Pythagorean triple\nresult = find_pythagorean_triple(n)\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(*result)"}
{"solution": "def are_remainders_distinct(n, k):\n    remainders = set()\n    for i in range(1, k + 1):\n        remainder = n % i\n        if remainder in remainders:\n            return False\n        remainders.add(remainder)\n    return True\n\nn, k = map(int, input().split())\nif are_remainders_distinct(n, k):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "# Fast input/output methods\nimport sys\nread_input = sys.stdin.readline\nwrite_output = sys.stdout.write\n\n# Read input\na = read_input().strip()\nb = read_input().strip()\n\n# Compare lengths\nif len(a) < len(b):\n    write_output(\"<\")\nelif len(a) > len(b):\n    write_output(\">\")\nelse:\n    # Lexicographical comparison\n    if a < b:\n        write_output(\"<\")\n    elif a > b:\n        write_output(\">\")\n    else:\n        write_output(\"=\")"}
{"solution": "MOD = 10**9 + 7\n\ndef count_ways(n, p, colors):\n    # Initialize a 2D dynamic programming array\n    dp = [[0] * 2 for _ in range(n)]\n\n    # Base case: if there is only one piece\n    if n == 1:\n        if colors[0] == -1:\n            return 2\n        else:\n            return 1\n\n    # Iterate through each piece\n    for i in range(n):\n        # If the current piece is already colored\n        if colors[i] != -1:\n            # If it's the first piece\n            if i == 0:\n                dp[i][colors[i]] = 1\n            else:\n                # Calculate the number of ways to place arrows and color the current piece\n                dp[i][colors[i]] = sum(dp[j][1 - colors[i]] for j in range(i))\n        # If the current piece is not colored\n        else:\n            # Calculate the number of ways to place arrows and color the current piece\n            dp[i][0] = sum(dp[j][1] for j in range(i))\n            dp[i][1] = sum(dp[j][0] for j in range(i))\n\n    # Calculate the total number of ways to achieve the desired parity\n    total_ways = sum(dp[i][p] for i in range(n))\n\n    return total_ways % MOD\n\n# Read input\nn, p = map(int, input().split())\ncolors = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = count_ways(n, p, colors)\nprint(result)"}
{"solution": "def min_rubles(n, a, b, c):\n    # Calculate the number of copybooks Alyona needs to buy\n    k = (4 - n % 4) % 4\n\n    # Calculate the cost of buying k copybooks using the most cost-effective packs\n    cost = 0\n    while k > 0:\n        if k >= 3 and c <= 2 * a:\n            cost += c\n            k -= 3\n        elif k >= 2 and b <= 2 * a:\n            cost += b\n            k -= 2\n        else:\n            cost += a\n            k -= 1\n\n    return cost\n\n# Read the input\nn, a, b, c = map(int, input().split())\n\n# Print the minimum amount of rubles Alyona should pay\nprint(min_rubles(n, a, b, c))"}
{"solution": "import sys\n\ndef dfs(node, graph, visited, recursion_stack):\n    visited[node] = True\n    recursion_stack[node] = True\n\n    for neighbor in graph[node]:\n        if not visited[neighbor] and dfs(neighbor, graph, visited, recursion_stack):\n            return True\n        elif recursion_stack[neighbor]:\n            return True\n\n    recursion_stack[node] = False\n    return False\n\ndef is_cyclic(graph):\n    visited = [False] * len(graph)\n    recursion_stack = [False] * len(graph)\n\n    for node in range(len(graph)):\n        if not visited[node] and dfs(node, graph, visited, recursion_stack):\n            return True\n    return False\n\ndef is_possible_to_make_acyclic(n, m, edges):\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u - 1].append(v - 1)\n\n    if not is_cyclic(graph):\n        return True\n\n    for u, v in edges:\n        graph[u - 1].remove(v - 1)\n        if not is_cyclic(graph):\n            return True\n        graph[u - 1].append(v - 1)\n\n    return False\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    edges = [tuple(map(int, sys.stdin.readline().split())) for _ in range(m)]\n\n    if is_possible_to_make_acyclic(n, m, edges):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\n\ndef min_coins(n, m, antennas):\n    # Sort the antennas by their positions\n    antennas.sort()\n\n    # Initialize the minimum coins required to cover all positions\n    min_coins = 0\n\n    # Initialize the current rightmost position covered by an antenna\n    curr_right = 0\n\n    # Iterate over the antennas\n    for i in range(n):\n        # If the current antenna doesn't cover the next position,\n        # increment the scope of the antenna to cover it\n        if antennas[i][0] - antennas[i][1] > curr_right + 1:\n            min_coins += antennas[i][0] - antennas[i][1] - curr_right - 1\n            curr_right = antennas[i][0] + antennas[i][1]\n        else:\n            # Otherwise, update the current rightmost position covered by an antenna\n            curr_right = max(curr_right, antennas[i][0] + antennas[i][1])\n\n        # If all positions are covered, break the loop\n        if curr_right >= m:\n            break\n\n    # If not all positions are covered, increment the scope of the last antenna\n    if curr_right < m:\n        min_coins += m - curr_right\n\n    return min_coins\n\n# Read the input\nn, m = map(int, sys.stdin.readline().split())\nantennas = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]\n\n# Print the minimum amount of coins required\nprint(min_coins(n, m, antennas))"}
{"solution": "def max_weight_subset(W, cnt):\n    # Initialize the dynamic programming table\n    dp = [0] * (W + 1)\n\n    # Iterate over each weight from 1 to 8\n    for weight in range(1, 9):\n        # Iterate over each possible total weight from W to weight\n        for total_weight in range(W, weight - 1, -1):\n            # Iterate over each possible number of items with the current weight\n            for num_items in range(1, min(cnt[weight - 1], total_weight // weight) + 1):\n                # Update the maximum possible weight of a good subset\n                dp[total_weight] = max(dp[total_weight], dp[total_weight - num_items * weight] + num_items * weight)\n\n    # Return the maximum possible weight of a good subset\n    return dp[W]\n\n# Read the input\nW = int(input())\ncnt = list(map(int, input().split()))\n\n# Print the output\nprint(max_weight_subset(W, cnt))"}
{"solution": "def min_cost(n, L, costs):\n    # Initialize a list to store the minimum cost to buy i liters of lemonade\n    dp = [float('inf')] * (L + 1)\n    dp[0] = 0\n\n    # Iterate through each type of bottle\n    for i in range(n):\n        # Iterate through each possible volume of lemonade\n        for j in range(L, 2**i - 1, -1):\n            # Update the minimum cost to buy j liters of lemonade\n            dp[j] = min(dp[j], dp[j - 2**i + 1] + costs[i])\n\n    # Return the minimum cost to buy at least L liters of lemonade\n    return dp[L]\n\n# Read input\nn, L = map(int, input().split())\ncosts = list(map(int, input().split()))\n\n# Print output\nprint(min_cost(n, L, costs))"}
{"solution": "def max_mex(n, a):\n    a.sort()\n    mex = 1\n    for num in a:\n        if num >= mex:\n            mex += 1\n    return mex\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result\nresult = max_mex(n, a)\n\n# Print the result\nprint(result)"}
{"solution": "def is_lucky_ticket(n, digits):\n    total_sum = sum(int(digit) for digit in digits)\n\n    # Try every possible segment sum from 1 to total_sum\n    for segment_sum in range(1, total_sum + 1):\n        if total_sum % segment_sum == 0:\n            current_sum = 0\n            valid_partition = True\n            for digit in digits:\n                current_sum += int(digit)\n                if current_sum > segment_sum:\n                    valid_partition = False\n                    break\n                elif current_sum == segment_sum:\n                    current_sum = 0\n            if valid_partition and current_sum == 0:\n                return \"YES\"\n\n    return \"NO\"\n\n# Read input\nn = int(input())\ndigits = input().strip()\n\n# Print output\nprint(is_lucky_ticket(n, digits))"}
{"solution": "def determine_gender(username):\n    distinct_characters = set(username)\n    if len(distinct_characters) % 2 == 0:\n        return \"CHAT WITH HER!\"\n    else:\n        return \"IGNORE HIM!\"\n\n# Read the input\nusername = input().strip()\n\n# Determine and print the gender\nprint(determine_gender(username))"}
{"solution": "# Read input\nn, k = map(int, input().split())\ntabs = list(map(int, input().split()))\n\n# Initialize maximum difference\nmax_diff = 0\n\n# Iterate over all possible starting points\nfor b in range(1, n + 1):\n    # Initialize counts\n    e, s = 0, 0\n\n    # Iterate over all tabs\n    for i in range(n):\n        # If tab is not closed\n        if (i + 1 - b) % k != 0:\n            # If tab contains information for the test\n            if tabs[i] == 1:\n                e += 1\n            # If tab contains a social network site\n            else:\n                s += 1\n\n    # Update maximum difference\n    max_diff = max(max_diff, abs(e - s))\n\n# Print maximum difference\nprint(max_diff)"}
{"solution": "def min_cost_encoding(n, c0, c1):\n    # Initialize the cost to 0\n    cost = 0\n\n    # Determine the cheaper bit\n    cheaper_bit = '0' if c0 < c1 else '1'\n\n    # Assign the cheaper bit to the first letter\n    encoding = [cheaper_bit]\n\n    # Assign the remaining letters\n    for i in range(1, n):\n        # Convert the current number to binary\n        binary = bin(i)[2:]\n\n        # Pad the binary number with leading zeros\n        binary = binary.zfill(len(encoding))\n\n        # Append the binary number to the encoding\n        encoding.append(binary)\n\n    # Calculate the total cost\n    for bit in ''.join(encoding):\n        cost += c0 if bit == '0' else c1\n\n    return cost\n\n# Read the input\nn, c0, c1 = map(int, input().split())\n\n# Calculate the minimum possible total cost\nmin_cost = min_cost_encoding(n, c0, c1)\n\n# Print the output\nprint(min_cost)"}
{"solution": "def will_meet(n, a, x, b, y):\n    while a != x and b != y:\n        if a == b:\n            return \"YES\"\n        a = a + 1 if a < n else 1\n        b = b - 1 if b > 1 else n\n    return \"YES\" if a == b else \"NO\"\n\nn, a, x, b, y = map(int, input().split())\nprint(will_meet(n, a, x, b, y))"}
{"solution": "def generate_unlucky_years(x, y, limit):\n    unlucky_years = set()\n    x_powers = {1}\n    y_powers = {1}\n\n    while max(x_powers) <= limit:\n        x_powers.update({i * x for i in x_powers})\n\n    while max(y_powers) <= limit:\n        y_powers.update({i * y for i in y_powers})\n\n    for x_power in x_powers:\n        for y_power in y_powers:\n            if x_power + y_power <= limit:\n                unlucky_years.add(x_power + y_power)\n\n    return unlucky_years\n\ndef find_max_golden_age(x, y, l, r):\n    unlucky_years = generate_unlucky_years(x, y, r)\n    max_length = 0\n    current_length = 0\n    last_unlucky_year = l - 1\n\n    for year in range(l, r + 1):\n        if year in unlucky_years:\n            max_length = max(max_length, current_length)\n            current_length = 0\n            last_unlucky_year = year\n        else:\n            current_length = year - last_unlucky_year\n\n    max_length = max(max_length, current_length)\n\n    return max_length\n\nx, y, l, r = map(int, input().split())\nprint(find_max_golden_age(x, y, l, r))"}
{"solution": "def min_tax(n):\n    # If n is prime, then the minimum tax is n-1\n    if is_prime(n):\n        return n - 1\n    # Otherwise, split n into two parts: n-1 and 1\n    # This way, the tax for the first part is n-1 and the tax for the second part is 1\n    # The total tax is n-1+1=n, which is the minimum possible\n    else:\n        return n\n\ndef is_prime(n):\n    # Check if n is prime\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += 2\n    return True\n\n# Read the input\nn = int(input())\n# Print the minimum possible number of burles that mr. Funt has to pay as a tax\nprint(min_tax(n))"}
{"solution": "def fix_typos(word):\n    vowels = set('aeiou')\n    n = len(word)\n    result = []\n    i = 0\n\n    while i < n:\n        result.append(word[i])\n        if word[i] not in vowels:\n            start = i\n            while i < n and word[i] not in vowels:\n                i += 1\n            if i - start >= 3:\n                block = word[start:i]\n                if len(set(block)) > 1:\n                    result.append(' ')\n        i += 1\n\n    return ''.join(result)\n\nword = input()\nprint(fix_typos(word))"}
{"solution": "def min_time(n, m, k, x, s, a, b, c, d):\n    min_time = n * x\n\n    # Check all spells of the first type\n    for i in range(m):\n        if b[i] <= s:\n            time_with_spell = n * a[i] + b[i]\n            min_time = min(min_time, time_with_spell)\n\n    # Check all spells of the second type\n    for i in range(k):\n        if d[i] <= s:\n            time_with_spell = (n - c[i]) * x + d[i]\n            min_time = min(min_time, time_with_spell)\n\n    # Check combinations of spells\n    for i in range(m):\n        for j in range(k):\n            if b[i] + d[j] <= s:\n                time_with_spells = min(n, c[j]) * a[i] + d[j]\n                min_time = min(min_time, time_with_spells)\n\n    return min_time\n\n# Read input\nn, m, k = map(int, input().split())\nx, s = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\nd = list(map(int, input().split()))\n\n# Print output\nprint(min_time(n, m, k, x, s, a, b, c, d))"}
{"solution": "def max_points(n, k, M, t):\n    # Sort the subtasks in ascending order of time required to solve\n    t.sort()\n\n    # Initialize the maximum number of points Polycarp can earn\n    max_points = 0\n\n    # Iterate over the number of tasks Polycarp can complete\n    for i in range(min(n, M // sum(t)) + 1):\n        # Calculate the remaining time after completing i tasks\n        remaining_time = M - i * sum(t)\n\n        # Calculate the number of additional subtasks Polycarp can solve\n        additional_subtasks = min(k, remaining_time // t[-1])\n\n        # Update the maximum number of points Polycarp can earn\n        max_points = max(max_points, i * (k + 1) + additional_subtasks)\n\n    return max_points\n\n# Read the input\nn, k, M = map(int, input().split())\nt = list(map(int, input().split()))\n\n# Print the maximum number of points Polycarp can earn\nprint(max_points(n, k, M, t))"}
{"solution": "MOD = 998244353\n\ndef solve(n):\n    # Initialize arrays to store the number of trees and sum of depths\n    trees = [0] * (n + 1)\n    sum_depths = [0] * (n + 1)\n\n    # Base case: 0 vertices\n    trees[0] = 1\n    sum_depths[0] = 0\n\n    # Calculate the number of trees and sum of depths for each number of vertices\n    for i in range(1, n + 1):\n        # Calculate the number of trees\n        trees[i] = (trees[i - 1] * (4 * i - 2)) % MOD\n\n        # Calculate the sum of depths\n        sum_depths[i] = (sum_depths[i - 1] + trees[i - 1] * (2 * i - 1)) % MOD\n\n        # Subtract the invalid trees\n        if i >= 2:\n            trees[i] = (trees[i] - trees[i - 2] * (2 * i - 3)) % MOD\n            sum_depths[i] = (sum_depths[i] - trees[i - 2] * (2 * i - 3)) % MOD\n\n    # Calculate the number of perfectly balanced striped trees\n    result = (trees[n] - sum_depths[n] + MOD) % MOD\n\n    return result\n\n# Read the input\nn = int(input())\n\n# Print the output\nprint(solve(n))"}
{"solution": "def find_position(n, m, k):\n    # Lara moves down first\n    if k < n:\n        return k + 1, 1\n    k -= n\n\n    # Then she moves in a snake fashion\n    # Calculate the number of moves in a single snake cycle\n    cycle_length = (m - 1) * 2\n    # Find the current position in the cycle\n    cycle_position = k % cycle_length\n\n    # If the cycle position is less than m - 1, Lara is moving right\n    if cycle_position < m - 1:\n        return 1, cycle_position + 2\n    # Otherwise, Lara is moving left\n    else:\n        cycle_position -= m - 1\n        return cycle_position // 2 + 2, m - cycle_position % 2\n\nn, m, k = map(int, input().split())\nrow, col = find_position(n, m, k)\nprint(row, col)"}
{"solution": "import math\n\ndef find_min_max_ab(X):\n    factors = []\n    for i in range(1, int(math.sqrt(X)) + 1):\n        if X % i == 0:\n            factors.append(i)\n            if i != X // i:\n                factors.append(X // i)\n    factors.sort()\n    min_max = float('inf')\n    a, b = 0, 0\n    for i in range(len(factors)):\n        for j in range(i, len(factors)):\n            if math.lcm(factors[i], factors[j]) == X and max(factors[i], factors[j]) < min_max:\n                min_max = max(factors[i], factors[j])\n                a, b = factors[i], factors[j]\n    return a, b\n\nX = int(input())\na, b = find_min_max_ab(X)\nprint(a, b)"}
{"solution": "def max_fruits_for_compote(a, b, c):\n    max_sets_lemons = a // 1\n    max_sets_apples = b // 2\n    max_sets_pears = c // 4\n\n    max_complete_sets = min(max_sets_lemons, max_sets_apples, max_sets_pears)\n\n    total_fruits = max_complete_sets * (1 + 2 + 4)\n\n    return total_fruits\n\na = int(input())\nb = int(input())\nc = int(input())\n\nprint(max_fruits_for_compote(a, b, c))"}
{"solution": "def can_divide_teams(n, ratings):\n    ratings.sort()\n    for i in range(n):\n        if ratings[i] >= ratings[i + n]:\n            return \"NO\"\n    return \"YES\"\n\nn = int(input())\nratings = list(map(int, input().split()))\nprint(can_divide_teams(n, ratings))"}
{"solution": "from math import gcd\n\ndef make_coprime(arr):\n    n = len(arr)\n    coprime_arr = [arr[0]]\n    insertions = 0\n\n    for i in range(1, n):\n        if gcd(coprime_arr[-1], arr[i]) != 1:\n            for j in range(2, 10**9 + 1):\n                if gcd(coprime_arr[-1], j) == 1 and gcd(j, arr[i]) == 1:\n                    coprime_arr.append(j)\n                    insertions += 1\n                    break\n        coprime_arr.append(arr[i])\n\n    return insertions, coprime_arr\n\nn = int(input())\narr = list(map(int, input().split()))\n\ninsertions, coprime_arr = make_coprime(arr)\nprint(insertions)\nprint(*coprime_arr)"}
{"solution": "import math\nfrom functools import reduce\nfrom math import gcd\n\ndef compute_gcd_of_list(lst):\n    return reduce(gcd, lst)\n\ndef max_divisor_after_operations(N, K, A):\n    if N == 1:\n        return A[0]\n\n    # Compute the GCD of the differences between all pairs\n    diffs = [abs(A[i] - A[j]) for i in range(N) for j in range(i + 1, N)]\n    initial_gcd = compute_gcd_of_list(diffs)\n\n    # Check all divisors of the initial GCD\n    max_divisor = 1\n    for d in range(1, initial_gcd + 1):\n        if initial_gcd % d == 0:\n            # Check if we can make all elements divisible by d\n            if all((a % d) <= K for a in A):\n                max_divisor = d\n\n    return max_divisor\n\n# Read input\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Compute and print the result\nprint(max_divisor_after_operations(N, K, A))"}
{"solution": "def cat_furrier_transform(x):\n    operations = []\n    n = 0\n    while x != (2**n - 1) and len(operations) < 40:\n        x = x ^ (2**n - 1)\n        operations.append(n)\n        if x != (2**n - 1) and len(operations) < 40:\n            x += 1\n            operations.append(x)\n        n += 1\n    return operations\n\ndef print_operations(operations):\n    print(len(operations))\n    for i in range(0, len(operations), 2):\n        print(operations[i], end=' ')\n    print()\n\nx = int(input())\noperations = cat_furrier_transform(x)\nprint_operations(operations)"}
{"solution": "# Read the input\nn, k = map(int, input().split())\nbuckets = list(map(int, input().split()))\n\n# Initialize the minimum number of hours to a large value\nmin_hours = float('inf')\n\n# Iterate through the buckets\nfor bucket in buckets:\n    # Check if the bucket can water the garden in integer number of hours\n    if k % bucket == 0:\n        # Calculate the number of hours required to water the garden using this bucket\n        hours = k // bucket\n        # Update the minimum number of hours\n        min_hours = min(min_hours, hours)\n\n# Print the minimum number of hours required to water the garden\nprint(min_hours)"}
{"solution": "def can_reach_insect(n, k, line):\n    # Find the positions of the grasshopper and the insect\n    grasshopper_pos = line.index('G')\n    insect_pos = line.index('T')\n\n    # If the grasshopper is to the right of the insect, swap their positions\n    if grasshopper_pos > insect_pos:\n        grasshopper_pos, insect_pos = insect_pos, grasshopper_pos\n\n    # Check if the grasshopper can reach the insect by jumping over obstacles\n    while grasshopper_pos < insect_pos:\n        # Calculate the next possible position of the grasshopper\n        next_pos = grasshopper_pos + k\n\n        # If the next position is beyond the insect, return False\n        if next_pos > insect_pos:\n            return False\n\n        # If the next position contains an obstacle, return False\n        if line[next_pos] == '#':\n            return False\n\n        # Move the grasshopper to the next position\n        grasshopper_pos = next_pos\n\n    # If the grasshopper has reached the insect, return True\n    return True\n\n# Read the input\nn, k = map(int, input().split())\nline = input()\n\n# Check if the grasshopper can reach the insect\nif can_reach_insect(n, k, line):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "import math\n\ndef calculate_intersection_point():\n    # Get the input values\n    y1, y2, yw, xb, yb, r = map(int, input().split())\n\n    # Calculate the slope of the line from the ball to the goal\n    m = (yb - yw) / xb\n\n    # Calculate the y-intercept of the line from the ball to the goal\n    c = yb - m * xb\n\n    # Calculate the distance from the y-axis to the line of the goal\n    d = abs(y1 - y2) / 2\n\n    # Calculate the distance from the y-axis to the line from the ball to the goal\n    h = abs(c)\n\n    # Check if the ball can reach the goal after bouncing off the wall\n    if h > r + d:\n        print(-1)\n        return\n\n    # Calculate the distance from the intersection point to the y-axis\n    a = math.sqrt(abs(r**2 - h**2))\n\n    # Calculate the x-coordinate of the intersection point\n    x = (d + a) / m\n\n    # Print the result\n    print(x)\n\ncalculate_intersection_point()"}
{"solution": "def min_missed_meals(b, d, s):\n    # Calculate the total number of meals\n    total_meals = b + d + s\n\n    # Calculate the minimum number of full days Vasiliy could have stayed\n    full_days = min(b, d, s)\n\n    # Calculate the remaining meals after accounting for full days\n    remaining_meals = total_meals - full_days * 3\n\n    # If Vasiliy left after having a meal, he could not have missed any meals\n    if remaining_meals == 0:\n        return 0\n\n    # If Vasiliy left before having a meal, he could have missed one meal\n    # If Vasiliy arrived after having a meal, he could have missed one meal\n    # If Vasiliy arrived before having a meal and left after having a meal, he could not have missed any meals\n    # Therefore, the minimum number of missed meals is 1\n    return 1\n\n# Get the input\nb, d, s = map(int, input().split())\n\n# Print the output\nprint(min_missed_meals(b, d, s))"}
{"solution": "def find_matrix_dimensions(path):\n    n = len(path)\n    x, y = 1, 1\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    current_position = (1, 1)\n    visited = set()\n\n    for i in range(n):\n        current_value = path[i]\n        visited.add(current_value)\n\n        if i > 0:\n            prev_value = path[i - 1]\n            diff = current_value - prev_value\n\n            if diff == y:\n                current_position = (current_position[0] + 1, current_position[1])\n            elif diff == 1:\n                current_position = (current_position[0], current_position[1] + 1)\n            elif diff == -y:\n                current_position = (current_position[0] - 1, current_position[1])\n            elif diff == -1:\n                current_position = (current_position[0], current_position[1] - 1)\n\n            x = max(x, current_position[0])\n            y = max(y, current_position[1])\n\n        if i < n - 1:\n            next_value = path[i + 1]\n\n            if next_value - current_value == y and current_position[0] < x:\n                continue\n            if next_value - current_value == 1 and current_position[1] < y:\n                continue\n            if next_value - current_value == -y and current_position[0] > 1:\n                continue\n            if next_value - current_value == -1 and current_position[1] > 1:\n                continue\n\n            return \"NO\"\n\n    if len(visited) != x * y:\n        return \"NO\"\n\n    return \"YES\\n\" + str(x) + \" \" + str(y)\n\nn = int(input())\npath = list(map(int, input().split()))\nprint(find_matrix_dimensions(path))"}
{"solution": "def longest_common_subsequence(a, b):\n    m, n = len(a), len(b)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if a[i - 1] == b[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    lcs = []\n    i, j = m, n\n    while i > 0 and j > 0:\n        if a[i - 1] == b[j - 1]:\n            lcs.append(a[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n\n    return ''.join(lcs[::-1])\n\na = input()\nb = input()\nresult = longest_common_subsequence(a, b)\nprint(result if result else '-')"}
{"solution": "def minimal_stones(n, s):\n    current_stones = 0\n    min_stones = 0\n\n    for char in s:\n        if char == '+':\n            current_stones += 1\n        elif char == '-':\n            current_stones -= 1\n        min_stones = min(min_stones, current_stones)\n\n    return max(0, -min_stones)\n\nn = int(input())\ns = input().strip()\nprint(minimal_stones(n, s))"}
{"solution": "def max_kefir_liters(n, a, b, c):\n    # Calculate the maximum number of plastic bottles Kolya can buy\n    max_plastic_bottles = n // a\n\n    # Calculate the maximum number of glass bottles Kolya can buy and return\n    max_glass_bottles = (n // b) * 2\n    remaining_money = n % b\n    if remaining_money >= c:\n        max_glass_bottles += 1\n\n    # Return the maximum number of liters of kefir Kolya can drink\n    return max(max_plastic_bottles, max_glass_bottles)\n\n# Read the input\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# Print the output\nprint(max_kefir_liters(n, a, b, c))"}
{"solution": "def play_game(deck1, deck2):\n    seen_configurations = set()\n    fights = 0\n\n    while deck1 and deck2:\n        configuration = tuple(deck1 + deck2)\n        if configuration in seen_configurations:\n            return -1, 0\n        seen_configurations.add(configuration)\n\n        card1 = deck1.pop(0)\n        card2 = deck2.pop(0)\n\n        if card1 > card2:\n            deck1.append(card2)\n            deck1.append(card1)\n        else:\n            deck2.append(card1)\n            deck2.append(card2)\n\n        fights += 1\n\n    return fights, 1 if deck1 else 2\n\nn = int(input())\nk1 = int(input())\ndeck1 = list(map(int, input().split()))\ndeck2 = list(map(int, input().split()))\n\nresult = play_game(deck1, deck2)\n\nif result[0] == -1:\n    print(-1)\nelse:\n    print(result[0], result[1])"}
{"solution": "def check_password_complexity(password):\n    if len(password) < 5:\n        return 'Too weak'\n\n    has_upper = False\n    has_lower = False\n    has_digit = False\n\n    for char in password:\n        if char.isupper():\n            has_upper = True\n        elif char.islower():\n            has_lower = True\n        elif char.isdigit():\n            has_digit = True\n\n    if has_upper and has_lower and has_digit:\n        return 'Correct'\n    else:\n        return 'Too weak'\n\n# Get user input\npassword = input().strip()\n\n# Print the result of the password complexity check\nprint(check_password_complexity(password))"}
{"solution": "n = int(input())\ngroup_a = list(map(int, input().split()))\ngroup_b = list(map(int, input().split()))\n\n# Count the number of students with each academic performance in both groups\ncount_a = [0] * 6\ncount_b = [0] * 6\n\nfor i in range(n):\n    count_a[group_a[i]] += 1\n    count_b[group_b[i]] += 1\n\n# Calculate the minimum number of exchanges needed\nexchanges = 0\nfor i in range(1, 6):\n    diff = abs(count_a[i] - count_b[i])\n    # If the difference is odd, it's impossible to balance the groups\n    if diff % 2 != 0:\n        print(-1)\n        exit()\n    # Add half of the difference to the total number of exchanges\n    exchanges += diff // 2\n\nprint(exchanges)"}
{"solution": "def dfs(grid, visited, i, j):\n    if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or visited[i][j]:\n        return\n    visited[i][j] = True\n    if i > 0 and grid[i-1][j] == 'v':\n        dfs(grid, visited, i-1, j)\n    if i < len(grid) - 1 and grid[i][j] == '^':\n        dfs(grid, visited, i+1, j)\n    if j > 0 and grid[i][j-1] == '>':\n        dfs(grid, visited, i, j-1)\n    if j < len(grid[0]) - 1 and grid[i][j] == '<':\n        dfs(grid, visited, i, j+1)\n\ndef check_reachability(n, m, horizontal, vertical):\n    grid = [['' for _ in range(m)] for _ in range(n)]\n    for i in range(n-1):\n        grid[i][0] = horizontal[i]\n    for j in range(m-1):\n        grid[0][j] = vertical[j]\n    for i in range(1, n):\n        for j in range(1, m):\n            visited = [[False for _ in range(m)] for _ in range(n)]\n            dfs(grid, visited, i-1, j)\n            dfs(grid, visited, i, j-1)\n            if not all(visited[k][l] for k in range(n) for l in range(m)):\n                return False\n    return True\n\nn, m = map(int, input().split())\nhorizontal = input()\nvertical = input()\nprint('YES' if check_reachability(n, m, horizontal, vertical) else 'NO')"}
{"solution": "def solve_logical_expression(n, a):\n    # Check if it's possible to make the expression false\n    if a[-1] == 1 or all(x == 1 for x in a):\n        return \"NO\"\n\n    # Initialize the expression with the first argument\n    expression = str(a[0])\n\n    # Iterate through the rest of the arguments\n    for i in range(1, n):\n        # If the current argument is 0, place brackets around the previous expression\n        if a[i] == 0:\n            expression = \"(\" + expression + \"->0)\"\n        # If the current argument is 1, append it to the expression with \"->\"\n        else:\n            expression += \"->1\"\n\n    return \"YES\\n\" + expression\n\n# Read the input\nn = int(input())\na = list(map(int, input().split()))\n\n# Print the result\nprint(solve_logical_expression(n, a))"}
{"solution": "def process_values(a, b):\n    while a != 0 and b != 0:\n        if a >= 2 * b:\n            a = a - 2 * b\n        elif b >= 2 * a:\n            b = b - 2 * a\n        else:\n            break\n    return a, b\n\n# Read input values\nn, m = map(int, input().split())\n\n# Process values\nresult_a, result_b = process_values(n, m)\n\n# Print output\nprint(result_a, result_b)"}
{"solution": "def count_k_divisible_numbers(k, a, b):\n    # Calculate the number of k-divisible numbers in the segment [0, b]\n    count_b = b // k\n\n    # Calculate the number of k-divisible numbers in the segment [0, a-1]\n    count_a = (a - 1) // k\n\n    # The number of k-divisible numbers in the segment [a, b] is the difference between the two counts\n    return count_b - count_a\n\n# Read the input\nk, a, b = map(int, input().split())\n\n# Print the result\nprint(count_k_divisible_numbers(k, a, b))"}
{"solution": "def find_kth_digit(k):\n    if k <= 9:\n        return k\n\n    length = 1\n    count = 9\n    start = 1\n\n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n\n    start += (k - 1) // length\n    return int(str(start)[(k - 1) % length])\n\nk = int(input())\nprint(find_kth_digit(k))"}
{"solution": "def can_vasya_win(n, s):\n    # Calculate the number of moves each player will make\n    moves_each = (n - 11) // 2\n\n    # Count the number of '8's in the first n - 10 characters\n    count_8s = s[:n - 10].count('8')\n\n    # Vasya wins if there are more '8's than the number of moves Petya can make\n    if count_8s > moves_each:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Determine if Vasya has a winning strategy\nresult = can_vasya_win(n, s)\nprint(result)"}
{"solution": "MOD = 10**9 + 7\n\ndef count_permutations(n, x, pos):\n    dp = [[[0] * (n + 1) for _ in range(n + 1)] for _ in range(n + 1)]\n    dp[0][0][0] = 1\n\n    for i in range(1, n + 1):\n        for lt in range(i + 1):\n            for l in range(lt + 1):\n                if lt > 0:\n                    dp[i][lt][l] = (dp[i][lt][l] + dp[i - 1][lt - 1][l]) % MOD\n                if lt < i and l < i - 1:\n                    dp[i][lt][l] = (dp[i][lt][l] + dp[i - 1][lt][l]) % MOD\n                if lt < i:\n                    dp[i][lt][l] = (dp[i][lt][l] + dp[i - 1][lt][l - 1]) % MOD\n\n    return dp[n][x - 1][pos]\n\nn, x, pos = map(int, input().split())\nresult = count_permutations(n, x, pos)\nprint(result)"}
{"solution": "def decode_message(s, k):\n    n = len(s)\n    dp = [[False] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            if s[i - 1] == '?':\n                dp[i][j] = dp[i - 2][j]\n            elif s[i - 1] == '*':\n                dp[i][j] = dp[i - 2][j] or (j > 0 and dp[i - 2][j - 1])\n            else:\n                dp[i][j] = j > 0 and dp[i - 1][j - 1]\n\n    if not dp[n][k]:\n        return \"Impossible\"\n\n    result = [''] * k\n    i, j = n, k\n    while i > 0 and j > 0:\n        if s[i - 1] == '?':\n            i -= 2\n        elif s[i - 1] == '*':\n            if j > 0 and dp[i - 2][j - 1]:\n                result[j - 1] = s[i - 2]\n                j -= 1\n            i -= 2\n        else:\n            result[j - 1] = s[i - 1]\n            i -= 1\n            j -= 1\n\n    return ''.join(result)\n\ns = input()\nk = int(input())\nprint(decode_message(s, k))"}
{"solution": "def min_turns(angle):\n    # Normalize the angle to be between 0 and 360\n    angle = angle % 360\n\n    # If the angle is negative, convert it to positive\n    if angle < 0:\n        angle += 360\n\n    # Calculate the minimum number of 90 degree turns needed\n    turns = min(angle // 90, 4 - angle // 90)\n\n    return turns\n\n# Get the input angle\nangle = int(input())\n\n# Print the minimum number of turns\nprint(min_turns(angle))"}
{"solution": "# Get the initial number of spheres\na, b, c = map(int, input().split())\n\n# Get the required number of spheres\nx, y, z = map(int, input().split())\n\n# Calculate the difference in spheres needed\ndiff_blue = x - a\ndiff_violet = y - b\ndiff_orange = z - c\n\n# If the difference is negative, it means we have more spheres than needed\n# In this case, we can use these extra spheres to create new ones of the needed colors\nif diff_blue < 0:\n    if diff_violet < 0:\n        diff_orange += diff_blue\n    elif diff_orange < 0:\n        diff_violet += diff_blue\n    else:\n        # If we can't use the extra blue spheres to create violet or orange spheres,\n        # we can't solve the problem\n        print(\"No\")\n        exit()\n\nif diff_violet < 0:\n    if diff_blue < 0:\n        diff_orange += diff_violet\n    elif diff_orange < 0:\n        diff_blue += diff_violet\n    else:\n        print(\"No\")\n        exit()\n\nif diff_orange < 0:\n    if diff_blue < 0:\n        diff_violet += diff_orange\n    elif diff_violet < 0:\n        diff_blue += diff_orange\n    else:\n        print(\"No\")\n        exit()\n\n# If we can create the required number of spheres using the available ones,\n# we can solve the problem\nif diff_blue % 2 == 0 and diff_violet % 2 == 0 and diff_orange % 2 == 0:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "def solve(n, k, m):\n    # dp[i][j] is the number of valid numbers of length i that end in j\n    dp = [[0] * k for _ in range(n + 1)]\n    # Base case: there is one valid number of length 1 that ends in j\n    for j in range(k):\n        dp[1][j] = 1\n    # Iterate over the length of the number\n    for i in range(2, n + 1):\n        # Iterate over the possible last digits of the number\n        for j in range(k):\n            # Iterate over the possible last digits of the suffix\n            for l in range(k):\n                # If the suffix is a valid suffix, add it to the count\n                if (j - l) % k == 0:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][l]) % m\n    # The answer is the sum of dp[n][j] for all j\n    return sum(dp[n]) % m\n\n# Read the input\nn, k, m = map(int, input().split())\n# Print the answer\nprint(solve(n, k, m))"}
{"solution": "def max_team_size(l, r, a):\n    if l > r:\n        l, r = r, l  # Ensure l is always the smaller or equal group\n\n    # Use ambidexters to balance the difference\n    d = r - l\n    if a >= d:\n        l += d\n        a -= d\n        # Now l == r, distribute remaining ambidexters equally\n        l += a // 2\n        r += a // 2\n    else:\n        l += a\n        # Not enough ambidexters to balance completely, r remains larger\n\n    # The maximum team size is twice the smaller group\n    return 2 * min(l, r)\n\n# Get input\nl, r, a = map(int, input().split())\n\n# Print output\nprint(max_team_size(l, r, a))"}
{"solution": "def min_moves(n, k):\n    # Initialize the number of moves\n    moves = 0\n\n    # Throw stones to the leftmost manhole\n    moves += (k - 1) * 2\n\n    # Open the leftmost manhole and pick the coin\n    moves += 1\n\n    # Throw stones from the leftmost manhole to the rightmost manhole\n    moves += (n - 1) * 2\n\n    # Open the rightmost manhole and pick the coin\n    moves += 1\n\n    # Throw stones from the rightmost manhole to the leftmost manhole,\n    # opening and picking coins along the way\n    moves += (n - 2) * 5\n\n    return moves\n\n# Read the input\nn, k = map(int, input().split())\n\n# Print the minimum number of moves\nprint(min_moves(n, k))"}
{"solution": "def min_tallest_tower(n, m):\n    # Calculate the total number of blocks available\n    total_blocks = 2 * n + 3 * m\n\n    # Initialize the height of the tallest tower\n    tallest_tower = 0\n\n    # Initialize the number of blocks used\n    blocks_used = 0\n\n    # Initialize the height of the current tower\n    current_height = 1\n\n    # While there are still blocks available\n    while blocks_used < total_blocks:\n        # If the current height is available for a two-block piece student\n        if n > 0 and blocks_used + 2 <= total_blocks:\n            # Use two blocks for the current tower\n            blocks_used += 2\n            n -= 1\n        # If the current height is available for a three-block piece student\n        elif m > 0 and blocks_used + 3 <= total_blocks:\n            # Use three blocks for the current tower\n            blocks_used += 3\n            m -= 1\n        # If the current height is not available for any student\n        else:\n            # Move to the next height\n            current_height += 1\n            continue\n\n        # Update the height of the tallest tower\n        tallest_tower = max(tallest_tower, current_height)\n\n        # Move to the next height\n        current_height += 1\n\n    return tallest_tower\n\n# Read the input\nn, m = map(int, input().split())\n\n# Print the output\nprint(min_tallest_tower(n, m))"}
{"solution": "from collections import Counter\n\n# Get the number of cards\nn = int(input())\n\n# Get the numbers on the cards\ncards = [int(input()) for _ in range(n)]\n\n# Count the occurrence of each number\ncounts = Counter(cards)\n\n# Check if it's possible to split the cards evenly\nfor num, count in counts.items():\n    if count > n // 2:\n        print(\"NO\")\n        break\nelse:\n    # Find two numbers that can be chosen by Petya and Vasya\n    petya, vasya = None, None\n    for num, count in counts.items():\n        if count == n // 2:\n            if petya is None:\n                petya = num\n            elif vasya is None:\n                vasya = num\n        if petya is not None and vasya is not None:\n            break\n    if petya is None or vasya is None:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(petya, vasya)"}
{"solution": "def can_seat_army(n, k, soldiers):\n    total_seats = 8 * n\n    soldiers.sort(reverse=True)\n\n    for i in range(0, total_seats, 8):\n        for j in range(k):\n            if soldiers[j] > 0:\n                if i + 1 < total_seats and soldiers[j] > 0:\n                    soldiers[j] -= 1\n                if i + 3 < total_seats and soldiers[j] > 0:\n                    soldiers[j] -= 1\n                if i + 5 < total_seats and soldiers[j] > 0:\n                    soldiers[j] -= 1\n                if i + 7 < total_seats and soldiers[j] > 0:\n                    soldiers[j] -= 1\n\n    return all(soldier == 0 for soldier in soldiers)\n\nn, k = map(int, input().split())\nsoldiers = list(map(int, input().split()))\n\nif can_seat_army(n, k, soldiers):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "# Read the input\nn = int(input())\nsticks = list(map(int, input().split()))\n\n# Initialize the minimum cost and the optimal t\nmin_cost = float('inf')\noptimal_t = 0\n\n# Iterate over all possible values of t\nfor t in range(1, 101):\n    # Calculate the cost for this t\n    cost = 0\n    for stick in sticks:\n        cost += min(abs(stick - t), abs(stick - t - 1), abs(stick - t + 1))\n\n    # Update the minimum cost and the optimal t\n    if cost < min_cost:\n        min_cost = cost\n        optimal_t = t\n\n# Print the result\nprint(optimal_t, min_cost)"}
{"solution": "# Read the dimensions of the star map\nn, m = map(int, input().split())\n\n# Initialize variables to store the coordinates of the top-left and bottom-right corners of the bounding rectangle\ntop_left_x, top_left_y = float('inf'), float('inf')\nbottom_right_x, bottom_right_y = float('-inf'), float('-inf')\n\n# Read the star map and find the bounding rectangle\nfor i in range(n):\n    row = input()\n    for j in range(m):\n        if row[j] == '*':\n            top_left_x = min(top_left_x, j)\n            top_left_y = min(top_left_y, i)\n            bottom_right_x = max(bottom_right_x, j)\n            bottom_right_y = max(bottom_right_y, i)\n\n# Calculate the length and width of the bounding rectangle\nlength = bottom_right_x - top_left_x + 1\nwidth = bottom_right_y - top_left_y + 1\n\n# Find the minimum side length of the square that can cover all the stars\nmin_side_length = max(length, width)\n\n# Print the result\nprint(min_side_length)"}
{"solution": "def factorial(n, mod):\n    fact = 1\n    for i in range(1, n + 1):\n        fact = (fact * i) % mod\n    return fact\n\ndef power(n, p, mod):\n    result = 1\n    while p > 0:\n        if p % 2 == 1:\n            result = (result * n) % mod\n        n = (n * n) % mod\n        p //= 2\n    return result\n\ndef inverse(n, mod):\n    return power(n, mod - 2, mod)\n\ndef ncr(n, r, mod):\n    if r > n:\n        return 0\n    return (factorial(n, mod) * inverse(factorial(r, mod), mod) * inverse(factorial(n - r, mod), mod)) % mod\n\ndef solve(n, k, a):\n    mod = 10**9 + 7\n    ones = a.count(1)\n    zeros = n - ones\n    if k >= ones * zeros:\n        return 0\n    total = 0\n    for i in range(ones + 1):\n        for j in range(zeros + 1):\n            if i * j > k or (i * j - k) % 2 == 1:\n                continue\n            total = (total + ncr(ones, i, mod) * ncr(zeros, j, mod)) % mod\n    return (total * inverse(power(2, k, mod), mod)) % mod\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nprint(solve(n, k, a))"}
{"solution": "def min_seconds(x, y):\n    seconds = 0\n    while x > y:\n        # If x is odd, reduce it to the nearest smaller even number\n        if x % 2 == 1:\n            x -= 1\n        # Divide x by 2 to reduce the number of operations\n        x //= 2\n        seconds += 1\n    return seconds\n\n# Read the input\nx, y = map(int, input().split())\n\n# Print the minimum number of seconds required\nprint(min_seconds(x, y))"}
{"solution": "# Read the input matrix A\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Calculate the determinant of matrix A\ndet_A = a * d - b * c\n\n# If the determinant is already zero, the matrix is already degenerate\nif det_A == 0:\n    print(0)\nelse:\n    # Calculate the scaling factor to make the determinant equal to zero\n    scale = det_A / (a * a + c * c)\n\n    # Calculate the values of matrix B\n    B_a = a - scale * a\n    B_b = b - scale * c\n    B_c = c - scale * a\n    B_d = d - scale * c\n\n    # Calculate the norm ||A - B||\n    norm = max(abs(a - B_a), abs(b - B_b), abs(c - B_c), abs(d - B_d))\n\n    # Print the result\n    print(norm)"}
{"solution": "# Read input\nn, a, b = map(int, input().split())\ngroups = list(map(int, input().split()))\n\n# Initialize tables\none_seaters = a\ntwo_seaters = b\nsingle_in_two_seater = 0\n\n# Initialize denied count\ndenied = 0\n\n# Process each group\nfor group in groups:\n    if group == 1:\n        # Try to seat at one-seater table\n        if one_seaters > 0:\n            one_seaters -= 1\n        # Try to seat at vacant two-seater table\n        elif two_seaters > 0:\n            two_seaters -= 1\n            single_in_two_seater += 1\n        # Try to seat at two-seater table with a single person\n        elif single_in_two_seater > 0:\n            single_in_two_seater -= 1\n        # Deny service\n        else:\n            denied += 1\n    else:\n        # Try to seat at two-seater table\n        if two_seaters > 0:\n            two_seaters -= 1\n        # Deny service\n        else:\n            denied += 2\n\n# Print result\nprint(denied)"}
{"solution": "# Get the input values\nA, B, C, N = map(int, input().split())\n\n# Check if the data is valid\nif A + B - C > N or A + C > N or B + C > N or A + B - C < 0 or A + C < 0 or B + C < 0:\n    print(-1)\nelse:\n    # Calculate the number of students who didn't pass the exam\n    not_passed = N - (A + B - C)\n    # Check if at least one student stayed home\n    if not_passed > 0:\n        print(not_passed)\n    else:\n        print(-1)"}
{"solution": "MOD = 10**9 + 7\n\ndef power(base, exponent):\n    result = 1\n    base %= MOD\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % MOD\n        base = (base * base) % MOD\n        exponent //= 2\n    return result\n\ndef solve(x, k):\n    if k == 0:\n        return x\n\n    # Calculate the probability of keeping a dress each month\n    prob_keep = power(2, MOD - 2)\n\n    # Calculate the expected number of dresses after each month\n    expected_dresses = x\n    for _ in range(k):\n        expected_dresses = (expected_dresses * 2 * prob_keep) % MOD\n\n    return int(expected_dresses)\n\n# Read input\nx, k = map(int, input().split())\n\n# Print output\nprint(solve(x, k))"}
{"solution": "MOD = 998244353\n\ndef power(x, y):\n    result = 1\n    while y > 0:\n        if y % 2 == 1:\n            result = (result * x) % MOD\n        x = (x * x) % MOD\n        y = y // 2\n    return result\n\ndef calculate_probability(n, l, r):\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            for k in range(l[i - 1], r[i - 1] + 1):\n                if k >= j:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j]) % MOD\n                else:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][k]) % MOD\n\n    total_ways = power(r[0] - l[0] + 1, n)\n    no_inversion_ways = dp[n][n]\n    probability = (no_inversion_ways * power(total_ways, MOD - 2)) % MOD\n    return probability\n\nn = int(input())\nl = []\nr = []\nfor _ in range(n):\n    li, ri = map(int, input().split())\n    l.append(li)\n    r.append(ri)\n\nprobability = calculate_probability(n, l, r)\nprint(probability)"}
{"solution": "def count_ways(n):\n    # INTJs prefer a systematic approach, so we'll iterate through all possible lengths\n    count = 0\n    for a in range(1, n // 4 + 1):\n        for b in range(a, (n - a) // 3 + 1):\n            # INTJs are logical thinkers, so we'll check if the lengths can form a rectangle but not a square\n            if (n - a - b) % 2 == 0 and a != (n - a - b) // 2:\n                count += 1\n    return count\n\n# INTJs are decisive, so we'll get the input and print the output immediately\nn = int(input())\nprint(count_ways(n))"}
{"solution": "def find_min_kvass(n, s, kegs):\n    # Sort the kegs in ascending order\n    kegs.sort()\n\n    # Initialize the minimum possible volume in the least keg\n    min_volume = 0\n\n    # Initialize the total volume of kvass poured\n    total_poured = 0\n\n    # Iterate through the kegs\n    for i in range(n):\n        # Calculate the maximum possible volume that can be poured from the current keg\n        max_pour = min(s - total_poured, kegs[i])\n\n        # Pour the maximum possible volume from the current keg\n        total_poured += max_pour\n\n        # Update the minimum possible volume in the least keg\n        min_volume = max(min_volume, kegs[i] - max_pour)\n\n        # If the total volume of kvass poured equals the desired amount, return the minimum possible volume in the least keg\n        if total_poured == s:\n            return min_volume\n\n    # If the total volume of kvass poured is less than the desired amount, return -1\n    return -1\n\n# Read the input\nn, s = map(int, input().split())\nkegs = list(map(int, input().split()))\n\n# Find the minimum possible volume in the least keg\nresult = find_min_kvass(n, s, kegs)\n\n# Print the result\nprint(result)"}
{"solution": "def days_to_apple(h1, h2, a, b):\n    # Initialize the caterpillar's height and the number of days\n    height = h1\n    days = 0\n\n    # Loop until the caterpillar reaches the apple or slips below the ground\n    while height < h2 and height >= 0:\n        # Calculate the caterpillar's height at the end of the day\n        height += 8 * a\n        # Calculate the caterpillar's height at the end of the night\n        height -= 12 * b\n        # Increment the number of days\n        days += 1\n\n    # Check if the caterpillar reached the apple\n    if height >= h2:\n        return days\n    else:\n        return -1\n\n# Read the input\nh1, h2 = map(int, input().split())\na, b = map(int, input().split())\n\n# Print the output\nprint(days_to_apple(h1, h2, a, b))"}
{"solution": "# Get input\nC, Hr, Hb, Wr, Wb = map(int, input().split())\n\n# Calculate maximum number of red candies Om Nom can eat\nmax_red_candies = min(C // Wr, C // Wb)\n\n# Calculate maximum number of blue candies Om Nom can eat\nmax_blue_candies = (C - max_red_candies * Wr) // Wb\n\n# Calculate total joy units\ntotal_joy = max_red_candies * Hr + max_blue_candies * Hb\n\n# Print result\nprint(total_joy)"}
{"solution": "# Get the start and end coordinates\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\n\n# Calculate the absolute difference between the coordinates\ndx = abs(x1 - x2)\ndy = abs(y1 - y2)\n\n# The minimal number of steps is the maximum of dx and dy\nmin_steps = max(dx, dy)\n\n# Print the result\nprint(min_steps)"}
{"solution": "n = int(input())\nfractions = input()\n\nstack = []\n\nfor i in range(n):\n    if fractions[i] == 'D':\n        stack.append('D')\n    else:\n        if stack and stack[-1] == 'D':\n            stack.pop()\n\nif stack:\n    print('D')\nelse:\n    print('R')"}
{"solution": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef solve(a, b, x, y):\n    g = gcd(x, y)\n    x //= g\n    y //= g\n    return min(a // x, b // y)\n\na, b, x, y = map(int, input().split())\nprint(solve(a, b, x, y))"}
{"solution": "def factorial_trailing_zeros(n, b):\n    # Initialize the count of trailing zeros\n    count = 0\n\n    # Count the number of times b divides n!\n    i = 5\n    while n // i >= 1:\n        count += n // i\n        i *= 5\n\n    # Count the number of times b divides count!\n    i = b\n    while i % 5 == 0:\n        i //= 5\n        count //= b\n        count += n // i\n\n    return count\n\n# Read the input\nn, b = map(int, input().split())\n\n# Calculate the number of trailing zeros\nresult = factorial_trailing_zeros(n, b)\n\n# Print the result\nprint(result)"}
{"solution": "def frog_jumps(m, a, b):\n    dp = [0] * (m + 1)\n    dp[0] = 1\n    reach = [0] * (m + 1)\n    reach[0] = 0\n    max_reach = 0\n\n    for i in range(1, m + 1):\n        if i - a >= 0:\n            dp[i] += dp[i - a]\n            reach[i] = max(reach[i], reach[i - a] + 1)\n        if i + b <= m:\n            dp[i] -= dp[i + b]\n            reach[i] = max(reach[i], reach[i + b] + 1)\n        max_reach = max(max_reach, reach[i])\n        dp[i] += max_reach\n\n    return sum(dp)\n\nm, a, b = map(int, input().split())\nprint(frog_jumps(m, a, b))"}
{"solution": "# Read the length of the sequence\nn = int(input())\n\n# Read the elements of the sequence\nsequence = list(map(int, input().split()))\n\n# Check if the first and last elements are odd\nif sequence[0] % 2 == 0 or sequence[-1] % 2 == 0:\n    print(\"No\")\nelse:\n    # Count the number of odd elements in the sequence\n    odd_count = sum(1 for num in sequence if num % 2 != 0)\n\n    # Check if the number of odd elements is odd\n    if odd_count % 2 != 0:\n        print(\"Yes\")\n    else:\n        print(\"No\")"}
{"solution": "# Get the coordinates of the two known trees\nx1, y1, x2, y2 = map(int, input().split())\n\n# Check if the two known trees are on the same horizontal or vertical line\nif x1 == x2 or y1 == y2:\n    # Calculate the coordinates of the two remaining trees\n    x3 = x1 if x1 != x2 else x1 + (y2 - y1)\n    y3 = y2 if y1 != y2 else y1 + (x2 - x1)\n    x4 = x2 if x1 != x2 else x2 + (y2 - y1)\n    y4 = y1 if y1 != y2 else y2 + (x2 - x1)\n    # Print the coordinates of the two remaining trees\n    print(x3, y3, x4, y4)\nelse:\n    # Check if the two known trees are on the same diagonal line\n    if abs(x1 - x2) == abs(y1 - y2):\n        # Calculate the coordinates of the two remaining trees\n        x3 = x1 if x1 > x2 else x2\n        y3 = y2 if x1 > x2 else y1\n        x4 = x2 if x1 > x2 else x1\n        y4 = y1 if x1 > x2 else y2\n        # Print the coordinates of the two remaining trees\n        print(x3, y3, x4, y4)\n    else:\n        # If the two known trees are not on the same horizontal, vertical, or diagonal line, there is no solution\n        print(-1)"}
{"solution": "# Read input\nx, y = map(int, input().split())\nn = int(input())\n\n# Initialize the sequence\nf = [0] * (n + 1)\nf[1] = x\nf[2] = y\n\n# Calculate the sequence using the given property\nfor i in range(3, n + 1):\n    f[i] = (f[i - 1] + f[i - 2]) % (10**9 + 7)\n\n# Print the result\nprint(f[n])"}
{"solution": "def split_array(n, arr):\n    subarrays = []\n    start = 0\n    for i in range(n):\n        if arr[i] == 0:\n            if start < i:\n                subarrays.append((start, i))\n            start = i + 1\n        elif i == n - 1:\n            subarrays.append((start, i + 1))\n    return subarrays\n\nn = int(input())\narr = list(map(int, input().split()))\nsubarrays = split_array(n, arr)\n\nif not subarrays:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(len(subarrays))\n    for subarray in subarrays:\n        print(*subarray)"}
{"solution": "# Read the input\nn, m, k = map(int, input().split())\n\n# Initialize the minimum possible score\nmin_score = m\n\n# Calculate the number of times the score doubled\ndoubles = m // k\n\n# Calculate the remaining correct answers after doubling the score\nremaining_correct = m % k\n\n# Subtract the points that were already doubled\nmin_score -= doubles * k\n\n# Add the points that were not doubled\nmin_score += remaining_correct\n\n# Calculate the remainder of the minimum possible score after division by 1000000009\nremainder = min_score % 1000000009\n\n# Print the result\nprint(remainder)"}
{"solution": "def is_divisible_by_eight(n):\n    # Check if the number is divisible by 8\n    return int(n) % 8 == 0\n\ndef find_solution(n):\n    # Convert the number to a list of digits\n    digits = list(n)\n    # Generate all possible subsets of digits\n    for i in range(len(digits)):\n        for j in range(i, len(digits)):\n            # Remove the subset of digits\n            subset = digits[:i] + digits[j+1:]\n            # Convert the subset back to a number\n            number = ''.join(subset)\n            # Check if the number is divisible by 8\n            if is_divisible_by_eight(number):\n                return number\n    # If no solution is found, return None\n    return None\n\n# Read the input\nn = input()\n# Find a solution\nsolution = find_solution(n)\n# Print the output\nif solution is None:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(solution)"}
{"solution": "def find_floor(n, m, memory):\n    # Sort memory by flat number\n    memory.sort(key=lambda x: x[0])\n\n    # Initialize possible number of flats per floor\n    possible_flats = set(range(1, 101))\n\n    # Check each flat in memory\n    for flat, floor in memory:\n        # Calculate possible number of flats per floor\n        possible_flats = set(range(flat, 101, floor))\n\n        # If no possible number of flats, return -1\n        if not possible_flats:\n            return -1\n\n    # Check if n-th flat is possible\n    for flats in possible_flats:\n        if (n - 1) % flats == 0:\n            return (n - 1) // flats + 1\n\n    # If no possible floor, return -1\n    return -1\n\n# Get input\nn, m = map(int, input().split())\nmemory = [list(map(int, input().split())) for _ in range(m)]\n\n# Print output\nprint(find_floor(n, m, memory))"}
{"solution": "def max_bishwocks(board1, board2):\n    n = len(board1)\n    board = [[board1[i], board2[i]] for i in range(n)]\n\n    # Define the four possible shapes of the bishwock\n    bishwock_shapes = [\n        [(0, 0), (0, 1), (1, 0)],  # Original L shape\n        [(0, 0), (0, 1), (1, 1)],  # Rotated 90 degrees\n        [(0, 1), (1, 0), (1, 1)],  # Rotated 180 degrees\n        [(0, 0), (1, 0), (1, 1)]   # Rotated 270 degrees\n    ]\n\n    def can_place_bishwock(x, y, shape):\n        for dx, dy in shape:\n            nx, ny = x + dx, y + dy\n            if nx >= 2 or ny >= n or board[ny][nx] == 'X':\n                return False\n        return True\n\n    def place_bishwock(x, y, shape):\n        for dx, dy in shape:\n            nx, ny = x + dx, y + dy\n            board[ny][nx] = 'X'\n\n    count = 0\n    for y in range(n):\n        for x in range(2):\n            for shape in bishwock_shapes:\n                if can_place_bishwock(x, y, shape):\n                    place_bishwock(x, y, shape)\n                    count += 1\n                    break\n\n    return count\n\n# Example usage\nboard1 = \"00X00X0XXX0\"\nboard2 = \"0XXX0X00X00\"\nmax_bishwocks(board1, board2)"}
{"solution": "def max_pretty_set_length(n, s):\n    max_length = 0\n    current_set = set()\n\n    for char in s:\n        if char.islower():\n            current_set.add(char)\n        else:\n            max_length = max(max_length, len(current_set))\n            current_set.clear()\n\n    # Check the last segment\n    max_length = max(max_length, len(current_set))\n\n    return max_length\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Get the result\nresult = max_pretty_set_length(n, s)\n\n# Print the result\nprint(result)"}
{"solution": "# Read the number of elements in the sequence\nn = int(input())\n\n# Read the elements of the sequence\nsequence = list(map(int, input().split()))\n\n# Initialize the sum of the sequence\ntotal_sum = sum(sequence)\n\n# Initialize the maximum possible value of B - C\nmax_diff = 0\n\n# Iterate through all possible partitions of the sequence\nfor i in range(1 << n):\n    # Initialize the sum of the elements in the current partition\n    partition_sum = 0\n\n    # Iterate through all elements in the sequence\n    for j in range(n):\n        # If the j-th element is included in the current partition\n        if i & (1 << j):\n            # Add the j-th element to the sum of the current partition\n            partition_sum += sequence[j]\n\n    # Calculate the sum of the elements in the other partition\n    other_partition_sum = total_sum - partition_sum\n\n    # Calculate the difference between the sums of the two partitions\n    diff = partition_sum - other_partition_sum\n\n    # Update the maximum possible value of B - C\n    max_diff = max(max_diff, diff)\n\n# Print the maximum possible value of B - C\nprint(max_diff)"}
{"solution": "def min_refuels(a, b, f, k):\n    # Calculate the distance the bus can travel without refueling\n    max_distance = b\n\n    # Calculate the distance the bus can travel in one journey\n    journey_distance = 2 * a\n\n    # Check if the bus can make one journey without refueling\n    if journey_distance > max_distance:\n        return -1\n\n    # Calculate the number of refuels needed for one journey\n    refuels_per_journey = 1 if journey_distance > f else 0\n\n    # Calculate the total number of refuels needed for k journeys\n    total_refuels = refuels_per_journey * k\n\n    return total_refuels\n\n# Get the input\na, b, f, k = map(int, input().split())\n\n# Print the result\nprint(min_refuels(a, b, f, k))"}
{"solution": "def split_string(n, p, q, s):\n    for i in range(n // p):\n        if (n - p * (i + 1)) % q == 0:\n            return [s[j:j+p] for j in range(0, p*i, p)] + [s[p*i:]]\n    return -1\n\nn, p, q = map(int, input().split())\ns = input()\nresult = split_string(n, p, q, s)\n\nif result != -1:\n    print(len(result))\n    for part in result:\n        print(part)\nelse:\n    print(-1)"}
{"solution": "def solve_problem():\n    n, m, s, d = map(int, input().split())\n    obstacles = sorted(map(int, input().split()))\n\n    position = 0\n    for obstacle in obstacles:\n        if obstacle - position < s:\n            print(\"IMPOSSIBLE\")\n            return\n        else:\n            print(f\"RUN {s}\")\n            position += s\n            if obstacle - position > d:\n                print(f\"JUMP {obstacle - position}\")\n                position = obstacle\n            else:\n                print(f\"JUMP {obstacle - position + 1}\")\n                position = obstacle + 1\n\n    if m - position < s:\n        print(\"IMPOSSIBLE\")\n    else:\n        print(f\"RUN {m - position}\")\n\nsolve_problem()"}
{"solution": "s, x = map(int, input().split())\n\n# Check if s - x is even and positive\nif (s - x) % 2 == 0 and s - x > 0:\n    # Calculate b\n    b = (s - x) // 2\n    # Calculate a\n    a = s - b\n    # Check if a and b are positive\n    if a > 0 and b > 0:\n        # Each valid pair can be ordered in two ways\n        print(2)\n    else:\n        print(0)\nelse:\n    print(0)"}
{"solution": "def solve(n, k):\n    actions = []\n    for i in range(1, n + 1, 2 * k + 1):\n        actions.append(i)\n    return actions\n\nn, k = map(int, input().split())\nactions = solve(n, k)\nprint(len(actions))\nprint(' '.join(map(str, actions)))"}
{"solution": "def min_operations_to_square(n):\n    import math\n\n    n_str = str(n)\n    n_len = len(n_str)\n\n    # Generate all possible squares up to the maximum possible value\n    max_square_root = int(math.sqrt(2 * 10**9)) + 1\n    squares = [str(i * i) for i in range(1, max_square_root + 1)]\n\n    def is_subsequence(small, large):\n        it = iter(large)\n        return all(char in it for char in small)\n\n    min_deletions = float('inf')\n\n    for square in squares:\n        if is_subsequence(square, n_str):\n            deletions = n_len - len(square)\n            min_deletions = min(min_deletions, deletions)\n\n    return min_deletions if min_deletions != float('inf') else -1\n\n# Get input from the user\nn = int(input())\n\n# Print the result\nprint(min_operations_to_square(n))"}
{"solution": "import math\n\ndef f(p):\n    g = [0] * len(p)\n    g[0] = p[0]\n    for i in range(1, len(p)):\n        g[i] = math.gcd(g[i-1], p[i])\n    return len(set(g))\n\ndef count_permutations(n):\n    MOD = 10**9 + 7\n    f_max = max(f(p) for p in permutations(range(1, n+1)))\n    count = 0\n    for p in permutations(range(1, n+1)):\n        if f(p) == f_max:\n            count = (count + 1) % MOD\n    return count\n\ndef permutations(arr):\n    if len(arr) == 1:\n        return [arr]\n    perms = []\n    for i in range(len(arr)):\n        m = arr[i]\n        rem_arr = arr[:i] + arr[i+1:]\n        for p in permutations(rem_arr):\n            perms.append([m] + p)\n    return perms\n\nn = int(input())\nresult = count_permutations(n)\nprint(result)"}
{"solution": "def minimum_jump_ability(s):\n    vowels = {'A', 'E', 'I', 'O', 'U', 'Y'}\n    positions = [-1]  # Start position before the first character\n\n    # Collect positions of all vowels\n    for i, char in enumerate(s):\n        if char in vowels:\n            positions.append(i)\n\n    positions.append(len(s))  # End position after the last character\n\n    # Calculate maximum distance between consecutive positions\n    max_distance = 0\n    for i in range(1, len(positions)):\n        max_distance = max(max_distance, positions[i] - positions[i - 1])\n\n    return max_distance\n\n# Read input string\ns = input()\n\n# Print the minimum jump ability\nprint(minimum_jump_ability(s))"}
{"solution": "# Get the input\na1, a2, a3, a4 = map(int, input().split())\n\n# Calculate the total sum of candies\ntotal_sum = a1 + a2 + a3 + a4\n\n# Check if the total sum is odd, if so, it's not possible to distribute equally\nif total_sum % 2 != 0:\n    print(\"NO\")\nelse:\n    # Calculate half of the total sum\n    half_sum = total_sum // 2\n\n    # Check if it's possible to distribute the bags in such a way that each friend receives the same amount of candies\n    if a1 == half_sum or a2 == half_sum or a3 == half_sum or a4 == half_sum:\n        print(\"YES\")\n    elif a1 + a2 == half_sum or a1 + a3 == half_sum or a1 + a4 == half_sum or a2 + a3 == half_sum or a2 + a4 == half_sum or a3 + a4 == half_sum:\n        print(\"YES\")\n    elif a1 + a2 + a3 == half_sum or a1 + a2 + a4 == half_sum or a1 + a3 + a4 == half_sum or a2 + a3 + a4 == half_sum:\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "def pie_distribution(n, pies):\n    dp = [[0, 0] for _ in range(n + 1)]\n\n    for i in range(n - 1, -1, -1):\n        dp[i][0] = max(pies[i] + dp[i + 1][1], pies[i] + dp[i + 2][0])\n        dp[i][1] = max(dp[i + 1][0], dp[i + 2][1])\n\n    return dp[0]\n\nn = int(input())\npies = list(map(int, input().split()))\n\nalice, bob = pie_distribution(n, pies)\nprint(alice, bob)"}
{"solution": "def find_min_variables(n, a):\n    # Initialize the set of variables\n    variables = set()\n\n    # Iterate through the sequence\n    for num in a:\n        # If the number is already in the set of variables, continue to the next number\n        if num in variables:\n            continue\n\n        # Otherwise, find the sums of existing variables that can produce the current number\n        sums = set()\n        for var1 in variables:\n            for var2 in variables:\n                sums.add(var1 + var2)\n\n        # If the current number is not in the set of sums, add a new variable\n        if num not in sums:\n            variables.add(num)\n\n    # Return the minimum number of variables needed\n    return len(variables)\n\n# Read the input\nn = int(input())\na = list(map(int, input().split()))\n\n# Find the minimum number of variables\nresult = find_min_variables(n, a)\n\n# Print the result\nprint(result)"}
{"solution": "def determine_winner(n, piles):\n    odd_count = sum(1 for pile in piles if pile % 2 != 0)\n    if odd_count % 2 == 0:\n        return \"Alice\"\n    else:\n        return \"Bob\"\n\n# Read input\nn = int(input())\npiles = list(map(int, input().split()))\n\n# Determine and print the winner\nprint(determine_winner(n, piles))"}
{"solution": "def can_make_equal(n, arr):\n    arr.sort()\n    diff = [arr[i] - arr[i - 1] for i in range(1, n)]\n    gcd_val = diff[0]\n    for i in range(1, n - 1):\n        gcd_val = gcd(gcd_val, diff[i])\n    if gcd_val == 0:\n        return \"YES\"\n    else:\n        return \"NO\"\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\nn = int(input())\narr = list(map(int, input().split()))\nprint(can_make_equal(n, arr))"}
{"solution": "def longest_repeated_substring(n, s):\n    max_len = 0\n    for length in range(n // 2, 0, -1):\n        for start in range(n - 2 * length + 1):\n            substring = s[start:start + length]\n            if substring in s[start + length:]:\n                return length\n    return 0\n\nn = int(input())\ns = input()\nprint(longest_repeated_substring(n, s))"}
{"solution": "def minimum_time_to_house(n, a):\n    if a % 2 == 1:\n        # a is odd\n        return (a + 1) // 2\n    else:\n        # a is even\n        return (n - a + 2) // 2\n\n# Read input\nn, a = map(int, input().split())\n\n# Calculate and print the result\nprint(minimum_time_to_house(n, a))"}
{"solution": "def check_interval(n, m, colors, desired_counts):\n    # Initialize counters for each color\n    counters = [0] * m\n\n    # Initialize left and right pointers\n    left = 0\n    right = 0\n\n    # Expand and contract the window\n    while right < n:\n        # Add the color to the counters\n        counters[colors[right] - 1] += 1\n\n        # Check if the window meets the required counts\n        if all(counters[i] == desired_counts[i] for i in range(m)):\n            return \"YES\"\n\n        # If the window exceeds the required counts, move the left pointer\n        while left < right and all(counters[i] > desired_counts[i] for i in range(m)):\n            counters[colors[left] - 1] -= 1\n            left += 1\n\n        right += 1\n\n    # If no valid window is found, return \"NO\"\n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\ncolors = list(map(int, input().split()))\ndesired_counts = list(map(int, input().split()))\n\n# Print the result\nprint(check_interval(n, m, colors, desired_counts))"}
{"solution": "def determine_winner(n, rounds):\n    mishka_wins = 0\n    chris_wins = 0\n\n    for round in rounds:\n        m, c = round\n        if m > c:\n            mishka_wins += 1\n        elif c > m:\n            chris_wins += 1\n\n    if mishka_wins > chris_wins:\n        return \"Mishka\"\n    elif chris_wins > mishka_wins:\n        return \"Chris\"\n    else:\n        return \"Friendship is magic!^^\"\n\n# Read input\nn = int(input())\nrounds = []\nfor _ in range(n):\n    m, c = map(int, input().split())\n    rounds.append((m, c))\n\n# Determine winner\nwinner = determine_winner(n, rounds)\nprint(winner)"}
{"solution": "def is_valid(field, i, j):\n    directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n    count = 0\n    for dx, dy in directions:\n        ni, nj = i + dx, j + dy\n        if 0 <= ni < n and 0 <= nj < m and field[ni][nj] == '*':\n            count += 1\n    if field[i][j] == '.':\n        return count == 0\n    else:\n        return count == int(field[i][j])\n\nn, m = map(int, input().split())\nfield = [list(input()) for _ in range(n)]\n\nvalid = True\nfor i in range(n):\n    for j in range(m):\n        if not is_valid(field, i, j):\n            valid = False\n            break\n    if not valid:\n        break\n\nprint(\"YES\" if valid else \"NO\")"}
{"solution": "def can_vasya_eat_half(n, k):\n    total_candies = n\n    vasya_eaten = 0\n\n    while total_candies > 0:\n        # Vasya eats k candies\n        vasya_eaten += min(k, total_candies)\n        total_candies -= min(k, total_candies)\n\n        # Petya eats 10% of the remaining candies\n        petya_eaten = total_candies // 10\n        total_candies -= petya_eaten\n\n    return vasya_eaten >= (n + 1) // 2\n\ndef find_min_k(n):\n    left, right = 1, n\n    while left < right:\n        mid = (left + right) // 2\n        if can_vasya_eat_half(n, mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\n# Read input\nn = int(input().strip())\n\n# Find and print the minimal k\nprint(find_min_k(n))"}
{"solution": "def can_rearrange_necklace(s):\n    p = s.count('o')\n    l = s.count('-')\n\n    if p == 0 or p == 1:\n        return \"YES\"\n    if l % p == 0:\n        return \"YES\"\n    return \"NO\"\n\n# Get user input\ns = input()\n\n# Print the result\nprint(can_rearrange_necklace(s))"}
{"solution": "# Read input\nn, m, k = map(int, input().split())\n\n# Calculate the minimum pillows each hobbit needs\nmin_pillows = m // n\n\n# Calculate the remaining pillows after distributing the minimum pillows to each hobbit\nremaining_pillows = m - min_pillows * n\n\n# Calculate the number of hobbits who will get an extra pillow\nextra_pillows = min(remaining_pillows, k - 1)\n\n# Calculate the number of pillows Frodo can have\nfrodo_pillows = min_pillows + extra_pillows\n\n# Print the result\nprint(frodo_pillows)"}
{"solution": "import sys\nimport math\n\ndef max_subarray_cost(n, m, k, a):\n    prefix_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + a[i - 1]\n\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = max(dp[i - 1], prefix_sum[i] - k * math.ceil(i / m))\n        for j in range(i - 1, 0, -1):\n            dp[i] = max(dp[i], prefix_sum[i] - prefix_sum[j - 1] - k * math.ceil((i - j + 1) / m))\n\n    return max(dp)\n\ndef main():\n    n, m, k = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n\n    result = max_subarray_cost(n, m, k, a)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_longest_polyline(n, m):\n    # INTJs prefer structure and planning, so let's start by defining the grid\n    grid = [(x, y) for x in range(n+1) for y in range(m+1)]\n\n    # INTJs are intuitive, so let's consider the big picture and understand that\n    # the longest polyline will be a rectangle that uses the maximum dimensions\n    # of the grid.\n    if n > m:\n        return [(0, 0), (n, 0), (n, m), (0, m)]\n    else:\n        return [(0, 0), (0, m), (n, m), (n, 0)]\n\n# Read input\nn, m = map(int, input().split())\n\n# Find the longest polyline\npoints = find_longest_polyline(n, m)\n\n# Print the output\nfor point in points:\n    print(*point)"}
{"solution": "from collections import Counter\n\ndef find_smallest_number(shuffled_string, substring):\n    # Count the frequency of each digit in the shuffled string and the substring\n    shuffled_counter = Counter(shuffled_string)\n    substring_counter = Counter(substring)\n\n    # Calculate the excess digits (digits in the shuffled string that are not in the substring)\n    excess_digits = shuffled_counter - substring_counter\n\n    # Initialize the result string with the substring\n    result = substring\n\n    # Iterate through the digits in the shuffled string\n    for digit in shuffled_string:\n        # If the digit is in excess, append it to the result\n        if excess_digits[digit] > 0:\n            result += digit\n            excess_digits[digit] -= 1\n\n    # Remove leading zeros from the result, except for the case of zero itself\n    result = result.lstrip('0')\n    if result == '':\n        result = '0'\n\n    return result\n\n# Read the input\nshuffled_string = input()\nsubstring = input()\n\n# Find and print the smallest possible initial integer\nprint(find_smallest_number(shuffled_string, substring))"}
{"solution": "def check_temperatures(n, m, min_temp, max_temp, temps):\n    # Check if the minimum and maximum temperatures in the given list are within the allowed range\n    if min(temps) < min_temp or max(temps) > max_temp:\n        return 'Incorrect'\n\n    # Check if it's possible to add temperatures to reach the required number of measurements\n    if m < n:\n        # Check if it's possible to add the minimum temperature to reach the required number of measurements\n        if min_temp not in temps and m < n - 1:\n            return 'Incorrect'\n        # Check if it's possible to add the maximum temperature to reach the required number of measurements\n        if max_temp not in temps and m < n - 1:\n            return 'Incorrect'\n\n    return 'Correct'\n\n# Read the input\nn, m, min_temp, max_temp = map(int, input().split())\ntemps = list(map(int, input().split()))\n\n# Print the result\nprint(check_temperatures(n, m, min_temp, max_temp, temps))"}
{"solution": "def count_trailing_zeros(n):\n    count = 0\n    i = 5\n    while n / i >= 1:\n        count += int(n / i)\n        i *= 5\n    return count\n\ndef find_numbers(m):\n    low = 0\n    high = 5 * m\n    while low < high:\n        mid = (low + high) // 2\n        if count_trailing_zeros(mid) < m:\n            low = mid + 1\n        else:\n            high = mid\n    if count_trailing_zeros(low) != m:\n        return 0, []\n    start = low\n    while count_trailing_zeros(start) == m:\n        start -= 1\n    return high - start, list(range(start + 1, high + 1))\n\nm = int(input())\nk, numbers = find_numbers(m)\nprint(k)\nprint(*numbers)"}
{"solution": "import heapq\n\ndef dijkstra(graph, start):\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n\n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node].items():\n            distance = max(current_distance, weight)\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n\n    return distances\n\ndef main():\n    n, m, k = map(int, input().split())\n    special_vertices = list(map(int, input().split()))\n\n    graph = {i: {} for i in range(1, n + 1)}\n\n    for _ in range(m):\n        u, v, w = map(int, input().split())\n        graph[u][v] = graph[v][u] = w\n\n    results = []\n\n    for vertex in special_vertices:\n        distances = dijkstra(graph, vertex)\n        max_distance = max(distances[v] for v in special_vertices if v != vertex)\n        results.append(max_distance)\n\n    print(*results)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Read the input\nn = int(input())\nx = int(input())\n\n# Simulate the movements in reverse order\nfor i in range(n, 0, -1):\n    if i % 2 == 1:  # Odd movement\n        if x == 0:\n            x = 1\n        elif x == 1:\n            x = 0\n    else:  # Even movement\n        if x == 1:\n            x = 2\n        elif x == 2:\n            x = 1\n\n# Print the initial position of the ball\nprint(x)"}
{"solution": "def is_square(rectangles):\n    min_x = min(rect[0] for rect in rectangles)\n    max_x = max(rect[2] for rect in rectangles)\n    min_y = min(rect[1] for rect in rectangles)\n    max_y = max(rect[3] for rect in rectangles)\n\n    if max_x - min_x != max_y - min_y:\n        return False\n\n    area = (max_x - min_x) * (max_y - min_y)\n    total_rectangle_area = sum((rect[2] - rect[0]) * (rect[3] - rect[1]) for rect in rectangles)\n\n    return area == total_rectangle_area\n\nn = int(input())\nrectangles = [list(map(int, input().split())) for _ in range(n)]\n\nif is_square(rectangles):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def sum_of_digits(n):\n    return sum(int(digit) for digit in str(n))\n\ndef count_really_big_numbers(n, s):\n    count = 0\n    for i in range(1, n + 1):\n        if i - sum_of_digits(i) >= s:\n            count += 1\n    return count\n\nn, s = map(int, input().split())\nprint(count_really_big_numbers(n, s))"}
{"solution": "def can_cover_points(points):\n    if len(points) <= 2:\n        return True\n\n    # Check if all points are on the same line\n    x0, y0 = points[0]\n    for x, y in points[1:]:\n        if x != x0 and y != y0:\n            break\n    else:\n        return True\n\n    # Check if there are two points that can form a line that covers other points\n    for i in range(len(points)):\n        x1, y1 = points[i]\n        for j in range(i+1, len(points)):\n            x2, y2 = points[j]\n            if x1 == x2 or y1 == y2:\n                continue\n            line_points = set()\n            for x, y in points:\n                if (x1 - x) * (y2 - y) == (y1 - y) * (x2 - x):\n                    line_points.add((x, y))\n            if len(line_points) >= 2:\n                remaining_points = set(points) - line_points\n                return can_cover_points(list(line_points)) and can_cover_points(list(remaining_points))\n\n    return False\n\ndef main():\n    n = int(input())\n    points = [tuple(map(int, input().split())) for _ in range(n)]\n    print(\"YES\" if can_cover_points(points) else \"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(a, b, k, t):\n    dp = [[0] * (2 * k + 1) for _ in range(t + 1)]\n    dp[0][a - b + k] = 1\n\n    for i in range(1, t + 1):\n        for j in range(2 * k + 1):\n            for x in range(-k, k + 1):\n                if j + x >= 0 and j + x < 2 * k + 1:\n                    dp[i][j + x] = (dp[i][j + x] + dp[i - 1][j]) % MOD\n\n    return sum(dp[t][k + 1:]) % MOD\n\na, b, k, t = map(int, input().split())\nprint(solve(a, b, k, t))"}
{"solution": "def find_min_marks(n, l, x, y, marks):\n    # Initialize variables\n    min_marks = 0\n    additional_marks = []\n\n    # Check if x can be measured\n    x_measurable = False\n    for i in range(n):\n        if marks[i] + x in marks:\n            x_measurable = True\n            break\n    if not x_measurable:\n        min_marks += 1\n        additional_marks.append(x)\n\n    # Check if y can be measured\n    y_measurable = False\n    for i in range(n):\n        if marks[i] + y in marks:\n            y_measurable = True\n            break\n    if not y_measurable:\n        min_marks += 1\n        additional_marks.append(y)\n\n    # Return the minimum number of marks and the additional marks\n    return min_marks, additional_marks\n\n# Read input\nn, l, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Find the minimum number of marks and the additional marks\nmin_marks, additional_marks = find_min_marks(n, l, x, y, marks)\n\n# Print the output\nprint(min_marks)\nprint(*additional_marks)"}
{"solution": "import math\n\n# Get the number of cakes\nn = int(input())\n\n# List to store the volumes of the cakes\nvolumes = []\n\n# Calculate the volume of each cake and store it in the list\nfor _ in range(n):\n    r, h = map(int, input().split())\n    volume = math.pi * r**2 * h\n    volumes.append(volume)\n\n# Sort the volumes in descending order\nvolumes.sort(reverse=True)\n\n# Initialize the maximum possible volume\nmax_volume = 0\n\n# Initialize the current volume\ncurrent_volume = 0\n\n# Iterate over the volumes\nfor volume in volumes:\n    # If the current volume is less than the current cake's volume, add it to the maximum possible volume\n    if current_volume < volume:\n        max_volume += volume\n        current_volume = volume\n\n# Print the maximum possible volume\nprint(max_volume)"}
{"solution": "def min_slices(n, k, heights):\n    heights.sort()\n    min_slices = float('inf')\n    total_slices = 0\n    left = 0\n\n    for right in range(n):\n        while heights[right] - heights[left] > k:\n            total_slices += right - left\n            left += 1\n        total_slices += (right - left + 1) * (heights[right] - heights[left])\n        if right - left + 1 <= k:\n            min_slices = min(min_slices, total_slices)\n        total_slices -= heights[right]\n\n    return min_slices\n\nn, k = map(int, input().split())\nheights = list(map(int, input().split()))\nprint(min_slices(n, k, heights))"}
{"solution": "def max_score(n, a):\n    # Calculate prefix sums\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + a[i]\n\n    max_score = float('-inf')\n\n    # Iterate over all possible segments [l, r]\n    for l in range(n):\n        max_in_segment = float('-inf')\n        for r in range(l, n):\n            # Update the maximum value in the current segment\n            max_in_segment = max(max_in_segment, a[r])\n            # Calculate the sum of the current segment\n            segment_sum = prefix_sum[r + 1] - prefix_sum[l]\n            # Calculate the score after Bob removes the max value\n            score = segment_sum - max_in_segment\n            # Update the maximum score\n            max_score = max(max_score, score)\n\n    return max_score\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Print output\nprint(max_score(n, a))"}
{"solution": "import math\n\n# Get the input intervals\nk1, k2, k3 = map(int, input().split())\n\n# Calculate the greatest common divisor of the three intervals\ngcd = math.gcd(math.gcd(k1, k2), k3)\n\n# If the greatest common divisor is 1, it is possible to ensure that at least one garland is lit at all times\nif gcd == 1:\n    print(\"YES\")\n# Otherwise, it is not possible\nelse:\n    print(\"NO\")"}
{"solution": "def min_operations_to_delete_string(n, s):\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(n)]\n\n    # Base case: single character substrings\n    for i in range(n):\n        dp[i][i] = 1\n\n    # Fill the DP table for substrings of length greater than 1\n    for length in range(2, n + 1):  # length of the substring\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                dp[i][j] = dp[i][j-1]\n            else:\n                dp[i][j] = float('inf')\n                for k in range(i, j):\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n\n    # The result for the entire string\n    return dp[0][n-1]\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Print output\nprint(min_operations_to_delete_string(n, s))"}
{"solution": "# Read input\nn = int(input())\nboys = sorted(list(map(int, input().split())))\nm = int(input())\ngirls = sorted(list(map(int, input().split())))\n\n# Initialize pair count\npairs = 0\n\n# Iterate through boys and girls\ni = 0\nj = 0\nwhile i < n and j < m:\n    # If the skill difference is at most 1, form a pair\n    if abs(boys[i] - girls[j]) <= 1:\n        pairs += 1\n        i += 1\n        j += 1\n    # If the boy's skill is less than the girl's, move to the next boy\n    elif boys[i] < girls[j]:\n        i += 1\n    # If the girl's skill is less than the boy's, move to the next girl\n    else:\n        j += 1\n\n# Print the maximum possible number of pairs\nprint(pairs)"}
{"solution": "# Read the input\nplayer_stats = [list(map(int, input().split())) for _ in range(4)]\n\n# Separate the players into two teams\nteam1 = player_stats[:2]\nteam2 = player_stats[2:]\n\n# Sort the players in each team based on their defence and attack skills\nteam1.sort(key=lambda x: (x[0], x[1]))\nteam2.sort(key=lambda x: (x[0], x[1]))\n\n# Determine the defence and attack skills of each team\nteam1_defence = team1[0][0]\nteam1_attack = team1[1][1]\nteam2_defence = team2[0][0]\nteam2_attack = team2[1][1]\n\n# Determine the winner\nif team1_defence > team2_attack and team1_attack > team2_defence:\n    print(\"Team 1\")\nelif team2_defence > team1_attack and team2_attack > team1_defence:\n    print(\"Team 2\")\nelse:\n    print(\"Draw\")"}
{"solution": "import sys\nfrom math import sqrt\nfrom collections import defaultdict\n\ndef read_input():\n    N, K = map(int, sys.stdin.readline().split())\n    meat = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]\n    return N, K, meat\n\ndef binary_search(N, K, meat):\n    left, right = 0, 10000\n    for _ in range(100):\n        mid = (left + right) / 2\n        if is_possible(N, K, meat, mid):\n            right = mid\n        else:\n            left = mid\n    return right\n\ndef is_possible(N, K, meat, time):\n    graph = defaultdict(lambda: defaultdict(int))\n    source, sink = N, N + 1\n    for i in range(N):\n        graph[source][i] = 1\n        graph[i][sink] = 1 if sqrt((meat[i][0] ** 2 + meat[i][1] ** 2) / (meat[i][2] ** 2)) <= time else 0\n        for j in range(i + 1, N):\n            dist = sqrt((meat[i][0] - meat[j][0]) ** 2 + (meat[i][1] - meat[j][1]) ** 2)\n            if dist / (meat[i][2] + meat[j][2]) <= time:\n                graph[i][j] = graph[j][i] = 1\n    return max_flow(graph, source, sink) >= K\n\ndef max_flow(graph, source, sink):\n    def bfs(graph, source, sink, parent):\n        visited = [False] * (N + 2)\n        queue = [source]\n        visited[source] = True\n        while queue:\n            u = queue.pop(0)\n            for v in range(N + 2):\n                if not visited[v] and graph[u][v] > 0:\n                    queue.append(v)\n                    visited[v] = True\n                    parent[v] = u\n        return visited[sink]\n\n    def dfs(graph, source, sink, parent, flow):\n        if sink not in parent:\n            return 0\n        if source == sink:\n            return flow\n        for u in range(N + 2):\n            if graph[parent[sink]][u] > 0 and u == parent[sink]:\n                bottleneck = dfs(graph, source, parent[sink], parent, min(flow, graph[parent[sink]][u]))\n                if bottleneck > 0:\n                    graph[parent[sink]][u] -= bottleneck\n                    graph[u][parent[sink]] += bottleneck\n                    return bottleneck\n        return 0\n\n    parent = {}\n    max_flow = 0\n    while bfs(graph, source, sink, parent):\n        flow = dfs(graph, source, sink, parent, float('inf'))\n        while flow > 0:\n            max_flow += flow\n            flow = dfs(graph, source, sink, parent, float('inf'))\n    return max_flow\n\nN, K, meat = read_input()\ntime = binary_search(N, K, meat)\nprint(time)"}
{"solution": "def determine_winner(n, ticket):\n    # Calculate the sum of the first half and the second half of the ticket\n    first_half_sum = sum(int(ticket[i]) for i in range(n // 2) if ticket[i] != '?')\n    second_half_sum = sum(int(ticket[i]) for i in range(n // 2, n) if ticket[i] != '?')\n\n    # Count the number of unknown digits in the first half and the second half\n    first_half_unknown = ticket[:n // 2].count('?')\n    second_half_unknown = ticket[n // 2:].count('?')\n\n    # Determine the winner based on the number of unknown digits and the difference between the sums\n    if first_half_unknown == 0 and second_half_unknown == 0:\n        return 'Bicarp' if first_half_sum == second_half_sum else 'Monocarp'\n    elif first_half_unknown == second_half_unknown:\n        return 'Bicarp'\n    elif abs(first_half_sum - second_half_sum) % 9 < first_half_unknown + second_half_unknown:\n        return 'Bicarp'\n    else:\n        return 'Monocarp'\n\n# Read the input\nn = int(input())\nticket = input()\n\n# Print the winner\nprint(determine_winner(n, ticket))"}
{"solution": "def find_bus_route(n, t, bus_routes):\n    earliest_time = float('inf')\n    chosen_route = -1\n\n    for i in range(n):\n        s_i, d_i = bus_routes[i]\n\n        if s_i >= t:\n            next_bus_time = s_i\n        else:\n            # Calculate the next bus time after t\n            if (t - s_i) % d_i == 0:\n                next_bus_time = t\n            else:\n                next_bus_time = s_i + ((t - s_i) // d_i + 1) * d_i\n\n        if next_bus_time < earliest_time:\n            earliest_time = next_bus_time\n            chosen_route = i + 1\n\n    return chosen_route\n\n# Read input\nn, t = map(int, input().split())\nbus_routes = [list(map(int, input().split())) for _ in range(n)]\n\n# Find and print the bus route\nprint(find_bus_route(n, t, bus_routes))"}
{"solution": "def count_numbers_with_k_bits(n, k):\n    # Count the number of numbers up to n that have exactly k bits set to 1\n    count = 0\n    for i in range(n + 1, 2 * n + 1):\n        if bin(i).count('1') == k:\n            count += 1\n    return count\n\ndef find_n(m, k):\n    # Use binary search to find the required number n\n    left, right = 1, 10**18\n    while left < right:\n        mid = (left + right) // 2\n        if count_numbers_with_k_bits(mid, k) < m:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\n# Read input\nm, k = map(int, input().split())\n\n# Find and print the required number n\nprint(find_n(m, k))"}
{"solution": "# Read the number of segments in the level\nn = int(input())\n\n# Read the scheme of the level\nlevel = input()\n\n# Initialize variables to keep track of the last platform index and the jump length\nlast_platform = -1\njump_length = 0\n\n# Initialize a counter for the number of jumps\njumps = 0\n\n# Iterate over the segments in the level\nfor i in range(n):\n    # If the current segment is a platform\n    if level[i] == '*':\n        # If this is the first platform, set the last platform index to the current index\n        if last_platform == -1:\n            last_platform = i\n        # Otherwise, check if the jump length is the same as the previous jump\n        else:\n            # If the jump length is the same, increment the number of jumps\n            if i - last_platform == jump_length:\n                jumps += 1\n                # If this is the fourth jump, the level is good\n                if jumps == 3:\n                    print(\"yes\")\n                    exit(0)\n            # If the jump length is different, reset the number of jumps and update the jump length\n            else:\n                jumps = 0\n                jump_length = i - last_platform\n            # Update the last platform index\n            last_platform = i\n\n# If no sequence of four jumps was found, the level is not good\nprint(\"no\")"}
{"solution": "def find_missing_number(grid):\n    n = len(grid)\n    total_sum = 0\n    empty_cell = (-1, -1)\n\n    # Calculate the total sum of a row, column, or diagonal\n    def calculate_sum(indices):\n        return sum(grid[i][j] for i, j in indices)\n\n    # Find the empty cell and calculate the total sum of a row, column, and diagonals\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 0:\n                empty_cell = (i, j)\n            else:\n                total_sum += grid[i][j]\n\n    # Calculate the sum of a row, column, and diagonals that contain the empty cell\n    row_sum = calculate_sum([(empty_cell[0], j) for j in range(n)])\n    col_sum = calculate_sum([(i, empty_cell[1]) for i in range(n)])\n    diag1_sum = calculate_sum([(i, i) for i in range(n)]) if empty_cell[0] == empty_cell[1] else 0\n    diag2_sum = calculate_sum([(i, n - i - 1) for i in range(n)]) if empty_cell[0] + empty_cell[1] == n - 1 else 0\n\n    # Calculate the missing number\n    missing_number = (total_sum // (n * 2 + 2)) - (row_sum + col_sum + diag1_sum + diag2_sum)\n\n    return missing_number if missing_number > 0 else -1\n\n# Read input\nn = int(input())\ngrid = [list(map(int, input().split())) for _ in range(n)]\n\n# Find and print the missing number\nprint(find_missing_number(grid))"}
{"solution": "import math\n\n# Get the number of benches\nn = int(input())\n\n# Get the number of additional people\nm = int(input())\n\n# Get the initial number of people on each bench\na = [int(input()) for _ in range(n)]\n\n# Calculate the maximum possible k\nmax_k = max(a) + m\n\n# Calculate the total number of people after adding m\ntotal_people = sum(a) + m\n\n# Calculate the minimum possible k\nmin_k = math.ceil(total_people / n)\n\n# Print the minimum and maximum possible k\nprint(min_k, max_k)"}
{"solution": "MOD = 10**9 + 7\n\ndef power(x, y):\n    result = 1\n    while y > 0:\n        if y % 2 == 1:\n            result = (result * x) % MOD\n        x = (x * x) % MOD\n        y //= 2\n    return result\n\ndef factorial(n):\n    fact = 1\n    for i in range(2, n + 1):\n        fact = (fact * i) % MOD\n    return fact\n\ndef inverse(n):\n    return power(n, MOD - 2)\n\ndef ncr(n, r):\n    return (factorial(n) * inverse(factorial(r)) * inverse(factorial(n - r))) % MOD\n\ndef solve(n, m):\n    if m <= n:\n        return (power(2, m) * factorial(n)) % MOD\n    else:\n        result = 0\n        for i in range(n + 1):\n            result = (result + ncr(n, i) * power(2, n - i) * power(2, m - i) * factorial(n - i)) % MOD\n        return result\n\nn, m = map(int, input().split())\nprint(solve(n, m))"}
{"solution": "from itertools import combinations\n\ndef max_friends(n, m, friends, pizzas):\n    max_pleased = 0\n    min_price = float('inf')\n    result = (-1, -1)\n\n    for p1, p2 in combinations(range(m), 2):\n        pizza1 = set(pizzas[p1][1:])\n        pizza2 = set(pizzas[p2][1:])\n        union = pizza1 | pizza2\n\n        pleased = sum(all(ingredient in union for ingredient in friend) for friend in friends)\n\n        if pleased > max_pleased or (pleased == max_pleased and pizzas[p1][0] + pizzas[p2][0] < min_price):\n            max_pleased = pleased\n            min_price = pizzas[p1][0] + pizzas[p2][0]\n            result = (p1, p2)\n\n    return result\n\nn, m = map(int, input().split())\nfriends = [list(map(int, input().split()))[1:] for _ in range(n)]\npizzas = [list(map(int, input().split())) for _ in range(m)]\n\nj1, j2 = max_friends(n, m, friends, pizzas)\nprint(j1 + 1, j2 + 1)"}
{"solution": "def find_numbers(m, s):\n    # Initialize the smallest and largest numbers as empty strings\n    smallest = \"\"\n    largest = \"\"\n\n    # If the sum is 0 and the length is greater than 1, return \"-1 -1\"\n    if s == 0 and m > 1:\n        return \"-1 -1\"\n\n    # Calculate the largest number\n    while s > 0 and m > 0:\n        # If the sum is greater than 9, add 9 to the number\n        if s >= 9:\n            largest = \"9\" + largest\n            s -= 9\n        # Otherwise, add the remaining sum to the number\n        else:\n            largest = str(s) + largest\n            s = 0\n        m -= 1\n\n    # If the length of the largest number is less than the required length, add leading zeros\n    while m > 0:\n        largest = \"0\" + largest\n        m -= 1\n\n    # Reset the length and sum for the smallest number\n    m, s = len(largest), sum(map(int, largest))\n\n    # Calculate the smallest number\n    while s > 0 and m > 0:\n        # If the sum is greater than 9, add 9 to the number\n        if s > 9:\n            smallest = \"9\" + smallest\n            s -= 9\n        # Otherwise, add the remaining sum to the number\n        else:\n            smallest = str(s) + smallest\n            s = 0\n        m -= 1\n\n    # If the smallest number starts with \"0\", it is not a valid number\n    if smallest[0] == \"0\":\n        return \"-1 -1\"\n\n    # Return the smallest and largest numbers\n    return smallest + \" \" + largest\n\n# Get the input\nm, s = map(int, input().split())\n\n# Print the output\nprint(find_numbers(m, s))"}
{"solution": "MOD = 998244353\n\ndef count(n, k):\n    dp = [[0] * (1 << 10) for _ in range(20)]\n    dp[0][0] = 1\n    for i in range(19):\n        for j in range(1 << 10):\n            for d in range(10):\n                if (j >> d) & 1 or bin(j).count('1') < k:\n                    dp[i + 1][j | (1 << d)] = (dp[i + 1][j | (1 << d)] + dp[i][j]) % MOD\n    res = 0\n    for i in range(1, 20):\n        for j in range(1, 1 << 10):\n            if bin(j).count('1') <= k:\n                res = (res + dp[i][j] * ((n // (10 ** i) % 10) * i * (10 ** (i - 1)) % MOD)) % MOD\n    if bin(int(str(n)[-1])).count('1') <= k:\n        res = (res + n) % MOD\n    return res\n\nl, r, k = map(int, input().split())\nprint((count(r, k) - count(l - 1, k)) % MOD)"}
{"solution": "def can_distribute_pencils(n, k, d, pencils):\n    pencils.sort()\n    i = 0\n    while i < n:\n        count = 1\n        while i + count < n and pencils[i + count] - pencils[i] <= d:\n            count += 1\n        if count < k:\n            return False\n        i += count\n    return True\n\nn, k, d = map(int, input().split())\npencils = list(map(int, input().split()))\n\nif can_distribute_pencils(n, k, d, pencils):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def count_dead_light_bulbs(garland):\n    colors = {'R': 0, 'B': 0, 'Y': 0, 'G': 0}\n    for i in range(len(garland)):\n        if garland[i] == '!':\n            if i == 0:\n                colors[garland[i+1]] += 1\n            elif i == len(garland) - 1:\n                colors[garland[i-1]] += 1\n            elif garland[i-1] != garland[i+1]:\n                colors[garland[i-1]] += 1\n            else:\n                if i+2 < len(garland) and garland[i+2] != garland[i+1]:\n                    colors[garland[i+2]] += 1\n                else:\n                    colors[garland[i-2]] += 1\n    return colors['R'], colors['B'], colors['Y'], colors['G']\n\ngarland = input()\nresult = count_dead_light_bulbs(garland)\nprint(*result)"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef expected_passages(n, m, edges):\n    graph = defaultdict(list)\n    for s, t in edges:\n        graph[s].append(t)\n\n    dp = [0] * (n + 1)\n    dp[n] = 0\n\n    for i in range(n - 1, 0, -1):\n        total = 0\n        for j in graph[i]:\n            total += dp[j]\n        dp[i] = total / len(graph[i]) + 1\n\n    min_expected = float('inf')\n    for j in graph[1]:\n        if j == n:\n            continue\n        new_expected = (dp[j] + 1) / (len(graph[1]) - 1) + 1\n        min_expected = min(min_expected, new_expected)\n\n    return min(dp[1], min_expected)\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    edges = [tuple(map(int, sys.stdin.readline().split())) for _ in range(m)]\n    print(expected_passages(n, m, edges))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Get the input number from the user\nn = int(input(\"Enter a non-negative integer: \"))\n\n# Check if the number already ends in 0\nif n % 10 == 0:\n    print(n)\nelse:\n    # Calculate the nearest lower and higher multiples of 10\n    lower_multiple = n - (n % 10)\n    higher_multiple = lower_multiple + 10\n\n    # Determine the closest multiple\n    if (n - lower_multiple) < (higher_multiple - n):\n        print(lower_multiple)\n    else:\n        print(higher_multiple)"}
{"solution": "def find_swaps(s, t):\n    if len(s) != len(t):\n        return -1\n\n    mismatches = {}\n\n    for i in range(len(s)):\n        if s[i] != t[i]:\n            if s[i] in mismatches and mismatches[s[i]] != t[i]:\n                return -1\n            if t[i] in mismatches and mismatches[t[i]] != s[i]:\n                return -1\n            mismatches[s[i]] = t[i]\n            mismatches[t[i]] = s[i]\n\n    visited = set()\n    swaps = []\n\n    for key in mismatches:\n        if key not in visited:\n            cycle = []\n            current = key\n            while current not in visited:\n                visited.add(current)\n                cycle.append(current)\n                current = mismatches[current]\n            if len(cycle) != 2:\n                return -1\n            swaps.append((cycle[0], cycle[1]))\n\n    print(len(swaps))\n    for swap in swaps:\n        print(swap[0], swap[1])\n\n# Example usage:\ns = \"helloworld\"\nt = \"ehoolwlroz\"\nfind_swaps(s, t)"}
{"solution": "def earliest_login(first_name, last_name):\n    # Generate all possible prefixes for first and last names\n    first_prefixes = [first_name[:i] for i in range(1, len(first_name) + 1)]\n    last_prefixes = [last_name[:i] for i in range(1, len(last_name) + 1)]\n\n    # Generate all possible combinations of first and last name prefixes\n    combinations = [f + l for f in first_prefixes for l in last_prefixes]\n\n    # Sort the combinations alphabetically and return the first one\n    return sorted(combinations)[0]\n\n# Get the input\nfirst_name, last_name = input().split()\n\n# Print the output\nprint(earliest_login(first_name, last_name))"}
{"solution": "def draw_brackets(sequence, level, start, end):\n    if start == end:\n        return [' ' * (end - start + 1)]\n\n    result = []\n    for i in range(start + 1, end, 2):\n        if sequence[i] == ']':\n            left = draw_brackets(sequence, level + 1, start + 1, i)\n            right = draw_brackets(sequence, level + 1, i + 1, end - 1)\n            width = max(len(left[0]), len(right[0]))\n            left = [line.center(width) for line in left]\n            right = [line.center(width) for line in right]\n            result.append('+' + '-' * (width - 1) + '+')\n            for l, r in zip(left, right):\n                result.append('|' + l + '|' + r + '|')\n            result.append('+' + '-' * (width - 1) + '+')\n            break\n\n    return result\n\nn = int(input())\nsequence = input()\nresult = draw_brackets(sequence, 0, 0, n)\nfor line in result:\n    print(line)"}
{"solution": "def normalize_golden_number(golden_number):\n    golden_number = list(map(int, golden_number))\n    n = len(golden_number)\n\n    for i in range(n - 1, 0, -1):\n        if golden_number[i] > 1:\n            golden_number[i] -= 2\n            golden_number[i - 1] += 1\n            if i - 2 >= 0:\n                golden_number[i - 2] += 1\n\n    while len(golden_number) > 1 and golden_number[0] == 0:\n        golden_number.pop(0)\n\n    return golden_number\n\ndef compare_golden_numbers(num1, num2):\n    norm_num1 = normalize_golden_number(num1)\n    norm_num2 = normalize_golden_number(num2)\n\n    if len(norm_num1) > len(norm_num2):\n        return \">\"\n    elif len(norm_num1) < len(norm_num2):\n        return \"<\"\n\n    for digit1, digit2 in zip(norm_num1, norm_num2):\n        if digit1 > digit2:\n            return \">\"\n        elif digit1 < digit2:\n            return \"<\"\n\n    return \"=\"\n\nnum1 = input().strip()\nnum2 = input().strip()\n\nresult = compare_golden_numbers(num1, num2)\nprint(result)"}
{"solution": "# Define the dictionary of Infinity Gems\ninfinity_gems = {\n    'purple': 'Power',\n    'green': 'Time',\n    'blue': 'Space',\n    'orange': 'Soul',\n    'red': 'Reality',\n    'yellow': 'Mind'\n}\n\n# Get the number of Gems in Infinity Gauntlet\nn = int(input())\n\n# Get the colors of Gems in Infinity Gauntlet\ngems_in_gauntlet = [input() for _ in range(n)]\n\n# Determine the absent Gems\nabsent_gems = [gem for color, gem in infinity_gems.items() if color not in gems_in_gauntlet]\n\n# Print the number of absent Gems\nprint(len(absent_gems))\n\n# Print the names of absent Gems\nfor gem in absent_gems:\n    print(gem)"}
{"solution": "def find_meeting_round(n, a, b):\n    round = 1\n    while n > 1:\n        if a % 2 == 1 and a + 1 == b:\n            return round\n        if b % 2 == 1 and b + 1 == a:\n            return round\n        a = (a + 1) // 2\n        b = (b + 1) // 2\n        n //= 2\n        round += 1\n    return \"Final!\"\n\nn, a, b = map(int, input().split())\nprint(find_meeting_round(n, a, b))"}
{"solution": "def min_changes(n, p, b):\n    # Create a list to store the visited positions for each skewer\n    visited = [set() for _ in range(n)]\n\n    # Simulate the movement of each skewer\n    for i in range(n):\n        pos = i\n        for _ in range(2 * n):\n            visited[i].add(pos)\n            pos = p[pos] - 1\n            if b[pos] == 1:\n                pos = n - 1 - pos\n\n    # Count the minimum number of changes needed\n    changes = 0\n    for i in range(n):\n        if len(visited[i]) < 2 * n:\n            changes += 1\n\n    return changes\n\n# Read the input\nn = int(input())\np = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Calculate the minimum number of changes\nresult = min_changes(n, p, b)\n\n# Print the result\nprint(result)"}
{"solution": "# Get the input\nv1, v2 = map(int, input().split())\nt, d = map(int, input().split())\n\n# Initialize the maximum possible length\nmax_length = 0\n\n# Initialize the current speed\ncurrent_speed = v1\n\n# Iterate over the time\nfor _ in range(t):\n    # Add the current speed to the maximum length\n    max_length += current_speed\n\n    # If the current speed is less than v2, increase it by d\n    if current_speed < v2:\n        current_speed = min(current_speed + d, v2)\n    # If the current speed is greater than v2, decrease it by d\n    elif current_speed > v2:\n        current_speed = max(current_speed - d, v2)\n\n# Print the maximum possible length\nprint(max_length)"}
{"solution": "import sys\nfrom bisect import bisect_left\n\ndef solve():\n    n, m = map(int, sys.stdin.readline().split())\n    weights = list(map(int, sys.stdin.readline().split()))\n    lengths = [0] * m\n    capacities = [0] * m\n    for i in range(m):\n        lengths[i], capacities[i] = map(int, sys.stdin.readline().split())\n\n    weights.sort(reverse=True)\n    dp = [[0] * (1 << n) for _ in range(m)]\n    for i in range(m):\n        for j in range(1 << n):\n            dp[i][j] = float('inf')\n\n    for i in range(m):\n        for j in range(1 << n):\n            if bin(j).count('1') == 1:\n                dp[i][j] = 0\n                continue\n            for k in range(n):\n                if (j >> k) & 1:\n                    for l in range(i):\n                        if dp[l][j ^ (1 << k)] != float('inf'):\n                            dp[i][j] = min(dp[i][j], max(dp[l][j ^ (1 << k)], (weights[k] + sum(weights[x] for x in range(n) if (j >> x) & 1 and x != k)) * lengths[i] // capacities[i]))\n\n    if dp[-1][-1] == float('inf'):\n        print(-1)\n    else:\n        print(dp[-1][-1])\n\nsolve()"}
{"solution": "def last_digit_factorial(n):\n    if n == 0:\n        return 1\n    elif n <= 2:\n        return n\n    elif n <= 4:\n        return 0\n    else:\n        return 0\n\ndef last_digit_division(a, b):\n    if a == b:\n        return 1\n    elif a > b:\n        return 0\n    else:\n        return (last_digit_factorial(b) * last_digit_division(a, b - 1)) % 10\n\na, b = map(int, input().split())\nprint(last_digit_division(a, b))"}
{"solution": "from collections import deque\n\ndef min_jumps(n, d, lilies):\n    visited = [False] * n\n    queue = deque([(0, 0)])\n    visited[0] = True\n\n    while queue:\n        pos, jumps = queue.popleft()\n\n        for i in range(1, d + 1):\n            next_pos = pos + i\n\n            if next_pos < n and lilies[next_pos] == '1' and not visited[next_pos]:\n                if next_pos == n - 1:\n                    return jumps + 1\n\n                visited[next_pos] = True\n                queue.append((next_pos, jumps + 1))\n\n    return -1\n\nn, d = map(int, input().split())\nlilies = input()\n\nprint(min_jumps(n, d, lilies))"}
{"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_counterexample(n):\n    for m in range(1, 1001):\n        if not is_prime(n * m + 1):\n            return m\n\n# Read input\nn = int(input().strip())\n\n# Find and print the counterexample\nprint(find_counterexample(n))"}
{"solution": "def can_buy_items(n):\n    for a in range(n // 1234567 + 1):\n        for b in range((n - a * 1234567) // 123456 + 1):\n            c = (n - a * 1234567 - b * 123456) // 1234\n            if a * 1234567 + b * 123456 + c * 1234 == n:\n                return True\n    return False\n\nn = int(input())\nif can_buy_items(n):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def check_intersection(n, x1, x2, lines):\n    intersections = []\n    for i in range(n):\n        for j in range(i+1, n):\n            k1, b1 = lines[i]\n            k2, b2 = lines[j]\n            if k1 != k2:\n                x = (b2 - b1) / (k1 - k2)\n                if x1 < x < x2:\n                    intersections.append((x, k1*x + b1))\n    return len(intersections) > 0\n\nn = int(input())\nx1, x2 = map(int, input().split())\nlines = [tuple(map(int, input().split())) for _ in range(n)]\n\nif check_intersection(n, x1, x2, lines):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def count_weights(n):\n    # Initialize the count of weights\n    count = 0\n\n    # Iterate through all possible first elements of the split\n    for i in range(1, n + 1):\n        # Calculate the remaining sum for the rest of the split\n        remaining = n - i\n\n        # Calculate the number of elements in the split that are equal to the first element\n        weight = remaining // i + 1\n\n        # Check if the weight is valid\n        if weight * i <= n:\n            count += 1\n\n    return count\n\n# Read the input\nn = int(input())\n\n# Find the number of different weights of splits\nresult = count_weights(n)\n\n# Print the output\nprint(result)"}
{"solution": "def find_good_apartments(n, k):\n    if k == 0:\n        min_good = 0\n        max_good = 0\n    else:\n        min_good = 1\n        max_good = min(n - k, 2 * k)\n\n    return min_good, max_good\n\n# Get input\nn, k = map(int, input().split())\n\n# Find minimum and maximum good apartments\nmin_good, max_good = find_good_apartments(n, k)\n\n# Print output\nprint(min_good, max_good)"}
{"solution": "import math\n\n# Get the number of players from the input\nn = int(input())\n\n# Calculate the maximum number of games the winner can play\nmax_games = math.floor(math.log2(n))\n\n# Print the result\nprint(max_games)"}
{"solution": "def max_vk_occurrences(s):\n    count = 0\n    i = 0\n    while i < len(s) - 1:\n        if s[i] == 'V' and s[i + 1] == 'K':\n            count += 1\n            i += 2\n        else:\n            i += 1\n    if count < s.count('V') and count < s.count('K'):\n        count += 1\n    return count\n\ns = input()\nprint(max_vk_occurrences(s))"}
{"solution": "import math\n\ndef min_segments(n):\n    a = int(math.sqrt(n))\n    b = (n + a - 1) // a\n    return a + b + 2\n\nn = int(input().strip())\nprint(min_segments(n))"}
{"solution": "# Get the initial weights of Limak and Bob\na, b = map(int, input().split())\n\n# Initialize the number of years\nyears = 0\n\n# While Limak's weight is less than or equal to Bob's weight\nwhile a <= b:\n    # Triple Limak's weight and double Bob's weight\n    a *= 3\n    b *= 2\n\n    # Increment the number of years\n    years += 1\n\n# Print the number of years it takes for Limak to become strictly larger than Bob\nprint(years)"}
{"solution": "def solve(h, n):\n    # Initialize the current node and the number of visited nodes\n    current_node = 1\n    visited_nodes = 0\n\n    # Loop until the exit node is reached\n    while current_node != n:\n        # Calculate the next node based on the current node and the command string\n        next_node = current_node * 2 if (current_node < n) else current_node // 2\n\n        # If the next node is not the current node, it means that the current command was not skipped\n        if next_node != current_node:\n            # Increment the number of visited nodes\n            visited_nodes += 1\n\n            # Update the current node\n            current_node = next_node\n\n    # Return the number of visited nodes\n    return visited_nodes\n\n# Read the input\nh, n = map(int, input().split())\n\n# Print the output\nprint(solve(h, n))"}
{"solution": "def count_tables(x):\n    # Initialize an empty list to store the pairs of (n, m)\n    tables = []\n    # Initialize a counter for the number of tables\n    count = 0\n    # Iterate through all possible values of n and m\n    for n in range(1, int(x**0.5) + 1):\n        for m in range(n, x // n + 1):\n            # Calculate the number of distinct squares in the table\n            squares = (n * (n + 1) * m * (m + 1)) // 4\n            # If the number of squares is equal to x, add the pair to the list and increment the counter\n            if squares == x:\n                tables.append((n, m))\n                count += 1\n    # Return the number of tables and the list of pairs\n    return count, tables\n\n# Read the input\nx = int(input())\n# Call the function to count the tables\ncount, tables = count_tables(x)\n# Print the output\nprint(count)\nfor n, m in tables:\n    print(n, m)"}
{"solution": "def is_valid_sequence(sequence):\n    # Define the number of days in each month\n    months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    # Iterate over the months\n    for i in range(12):\n        # Check if the current month matches the first element of the sequence\n        if months[i] == sequence[0]:\n            # If it does, check if the rest of the sequence matches the next months\n            if sequence == months[i:i+len(sequence)] or sequence == months[i:] + months[:len(sequence)-(12-i)]:\n                return True\n    return False\n\n# Get the input\nn = int(input())\nsequence = list(map(int, input().split()))\n\n# Check if the sequence is valid\nif is_valid_sequence(sequence):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def find_fractions(n):\n    # Find all divisors of n\n    divisors = [i for i in range(2, n) if n % i == 0]\n\n    # Initialize the sequence\n    sequence = []\n\n    # Iterate over divisors\n    for b in divisors:\n        # Calculate a\n        a = 1\n\n        # Check if the fraction meets the conditions\n        if 1 <= a < b and (1 - 1/n - sum(a/b for a, b in sequence)) > 0:\n            # Add the fraction to the sequence\n            sequence.append((a, b))\n\n    # Check if the sequence sums to 1 - 1/n\n    if sum(a/b for a, b in sequence) == 1 - 1/n:\n        return \"YES\", sequence\n    else:\n        return \"NO\", []\n\n# Read input\nn = int(input())\n\n# Find the sequence of fractions\nresult, sequence = find_fractions(n)\n\n# Print the result\nprint(result)\n\n# Print the sequence\nif result == \"YES\":\n    print(len(sequence))\n    for a, b in sequence:\n        print(a, b)"}
{"solution": "def min_unattractiveness(n, a, b, h):\n    # Initialize a 2D DP table\n    dp = [[float('inf')] * (b + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    # Iterate through each board\n    for i in range(1, n + 1):\n        # Iterate through all possible red and green areas\n        for j in range(a + 1):\n            for k in range(b + 1):\n                # Paint the current board red\n                if j >= h[i - 1]:\n                    dp[i][k] = min(dp[i][k], dp[i - 1][k] + (h[i - 1] if i > 1 and h[i - 1] != h[i - 2] else 0))\n                # Paint the current board green\n                if k >= h[i - 1]:\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j] + (h[i - 1] if i > 1 and h[i - 1] != h[i - 2] else 0))\n\n    # Find the minimum unattractiveness value\n    min_val = float('inf')\n    for j in range(a + 1):\n        for k in range(b + 1):\n            min_val = min(min_val, dp[n][j] + dp[n][k] - min(h[-1], h[-2]) if n > 1 and h[-1] != h[-2] else 0)\n\n    return min_val if min_val != float('inf') else -1\n\n# Read input\nn = int(input())\na, b = map(int, input().split())\nh = list(map(int, input().split()))\n\n# Print output\nprint(min_unattractiveness(n, a, b, h))"}
{"solution": "def find_triangle_points(n, m, k):\n    # Check if it's possible to form a triangle with the given area\n    if (n * m) % k != 0:\n        return \"NO\"\n\n    # Calculate the area of each small triangle\n    small_triangle_area = (n * m) // k\n\n    # Iterate through all possible points\n    for x1 in range(n + 1):\n        for y1 in range(m + 1):\n            # Calculate the area of the triangle formed by (0, 0), (x1, y1), and (n, m)\n            triangle_area = (x1 * m + y1 * n) // 2\n\n            # Check if the area of the triangle is equal to the desired area\n            if triangle_area == small_triangle_area:\n                # Calculate the coordinates of the third point\n                x2, y2 = x1, m\n                x3, y3 = n, y1\n\n                return \"YES\\n{}\\n{}\\n{}\\n\".format((x1, y1), (x2, y2), (x3, y3))\n\n    return \"NO\"\n\n# Read the input\nn, m, k = map(int, input().split())\n\n# Find the points and print the result\nprint(find_triangle_points(n, m, k))"}
{"solution": "# Get the input values for the number of sticks and the number of sticks to be crossed out on each turn\nn, k = map(int, input().split())\n\n# Calculate the number of moves each player can make\nsasha_moves = n // k\nlena_moves = (n - k) // k\n\n# Check if Sasha makes more moves than Lena\nif sasha_moves > lena_moves:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "# Read and parse input\nn = int(input())\nrepetitions = list(map(int, input().split()))\n\n# Initialize counters for each muscle group\nchest = 0\nbiceps = 0\nback = 0\n\n# Iterate through the list of exercises\nfor i in range(n):\n    # Determine the muscle group based on the cyclic pattern\n    if i % 3 == 0:\n        chest += repetitions[i]\n    elif i % 3 == 1:\n        biceps += repetitions[i]\n    else:\n        back += repetitions[i]\n\n# Compare totals and output the result\nif chest > biceps and chest > back:\n    print(\"chest\")\nelif biceps > chest and biceps > back:\n    print(\"biceps\")\nelse:\n    print(\"back\")"}
{"solution": "def min_redos_to_get_five(n, grades):\n    current_sum = sum(grades)\n    target_sum = n * 4.5\n\n    if current_sum >= target_sum:\n        return 0\n\n    grades.sort()\n    redos = 0\n\n    for grade in grades:\n        if current_sum >= target_sum:\n            break\n        current_sum += (5 - grade)\n        redos += 1\n\n    return redos\n\nn = int(input())\ngrades = list(map(int, input().split()))\nprint(min_redos_to_get_five(n, grades))"}
{"solution": "def solve(u, v):\n    if u == v:\n        if u == 0:\n            return [0]\n        else:\n            return [u]\n    elif u > v:\n        return -1\n    elif (v - u) % 2 == 1:\n        return -1\n    else:\n        half = (v - u) // 2\n        if half & u != 0:\n            return [-1]\n        else:\n            return [half, half ^ u]\n\nu, v = map(int, input().split())\nresult = solve(u, v)\nif result == -1:\n    print(-1)\nelse:\n    print(len(result))\n    print(' '.join(map(str, result)))"}
{"solution": "def min_digits(n):\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = dp[i - 1] + len(str(i).replace('0', ''))\n        j = 10\n        while j <= i:\n            dp[i] = min(dp[i], dp[i - j] + 1)\n            j *= 10\n    return dp[n]\n\nn = int(input())\nprint(min_digits(n))"}
{"solution": "# Get input\nx1, y1, x2, y2 = map(int, input().split())\nx, y = map(int, input().split())\n\n# Calculate the difference between the starting and ending coordinates\ndx = x2 - x1\ndy = y2 - y1\n\n# Check if the difference can be expressed as a combination of the given moves\nif dx % x == 0 and dy % y == 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "from itertools import permutations\n\ndef count_valid_bus_numbers(n):\n    # Convert the number to a string to extract digits\n    digits = list(str(n))\n\n    # Generate all unique permutations of the digits\n    all_permutations = set(permutations(digits))\n\n    # Filter out permutations that start with '0'\n    valid_permutations = set()\n    for perm in all_permutations:\n        if perm[0] != '0':\n            valid_permutations.add(perm)\n\n    # Return the count of valid permutations\n    return len(valid_permutations)\n\n# Read input\nn = int(input().strip())\n\n# Get the count of valid bus numbers\nresult = count_valid_bus_numbers(n)\n\n# Print the result\nprint(result)"}
{"solution": "# Get the input\na = int(input())  # number of ties\nb = int(input())  # number of scarves\nc = int(input())  # number of vests\nd = int(input())  # number of jackets\ne = int(input())  # cost of one suit of the first type\nf = int(input())  # cost of one suit of the second type\n\n# Calculate the maximum number of suits of the first type that can be made\nmax_first_type = min(a, d)\n\n# Calculate the maximum number of suits of the second type that can be made\nmax_second_type = min(b, c, d)\n\n# Calculate the maximum possible cost of a set of suits\nmax_cost = max_first_type * e + max_second_type * f\n\n# Print the result\nprint(max_cost)"}
{"solution": "def discrete_logarithm(a, b, p):\n    # Calculate the discrete logarithm of b base a modulo p\n    # using the baby-step giant-step algorithm\n    m = int(p ** 0.5) + 1\n    table = {pow(a, i, p): i for i in range(m)}\n    inv_a = pow(a, p - 2, p)\n    c = pow(inv_a, m, p)\n    for j in range(m):\n        y = (b * pow(inv_a, j, p)) % p\n        if y in table:\n            return j * m + table[y]\n    return -1\n\ndef count_solutions(a, b, p, x):\n    # Count the number of positive integers n that satisfy the equation\n    count = 0\n    for n in range(1, x + 1):\n        if (n * pow(a, n, p)) % p == b:\n            count += 1\n    return count\n\ndef main():\n    a, b, p, x = map(int, input().split())\n    log_a = discrete_logarithm(a, b, p)\n    if log_a != -1:\n        count = count_solutions(a, b, p, x // p)\n        if x % p >= log_a:\n            count += 1\n    else:\n        count = 0\n    print(count)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Get the input\nk_2, k_3, k_5, k_6 = map(int, input().split())\n\n# Calculate the maximum possible number of 256 that can be formed\nnum_256 = min(k_2, k_5, k_6)\n\n# Calculate the remaining digits after forming 256\nremaining_2 = k_2 - num_256\nremaining_3 = k_3\nremaining_5 = k_5 - num_256\nremaining_6 = k_6 - num_256\n\n# Calculate the maximum possible number of 32 that can be formed\nnum_32 = min(remaining_2, remaining_3)\n\n# Calculate the maximum possible sum\nmax_sum = num_256 * 256 + num_32 * 32\n\n# Print the result\nprint(max_sum)"}
{"solution": "def bender_happy(n, x, y, c):\n    # If the initial cell is already enough, return 0\n    if c == 1:\n        return 0\n\n    # Initialize the grid with all cells off\n    grid = [[0] * n for _ in range(n)]\n    grid[x-1][y-1] = 1  # Turn on the initial cell\n\n    # Initialize the count of on cells\n    on_cells = 1\n\n    # Initialize the time\n    time = 0\n\n    # While there are not enough on cells\n    while on_cells < c:\n        # Create a copy of the grid to avoid modifying it while iterating\n        new_grid = [row[:] for row in grid]\n\n        # Iterate over each cell in the grid\n        for i in range(n):\n            for j in range(n):\n                # If the cell is off but has an on side-adjacent cell\n                if grid[i][j] == 0 and (\n                    (i > 0 and grid[i-1][j] == 1) or\n                    (i < n-1 and grid[i+1][j] == 1) or\n                    (j > 0 and grid[i][j-1] == 1) or\n                    (j < n-1 and grid[i][j+1] == 1)\n                ):\n                    # Turn on the cell in the new grid\n                    new_grid[i][j] = 1\n                    on_cells += 1\n\n                    # If we have enough on cells, return the time\n                    if on_cells >= c:\n                        return time + 1\n\n        # Update the grid\n        grid = new_grid\n\n        # Increment the time\n        time += 1\n\n    # If we never reached the required number of on cells, return -1\n    return -1\n\n# Read the input\nn, x, y, c = map(int, input().split())\n\n# Print the result\nprint(bender_happy(n, x, y, c))"}
{"solution": "# Read input\nl, r = map(int, input().split())\n\n# Calculate the maximum value of a ^ b\nmax_value = 0\n\n# If the range is even, the maximum value is the XOR of the range's end\nif (r - l) % 2 == 0:\n    max_value = r\n# If the range is odd, the maximum value is the XOR of the range's end and the range's end - 1\nelse:\n    max_value = r ^ (r - 1)\n\n# Print the maximum value\nprint(max_value)"}
{"solution": "def minimum_height(n, k):\n    left, right = 1, k\n\n    while left < right:\n        mid = (left + right) // 2\n        if n * mid >= k:\n            right = mid\n        else:\n            left = mid + 1\n\n    return left\n\nn, k = map(int, input().split())\nprint(minimum_height(n, k))"}
{"solution": "def should_use_elevator(x, y, z, t1, t2, t3):\n    stairs_time = abs(x - y) * t1\n    elevator_to_masha_time = abs(z - x) * t2 + t3\n    elevator_to_egor_time = abs(x - y) * t2 + 2 * t3\n    elevator_time = elevator_to_masha_time + elevator_to_egor_time\n    if stairs_time < elevator_time:\n        return \"NO\"\n    else:\n        return \"YES\"\n\nx, y, z, t1, t2, t3 = map(int, input().split())\nprint(should_use_elevator(x, y, z, t1, t2, t3))"}
{"solution": "# Read the input\nn, m = map(int, input().split())\n\n# If m is at one of the extremes, a should be at the other extreme\nif m == 1:\n    a = n\nelif m == n:\n    a = 1\n# If m is closer to the upper end, a should be closer to the lower end\nelif m > n // 2:\n    a = 1\n# If m is closer to the lower end, a should be closer to the upper end\nelse:\n    a = n\n\n# Print the result\nprint(a)"}
{"solution": "# Read the number of lessons\nn = int(input())\n\n# Read the schedule for the lessons\nschedule = list(map(int, input().split()))\n\n# Initialize the count of pairs Alena stays at the university\ncount = 0\n\n# Initialize a flag to check if Alena is at the university\nat_university = False\n\n# Iterate over the schedule\nfor i in range(n):\n    # If Alena has a pair\n    if schedule[i] == 1:\n        # Increment the count\n        count += 1\n        # Set the flag to True\n        at_university = True\n    # If Alena doesn't have a pair\n    else:\n        # If Alena is at the university\n        if at_university:\n            # Increment the count\n            count += 1\n        # If Alena is not at the university\n        else:\n            # Check if the next pair is also a break\n            if i < n - 1 and schedule[i + 1] == 0:\n                # If it is, set the flag to True\n                at_university = True\n\n# Print the count\nprint(count)"}
{"solution": "# Read input\nn, k = map(int, input().split())\ncandies = list(map(int, input().split()))\n\n# Initialize variables\ndays = 0\nbran_candies = 0\n\n# Iterate through each day\nfor i in range(n):\n    # Arya gives Bran candies up to 8 per day\n    bran_candies += min(8, candies[i])\n    candies[i] -= min(8, candies[i])\n\n    # Increment the day counter\n    days += 1\n\n    # Check if Bran has received enough candies\n    if bran_candies >= k:\n        break\n\n# Print the result\nif bran_candies >= k:\n    print(days)\nelse:\n    print(-1)"}
{"solution": "def minimum_additional_walks(n, k, a):\n    b = a[:]\n    additional_walks = 0\n\n    for i in range(n - 1):\n        if b[i] + b[i + 1] < k:\n            needed_walks = k - (b[i] + b[i + 1])\n            b[i + 1] += needed_walks\n            additional_walks += needed_walks\n\n    return additional_walks, b\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Get the result\nadditional_walks, b = minimum_additional_walks(n, k, a)\n\n# Print the result\nprint(additional_walks)\nprint(' '.join(map(str, b)))"}
{"solution": "def calculate_rhombus_cells(n):\n    # The number of cells in a 1st order rhombus is 1\n    if n == 1:\n        return 1\n    else:\n        # The number of cells in an n-th order rhombus is the sum of the number of cells in the (n-1)-th order rhombus\n        # and the number of cells added in the n-th order (which is 4 times the order minus 3)\n        return calculate_rhombus_cells(n - 1) + 4 * n - 3\n\n# Read the input\nn = int(input())\n\n# Calculate the number of cells in the n-th order rhombus\nresult = calculate_rhombus_cells(n)\n\n# Print the result\nprint(result)"}
{"solution": "# Read the input\nn = int(input())\ninput_string = input()\n\n# Convert the input string to lowercase for simplicity\ninput_string = input_string.lower()\n\n# Create a set to store unique letters found in the string\nunique_letters = set()\n\n# Iterate through the string and add each letter to the set\nfor letter in input_string:\n    unique_letters.add(letter)\n\n# Check if the set contains all 26 letters of the alphabet\nif len(unique_letters) == 26:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "# Get the current time and the number of minutes passed\ncurrent_time = input().split(':')\nminutes_passed = int(input())\n\n# Convert the current time to minutes\ncurrent_time_in_minutes = int(current_time[0]) * 60 + int(current_time[1])\n\n# Calculate the new time in minutes\nnew_time_in_minutes = (current_time_in_minutes + minutes_passed) % (24 * 60)\n\n# Convert the new time back to hours and minutes\nnew_hours = new_time_in_minutes // 60\nnew_minutes = new_time_in_minutes % 60\n\n# Print the new time in the format hh:mm\nprint(f'{new_hours:02d}:{new_minutes:02d}')"}
{"solution": "def can_turn_on_all_lamps(switches, lamps):\n    # Create a set of all lamps that can be turned on\n    all_lamps = set(range(lamps))\n\n    # Create a list of sets, where each set contains the lamps that can be turned on by the corresponding switch\n    switch_lamps = [set(i for i, lamp in enumerate(switch) if lamp == '1') for switch in switches]\n\n    # Iterate over each switch\n    for i in range(len(switches)):\n        # Create a set of lamps that can be turned on by all switches except the current one\n        remaining_lamps = set.union(*switch_lamps[:i], *switch_lamps[i+1:])\n\n        # If the set of lamps that can be turned on by all switches except the current one is equal to the set of all lamps,\n        # then the current switch can be ignored\n        if remaining_lamps == all_lamps:\n            return True\n\n    # If no switch can be ignored, return False\n    return False\n\n# Read the input\nn, m = map(int, input().split())\nswitches = [input() for _ in range(n)]\n\n# Print the output\nprint(\"YES\" if can_turn_on_all_lamps(switches, m) else \"NO\")"}
{"solution": "def min_rotations(n, dominoes):\n    upper_sum = sum(x for x, _ in dominoes)\n    lower_sum = sum(y for _, y in dominoes)\n\n    # If both sums are even, no rotations are needed\n    if upper_sum % 2 == 0 and lower_sum % 2 == 0:\n        return 0\n\n    # If it's not possible to make both sums even, return -1\n    for x, y in dominoes:\n        if x % 2 != y % 2:\n            return -1\n\n    # If we can make both sums even by rotating one domino, return 1\n    return 1\n\nn = int(input())\ndominoes = [tuple(map(int, input().split())) for _ in range(n)]\nprint(min_rotations(n, dominoes))"}
{"solution": "import math\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef calculate_area(a, b):\n    return (a - b) * (a + b)\n\ndef solve_problem():\n    t = int(input())\n    for _ in range(t):\n        a, b = map(int, input().split())\n        area = calculate_area(a, b)\n        if is_prime(area):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nsolve_problem()"}
{"solution": "def can_remove_one_point(n, points):\n    positive_count = 0\n    negative_count = 0\n\n    for x, y in points:\n        if x > 0:\n            positive_count += 1\n        else:\n            negative_count += 1\n\n    if positive_count <= 1 or negative_count <= 1:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Reading input\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(can_remove_one_point(n, points))"}
{"solution": "import math\n\ndef factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * factorial(n-1)\n\nA, B = map(int, input().split())\n\nA_factorial = factorial(A)\nB_factorial = factorial(B)\n\ngcd = math.gcd(A_factorial, B_factorial)\n\nprint(gcd)"}
{"solution": "def find_composite_integers(n):\n    # Find a composite integer 'a'\n    a = n + 2\n    while True:\n        for i in range(2, int(a**0.5) + 1):\n            if a % i == 0:\n                # 'a' is composite, break the loop\n                break\n        else:\n            # 'a' is not composite, increment 'a'\n            a += 1\n            continue\n        break\n\n    # Calculate 'b'\n    b = a - n\n\n    return a, b\n\n# Read the input\nn = int(input())\n\n# Find the composite integers\na, b = find_composite_integers(n)\n\n# Print the output\nprint(a, b)"}
{"solution": "import sys\n\ndef max_score(N, M, P, edges):\n    # Create a graph with N vertices and initialize the maximum score array\n    graph = [[] for _ in range(N+1)]\n    max_score = [-float('inf')] * (N+1)\n    max_score[1] = 0\n\n    # Build the graph from the input edges\n    for A, B, C in edges:\n        graph[A].append((B, C))\n\n    # Iterate over the vertices in topological order\n    for i in range(1, N+1):\n        # Iterate over the outgoing edges of the current vertex\n        for j, C in graph[i]:\n            # Calculate the new score if we traverse the edge\n            new_score = max_score[i] + C - P\n            # Update the maximum score for the next vertex\n            max_score[j] = max(max_score[j], new_score)\n\n    # Return the maximum score that can be obtained at Vertex N\n    return max_score[N]\n\n# Read the input from standard input\nN, M, P = map(int, sys.stdin.readline().split())\nedges = [tuple(map(int, sys.stdin.readline().split())) for _ in range(M)]\n\n# Calculate and print the maximum score\nresult = max_score(N, M, P, edges)\nprint(result)"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef min_palindrome_cost():\n    n = int(sys.stdin.readline())\n    strings = []\n    costs = []\n    reversed_strings = defaultdict(list)\n\n    for _ in range(n):\n        s, c = sys.stdin.readline().split()\n        c = int(c)\n        strings.append(s)\n        costs.append(c)\n        reversed_strings[s[::-1]].append(_)\n\n    dp = [float('inf')] * (1 << n)\n    dp[0] = 0\n\n    for mask in range(1 << n):\n        for i in range(n):\n            if not (mask & (1 << i)):\n                rev = strings[i][::-1]\n                for j in reversed_strings[rev]:\n                    if mask & (1 << j):\n                        dp[mask | (1 << i)] = min(dp[mask | (1 << i)], dp[mask] + costs[i])\n                if strings[i] == rev:\n                    dp[mask | (1 << i)] = min(dp[mask | (1 << i)], dp[mask] + costs[i])\n\n    return min(dp[-1], -1)\n\nprint(min_palindrome_cost())"}
{"solution": "def largest_xor_sum(n, k):\n    # Find the number of bits in n\n    num_bits = n.bit_length()\n    # The largest possible xor-sum\n    max_xor_sum = (1 << num_bits) - 1\n    return max_xor_sum\n\n# Get input\nn, k = map(int, input().split())\n# Print output\nprint(largest_xor_sum(n, k))"}
{"solution": "def min_triangle_side():\n    n = int(input())\n    points = [list(map(int, input().split())) for _ in range(n)]\n\n    # Sort points by x-coordinate\n    points.sort(key=lambda x: x[0])\n\n    # Initialize minimum length of the shorter side\n    min_length = float('inf')\n\n    # Iterate through all possible x-coordinates for the vertex on the x-axis\n    for i in range(n):\n        # Calculate the y-coordinates of the vertices on the y-axis\n        y_coords = sorted(point[1] for point in points[:i+1])\n        y1, y2 = y_coords[0], y_coords[-1]\n\n        # Calculate the length of the shorter side\n        length = min(y1, points[i][1] - y2)\n\n        # Update the minimum length\n        min_length = min(min_length, length)\n\n    # Print the minimum length of the shorter side\n    print(min_length)\n\nmin_triangle_side()"}
{"solution": "def max_nineteens(s):\n    from collections import Counter\n\n    # Count the frequency of each character in the string\n    char_count = Counter(s)\n\n    # Define the required frequency of each character in the word \"nineteen\"\n    required_counts = {'n': 3, 'i': 1, 'e': 3, 't': 1}\n\n    # Calculate the maximum number of \"nineteen\" words that can be formed\n    max_nineteens = float('inf')\n    for char, required in required_counts.items():\n        if char in char_count:\n            max_nineteens = min(max_nineteens, char_count[char] // required)\n        else:\n            return 0  # If any required character is missing, we can't form \"nineteen\"\n\n    return max_nineteens\n\n# Get the input string\ns = input()\n\n# Print the maximum number of \"nineteen\" words that can be formed\nprint(max_nineteens(s))"}
{"solution": "def highest_branch(p, y):\n    # Start from the highest branch and check downwards\n    for branch in range(y, 1, -1):\n        # Check if the branch is reachable by any grasshopper\n        for grasshopper in range(2, p + 1):\n            if branch % grasshopper == 0:\n                # If the branch is reachable, break the inner loop\n                break\n        else:\n            # If the branch is not reachable by any grasshopper, return it\n            return branch\n    # If no suitable branch is found, return -1\n    return -1\n\n# Read the input\np, y = map(int, input().split())\n\n# Print the output\nprint(highest_branch(p, y))"}
{"solution": "# Read input\nn, m, k = map(int, input().split())\nhouses = list(map(int, input().split()))\n\n# Initialize minimum distance to a large number\nmin_distance = float('inf')\n\n# Iterate through all houses\nfor i in range(n):\n    # Check if the house is affordable\n    if houses[i] <= k:\n        # Calculate the distance from the girl's house\n        distance = abs(m - i - 1) * 10\n        # Update the minimum distance\n        min_distance = min(min_distance, distance)\n\n# Print the minimum distance\nprint(min_distance)"}
{"solution": "def transpose_submatrix(matrix, x, y, k):\n    for i in range(x, x + k):\n        for j in range(y, y + k):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\ndef can_transform(A, B):\n    n, m = len(A), len(A[0])\n    for k in range(min(n, m), 0, -2):\n        for i in range(n - k + 1):\n            for j in range(m - k + 1):\n                transpose_submatrix(A, i, j, k)\n                if A == B:\n                    return True\n                transpose_submatrix(A, i, j, k)\n    return False\n\nn, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\nB = [list(map(int, input().split())) for _ in range(n)]\n\nif can_transform(A, B):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "# Get the input strings\na = input()\nb = input()\n\n# If the strings are equal, there's no uncommon subsequence\nif a == b:\n    print(-1)\n# Otherwise, the longest uncommon subsequence is the length of the longest string\nelse:\n    print(max(len(a), len(b)))"}
{"solution": "def find_intersection(a, b, c, d):\n    if a == c:\n        if b == d:\n            return b\n        else:\n            return -1\n    elif (d - b) % (a - c) == 0:\n        return max(b, d) + abs(d - b) // abs(a - c) * abs(a - c)\n    else:\n        return -1\n\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\nprint(find_intersection(a, b, c, d))"}
{"solution": "# Read the input\nn = int(input())\n\n# Initialize the three numbers\na, b, c = 1, 1, n - 2\n\n# Check if any of the numbers is a multiple of 3\nwhile a % 3 == 0 or b % 3 == 0 or c % 3 == 0:\n    # If a is a multiple of 3, increase b and decrease c\n    if a % 3 == 0:\n        a += 1\n        b += 1\n        c -= 2\n    # If b is a multiple of 3, increase c and decrease a\n    elif b % 3 == 0:\n        a -= 1\n        b += 1\n        c += 1\n    # If c is a multiple of 3, increase a and decrease b\n    else:\n        a += 1\n        b -= 1\n        c -= 1\n\n# Print the result\nprint(a, b, c)"}
{"solution": "def find_distinct_squares(n, a, b, c, d):\n    # Calculate the sum of the top left 2x2 square\n    top_left_sum = a + b\n\n    # Initialize the count of distinct squares\n    count = 0\n\n    # Iterate through all possible values for the unknown cells\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            for k in range(1, n + 1):\n                # Calculate the sum of the other 2x2 squares\n                other_sum = i + j + k + d\n\n                # Check if the sums are equal and the values are distinct\n                if top_left_sum == other_sum and len({a, b, c, d, i, j, k}) == 6:\n                    count += 1\n\n    return count\n\n# Read the input\nn, a, b, c, d = map(int, input().split())\n\n# Print the result\nprint(find_distinct_squares(n, a, b, c, d))"}
{"solution": "# Read input\nw, h = map(int, input().split())\nu1, d1 = map(int, input().split())\nu2, d2 = map(int, input().split())\n\n# Simulate the snowball's descent\nwhile h > 0:\n    # Increase weight by current height\n    w += h\n\n    # Check if the snowball hits a stone\n    if h == d1:\n        w = max(0, w - u1)\n    elif h == d2:\n        w = max(0, w - u2)\n\n    # Move the snowball down\n    h -= 1\n\n# Print the final weight\nprint(w)"}
{"solution": "# Read the input\nm = int(input())\nscores = list(map(int, input().split()))\nx, y = map(int, input().split())\n\n# Initialize the cumulative sum of scores\ncumulative_scores = [0] * (m + 1)\nfor i in range(1, m + 1):\n    cumulative_scores[i] = cumulative_scores[i - 1] + scores[i - 1]\n\n# Iterate over possible passing rates\nfor k in range(1, m + 1):\n    # Calculate the size of each group\n    beginner_group_size = cumulative_scores[k - 1]\n    intermediate_group_size = cumulative_scores[m] - beginner_group_size\n\n    # Check if the size of each group is within the specified range\n    if x <= beginner_group_size <= y and x <= intermediate_group_size <= y:\n        print(k)\n        break\nelse:\n    print(0)"}
{"solution": "def min_coins(n, k, A, B):\n    coins = 0\n    while n > 1:\n        if n % k == 0 and B < A:\n            n //= k\n            coins += B\n        else:\n            n -= 1\n            coins += A\n    return coins\n\nn = int(input())\nk = int(input())\nA = int(input())\nB = int(input())\n\nprint(min_coins(n, k, A, B))"}
{"solution": "import math\n\ndef min_operations(n):\n    operations = 0\n    while n % 2 == 0:\n        n = math.isqrt(n)\n        operations += 1\n    while n % 4 == 1:\n        n *= 2\n        operations += 1\n    return n, operations\n\nn = int(input())\nmin_n, min_operations = min_operations(n)\nprint(min_n, min_operations)"}
{"solution": "# Get input\nn, k = map(int, input().split())\nr, s, p = map(int, input().split())\nt = input()\n\n# Initialize score and last_hands list\nscore = 0\nlast_hands = [-1] * k\n\n# Iterate over each round\nfor i in range(n):\n    # Get machine's hand\n    machine_hand = t[i]\n\n    # If it's within the first k rounds, choose the hand that gives the most points\n    if i < k:\n        if machine_hand == 'r':\n            hand = 'p'\n            score += p\n        elif machine_hand == 's':\n            hand = 'r'\n            score += r\n        else:\n            hand = 's'\n            score += s\n\n    # If it's after the first k rounds, choose the hand that gives the most points and hasn't been used in the last k rounds\n    else:\n        if machine_hand == 'r':\n            if last_hands[i % k] != 'p':\n                hand = 'p'\n                score += p\n            else:\n                hand = 's'\n                score += s\n        elif machine_hand == 's':\n            if last_hands[i % k] != 'r':\n                hand = 'r'\n                score += r\n            else:\n                hand = 'p'\n                score += p\n        else:\n            if last_hands[i % k] != 's':\n                hand = 's'\n                score += s\n            else:\n                hand = 'r'\n                score += r\n\n    # Update last_hands list\n    last_hands[i % k] = hand\n\n# Print the maximum total score\nprint(score)"}
{"solution": "# Read input\na, b, c = map(int, input().split())\n\n# Calculate the maximum possible length of the good string\nmax_length = 2 * min(a, b) + 2 * c\nif a != b:\n    max_length += 1\n\n# Print the result\nprint(max_length)"}
{"solution": "def solve_vova_marks(n, k, p, x, y, marks):\n    remaining_tests = n - k\n    current_sum = sum(marks)\n    marks.sort()\n    current_median = marks[k // 2]\n\n    if current_sum + remaining_tests * y > x:\n        return -1\n\n    target_sum = x - current_sum\n    if target_sum < remaining_tests * y:\n        return -1\n\n    remaining_marks = [y] * remaining_tests\n    remaining_sum = remaining_tests * y\n    for i in range(remaining_tests):\n        if remaining_sum > target_sum:\n            remaining_marks[i] = y - 1\n            remaining_sum -= 1\n        else:\n            break\n\n    return remaining_marks\n\nn, k, p, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\n\nresult = solve_vova_marks(n, k, p, x, y, marks)\nif result == -1:\n    print(-1)\nelse:\n    print(*result)"}
{"solution": "def is_berlanese(word):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    prev_char = ''\n\n    for char in word:\n        if char not in vowels and prev_char != 'n' and prev_char not in vowels:\n            return False\n        prev_char = char\n\n    if prev_char not in vowels and prev_char != 'n':\n        return False\n\n    return True\n\nword = input()\nif is_berlanese(word):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def max_dominoes(n, m, edges):\n    # Create an adjacency list representation of the graph\n    graph = [[] for _ in range(n + 1)]\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    # Initialize a color array to store the color of each vertex\n    color = [0] * (n + 1)\n\n    # Initialize a variable to store the maximum number of dominoes that can be placed\n    max_dominoes = 0\n\n    # Function to check if a vertex can be colored with a given color\n    def is_valid_color(vertex, c):\n        for neighbor in graph[vertex]:\n            if color[neighbor] == c:\n                return False\n        return True\n\n    # Function to perform depth-first search and color the vertices\n    def dfs(vertex, c):\n        nonlocal max_dominoes\n        color[vertex] = c\n        max_dominoes = max(max_dominoes, c)\n        for neighbor in graph[vertex]:\n            if color[neighbor] == 0 and is_valid_color(neighbor, c):\n                dfs(neighbor, c)\n\n    # Perform depth-first search for each uncolored vertex\n    for vertex in range(1, n + 1):\n        if color[vertex] == 0:\n            dfs(vertex, 1)\n\n    return max_dominoes\n\n# Read input\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Print output\nprint(max_dominoes(n, m, edges))"}
{"solution": "import sys\n\ndef max_points(n, m, a, b):\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    b = set(b)\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if j in b:\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j - 1] + a[j - 1], dp[i - 1][j] + a[j - 1])\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j - 1] + a[j - 1])\n\n    return dp[m][n]\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    a = list(map(int, sys.stdin.readline().split()))\n    b = list(map(int, sys.stdin.readline().split()))\n\n    print(max_points(n, m, a, b))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "# Get the input\nm = list(map(int, input().split()))\nw = list(map(int, input().split()))\nh = list(map(int, input().split()))\n\n# Define the maximum point values for each problem\nmax_points = [500, 1000, 1500, 2000, 2500]\n\n# Calculate the score for each problem\nscores = [max(0.3 * max_points[i], (1 - m[i] / 250) * max_points[i] - 50 * w[i]) for i in range(5)]\n\n# Calculate the total score\ntotal_score = sum(scores) + h[0] * 100 - h[1] * 50\n\n# Print the final score\nprint(int(total_score))"}
{"solution": "MOD = 998244353\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1:\n            res = (res * x) % p\n        y = y >> 1\n        x = (x * x) % p\n    return res\n\ndef find_grids(n, m, L, R):\n    if L == R:\n        return 1\n    if L + 1 == R:\n        return 2 if n * m % 2 == 0 else 1\n    if n * m % 2 == 1:\n        return (power(2, n * m, MOD) - 2 * power(2, n * m - 1, MOD)) % MOD\n    else:\n        return (power(2, n * m, MOD) - 2 * power(2, n * m - 1, MOD) + power(2, n * m // 2, MOD)) % MOD\n\nn, m, L, R = map(int, input().split())\nprint(find_grids(n, m, L, R))"}
{"solution": "def is_possible_to_make_increasing(n, m, matrix_a, matrix_b):\n    for i in range(n):\n        for j in range(m):\n            # Ensure that matrix_a[i][j] is the smaller or equal element\n            if matrix_a[i][j] > matrix_b[i][j]:\n                matrix_a[i][j], matrix_b[i][j] = matrix_b[i][j], matrix_a[i][j]\n\n    # Check rows for strictly increasing property\n    for i in range(n):\n        for j in range(1, m):\n            if matrix_a[i][j] <= matrix_a[i][j-1] or matrix_b[i][j] <= matrix_b[i][j-1]:\n                return \"Impossible\"\n\n    # Check columns for strictly increasing property\n    for j in range(m):\n        for i in range(1, n):\n            if matrix_a[i][j] <= matrix_a[i-1][j] or matrix_b[i][j] <= matrix_b[i-1][j]:\n                return \"Impossible\"\n\n    return \"Possible\"\n\n# Read input\nn, m = map(int, input().split())\nmatrix_a = [list(map(int, input().split())) for _ in range(n)]\nmatrix_b = [list(map(int, input().split())) for _ in range(n)]\n\n# Print output\nprint(is_possible_to_make_increasing(n, m, matrix_a, matrix_b))"}
{"solution": "# Read the input\nn = int(input())\na = list(map(int, input().split()))\n\n# Sort the list in descending order\na.sort(reverse=True)\n\n# Initialize the result\nresult = 0\n\n# Iterate over the sorted list\nfor i in range(n):\n    # The current letter can be used at most min(i+1, a[i]) times\n    result += min(i+1, a[i])\n\n# Print the result\nprint(result)"}
{"solution": "# Read the input\nn, k = map(int, input().split())\nproblems = list(map(int, input().split()))\n\n# Sort the problems in ascending order\nproblems.sort()\n\n# Initialize the count of problems to solve on other judges\ncount = 0\n\n# Initialize the maximum difficulty of problems that can be solved\nmax_difficulty = k\n\n# Iterate over the problems\nfor problem in problems:\n    # If the current problem can't be solved\n    if problem > max_difficulty:\n        # Calculate the minimum difficulty of the problem that needs to be solved on other judges\n        min_difficulty = problem // 2\n\n        # If the maximum difficulty of problems that can be solved is less than the minimum difficulty of the problem that needs to be solved on other judges\n        if max_difficulty < min_difficulty:\n            # Increment the count of problems to solve on other judges\n            count += 1\n\n            # Update the maximum difficulty of problems that can be solved\n            max_difficulty = min_difficulty * 2\n\n    # Update the maximum difficulty of problems that can be solved\n    max_difficulty = max(max_difficulty, problem)\n\n# Print the minimum number of problems to solve on other judges\nprint(count)"}
{"solution": "def distribute_diplomas(n, min_1, max_1, min_2, max_2, min_3, max_3):\n    # Start with the maximum number of first-degree diplomas\n    first_degree = max_1\n    # Calculate the remaining participants after giving first-degree diplomas\n    remaining = n - first_degree\n\n    # Distribute second-degree diplomas\n    if remaining >= min_2:\n        second_degree = min_2\n        remaining -= second_degree\n    else:\n        second_degree = remaining\n        remaining = 0\n\n    # Distribute third-degree diplomas\n    if remaining >= min_3:\n        third_degree = min_3\n    else:\n        third_degree = remaining\n\n    # If there are still diplomas left to distribute,\n    # try to increase the number of second-degree diplomas\n    if second_degree < max_2 and remaining > 0:\n        second_degree += min(remaining, max_2 - second_degree)\n        remaining -= min(remaining, max_2 - second_degree)\n\n    # If there are still diplomas left to distribute,\n    # increase the number of third-degree diplomas\n    if third_degree < max_3 and remaining > 0:\n        third_degree += min(remaining, max_3 - third_degree)\n\n    # If there are still diplomas left to distribute,\n    # decrease the number of first-degree diplomas\n    if first_degree > min_1 and remaining > 0:\n        first_degree -= min(remaining, first_degree - min_1)\n\n    return first_degree, second_degree, third_degree\n\n# Read input\nn = int(input())\nmin_1, max_1 = map(int, input().split())\nmin_2, max_2 = map(int, input().split())\nmin_3, max_3 = map(int, input().split())\n\n# Distribute diplomas\nfirst_degree, second_degree, third_degree = distribute_diplomas(n, min_1, max_1, min_2, max_2, min_3, max_3)\n\n# Print output\nprint(first_degree, second_degree, third_degree)"}
{"solution": "# Read the number of days Vitya was watching the moon\nn = int(input())\n\n# Read Vitya's records\nrecords = list(map(int, input().split()))\n\n# Define the moon cycle\nmoon_cycle = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n\n# Check if the records match the end of the moon cycle\nif records[-1] == 0 and records[-2] == 1:\n    print(\"UP\")\n# Check if the records match the start of the moon cycle\nelif records[-1] == 1 and records[-2] == 0:\n    print(\"DOWN\")\n# Check if the records match the peak of the moon cycle\nelif records[-1] == 15 and records[-2] == 14:\n    print(\"DOWN\")\n# Check if the records match the trough of the moon cycle\nelif records[-1] == 14 and records[-2] == 15:\n    print(\"UP\")\n# If the records don't match any clear pattern\nelse:\n    print(\"-1\")"}
{"solution": "def can_transform(s, t):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n\n    # Check if lengths are the same\n    if len(s) != len(t):\n        return \"No\"\n\n    # Check each character\n    for char_s, char_t in zip(s, t):\n        if (char_s in vowels) != (char_t in vowels):\n            return \"No\"\n\n    return \"Yes\"\n\n# Read input\ns = input().strip()\nt = input().strip()\n\n# Output the result\nprint(can_transform(s, t))"}
{"solution": "def determine_winner(board):\n    # Find the minimum number of moves required for player A to reach row 1\n    min_moves_a = float('inf')\n    for i in range(8):\n        for j in range(8):\n            if board[i][j] == 'W':\n                min_moves_a = min(min_moves_a, i)\n\n    # Find the minimum number of moves required for player B to reach row 8\n    min_moves_b = float('inf')\n    for i in range(8):\n        for j in range(8):\n            if board[i][j] == 'B':\n                min_moves_b = min(min_moves_b, 7 - i)\n\n    # Determine the winner based on the minimum number of moves required\n    if min_moves_a <= min_moves_b:\n        return 'A'\n    else:\n        return 'B'\n\n# Read the input board configuration\nboard = []\nfor _ in range(8):\n    row = input()\n    board.append(list(row))\n\n# Determine the winner\nwinner = determine_winner(board)\nprint(winner)"}
{"solution": "def max_equal_length(n, A, m, B):\n    if sum(A) != sum(B):\n        return -1\n\n    i, j = 0, 0\n    sumA, sumB = 0, 0\n    count = 0\n\n    while i < n and j < m:\n        sumA += A[i]\n        sumB += B[j]\n\n        if sumA == sumB:\n            count += 1\n            sumA = 0\n            sumB = 0\n            i += 1\n            j += 1\n        elif sumA < sumB:\n            i += 1\n        else:\n            j += 1\n\n    return count\n\nn = int(input())\nA = list(map(int, input().split()))\nm = int(input())\nB = list(map(int, input().split()))\n\nprint(max_equal_length(n, A, m, B))"}
{"solution": "# Define Alex's friends' names\nfriends_names = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\n\n# Get the problem name from the input\nproblem_name = input()\n\n# Initialize a counter for the number of friends' names found in the problem name\nname_count = 0\n\n# Check each friend's name in the problem name\nfor name in friends_names:\n    # If the name is found, increment the counter\n    if name in problem_name:\n        name_count += 1\n\n# Check if the problem name contains exactly one of Alex's friends' names\nif name_count == 1:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def sieve(n):\n    is_prime = [True] * (n + 1)\n    p = 2\n    while (p * p <= n):\n        if (is_prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                is_prime[i] = False\n        p += 1\n    is_prime[0], is_prime[1] = False, False  # 0 and 1 are not primes\n    return is_prime\n\ndef count_primes_in_range(is_prime, a, b):\n    prime_count = [0] * (b + 1)\n    for i in range(a, b + 1):\n        prime_count[i] = prime_count[i - 1] + (1 if is_prime[i] else 0)\n    return prime_count\n\ndef min_length_with_k_primes(a, b, k):\n    is_prime = sieve(b)\n    prime_count = count_primes_in_range(is_prime, a, b)\n\n    def has_k_primes_in_length(l):\n        for x in range(a, b - l + 2):\n            if prime_count[x + l - 1] - prime_count[x - 1] >= k:\n                return True\n        return False\n\n    left, right = 1, b - a + 1\n    result = -1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if has_k_primes_in_length(mid):\n            result = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return result\n\n# Input\na, b, k = map(int, input().split())\n\n# Output\nprint(min_length_with_k_primes(a, b, k))"}
{"solution": "def calculate_min_distance(a, h, w):\n    # Calculate the maximum number of photos that can fit in the wall\n    max_photos_h = h // a\n    max_photos_w = w // a\n\n    # If there is no way to put positive number of photos and satisfy the constraints\n    if max_photos_h == 0 or max_photos_w == 0:\n        return -1\n\n    # Calculate the minimum value of x which can be obtained after putting the photos on the wall\n    min_distance_h = h / (max_photos_h + 1)\n    min_distance_w = w / (max_photos_w + 1)\n\n    return max(min_distance_h, min_distance_w)\n\n# Read the input\na, h, w = map(int, input().split())\n\n# Calculate the minimum value of x\nresult = calculate_min_distance(a, h, w)\n\n# Print the result\nprint(result)"}
{"solution": "# Read the number of chapters\nn = int(input())\n\n# Initialize an empty list to store the chapters\nchapters = []\n\n# Read the chapters' start and end pages\nfor _ in range(n):\n    l, r = map(int, input().split())\n    chapters.append((l, r))\n\n# Read the marked page\nk = int(input())\n\n# Initialize a counter for unread chapters\nunread_chapters = 0\n\n# Iterate over the chapters\nfor l, r in chapters:\n    # If the marked page is within the chapter or the chapter starts after the marked page,\n    # increment the counter\n    if k <= l or k > r:\n        unread_chapters += 1\n\n# Print the number of unread chapters\nprint(unread_chapters)"}
{"solution": "def can_form_codeforces(word):\n    target = \"CODEFORCES\"\n    n = len(word)\n    m = len(target)\n\n    if n < m:\n        return \"NO\"\n\n    for i in range(m + 1):\n        if word[:i] == target[:i] and word[n - (m - i):] == target[i:]:\n            return \"YES\"\n\n    return \"NO\"\n\n# Get the input word\nword = input()\n\n# Print the result\nprint(can_form_codeforces(word))"}
{"solution": "def min_weight_triangulation(n):\n    # Create a table to store the minimum weight of triangulation for subpolygons\n    dp = [[0] * n for _ in range(n)]\n\n    # Calculate the minimum weight of triangulation for subpolygons with length 2 to n\n    for length in range(2, n):\n        for i in range(n - length):\n            j = i + length\n            dp[i][j] = float('inf')\n\n            # Try all possible triangles to divide the subpolygon\n            for k in range(i + 1, j):\n                # Calculate the weight of the current triangle\n                weight = (i + 1) * (k + 1) * (j + 1)\n\n                # Calculate the weight of the triangulation for the left and right subpolygons\n                left_weight = dp[i][k] if k > i + 1 else 0\n                right_weight = dp[k][j] if j > k + 1 else 0\n\n                # Update the minimum weight of triangulation for the current subpolygon\n                dp[i][j] = min(dp[i][j], weight + left_weight + right_weight)\n\n    # Return the minimum weight of triangulation for the entire polygon\n    return dp[0][n - 1]\n\n# Read the input\nn = int(input())\n\n# Calculate and print the minimum weight of triangulation\nresult = min_weight_triangulation(n)\nprint(result)"}
{"solution": "# Get the input\nn = int(input())\n\n# Initialize the total number of digits\ntotal_digits = 0\n\n# Calculate the total number of digits\n# For numbers from 1 to 9, there is 1 digit for each number\n# For numbers from 10 to 99, there are 2 digits for each number\n# And so on...\n\n# Calculate the number of digits for numbers from 1 to 9\ntotal_digits += 9 * 1\n\n# Calculate the number of digits for numbers from 10 to 99\ntotal_digits += 90 * 2\n\n# Calculate the number of digits for numbers from 100 to 999\ntotal_digits += 900 * 3\n\n# And so on...\n# We stop at 10^9 because the maximum input is 10^9\n\n# Calculate the number of digits for numbers from 10^i to 10^(i+1) - 1\ni = 3\nwhile i < 10:\n    total_digits += 9 * (10 ** (i - 1)) * i\n    i += 1\n\n# If n is less than 10^9, we need to calculate the number of digits for numbers from 1 to n\n# We can do this by subtracting the number of digits for numbers from n+1 to 10^9\nif n < 10**9:\n    total_digits -= (10**9 - n) * len(str(10**9))\n    total_digits += sum(len(str(i)) for i in range(n+1, 10**9 + 1))\n\n# Print the result\nprint(total_digits)"}
{"solution": "# Read input\nn, A = map(int, input().split())\ncars = list(map(int, input().split()))\n\n# Initialize counts\ncount_A = 0\ncount_B = 0\n\n# Initialize potential colors for Bob\npotential_colors = set(cars)\npotential_colors.discard(A)\n\n# Iterate through cars\nfor car in cars:\n    # Update counts\n    if car == A:\n        count_A += 1\n    elif car in potential_colors:\n        count_B += 1\n\n    # Check if Bob can still win with remaining potential colors\n    if count_B < count_A:\n        potential_colors.discard(car)\n\n# Print the result\nif potential_colors:\n    print(potential_colors.pop())\nelse:\n    print(-1)"}
{"solution": "# Read input\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculate the total length of segments and the number of gaps\ntotal_length = sum(a)\nnum_gaps = n - 1\n\n# Check if the total length of segments and gaps is equal to the crossword length\nif total_length + num_gaps == x:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "# Read the input\nn, S = map(int, input().split())\n\n# Initialize the number of coins required\ncoins = 0\n\n# Start from the largest coin value\ncoin_value = n\n\n# While the sum is not achieved\nwhile S > 0:\n    # If the coin value is less than or equal to the sum\n    if coin_value <= S:\n        # Subtract the coin value from the sum\n        S -= coin_value\n        # Increment the number of coins\n        coins += 1\n    # If the coin value is greater than the sum\n    else:\n        # Move to the next smaller coin value\n        coin_value -= 1\n\n# Print the minimum number of coins required\nprint(coins)"}
{"solution": "from collections import Counter\n\ndef min_changes_palindrome(s):\n    # Count the frequency of each character\n    counter = Counter(s)\n\n    # Initialize the result string\n    result = [''] * len(s)\n\n    # Initialize the left and right pointers\n    left, right = 0, len(s) - 1\n\n    # Initialize the middle character\n    middle = ''\n\n    # Iterate through the string\n    while left <= right:\n        # If the left and right characters are the same\n        if left == right:\n            # If there's an odd number of characters, assign the middle character\n            if middle:\n                result[left] = middle\n            break\n        # If the left and right characters are different\n        else:\n            # Iterate through the characters in alphabetical order\n            for char in 'abcdefghijklmnopqrstuvwxyz':\n                # If both the left and right characters have a count greater than 0\n                if counter[char] > 1:\n                    # Assign the character to the left and right positions\n                    result[left], result[right] = char, char\n                    # Decrease the count of the character\n                    counter[char] -= 2\n                    # Move the pointers inward\n                    left += 1\n                    right -= 1\n                    break\n            # If no common character is found, assign the first available character to the middle\n            else:\n                for char in 'abcdefghijklmnopqrstuvwxyz':\n                    if counter[char] > 0:\n                        middle = char\n                        counter[char] -= 1\n                        break\n\n    # Join the result string and return it\n    return ''.join(result)\n\n# Read the input string\ns = input()\n\n# Print the result\nprint(min_changes_palindrome(s))"}
{"solution": "def calculate_weight(board):\n    piece_weights = {\n        'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'P': 1,\n        'q': 9, 'r': 5, 'b': 3, 'n': 3, 'p': 1\n    }\n\n    white_weight = 0\n    black_weight = 0\n\n    for row in board:\n        for piece in row:\n            if piece in piece_weights:\n                if piece.isupper():\n                    white_weight += piece_weights[piece]\n                else:\n                    black_weight += piece_weights[piece]\n\n    if white_weight > black_weight:\n        return \"White\"\n    elif black_weight > white_weight:\n        return \"Black\"\n    else:\n        return \"Draw\"\n\n# Example usage:\nboard = [\n    \"...QK...\",\n    \"........\",\n    \"........\",\n    \"........\",\n    \"........\",\n    \"........\",\n    \"........\",\n    \"...rk...\"\n]\n\ncalculate_weight(board)"}
{"solution": "from collections import deque\nimport sys\n\ndef main():\n    n, m = map(int, sys.stdin.readline().split())\n    s = sys.stdin.readline().strip()\n\n    # dp[i] is the minimum number of turns to reach square i\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n\n    # prev[i] is the previous square that leads to square i in the optimal solution\n    prev = [-1] * (n + 1)\n\n    # moves[i] is the move taken to reach square i in the optimal solution\n    moves = [-1] * (n + 1)\n\n    # BFS to find the optimal solution\n    queue = deque([0])\n    while queue:\n        curr = queue.popleft()\n        for move in range(1, m + 1):\n            next = curr + move\n            if next > n or s[next] == '1':\n                continue\n            if dp[next] > dp[curr] + 1:\n                dp[next] = dp[curr] + 1\n                prev[next] = curr\n                moves[next] = move\n                queue.append(next)\n\n    # If Takahashi cannot win the game, print -1\n    if dp[n] == float('inf'):\n        print(-1)\n    else:\n        # Reconstruct the optimal sequence of moves\n        sequence = []\n        curr = n\n        while curr != 0:\n            sequence.append(moves[curr])\n            curr = prev[curr]\n        sequence.reverse()\n        print(*sequence)\n\nif __name__ == '__main__':\n    main()"}
{"solution": "def solve(k, x, y):\n    # If the difference between x and y is not a multiple of k, the game cannot be finished\n    if abs(x - y) % k != 0:\n        return -1\n\n    # Calculate the number of steps needed\n    steps = (abs(x) + abs(y)) // k\n\n    # If the sum of x and y is less than k, the game cannot be finished\n    if steps * k < abs(x) + abs(y):\n        return -1\n\n    # Calculate the path\n    path = []\n    for i in range(steps):\n        # Move diagonally towards the target\n        path.append((x if x > 0 else -x, y if y > 0 else -y))\n\n        # Update the position\n        x -= path[-1][0]\n        y -= path[-1][1]\n\n        # If the remaining distance is less than k, move directly to the target\n        if abs(x) + abs(y) < k:\n            path.append((0, 0))\n            break\n\n    # Add the target position\n    path.append((0, 0))\n\n    # Return the path\n    return path\n\n# Read the input\nk = int(input())\nx, y = map(int, input().split())\n\n# Solve the problem\npath = solve(k, x, y)\n\n# Print the output\nif path == -1:\n    print(-1)\nelse:\n    print(len(path) - 1)\n    for point in path:\n        print(*point)"}
{"solution": "def find_smallest_n(m):\n    # Iterate over possible values of n\n    for n in range(1, m + 1):\n        # Initialize the number of ways to steal chocolates\n        ways = 0\n        # Iterate over possible values of k\n        for k in range(2, m + 1):\n            # Calculate the number of chocolates stolen by the first thief\n            first = n // (k ** 3 - k ** 2 - k + 1)\n            # Check if the first thief stole at least one chocolate\n            if first < 1:\n                break\n            # Calculate the number of chocolates stolen by the second, third, and fourth thieves\n            second = first * k\n            third = second * k\n            fourth = third * k\n            # Check if the total number of chocolates stolen is equal to n\n            if first + second + third + fourth == n:\n                # Increment the number of ways to steal chocolates\n                ways += 1\n        # Check if the number of ways to steal chocolates is equal to m\n        if ways == m:\n            # Return the value of n\n            return n\n    # If no value of n satisfies the rumors, return -1\n    return -1\n\n# Read the input\nm = int(input())\n# Find the smallest possible value of n\nn = find_smallest_n(m)\n# Print the output\nprint(n)"}
{"solution": "import math\n\ndef circle_intersection_area(x1, y1, r1, x2, y2, r2):\n    # Calculate the distance between the centers of the two circles\n    d = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n\n    # If the circles do not intersect, return 0\n    if d > r1 + r2:\n        return 0\n\n    # If one circle is contained within the other, return the area of the smaller circle\n    if d < abs(r1 - r2):\n        return min(math.pi * r1**2, math.pi * r2**2)\n\n    # Calculate the angles subtended by the circular segments at the centers of the circles\n    theta1 = 2 * math.acos(r1 / d)\n    theta2 = 2 * math.acos(r2 / d)\n\n    # Calculate the area of the circular segments\n    segment1 = 0.5 * r1**2 * (theta1 - math.sin(theta1))\n    segment2 = 0.5 * r2**2 * (theta2 - math.sin(theta2))\n\n    # Return the area of intersection\n    return segment1 + segment2\n\n# Read the input\nx1, y1, r1 = map(int, input().split())\nx2, y2, r2 = map(int, input().split())\n\n# Print the area of intersection\nprint(circle_intersection_area(x1, y1, r1, x2, y2, r2))"}
{"solution": "def minimize_n(v):\n    # If v is 1, return 1 as the minimum value\n    if v == 1:\n        return 1\n    # Otherwise, return 1 as the minimum value by subtracting a non-divisor\n    else:\n        return 1\n\n# Read the input value of v\nv = int(input())\n\n# Print the minimum value of n\nprint(minimize_n(v))"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    n = int(sys.stdin.readline())\n    parents = list(map(int, sys.stdin.readline().split()))\n    citizens = list(map(int, sys.stdin.readline().split()))\n\n    graph = defaultdict(list)\n    for i, parent in enumerate(parents, 2):\n        graph[parent].append(i)\n\n    def dfs(node):\n        nonlocal total_citizens, caught_citizens\n        if not graph[node]:\n            caught_citizens += citizens[node - 1]\n            return citizens[node - 1]\n\n        max_citizens = 0\n        for child in graph[node]:\n            max_citizens = max(max_citizens, dfs(child))\n\n        total_citizens -= max_citizens\n        caught_citizens += citizens[node - 1] - max_citizens\n        return citizens[node - 1] - max_citizens\n\n    total_citizens = sum(citizens)\n    caught_citizens = 0\n    dfs(1)\n\n    print(caught_citizens)\n\nsolve()"}
{"solution": "def count_typo_words(n, S, T):\n    count = 0\n    for i in range(n + 1):\n        # Construct W by inserting a character at position i in both S and T\n        if i == 0:\n            W1 = S[0] + S\n            W2 = T[0] + T\n        elif i == n:\n            W1 = S + S[-1]\n            W2 = T + T[-1]\n        else:\n            W1 = S[:i] + S[i] + S[i:]\n            W2 = T[:i] + T[i] + T[i:]\n\n        # Check if the constructed words are the same\n        if W1 == W2:\n            count += 1\n\n    return count\n\n# Read input\nn = int(input())\nS = input().strip()\nT = input().strip()\n\n# Print output\nprint(count_typo_words(n, S, T))"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef read_input():\n    n = int(sys.stdin.readline())\n    strengths = list(map(int, sys.stdin.readline().split()))\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        u, v = map(int, sys.stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    return n, strengths, graph\n\ndef dfs(node, parent, strengths, graph, max_strength):\n    original_strength = strengths[node - 1]\n    strengths[node - 1] = float('inf')\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            dfs(neighbor, node, strengths, graph, max_strength)\n            strengths[node - 1] = min(strengths[node - 1], strengths[neighbor - 1] + 1)\n    strengths[node - 1] = min(strengths[node - 1], original_strength)\n    max_strength[0] = max(max_strength[0], strengths[node - 1])\n\ndef find_min_strength(n, strengths, graph):\n    max_strength = [0]\n    dfs(1, 0, strengths, graph, max_strength)\n    return max_strength[0]\n\nn, strengths, graph = read_input()\nmin_strength = find_min_strength(n, strengths, graph)\nprint(min_strength)"}
{"solution": "def max_groups(n, m):\n    return min(m, n - m)\n\nn, m = map(int, input().split())\nprint(max_groups(n, m))"}
{"solution": "# Get the input\nk, r = map(int, input().split())\n\n# Initialize the minimum number of shovels needed\nmin_shovels = 1\n\n# Loop until the minimum number of shovels is found\nwhile True:\n    # Calculate the total cost\n    total_cost = min_shovels * k\n\n    # Check if the total cost can be paid without any change\n    if total_cost % 10 == r or total_cost % 10 == 0:\n        break\n\n    # Increment the minimum number of shovels needed\n    min_shovels += 1\n\n# Print the result\nprint(min_shovels)"}
{"solution": "def can_form_rectangle(n, m, grid):\n    # Find the bounding box of the 'X' characters\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'X':\n                min_row = min(min_row, i)\n                max_row = max(max_row, i)\n                min_col = min(min_col, j)\n                max_col = max(max_col, j)\n\n    # Dimensions of the bounding box\n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n\n    # Extract the bounding box\n    piece = []\n    for i in range(min_row, max_row + 1):\n        piece.append(grid[i][min_col:max_col + 1])\n\n    # Check horizontal placement\n    if width * 2 == m:\n        valid = True\n        for i in range(height):\n            for j in range(width):\n                if piece[i][j] != piece[i][j + width]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return \"YES\"\n\n    # Check vertical placement\n    if height * 2 == n:\n        valid = True\n        for i in range(height):\n            for j in range(width):\n                if piece[i][j] != piece[i + height][j]:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            return \"YES\"\n\n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(can_form_rectangle(n, m, grid))"}
{"solution": "# Read the coordinates of the three points\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\nx3, y3 = map(int, input().split())\n\n# Check if all three points share the same x-coordinate or the same y-coordinate\nif x1 == x2 == x3 or y1 == y2 == y3:\n    print(1)\n# Check if two points share the same x-coordinate or y-coordinate\nelif x1 == x2 or x1 == x3 or x2 == x3 or y1 == y2 or y1 == y3 or y2 == y3:\n    print(2)\n# If no two points share the same x-coordinate or y-coordinate\nelse:\n    print(3)"}
{"solution": "def create_graph(k):\n    if k % 2 != 0:\n        return \"NO\"\n    else:\n        n = 2 * (k // 2)\n        m = k * n // 2\n        edges = []\n        for i in range(1, k // 2 + 1):\n            edges.append((i, i + k // 2))\n        for i in range(k // 2 + 1, n + 1):\n            for j in range(1, k // 2 + 1):\n                edges.append((i, j))\n        return \"YES\\n\" + str(n) + \" \" + str(m) + \"\\n\" + \"\\n\".join([\" \".join(map(str, edge)) for edge in edges])\n\nk = int(input())\nprint(create_graph(k))"}
{"solution": "def compute_prefix_function(pattern):\n    prefix_function = [0]\n    for i in range(1, len(pattern)):\n        j = prefix_function[i - 1]\n        while j > 0 and pattern[j] != pattern[i]:\n            j = prefix_function[j - 1]\n        if pattern[j] == pattern[i]:\n            j += 1\n        prefix_function.append(j)\n    return prefix_function\n\ndef kmp_algorithm(text, pattern):\n    prefix_function = compute_prefix_function(pattern)\n    occurrences = [0] * (len(text) - len(pattern) + 1)\n    j = 0\n    for i in range(len(text)):\n        while j > 0 and pattern[j] != text[i]:\n            j = prefix_function[j - 1]\n        if pattern[j] == text[i]:\n            j += 1\n        if j == len(pattern):\n            occurrences[i - len(pattern) + 1] = 1\n            j = prefix_function[j - 1]\n    return occurrences\n\ndef solve_query(s, t, l, r):\n    return sum(occurrences[l - 1:r])\n\nn, m, q = map(int, input().split())\ns = input()\nt = input()\noccurrences = kmp_algorithm(s, t)\nfor _ in range(q):\n    l, r = map(int, input().split())\n    print(solve_query(s, t, l, r))"}
{"solution": "MOD = 1000000007\n\ndef count_paths(n, k, d):\n    dp = [[0] * (n + 1) for _ in range(k + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, k + 1):\n        for j in range(n + 1):\n            for l in range(1, min(i, j) + 1):\n                if l >= d:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - l]) % MOD\n\n    return sum(dp[k][n - i] for i in range(d, n + 1)) % MOD\n\nn, k, d = map(int, input().split())\nprint(count_paths(n, k, d))"}
{"solution": "def encrypt_japanese_crossword(n, row):\n    groups = []\n    count = 0\n\n    for char in row:\n        if char == 'B':\n            count += 1\n        else:\n            if count > 0:\n                groups.append(count)\n                count = 0\n\n    if count > 0:\n        groups.append(count)\n\n    print(len(groups))\n    if groups:\n        print(\" \".join(map(str, groups)))\n\nn = int(input())\nrow = input().strip()\nencrypt_japanese_crossword(n, row)"}
{"solution": "def process_sequence(sequence, operations, cursor):\n    stack = []\n    for i, bracket in enumerate(sequence):\n        if bracket == '(':\n            stack.append(i)\n        else:\n            start = stack.pop()\n            sequence[start] = sequence[i] = ''\n    cursor -= 1\n    for operation in operations:\n        if operation == 'L':\n            cursor -= 1\n        elif operation == 'R':\n            cursor += 1\n        else:\n            start = end = cursor\n            while sequence[start] != '':\n                start -= 1\n            while sequence[end] != '':\n                end += 1\n            sequence[start:end] = ''\n            if cursor > end:\n                cursor = end\n            else:\n                cursor = start\n    return ''.join(sequence)\n\nn, m, p = map(int, input().split())\nsequence = list(input())\noperations = input()\nprint(process_sequence(sequence, operations, p))"}
{"solution": "def find_number(queries):\n    lower_bound = -2 * 10 ** 9\n    upper_bound = 2 * 10 ** 9\n\n    for query in queries:\n        sign, number, answer = query\n        number = int(number)\n\n        if answer == 'Y':\n            if sign == '>':\n                lower_bound = max(lower_bound, number + 1)\n            elif sign == '<':\n                upper_bound = min(upper_bound, number - 1)\n            elif sign == '>=':\n                lower_bound = max(lower_bound, number)\n            elif sign == '<=':\n                upper_bound = min(upper_bound, number)\n        else:\n            if sign == '>':\n                upper_bound = min(upper_bound, number)\n            elif sign == '<':\n                lower_bound = max(lower_bound, number)\n            elif sign == '>=':\n                upper_bound = min(upper_bound, number - 1)\n            elif sign == '<=':\n                lower_bound = max(lower_bound, number + 1)\n\n    if lower_bound <= upper_bound:\n        return lower_bound\n    else:\n        return \"Impossible\"\n\nn = int(input())\nqueries = [input().split() for _ in range(n)]\nprint(find_number(queries))"}
{"solution": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef count_periods(a, b):\n    total = a + b\n    periods = set()\n\n    for i in range(1, total + 1):\n        if gcd(i, total) == i:\n            periods.add(i)\n\n    return len(periods)\n\na, b = map(int, input().split())\nprint(count_periods(a, b))"}
{"solution": "def generate_names(n, k, conditions):\n    # Predefined list of unique names\n    names = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"]\n\n    # Initialize the result list with the first k names\n    result = names[:k]\n\n    for i in range(1, n - k + 1):\n        if conditions[i - 1] == \"YES\":\n            # If the group should be effective, add a new unique name\n            result.append(names[k + i - 1])\n        else:\n            # If the group should not be effective, repeat the last name\n            result.append(result[-1])\n\n    return result\n\n# Read input\nn, k = map(int, input().split())\nconditions = input().split()\n\n# Generate and print the names\nnames = generate_names(n, k, conditions)\nprint(\" \".join(names))"}
{"solution": "def min_operations_to_equal(a, b):\n    def count_factors(n, factor):\n        count = 0\n        while n % factor == 0:\n            n //= factor\n            count += 1\n        return count, n\n\n    # Count the number of times we can divide by 2, 3, and 5\n    a2, a = count_factors(a, 2)\n    a3, a = count_factors(a, 3)\n    a5, a = count_factors(a, 5)\n\n    b2, b = count_factors(b, 2)\n    b3, b = count_factors(b, 3)\n    b5, b = count_factors(b, 5)\n\n    # If the remaining parts are not equal, return -1\n    if a != b:\n        return -1\n\n    # Calculate the total number of operations needed\n    operations = abs(a2 - b2) + abs(a3 - b3) + abs(a5 - b5)\n\n    return operations\n\n# Read input\na, b = map(int, input().split())\n\n# Print the result\nprint(min_operations_to_equal(a, b))"}
{"solution": "def min_cost(n, a, b, suits):\n    cost = 0\n    for i in range(n // 2):\n        if suits[i] == suits[n - i - 1]:\n            continue\n        elif suits[i] == 2:\n            suits[i] = suits[n - i - 1]\n            cost += a if suits[i] == 0 else b\n        elif suits[n - i - 1] == 2:\n            suits[n - i - 1] = suits[i]\n            cost += a if suits[n - i - 1] == 0 else b\n        else:\n            return -1\n    if n % 2 == 1 and suits[n // 2] == 2:\n        cost += min(a, b)\n    return cost\n\nn, a, b = map(int, input().split())\nsuits = list(map(int, input().split()))\nprint(min_cost(n, a, b, suits))"}
{"solution": "def paint_cube(k):\n    if k % 2 != 0:\n        print(-1)\n        return\n\n    for i in range(k):\n        for j in range(k):\n            if (i + j) % 2 == 0:\n                print('b', end='')\n            else:\n                print('w', end='')\n        print()\n\nk = int(input())\npaint_cube(k)"}
{"solution": "def largest_lovely_number(n):\n    import math\n    from collections import Counter\n\n    def prime_factors(n):\n        i = 2\n        factors = []\n        while i * i <= n:\n            while (n % i) == 0:\n                factors.append(i)\n                n //= i\n            i += 1\n        if n > 1:\n            factors.append(n)\n        return factors\n\n    factors = prime_factors(n)\n    factor_counts = Counter(factors)\n\n    lovely_number = 1\n    for prime, count in factor_counts.items():\n        lovely_number *= prime\n\n    return lovely_number\n\nn = int(input())\nprint(largest_lovely_number(n))"}
{"solution": "def is_maximal_seating(n, seating):\n    # Check for adjacent occupied seats\n    for i in range(n - 1):\n        if seating[i] == '1' and seating[i + 1] == '1':\n            return \"No\"\n\n    # Check for possible additional seating\n    for i in range(n):\n        if seating[i] == '0':\n            if (i == 0 or seating[i - 1] == '0') and (i == n - 1 or seating[i + 1] == '0'):\n                return \"No\"\n\n    return \"Yes\"\n\n# Get input\nn = int(input())\nseating = input().strip()\n\n# Print output\nprint(is_maximal_seating(n, seating))"}
{"solution": "def find_possible_lengths(n, a):\n    possible_lengths = []\n    for k in range(1, n + 1):\n        x = [0] * k\n        x[0] = a[1]\n        for i in range(2, n + 1):\n            x[(i - 1) % k] = a[i] - a[i - 1]\n        if all(x[i] == x[0] for i in range(1, k)):\n            possible_lengths.append(k)\n    return possible_lengths\n\nn = int(input())\na = [0] + list(map(int, input().split()))\npossible_lengths = find_possible_lengths(n, a)\nprint(len(possible_lengths))\nprint(' '.join(map(str, possible_lengths)))"}
{"solution": "# Get the input scores\nscores = list(map(int, input().split()))\n\n# Sort the scores in descending order\nscores.sort(reverse=True)\n\n# Initialize a flag to check if teams can be formed\npossible = False\n\n# Check all possible combinations of 3 participants for the first team\nfor i in range(4):\n    for j in range(i+1, 5):\n        for k in range(j+1, 6):\n            # Calculate the score of the first team\n            team1_score = scores[i] + scores[j] + scores[k]\n\n            # Calculate the score of the second team\n            team2_score = sum(scores) - team1_score\n\n            # If the scores are equal, set the flag to True and break the loop\n            if team1_score == team2_score:\n                possible = True\n                break\n\n        if possible:\n            break\n\n    if possible:\n        break\n\n# Print the result\nif possible:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def count_2_3_integers(l, r):\n    # Initialize the count of 2-3 integers\n    count = 0\n\n    # Generate all 2-3 integers in the range [1, r]\n    i = 1\n    while i <= r:\n        j = i\n        # Check if j is a 2-3 integer and within the range [l, r]\n        while j <= r:\n            if l <= j <= r:\n                count += 1\n            j *= 2\n        i *= 3\n\n    return count\n\n# Read input\nl, r = map(int, input().split())\n\n# Print the result\nprint(count_2_3_integers(l, r))"}
{"solution": "n, k = map(int, input().split())\ncandies_eaten = 0\ncandies_in_box = 1\n\nfor _ in range(n - 1):\n    if candies_in_box >= candies_eaten + 1:\n        candies_eaten += 1\n        candies_in_box -= 1\n    else:\n        candies_in_box += candies_eaten + 1\n\nprint(candies_eaten)"}
{"solution": "# Read the number of line segments\nn = int(input())\n\n# Read the lengths of line segments\nsegments = list(map(int, input().split()))\n\n# Sort the lengths of line segments\nsegments.sort()\n\n# Check if it's possible to form a non-degenerate triangle\nfor i in range(n - 2):\n    if segments[i] + segments[i + 1] > segments[i + 2]:\n        print(\"YES\")\n        break\nelse:\n    print(\"NO\")"}
{"solution": "def can_achieve_toys(x, y):\n    # If there are no original toys, it's impossible to achieve the desired configuration\n    if y == 0:\n        return False\n\n    # If there are no copied toys, it's only possible if there's exactly one original toy\n    if x == 0:\n        return y == 1\n\n    # Calculate the number of times the machine needs to be applied to original toys\n    original_applications = y - 1\n\n    # Calculate the number of copied toys that can be obtained from original toys\n    copied_from_original = original_applications\n\n    # If the desired number of copied toys is less than or equal to the number of copied toys that can be obtained from original toys, it's possible to achieve the desired configuration\n    if x <= copied_from_original:\n        return True\n\n    # Calculate the number of additional applications needed to obtain the desired number of copied toys\n    additional_applications = (x - copied_from_original) // 2\n\n    # Calculate the total number of applications needed\n    total_applications = original_applications + additional_applications\n\n    # Calculate the number of copied toys that can be obtained from copied toys after the additional applications\n    copied_from_copied = 2 ** (additional_applications + 1) - 2\n\n    # If the desired number of copied toys is less than or equal to the total number of copied toys that can be obtained, it's possible to achieve the desired configuration\n    return x <= copied_from_original + copied_from_copied\n\n# Read the input\nx, y = map(int, input().split())\n\n# Print the output\nprint(\"Yes\" if can_achieve_toys(x, y) else \"No\")"}
{"solution": "def calculate_max_rating(n, k, skills):\n    # Calculate the initial total rating\n    total_rating = sum(skill // 10 for skill in skills)\n\n    # Identify improvement opportunities\n    improvements = [(10 - skill % 10) % 10 for skill in skills]\n\n    # Prioritize improvements\n    improvements.sort()\n\n    # Allocate units\n    for i in range(n):\n        if k >= improvements[i]:\n            k -= improvements[i]\n            total_rating += 1\n\n    return total_rating\n\n# Read input\nn, k = map(int, input().split())\nskills = list(map(int, input().split()))\n\n# Calculate and print the maximum total rating\nmax_rating = calculate_max_rating(n, k, skills)\nprint(max_rating)"}
{"solution": "def find_smallest_pretty_integer():\n    # Read input\n    n, m = map(int, input().split())\n    list1 = list(map(int, input().split()))\n    list2 = list(map(int, input().split()))\n\n    # Convert lists to sets for faster lookup\n    set1 = set(list1)\n    set2 = set(list2)\n\n    # Check for common digits\n    common_digits = set1.intersection(set2)\n    if common_digits:\n        print(min(common_digits))\n        return\n\n    # If no common digits, find the smallest combination\n    min1 = min(list1)\n    min2 = min(list2)\n\n    # Form the smallest two-digit number\n    smallest_pretty = min(int(str(min1) + str(min2)), int(str(min2) + str(min1)))\n    print(smallest_pretty)\n\nfind_smallest_pretty_integer()"}
{"solution": "# Get the input\nn, k = map(int, input().split())\n\n# Calculate the total time available for solving problems\ntotal_time = 240 - k\n\n# Initialize the time taken to solve problems and the number of problems solved\ntime_taken = 0\nproblems_solved = 0\n\n# Loop through the problems\nfor i in range(1, n + 1):\n    # Calculate the time required to solve the current problem\n    problem_time = 5 * i\n\n    # If solving the current problem would exceed the total time available, break the loop\n    if time_taken + problem_time > total_time:\n        break\n\n    # Otherwise, add the time required to solve the current problem to the total time taken\n    time_taken += problem_time\n\n    # Increment the number of problems solved\n    problems_solved += 1\n\n# Print the maximum possible number of problems Limak can solve\nprint(problems_solved)"}
{"solution": "def max_teams(n, x, y, a):\n    a.sort()\n    double_sided = x\n    single_sided = y\n    count = 0\n\n    for pages in a:\n        double_needed = pages // 2\n        single_needed = pages % 2\n\n        if double_needed <= double_sided:\n            double_sided -= double_needed\n            if single_needed <= single_sided:\n                single_sided -= single_needed\n                count += 1\n            else:\n                double_sided += double_needed\n                break\n        else:\n            remaining_pages = pages - 2 * double_sided\n            if remaining_pages <= single_sided:\n                single_sided -= remaining_pages\n                double_sided = 0\n                count += 1\n            else:\n                break\n\n    return count\n\nn, x, y = map(int, input().split())\na = list(map(int, input().split()))\nprint(max_teams(n, x, y, a))"}
{"solution": "def count_divisors(n):\n    divisors = set()\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n        i += 1\n    return len(divisors)\n\n# Read input\nb = int(input().strip())\n\n# Calculate the number of distinct values\nresult = count_divisors(b)\n\n# Print the result\nprint(result)"}
{"solution": "def calculate_falling_positions(n, bumpers):\n    falling_positions = 0\n    for i in range(n):\n        position = i\n        visited = set()\n        while 0 <= position < n:\n            if position in visited:\n                break\n            visited.add(position)\n            if bumpers[position] == '<':\n                position -= 1\n            else:\n                position += 1\n        if position < 0 or position >= n:\n            falling_positions += 1\n    return falling_positions\n\nn = int(input())\nbumpers = input()\nprint(calculate_falling_positions(n, bumpers))"}
{"solution": "# Read input\nn = int(input())\nsticks = list(map(int, input().split()))\n\n# Sort the sticks in descending order\nsticks.sort(reverse=True)\n\n# Initialize total area\ntotal_area = 0\n\n# Iterate through the sticks in reverse order\ni = 0\nwhile i < n - 1:\n    # If the current stick and the next stick have the same length\n    if sticks[i] == sticks[i + 1]:\n        # Check if there are at least two more equal lengths available\n        if i + 3 < n and sticks[i] == sticks[i + 2] == sticks[i + 3]:\n            # Calculate the area of the rectangle\n            area = sticks[i] * sticks[i + 2]\n            # Add the area to the total area\n            total_area += area\n            # Reduce the length of the sticks used in the rectangle\n            sticks[i] -= 1\n            sticks[i + 1] -= 1\n            sticks[i + 2] -= 1\n            sticks[i + 3] -= 1\n            # Sort the sticks again\n            sticks.sort(reverse=True)\n        else:\n            # Move to the next stick\n            i += 1\n    else:\n        # Move to the next stick\n        i += 1\n\n# Print the total area\nprint(total_area)"}
{"solution": "# Read the number of Petya's numbers\nn = int(input())\n\n# Read the Petya's numbers after Vasya's joke\nnumbers = [input() for _ in range(n)]\n\n# Create a dictionary to map letters to digits\nletter_to_digit = {}\n\n# Create a list to store the frequency of each letter\nfrequency = [0] * 26\n\n# Calculate the frequency of each letter\nfor number in numbers:\n    for letter in number:\n        frequency[ord(letter) - ord('a')] += 1\n\n# Sort the letters based on their frequency in descending order\nsorted_letters = sorted(range(26), key=lambda x: frequency[x], reverse=True)\n\n# Assign digits to letters based on their frequency\nfor i in range(10):\n    letter_to_digit[chr(sorted_letters[i] + ord('a'))] = str(i)\n\n# Restore Petya's numbers\nrestored_numbers = []\nfor number in numbers:\n    restored_number = ''\n    for letter in number:\n        restored_number += letter_to_digit[letter]\n    restored_numbers.append(int(restored_number))\n\n# Calculate the minimum sum of restored numbers\nmin_sum = sum(restored_numbers)\n\n# Print the minimum sum\nprint(min_sum)"}
{"solution": "def max_teams(n, m):\n    # Binary search to find the maximum number of teams\n    low, high = 0, min(n, m, (n + m) // 3)\n\n    while low < high:\n        mid = (low + high + 1) // 2\n        if mid <= n and mid <= m and 2 * mid <= n + m:\n            low = mid\n        else:\n            high = mid - 1\n\n    return low\n\n# Read input\nn, m = map(int, input().split())\n\n# Calculate and print the maximum number of teams\nprint(max_teams(n, m))"}
{"solution": "def check_substrings(s):\n    n = len(s)\n\n    # Check for \"AB\" followed by \"BA\"\n    found_AB = False\n    for i in range(n - 1):\n        if s[i:i+2] == \"AB\":\n            found_AB = True\n            for j in range(i + 2, n - 1):\n                if s[j:j+2] == \"BA\":\n                    print(\"YES\")\n                    return\n            break\n\n    # Check for \"BA\" followed by \"AB\"\n    found_BA = False\n    for i in range(n - 1):\n        if s[i:i+2] == \"BA\":\n            found_BA = True\n            for j in range(i + 2, n - 1):\n                if s[j:j+2] == \"AB\":\n                    print(\"YES\")\n                    return\n            break\n\n    # If neither condition is met\n    print(\"NO\")\n\n# Example usage\ns = input().strip()\ncheck_substrings(s)"}
{"solution": "def solve_monster_queue(n, a, k, b):\n    queue = a.copy()\n    eatings = []\n\n    while len(queue) > k:\n        for i in range(len(queue)):\n            if i > 0 and queue[i] > queue[i-1]:\n                queue[i] += queue[i-1]\n                queue.pop(i-1)\n                eatings.append(f\"{i+1} L\")\n                break\n            elif i < len(queue) - 1 and queue[i] > queue[i+1]:\n                queue[i] += queue[i+1]\n                queue.pop(i+1)\n                eatings.append(f\"{i+1} R\")\n                break\n\n    if queue == b:\n        print(\"YES\")\n        for eating in eatings:\n            print(eating)\n    else:\n        print(\"NO\")\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\nk = int(input())\nb = list(map(int, input().split()))\n\n# Solve the problem\nsolve_monster_queue(n, a, k, b)"}
{"solution": "import sys\nfrom collections import defaultdict\n\ndef read_input():\n    R, B = map(int, sys.stdin.readline().split())\n    rebel_ships = [tuple(map(int, sys.stdin.readline().split())) for _ in range(R)]\n    bases = [tuple(map(int, sys.stdin.readline().split())) for _ in range(B)]\n    return rebel_ships, bases\n\ndef on_segment(p, q, r):\n    if (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and\n            q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1])):\n        return True\n    return False\n\ndef orientation(p, q, r):\n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0\n    elif val > 0:\n        return 1\n    else:\n        return 2\n\ndef do_intersect(p1, q1, p2, q2):\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    if o1 != o2 and o3 != o4:\n        return True\n\n    if o1 == 0 and on_segment(p1, p2, q1):\n        return True\n\n    if o2 == 0 and on_segment(p1, q2, q1):\n        return True\n\n    if o3 == 0 and on_segment(p2, p1, q2):\n        return True\n\n    if o4 == 0 and on_segment(p2, q1, q2):\n        return True\n\n    return False\n\ndef hopcroft_karp(rebel_ships, bases):\n    match_R = [-1] * len(rebel_ships)\n    match_B = [-1] * len(bases)\n    def bpm(u):\n        for v in range(len(bases)):\n            if graph[u][v] and match_B[v] == -1:\n                match_R[u] = v\n                match_B[v] = u\n                return True\n            if graph[u][v] and match_B[v] != -1:\n                if bpm(match_B[v]):\n                    match_R[u] = v\n                    match_B[v] = u\n                    return True\n        return False\n    def max_matching():\n        result = 0\n        for i in range(len(rebel_ships)):\n            if bpm(i):\n                result += 1\n        return result\n    graph = [[False] * len(bases) for _ in range(len(rebel_ships))]\n    for i in range(len(rebel_ships)):\n        for j in range(len(bases)):\n            if not any(do_intersect(rebel_ships[i], bases[j], rebel_ships[k], bases[l]) for k, l in enumerate(match_R) if k != i and l != -1):\n                graph[i][j] = True\n    return max_matching() == len(rebel_ships)\n\nrebel_ships, bases = read_input()\nprint(\"Yes\" if hopcroft_karp(rebel_ships, bases) else \"No\")"}
{"solution": "# Read the length of the sequence\nn = int(input())\n\n# Read the sequence\nseq = list(map(int, input().split()))\n\n# Initialize the maximum power of 2 and the count of numbers divisible by it\nmax_power = 0\ncount = 0\n\n# Iterate over the sequence\nfor num in seq:\n    # Find the power of 2 for the current number\n    power = 0\n    while num % 2 == 0:\n        num //= 2\n        power += 1\n    # Update the maximum power and the count\n    if power > max_power:\n        max_power = power\n        count = 1\n    elif power == max_power:\n        count += 1\n\n# Print the maximum power of 2 and the count of numbers divisible by it\nprint(2**max_power, count)"}
{"solution": "def min_clicks(n, m):\n    clicks = 0\n    while n != m:\n        if n < m and m % 2 == 0:\n            m //= 2\n            clicks += 1\n        else:\n            m += 1\n            clicks += 1\n    return clicks\n\nn, m = map(int, input().split())\nprint(min_clicks(n, m))"}
{"solution": "import sys\n\ndef read_input():\n    return sys.stdin.readline\n\ndef write_output(x):\n    return sys.stdout.write(x)\n\ndef solve():\n    n = int(read_input())\n    segments = sorted([list(map(int, read_input().split())) for _ in range(n)])\n\n    parent = [i for i in range(n)]\n    rank = [0] * n\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        root_x = find(x)\n        root_y = find(y)\n\n        if root_x == root_y:\n            return False\n\n        if rank[root_x] > rank[root_y]:\n            parent[root_y] = root_x\n        elif rank[root_x] < rank[root_y]:\n            parent[root_x] = root_y\n        else:\n            parent[root_y] = root_x\n            rank[root_x] += 1\n\n        return True\n\n    edges = 0\n    for i in range(n):\n        l, r = segments[i]\n        for j in range(i + 1, n):\n            if segments[j][0] > r:\n                break\n            if segments[j][1] < l:\n                continue\n            if union(i, j):\n                edges += 1\n\n    if edges != n - 1:\n        write_output(\"NO\")\n    else:\n        write_output(\"YES\")\n\nsolve()"}
{"solution": "# Read input\nn = int(input())\nrequests = list(map(int, input().split()))\n\n# Initialize variables\nmax_length = 0\ncurrent_length = 0\ncurrent_sum = 0\n\n# Iterate through the requests\nfor i in range(n):\n    # Add the current request to the sum\n    current_sum += requests[i]\n\n    # Check if the sum exceeds the threshold\n    if current_sum > 100 * (i - current_length + 1):\n        # If it does, reset the sum and length\n        current_sum = requests[i]\n        current_length = 0\n    else:\n        # If it doesn't, increment the length\n        current_length += 1\n\n    # Update the maximum length\n    max_length = max(max_length, current_length)\n\n# Print the result\nprint(max_length)"}
{"solution": "def check_dissatisfaction(n, k, sequence):\n    max_consecutive_n = 0\n    current_consecutive_n = 0\n\n    for i in range(n):\n        if sequence[i] == 'N':\n            current_consecutive_n += 1\n        elif sequence[i] == 'Y':\n            max_consecutive_n = max(max_consecutive_n, current_consecutive_n)\n            current_consecutive_n = 0\n        else:\n            if current_consecutive_n + k <= i + 1 and i + k <= n:\n                max_consecutive_n = max(max_consecutive_n, current_consecutive_n + k)\n            current_consecutive_n = 0\n\n    max_consecutive_n = max(max_consecutive_n, current_consecutive_n)\n\n    return max_consecutive_n == k\n\nn, k = map(int, input().split())\nsequence = input()\n\nif check_dissatisfaction(n, k, sequence):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def count_subsets(N, X, D):\n    # Generate the sequence\n    sequence = [X + i * D for i in range(N)]\n\n    # Calculate the total sum of the sequence\n    total_sum = sum(sequence)\n\n    # If the total sum is odd, there are no ways to split the sequence into two subsets with equal sums\n    if total_sum % 2 != 0:\n        return 0\n\n    # Initialize a dynamic programming array to store the number of ways to split the sequence into two subsets\n    dp = [0] * (total_sum // 2 + 1)\n    dp[0] = 1\n\n    # Iterate over the elements of the sequence\n    for num in sequence:\n        # Iterate over the sums in reverse order to avoid double-counting\n        for i in range(total_sum // 2, num - 1, -1):\n            # Update the number of ways to split the sequence into two subsets\n            dp[i] += dp[i - num]\n\n    # Return the number of possible values of S - T\n    return 2 * dp[total_sum // 2] + (1 if D == 0 else 0)\n\n# Read the input\nN, X, D = map(int, input().split())\n\n# Print the result\nprint(count_subsets(N, X, D))"}
{"solution": "def did_anton_perform_good(n, participants):\n    for participant in participants:\n        handle, before, after = participant\n        if before >= 2400 and after > before:\n            return \"YES\"\n    return \"NO\"\n\nn = int(input())\nparticipants = [input().split() for _ in range(n)]\nparticipants = [(handle, int(before), int(after)) for handle, before, after in participants]\n\nprint(did_anton_perform_good(n, participants))"}
{"solution": "# Get the binary input\ns = input()\n\n# Convert binary to decimal\ns = int(s, 2)\n\n# Initialize the count of trains\ncount = 0\n\n# Initialize the departure time\ndeparture_time = 1\n\n# Loop until the departure time is less than s\nwhile departure_time < s:\n    # Increment the count\n    count += 1\n\n    # Update the departure time\n    departure_time *= 4\n\n# Print the count\nprint(count)"}
{"solution": "def min_rows(matrix):\n    n = len(matrix)\n    m = len(matrix[0])\n\n    # Check if the matrix is symmetric\n    for i in range(n // 2):\n        if matrix[i] != matrix[n - i - 1]:\n            return n\n\n    # Find the smallest repeating unit\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            unit = matrix[:i]\n            if unit * (n // i) == matrix:\n                return i\n\n    return n\n\n# Read input\nn, m = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# Print output\nprint(min_rows(matrix))"}
{"solution": "# Read the number of orders\nn = int(input())\n\n# Create a list to store the orders\norders = []\n\n# Read the orders and store them in the list\nfor _ in range(n):\n    l, r = map(int, input().split())\n    orders.append((l, r))\n\n# Sort the orders by their end times\norders.sort(key=lambda x: x[1])\n\n# Initialize the count of accepted orders and the end time of the last accepted order\ncount = 1\nlast_end = orders[0][1]\n\n# Iterate through the orders\nfor i in range(1, n):\n    # If the current order does not intersect with the last accepted order, accept it\n    if orders[i][0] >= last_end:\n        count += 1\n        last_end = orders[i][1]\n\n# Print the maximal number of orders that can be accepted\nprint(count)"}
{"solution": "def can_rearrange(n, k, tables, formulas):\n    window_tables = 0\n    window_formulas = 0\n    left = 0\n\n    for right in range(n):\n        window_tables += tables[right]\n        window_formulas += formulas[right]\n\n        while window_tables > k or window_formulas > k:\n            window_tables -= tables[left]\n            window_formulas -= formulas[left]\n            left += 1\n\n        if right - left + 1 > k:\n            return False\n\n    return True\n\nn, k = map(int, input().split())\ntables = list(map(int, input().split()))\nformulas = list(map(int, input().split()))\n\nif can_rearrange(n, k, tables, formulas):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def can_guarantee_victory(n, k, coefficients):\n    # Check if the game is already over\n    if coefficients[0] == k:\n        return False\n\n    # Check if the human can set the last coefficient to make the polynomial divisible by Q(x)\n    if coefficients[-1] == '?':\n        return True\n\n    # Calculate the remainder of the polynomial division by Q(x)\n    remainder = coefficients[0]\n    for i in range(1, n + 1):\n        remainder = (remainder * i + coefficients[i]) % k\n\n    # Check if the human can set a coefficient to make the remainder equal to 0\n    for i in range(n, -1, -1):\n        if coefficients[i] == '?':\n            # Calculate the coefficient value that makes the remainder equal to 0\n            coefficient_value = (k - remainder) % k\n            if coefficient_value == 0:\n                return True\n            remainder = (remainder - coefficients[i] * coefficient_value) % k\n\n    return False\n\n# Read input\nn, k = map(int, input().split())\ncoefficients = []\nfor _ in range(n + 1):\n    coefficient = input()\n    if coefficient == '?':\n        coefficients.append('?')\n    else:\n        coefficients.append(int(coefficient))\n\n# Determine if the human can guarantee a victory\nif can_guarantee_victory(n, k, coefficients):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "def smallest_prime_factor(n):\n    smallest_prime = [0 for _ in range(n+1)]\n    smallest_prime[1] = 1\n    for i in range(2, n+1):\n        if smallest_prime[i] == 0:\n            for j in range(i, n+1, i):\n                if smallest_prime[j] == 0:\n                    smallest_prime[j] = i\n    return smallest_prime\n\ndef solve(X_2):\n    smallest_prime = smallest_prime_factor(X_2)\n    X_1 = X_2 // smallest_prime[X_2] * smallest_prime[X_2]\n    X_0 = X_1 // smallest_prime[X_1] * smallest_prime[X_1]\n    return X_0\n\nX_2 = int(input())\nprint(solve(X_2))"}
{"solution": "def smallest_p_binary_sum(n, p):\n    count = 0\n    while n > 0:\n        # Find the largest p-binary number less than or equal to n\n        x = 0\n        while (1 << x) + p <= n:\n            x += 1\n        x -= 1\n\n        # Subtract the largest p-binary number from n\n        n -= (1 << x) + p\n        count += 1\n\n    return count if n == 0 else -1\n\n# Read input\nn, p = map(int, input().split())\n\n# Print output\nprint(smallest_p_binary_sum(n, p))"}
{"solution": "def min_possible_value(n, k, S):\n    S = list(S)\n    if S[0] != '1' and k > 0:\n        S[0] = '1'\n        k -= 1\n    for i in range(1, n):\n        if S[i] != '0' and k > 0:\n            S[i] = '0'\n            k -= 1\n    return ''.join(S)\n\nn, k = map(int, input().split())\nS = input()\nresult = min_possible_value(n, k, S)\nprint(result)"}
{"solution": "def count_numbers(cnt_1, cnt_2, x, y):\n    # Initialize the minimum number v\n    v = 1\n\n    # Count the numbers that each friend likes\n    cnt_x, cnt_y = 0, 0\n\n    while cnt_x < cnt_1 or cnt_y < cnt_2:\n        # Check if the current number is liked by both friends\n        if v % x != 0 and v % y != 0:\n            # If the first friend likes it, increment cnt_x\n            if cnt_x < cnt_1:\n                cnt_x += 1\n            # If the second friend likes it, increment cnt_y\n            elif cnt_y < cnt_2:\n                cnt_y += 1\n        # Check if the current number is liked by the first friend\n        elif v % x != 0:\n            # If the first friend likes it, increment cnt_x\n            if cnt_x < cnt_1:\n                cnt_x += 1\n        # Check if the current number is liked by the second friend\n        elif v % y != 0:\n            # If the second friend likes it, increment cnt_y\n            if cnt_y < cnt_2:\n                cnt_y += 1\n\n        # Move to the next number\n        v += 1\n\n    return v - 1\n\n# Read the input\ncnt_1, cnt_2, x, y = map(int, input().split())\n\n# Print the result\nprint(count_numbers(cnt_1, cnt_2, x, y))"}
{"solution": "def predict_bear_position(n, sx, sy, dx, dy, t):\n    # Calculate the number of raspberry bushes in the starting cell\n    raspberries = sx + sy\n\n    # Increase the speed of the bear based on the number of raspberry bushes\n    dx += raspberries\n    dy += raspberries\n\n    # Calculate the new position of the bear after t seconds\n    x = (((sx + dx - 1) * pow(2, t, n)) % n) + 1\n    y = (((sy + dy - 1) * pow(2, t, n)) % n) + 1\n\n    return x, y\n\n# Read the input values\nn, sx, sy, dx, dy, t = map(int, input().split())\n\n# Predict the bear's position\nx, y = predict_bear_position(n, sx, sy, dx, dy, t)\n\n# Print the output\nprint(x, y)"}
{"solution": "def solve_word_puzzle(s):\n    # Check if the length of the string is less than 26, if so, return -1\n    if len(s) < 26:\n        return -1\n\n    # Initialize a list to keep track of the missing letters\n    missing_letters = list('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n    # Initialize a list to keep track of the filled word\n    filled_word = list(s)\n\n    # Iterate over the string\n    for i in range(len(s)):\n        # If the current character is a letter, remove it from the missing letters list\n        if s[i] != '?':\n            missing_letters.remove(s[i])\n\n        # If the current character is a question mark and there are missing letters left\n        elif missing_letters:\n            # Fill the question mark with the first missing letter\n            filled_word[i] = missing_letters.pop(0)\n\n        # If the current character is a question mark and there are no missing letters left\n        else:\n            # Return -1 as it is not possible to fill the word\n            return -1\n\n    # If there are still missing letters left, return -1 as it is not possible to fill the word\n    if missing_letters:\n        return -1\n\n    # If the filled word is nice, return the filled word\n    if len(set(filled_word[i:i+26] for i in range(len(filled_word) - 26))) == 1:\n        return ''.join(filled_word)\n\n    # If the filled word is not nice, return -1\n    return -1\n\n# Read the input\ns = input()\n# Print the output\nprint(solve_word_puzzle(s))"}
{"solution": "def divide_apples(n, weights):\n    total_weight = sum(weights)\n    if total_weight % 2 != 0:\n        return \"NO\"\n\n    target_weight = total_weight // 2\n    dp = [False] * (target_weight + 1)\n    dp[0] = True\n\n    for weight in weights:\n        for i in range(target_weight, weight - 1, -1):\n            dp[i] = dp[i] or dp[i - weight]\n\n    return \"YES\" if dp[target_weight] else \"NO\"\n\nn = int(input())\nweights = list(map(int, input().split()))\nprint(divide_apples(n, weights))"}
{"solution": "def min_time(building):\n    n = len(building)\n    m = len(building[0]) - 2\n    dp = [[float('inf')] * (m + 2) for _ in range(n)]\n    dp[0][0] = 0\n\n    for i in range(n):\n        for j in range(m + 2):\n            if building[i][j] == '1':\n                if j > 0:\n                    dp[i][j] = min(dp[i][j], dp[i][j - 1] + 1)\n                if j < m + 1:\n                    dp[i][j] = min(dp[i][j], dp[i][j + 1] + 1)\n                if i > 0:\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1 + (m + 1 - j if j <= m // 2 else j))\n                if i < n - 1:\n                    dp[i][j] = min(dp[i][j], dp[i + 1][j] + 1 + (m + 1 - j if j > m // 2 else j))\n\n    return dp[-1][0]\n\nn, m = map(int, input().split())\nbuilding = [input() for _ in range(n)]\nprint(min_time(building))"}
{"solution": "def find_min_trap_cost(n, costs, transitions):\n    visited = [False] * n\n    in_stack = [False] * n\n    min_cost = 0\n\n    def dfs(node):\n        stack = []\n        while True:\n            if visited[node]:\n                if in_stack[node]:\n                    # Found a cycle, calculate the minimum cost in this cycle\n                    cycle_min_cost = float('inf')\n                    while stack:\n                        cycle_node = stack.pop()\n                        in_stack[cycle_node] = False\n                        cycle_min_cost = min(cycle_min_cost, costs[cycle_node])\n                        if cycle_node == node:\n                            break\n                    return cycle_min_cost\n                else:\n                    return 0\n            visited[node] = True\n            in_stack[node] = True\n            stack.append(node)\n            node = transitions[node] - 1\n\n    for i in range(n):\n        if not visited[i]:\n            min_cost += dfs(i)\n\n    return min_cost\n\n# Input reading\nn = int(input())\ncosts = list(map(int, input().split()))\ntransitions = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(find_min_trap_cost(n, costs, transitions))"}
{"solution": "# Get the input\nn, a, b = map(int, input().split())\n\n# Calculate the final entrance\nfinal_entrance = (a + b) % n\n\n# If the final entrance is 0, it means Vasya is at the last entrance\nif final_entrance == 0:\n    final_entrance = n\n\n# Print the result\nprint(final_entrance)"}
{"solution": "def min_arithmetic_progressions(seq):\n    n = len(seq)\n    if n == 1:\n        return 1\n\n    count = 0\n    i = 0\n    while i < n:\n        # Find the next known value\n        j = i + 1\n        while j < n and seq[j] == -1:\n            j += 1\n\n        # If all values are unknown, return 1\n        if j == n:\n            return 1\n\n        # Calculate the difference between known values\n        diff = seq[j] - seq[i]\n        step = (j - i) // gcd(j - i, diff)\n\n        # Check if the sequence forms an arithmetic progression\n        k = i + step\n        while k < j and (seq[k] == -1 or seq[k] - seq[k - step] == diff):\n            k += step\n\n        if k == j:\n            count += 1\n            i = j\n        else:\n            i += 1\n\n    return count\n\ndef gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\nn = int(input())\nseq = list(map(int, input().split()))\nprint(min_arithmetic_progressions(seq))"}
{"solution": "def max_beauty(n, k, s):\n    # Initialize variables to keep track of the maximum beauty and the current beauty\n    max_beauty = 0\n    current_beauty = 1\n\n    # Iterate through the string\n    for i in range(1, n):\n        # If the current character is the same as the previous character, increment the current beauty\n        if s[i] == s[i - 1]:\n            current_beauty += 1\n        # If the current character is different from the previous character, reset the current beauty to 1\n        else:\n            current_beauty = 1\n\n        # If the number of changes allowed is greater than 0, consider changing the current character\n        if k > 0:\n            # Calculate the potential beauty if the current character is changed\n            potential_beauty = current_beauty + 1\n            # If the previous character is the same as the character before it, add the number of changes allowed to the potential beauty\n            if i > 1 and s[i - 1] == s[i - 2]:\n                potential_beauty += k\n            # Update the maximum beauty\n            max_beauty = max(max_beauty, potential_beauty)\n        # If the number of changes allowed is 0, update the maximum beauty\n        else:\n            max_beauty = max(max_beauty, current_beauty)\n\n    # Return the maximum beauty\n    return max_beauty\n\n# Get the input\nn, k = map(int, input().split())\ns = input()\n\n# Print the maximum beauty\nprint(max_beauty(n, k, s))"}
{"solution": "# Read input\nn = int(input())\nseats = list(map(int, input().split()))\n\n# Calculate total seats\ntotal_seats = sum(seats)\n\n# Check if Alice's party can form a coalition on its own\nif seats[0] > total_seats // 2:\n    print(1)\n    print(1)\nelse:\n    # Sort the parties based on the number of seats\n    parties = sorted(enumerate(seats[1:], start=2), key=lambda x: x[1])\n\n    # Initialize coalition\n    coalition = [1]\n    coalition_seats = seats[0]\n\n    # Try to add parties to the coalition\n    for party, party_seats in parties:\n        if party_seats * 2 <= seats[0] and coalition_seats + party_seats > total_seats // 2:\n            coalition.append(party)\n            coalition_seats += party_seats\n\n    # Check if a coalition is possible\n    if coalition_seats > total_seats // 2:\n        print(len(coalition))\n        print(' '.join(map(str, coalition)))\n    else:\n        print(0)"}
{"solution": "def max_reward(n):\n    harmonic_sum = 0.0\n    for i in range(1, n + 1):\n        harmonic_sum += 1.0 / i\n    return harmonic_sum\n\n# Read input\nn = int(input().strip())\n\n# Calculate and print the maximum reward\nprint(f\"{max_reward(n):.12f}\")"}
{"solution": "def max_children(n):\n    k = 0\n    while (k * (k + 1)) // 2 <= n:\n        k += 1\n    k -= 1\n\n    remaining_candies = n - (k * (k + 1)) // 2\n    candies = list(range(1, k + 1))\n    candies[-1] += remaining_candies\n\n    return k, candies\n\nn = int(input())\nk, candies = max_children(n)\nprint(k)\nprint(' '.join(map(str, candies)))"}
{"solution": "# Read the input\nn = int(input())\nm = int(input())\n\n# Calculate 2^n\npower_of_two = 1 << n\n\n# Calculate m mod 2^n\nresult = m % power_of_two\n\n# Print the output\nprint(result)"}
{"solution": "def correct_word(word):\n    vowels = 'aeiouy'\n    corrected_word = []\n    i = 0\n\n    while i < len(word):\n        if i < len(word) - 1 and word[i] in vowels and word[i + 1] in vowels:\n            i += 1\n        else:\n            corrected_word.append(word[i])\n        i += 1\n\n    return ''.join(corrected_word)\n\nn = int(input())\ns = input()\n\nprint(correct_word(s))"}
{"solution": "def max_students(n, a, b, seats):\n    segments = []\n    i = 0\n\n    # Identify segments of empty seats\n    while i < n:\n        if seats[i] == '.':\n            start = i\n            while i < n and seats[i] == '.':\n                i += 1\n            segments.append(i - start)\n        else:\n            i += 1\n\n    total_students = 0\n\n    # Place students in each segment\n    for length in segments:\n        # Calculate the number of students that can be placed in this segment\n        # We will place students in an alternating fashion\n        if a > b:\n            # Start with a student-programmer if more student-programmers are available\n            programmers = (length + 1) // 2\n            athletes = length // 2\n        else:\n            # Start with a student-athlete if more student-athletes are available\n            athletes = (length + 1) // 2\n            programmers = length // 2\n\n        # Place the students\n        placed_programmers = min(programmers, a)\n        placed_athletes = min(athletes, b)\n\n        total_students += placed_programmers + placed_athletes\n        a -= placed_programmers\n        b -= placed_athletes\n\n    return total_students\n\n# Read input\nn, a, b = map(int, input().split())\nseats = input()\n\n# Print output\nprint(max_students(n, a, b, seats))"}
{"solution": "import math\n\ndef find_pair(r):\n    # Iterate over all possible values of x\n    for x in range(1, int(math.sqrt(r)) + 1):\n        # Calculate the discriminant of the quadratic equation\n        discriminant = 4 * (r - x * x - x - 1)\n        # Check if the discriminant is positive and a perfect square\n        if discriminant > 0 and math.isqrt(discriminant) ** 2 == discriminant:\n            # Calculate the value of y\n            y = (math.isqrt(discriminant) - 2 * x) // 2\n            # Check if y is positive\n            if y > 0:\n                return x, y\n    # If no pair is found, return \"NO\"\n    return \"NO\"\n\n# Read the input value of r\nr = int(input())\n# Find the pair (x, y) such that H(x, y) = r and x is smallest possible\nresult = find_pair(r)\n# Print the result\nprint(result)"}
{"solution": "def divide_balloons(n, a):\n    total_balloons = sum(a)\n\n    # Check if it's possible to divide the balloons\n    if n < 2 or total_balloons % 2 == 0:\n        return -1\n\n    # Sort the packets in descending order\n    a.sort(reverse=True)\n\n    # Try to divide the packets\n    for i in range(1, n):\n        if sum(a[:i]) > total_balloons // 2:\n            continue\n        if sum(a[i:]) < sum(a[:i]):\n            return i, [j+1 for j in range(i)]\n\n    return -1\n\n# Read the input\nn = int(input())\na = list(map(int, input().split()))\n\n# Divide the balloons\nresult = divide_balloons(n, a)\n\n# Print the output\nif result == -1:\n    print(-1)\nelse:\n    k, indices = result\n    print(k)\n    print(' '.join(map(str, indices)))"}
{"solution": "def min_digits(n):\n    # Start with the largest possible digit\n    digit = 9\n    # Initialize the result list\n    result = []\n\n    # While the number is greater than 0\n    while n > 0:\n        # If the digit is greater than the number\n        if digit > n:\n            # Decrease the digit\n            digit -= 1\n        # Append the digit to the result list\n        result.append(digit)\n        # Subtract the digit from the number\n        n -= digit\n\n    # Return the length of the result list and the result list\n    return len(result), result\n\n# Get the input number\nn = int(input())\n\n# Get the minimum number of digits and the digits themselves\nk, digits = min_digits(n)\n\n# Print the minimum number of digits\nprint(k)\n\n# Print the digits separated by spaces\nprint(' '.join(map(str, digits)))"}
{"solution": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_max_simple_subset(arr):\n    n = len(arr)\n    max_size = 0\n    max_subset = []\n\n    # Generate all subsets of the array\n    for i in range(1, 2**n):\n        subset = [arr[j] for j in range(n) if (i & (1 << j))]\n\n        # Check if the subset is simple\n        is_simple = True\n        for x in subset:\n            for y in subset:\n                if x != y and not is_prime(x + y):\n                    is_simple = False\n                    break\n            if not is_simple:\n                break\n\n        # Update the maximum size and subset if necessary\n        if is_simple and len(subset) > max_size:\n            max_size = len(subset)\n            max_subset = subset\n\n    return max_size, max_subset\n\n# Read input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Find the maximum size simple subset\nmax_size, max_subset = find_max_simple_subset(arr)\n\n# Print output\nprint(max_size)\nprint(' '.join(map(str, max_subset)))"}
{"solution": "def greatest_beautiful_divisor(n):\n    k = 1\n    while (2**k - 1) * (2**(k-1)) <= n:\n        k += 1\n    return (2**(k-1) - 1) * (2**(k-1))\n\nn = int(input())\nprint(greatest_beautiful_divisor(n))"}
{"solution": "MOD = 10**9 + 7\n\ndef count_d_magic_numbers(m, d, a, b):\n    a_str = str(a - 1)\n    b_str = str(b)\n    n = len(a_str)\n\n    # dp[i][j][k] represents the number of d-magic numbers in the range [0, j)\n    # where j has i digits and k is 1 if the number is less than b_str, 0 otherwise\n    dp = [[[0, 0] for _ in range(2)] for _ in range(n + 1)]\n    dp[0][0] = [1, 1]\n\n    for i in range(n):\n        for j in range(10):\n            for k in range(2):\n                if j == d and i % 2 == 0:\n                    dp[i + 1][j < int(b_str[i])][k or (j < int(a_str[i]))] = (dp[i + 1][j < int(b_str[i])][k or (j < int(a_str[i]))] + dp[i][k][0]) % MOD\n                elif j != d:\n                    dp[i + 1][j < int(b_str[i])][k or (j < int(a_str[i]))] = (dp[i + 1][j < int(b_str[i])][k or (j < int(a_str[i]))] + dp[i][k][0]) % MOD\n\n    return (dp[n][0][1] - dp[n][1][1]) % MOD\n\nm, d = map(int, input().split())\na = int(input())\nb = int(input())\n\nprint(count_d_magic_numbers(m, d, a, b))"}
{"solution": "def last_child(n, m, a):\n    queue = list(range(1, n + 1))\n    while queue:\n        child = queue.pop(0)\n        a[child - 1] -= m\n        if a[child - 1] > 0:\n            queue.append(child)\n        else:\n            last = child\n    return last\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\nprint(last_child(n, m, a))"}
{"solution": "def min_bills(n):\n    denominations = [100, 20, 10, 5, 1]\n    bills = 0\n\n    for denomination in denominations:\n        bills += n // denomination\n        n %= denomination\n\n    return bills\n\nn = int(input())\nprint(min_bills(n))"}
{"solution": "MOD = 10**9 + 7\n\ndef count_permutations(n, k):\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(min(i, k) + 1):\n            dp[i][j] = dp[i - 1][j] * (i - j) % MOD\n            if j > 0:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1] * (j + 1)) % MOD\n\n    return dp[n][k]\n\nn, k = map(int, input().split())\nprint(count_permutations(n, k))"}
{"solution": "# Read the input\nn, k = map(int, input().split())\nbeauty = list(map(int, input().split()))\ncolors = input()\n\n# Separate the roses into three lists based on their color\nwhite_roses = [beauty[i] for i in range(n) if colors[i] == 'W']\norange_roses = [beauty[i] for i in range(n) if colors[i] == 'O']\nred_roses = [beauty[i] for i in range(n) if colors[i] == 'R']\n\n# Sort each list of roses in descending order of beauty\nwhite_roses.sort(reverse=True)\norange_roses.sort(reverse=True)\nred_roses.sort(reverse=True)\n\n# If Arkady wants to buy more roses than there are of one color, check if there are enough roses of another color. If not, output -1.\nif k > len(white_roses) and k > len(orange_roses) + len(red_roses):\n    print(-1)\nelif k > len(orange_roses) and k > len(white_roses) + len(red_roses):\n    print(-1)\nelif k > len(red_roses) and k > len(white_roses) + len(orange_roses):\n    print(-1)\n# If Arkady wants to buy k roses of one color, output -1.\nelif k == len(white_roses) or k == len(orange_roses) or k == len(red_roses):\n    print(-1)\n# If Arkady wants to buy k roses of two colors, calculate the maximum possible total beauty of a bouquet of k roses by taking the sum of the k most beautiful roses of one color.\nelif len(white_roses) > 0 and len(orange_roses) > 0:\n    print(sum(white_roses[:k]) if k <= len(white_roses) else sum(white_roses) + sum(orange_roses[:k-len(white_roses)]))\nelif len(white_roses) > 0 and len(red_roses) > 0:\n    print(sum(white_roses[:k]) if k <= len(white_roses) else sum(white_roses) + sum(red_roses[:k-len(white_roses)]))\nelif len(orange_roses) > 0 and len(red_roses) > 0:\n    print(sum(orange_roses[:k]) if k <= len(orange_roses) else sum(orange_roses) + sum(red_roses[:k-len(orange_roses)]))\n# If Arkady wants to buy k roses of three colors, calculate the maximum possible total beauty of a bouquet of k roses by taking the sum of the k most beautiful roses of two colors.\nelse:\n    print(sum(white_roses[:k//2]) + sum(orange_roses[:k//2]) + sum(red_roses[:k-k//2]))"}
{"solution": "def convert_continued_fraction(coefficients):\n    numerator, denominator = 0, 1\n    for coefficient in reversed(coefficients):\n        numerator, denominator = denominator, coefficient * denominator + numerator\n    return numerator, denominator\n\ndef compare_fractions(p, q, coefficients):\n    numerator, denominator = convert_continued_fraction(coefficients)\n    return p == numerator and q == denominator\n\np, q = map(int, input().split())\nn = int(input())\ncoefficients = list(map(int, input().split()))\n\nprint(\"YES\" if compare_fractions(p, q, coefficients) else \"NO\")"}
{"solution": "# Read the input expression\nexpression = input()\n\n# Split the expression into A, B, and C\nA, B, C = expression.split('+')[0].count('|'), expression.split('=')[0].split('+')[1].count('|'), expression.split('=')[1].count('|')\n\n# Check if the expression is already correct\nif A + B == C:\n    print(expression)\nelse:\n    # Check if shifting one stick makes the expression correct\n    if A + B + 1 == C:\n        # Shift a stick from C to B\n        C -= 1\n        B += 1\n    elif A + B - 1 == C:\n        # Shift a stick from B to C\n        B -= 1\n        C += 1\n    elif A + 1 + B == C:\n        # Shift a stick from C to A\n        C -= 1\n        A += 1\n    elif A - 1 + B == C:\n        # Shift a stick from A to C\n        A -= 1\n        C += 1\n    else:\n        print(\"Impossible\")\n        exit()\n\n    # Print the corrected expression\n    print('|' * A + '+' + '|' * B + '=' + '|' * C)"}
{"solution": "MOD = 10**9 + 7\n\ndef solve(n, k):\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(i * i + 1):\n            for l in range(i):\n                if j - l * 2 >= 0:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - l * 2]) % MOD\n\n    return dp[n][k]\n\nn, k = map(int, input().split())\nprint(solve(n, k))"}
{"solution": "def calculate_robot_arm_configuration(points):\n    n = len(points)\n    m = 2 * n\n    d = [0] * m\n    w = [[''] * n for _ in range(m)]\n\n    for i in range(n):\n        x, y = points[i]\n        d[2*i] = abs(x)\n        d[2*i+1] = abs(y)\n        if x > 0:\n            w[2*i][i] = 'R'\n        elif x < 0:\n            w[2*i][i] = 'L'\n        if y > 0:\n            w[2*i+1][i] = 'U'\n        elif y < 0:\n            w[2*i+1][i] = 'D'\n\n    return m, d, w\n\ndef main():\n    n = int(input())\n    points = [tuple(map(int, input().split())) for _ in range(n)]\n\n    m, d, w = calculate_robot_arm_configuration(points)\n\n    print(m)\n    print(' '.join(map(str, d)))\n    for i in range(m):\n        print(''.join(w[i]))\n\nif __name__ == '__main__':\n    main()"}
{"solution": "def replace_fillers(s):\n    filler = 'ogo'\n    filler_length = len(filler)\n    result = ''\n    i = 0\n\n    while i < len(s):\n        if s[i:i+filler_length] == filler:\n            result += '***'\n            i += filler_length\n            while i < len(s) and s[i:i+filler_length] == 'go':\n                i += filler_length\n        else:\n            result += s[i]\n            i += 1\n\n    return result\n\nn = int(input())\ns = input()\nprint(replace_fillers(s))"}
{"solution": "import math\n\ndef prime_factors(n):\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef g(x, p):\n    k = 0\n    while x % (p ** (k + 1)) == 0:\n        k += 1\n    return p ** k\n\ndef f(x, y):\n    factors = prime_factors(y)\n    result = 1\n    for p in factors:\n        result *= g(x, p)\n    return result\n\ndef solve(x, n):\n    mod = 10 ** 9 + 7\n    result = 1\n    for i in range(1, n + 1):\n        result = (result * f(x, i)) % mod\n    return result\n\nx, n = map(int, input().split())\nprint(solve(x, n))"}
{"solution": "def sum_of_digits(x):\n    return sum(int(digit) for digit in str(x))\n\ndef find_solutions(a, b, c):\n    solutions = []\n    for s in range(1, 82):  # s(x) can be at most 81\n        x = b * (s ** a) + c\n        if 0 < x < 10**9 and sum_of_digits(x) == s:\n            solutions.append(x)\n    solutions.sort()\n    return solutions\n\n# Read input\na, b, c = map(int, input().split())\n\n# Find solutions\nsolutions = find_solutions(a, b, c)\n\n# Print results\nprint(len(solutions))\nif solutions:\n    print(\" \".join(map(str, solutions)))"}
{"solution": "def check_cube(colors):\n    color_count = {}\n    for color in colors:\n        if color in color_count:\n            color_count[color] += 1\n        else:\n            color_count[color] = 1\n\n    if sorted(color_count.values()) == [4, 4, 8, 8]:\n        return \"YES\"\n    else:\n        return \"NO\"\n\ncolors = list(map(int, input().split()))\nprint(check_cube(colors))"}
{"solution": "def solve(p, x, y):\n    # Calculate the initial value of i\n    i = ((y - 1) // 100 * 50) % 475\n\n    # Repeat the calculation 25 times to find the positions that will receive a T-shirt\n    t_shirt_positions = set()\n    for _ in range(25):\n        i = (i * 96 + 42) % 475\n        t_shirt_positions.add(26 + i)\n\n    # If the programmer's position is already in the T-shirt positions, no hacks are needed\n    if p in t_shirt_positions:\n        return 0\n\n    # Calculate the number of successful hacks needed\n    successful_hacks = (y - x) // 100\n\n    # Calculate the new position after the successful hacks\n    new_i = ((x + successful_hacks * 100) // 100 * 50) % 475\n    for _ in range(25):\n        new_i = (new_i * 96 + 42) % 475\n        if 26 + new_i == p:\n            return successful_hacks\n\n    # If the programmer still doesn't have a T-shirt, additional successful hacks are needed\n    while True:\n        successful_hacks += 1\n        new_i = ((x + successful_hacks * 100) // 100 * 50) % 475\n        for _ in range(25):\n            new_i = (new_i * 96 + 42) % 475\n            if 26 + new_i == p:\n                return successful_hacks\n\n# Read the input\np, x, y = map(int, input().split())\n\n# Print the result\nprint(solve(p, x, y))"}
{"solution": "# Read input\nn = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\n# Initialize minimum distance\nmin_distance = float('inf')\n\n# Iterate through all possible paths\nfor i in range(n):\n    # Calculate distance for current path\n    distance = i * a + (n - i - 1) * min(b, c)\n    # Update minimum distance\n    min_distance = min(min_distance, distance)\n\n# Print minimum distance\nprint(min_distance)"}
{"solution": "# Get the coordinates of the houses of the three friends\nx1, x2, x3 = map(int, input().split())\n\n# Sort the coordinates in ascending order\ncoordinates = sorted([x1, x2, x3])\n\n# Calculate the minimum total distance the friends need to travel\nmin_distance = (coordinates[1] - coordinates[0]) + (coordinates[2] - coordinates[1])\n\n# Print the minimum total distance\nprint(min_distance)"}
{"solution": "def min_operations(n, x, arr):\n    # Create a set to store unique elements after bitwise AND operation\n    unique_elements = set()\n\n    # Initialize the count of operations\n    operations = 0\n\n    # Iterate through the array\n    for i in range(n):\n        # Perform bitwise AND operation with x\n        arr[i] &= x\n\n        # If the element is already in the set, return the number of operations\n        if arr[i] in unique_elements:\n            return operations\n\n        # Add the element to the set\n        unique_elements.add(arr[i])\n\n        # Increment the number of operations\n        operations += 1\n\n    # If no two elements are equal, return -1\n    return -1\n\n# Read input\nn, x = map(int, input().split())\narr = list(map(int, input().split()))\n\n# Print the minimal number of operations\nprint(min_operations(n, x, arr))"}
{"solution": "def is_plus_shape(grid):\n    h = len(grid)\n    w = len(grid[0])\n    center = None\n\n    # Scanning the Grid\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == '*':\n                if center is not None:\n                    return False  # More than one center\n                center = (i, j)\n\n    if center is None:\n        return False  # No center\n\n    # Checking Conditions\n    for i in range(center[0] - 1, -1, -1):\n        if grid[i][center[1]] != '*':\n            break\n    else:\n        return False  # No vertical ray to the top\n\n    for i in range(center[0] + 1, h):\n        if grid[i][center[1]] != '*':\n            break\n    else:\n        return False  # No vertical ray to the bottom\n\n    for j in range(center[1] - 1, -1, -1):\n        if grid[center[0]][j] != '*':\n            break\n    else:\n        return False  # No horizontal ray to the left\n\n    for j in range(center[1] + 1, w):\n        if grid[center[0]][j] != '*':\n            break\n    else:\n        return False  # No horizontal ray to the right\n\n    # Ensuring Uniqueness\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == '*' and (i, j) != center:\n                if abs(i - center[0]) == abs(j - center[1]):\n                    return False  # Part of another '+' shape\n                elif i == center[0] or j == center[1]:\n                    return False  # Part of another line\n\n    return True\n\nh, w = map(int, input().split())\ngrid = [input() for _ in range(h)]\n\nprint(\"YES\" if is_plus_shape(grid) else \"NO\")"}
{"solution": "def create_matrix(n, a, b):\n    # Check if it's possible to create such a graph\n    if a + b > n + 1 or a * b < n - 1:\n        return \"NO\"\n\n    # Create an empty matrix\n    matrix = [[0] * n for _ in range(n)]\n\n    # Create 'a' components\n    for i in range(a - 1):\n        matrix[i][i + 1] = matrix[i + 1][i] = 1\n\n    # Create 'b' components in the complement\n    for i in range(a, a + b - 1):\n        matrix[i][i + 1] = matrix[i + 1][i] = 1\n\n    # Connect the last component to the first component of the complement\n    matrix[a - 1][a] = matrix[a][a - 1] = 1\n\n    # Fill the remaining cells\n    for i in range(a + b, n):\n        matrix[i][0] = matrix[0][i] = 1\n\n    return matrix\n\ndef print_matrix(matrix):\n    print(\"YES\")\n    for row in matrix:\n        print(\"\".join(map(str, row)))\n\nn, a, b = map(int, input().split())\nresult = create_matrix(n, a, b)\nif result == \"NO\":\n    print(result)\nelse:\n    print_matrix(result)"}
{"solution": "# Read input\nc, d = map(int, input().split())\nn, m = map(int, input().split())\nk = int(input())\n\n# Calculate the number of main rounds needed\nmain_rounds = max(0, m * n - k)\n\n# Calculate the number of additional rounds needed\nadditional_rounds = max(0, main_rounds - n)\n\n# Calculate the total number of problems needed\ntotal_problems = main_rounds * c + additional_rounds * d\n\n# Print the result\nprint(total_problems)"}
{"solution": "def create_grid(s):\n    # Create an adjacency list for each letter\n    adj = {letter: [] for letter in s}\n    for i in range(len(s) - 1):\n        adj[s[i]].append(s[i + 1])\n        adj[s[i + 1]].append(s[i])\n\n    # Create a grid with the first row\n    grid = [list(s[:13]), [' '] * 13]\n\n    # Fill the second row\n    for i in range(13):\n        # Find a letter that is adjacent to the current letter\n        for letter in adj[grid[0][i]]:\n            if letter not in grid[1]:\n                grid[1][i] = letter\n                adj[grid[0][i]].remove(letter)\n                adj[letter].remove(grid[0][i])\n                break\n        else:\n            # No adjacent letter found\n            return \"Impossible\"\n\n    # Convert the grid to strings\n    return ''.join(grid[0]), ''.join(grid[1])\n\n# Read the input\ns = input()\n\n# Create the grid\nresult = create_grid(s)\n\n# Print the result\nif result == \"Impossible\":\n    print(result)\nelse:\n    print(result[0])\n    print(result[1])"}
{"solution": "import math\n\ndef compare_powers(x, y):\n    if x == y:\n        return '='\n    elif x == 1:\n        return '<' if y > 1 else '='\n    elif y == 1:\n        return '>' if x > 1 else '='\n    else:\n        # Compute y * log(x) and x * log(y)\n        lhs = y * math.log(x)\n        rhs = x * math.log(y)\n\n        if lhs < rhs:\n            return '<'\n        elif lhs > rhs:\n            return '>'\n        else:\n            return '='\n\n# Read input\nx, y = map(int, input().split())\n\n# Output the result of the comparison\nprint(compare_powers(x, y))"}
{"solution": "import math\n\n# Get the input values for the radius and height of the cupboard\nr, h = map(int, input().split())\n\n# Calculate the volume of the cupboard\ncupboard_volume = (2/3) * math.pi * r**2 * (h + r)\n\n# Calculate the volume of a single balloon\nballoon_volume = (4/3) * math.pi * (r/2)**3\n\n# Calculate the maximum number of balloons that can fit in the cupboard\nmax_balloons = int(cupboard_volume / balloon_volume)\n\n# Print the result\nprint(max_balloons)"}
{"solution": "def min_sum(cards):\n    # Count the frequency of each number\n    freq = {}\n    for card in cards:\n        if card in freq:\n            freq[card] += 1\n        else:\n            freq[card] = 1\n\n    # Sort the numbers based on their frequency\n    sorted_freq = sorted(freq.items(), key=lambda x: x[1], reverse=True)\n\n    # Calculate the minimum sum\n    min_sum = sum(cards)\n    for num, count in sorted_freq:\n        if count >= 2:\n            min_sum -= 2 * num\n            break\n        elif count >= 3:\n            min_sum -= 3 * num\n            break\n\n    return min_sum\n\n# Read the input\ncards = list(map(int, input().split()))\n\n# Print the minimum sum\nprint(min_sum(cards))"}
{"solution": "# Read input\nn, a = map(int, input().split())\ncheckpoints = list(map(int, input().split()))\n\n# Sort checkpoints\ncheckpoints.sort()\n\n# Initialize minimum distance\nmin_distance = float('inf')\n\n# If Vasya's starting position is to the left of the first checkpoint\nif a <= checkpoints[0]:\n    min_distance = checkpoints[-1] - a\n# If Vasya's starting position is to the right of the last checkpoint\nelif a >= checkpoints[-1]:\n    min_distance = a - checkpoints[0]\n# If Vasya's starting position is between two checkpoints\nelse:\n    # Find the two checkpoints that are closest to Vasya's starting position\n    left = max([x for x in checkpoints if x <= a])\n    right = min([x for x in checkpoints if x >= a])\n\n    # Calculate the minimum distance\n    min_distance = min(a - left + right - left, right - a + right - left)\n\n# Print the minimum distance\nprint(min_distance)"}
{"solution": "def sum_of_digits(n):\n    return sum(int(digit) for digit in str(n))\n\ndef equation(x, n):\n    return x**2 + sum_of_digits(x)*x - n\n\ndef find_root(n):\n    left, right = 1, n\n    while left <= right:\n        mid = (left + right) // 2\n        if equation(mid, n) < 0:\n            left = mid + 1\n        elif equation(mid, n) > 0:\n            right = mid - 1\n        else:\n            return mid\n    return -1\n\nn = int(input())\nprint(find_root(n))"}
{"solution": "from datetime import datetime, timedelta\n\n# Get the current time and sleep duration from the user\ncurrent_time = input()\nsleep_duration = input()\n\n# Convert the time strings to datetime objects\ncurrent_time = datetime.strptime(current_time, \"%H:%M\")\nsleep_duration = datetime.strptime(sleep_duration, \"%H:%M\")\n\n# Calculate the time George went to bed\nbed_time = current_time - timedelta(hours=sleep_duration.hour, minutes=sleep_duration.minute)\n\n# Print the bed time in the correct format\nprint(bed_time.strftime(\"%H:%M\"))"}
{"solution": "# Read the input\nn = int(input())\narr = list(map(int, input().split()))\n\n# Initialize variables\nmax_mean = float('-inf')\nmax_len = 0\ncurr_sum = 0\ncurr_len = 0\n\n# Iterate over the array\nfor i in range(n):\n    curr_sum += arr[i]\n    curr_len += 1\n\n    # If current mean is greater than max_mean, update max_mean and max_len\n    if curr_sum / curr_len > max_mean:\n        max_mean = curr_sum / curr_len\n        max_len = curr_len\n    # If current mean is equal to max_mean, update max_len if current length is greater\n    elif curr_sum / curr_len == max_mean:\n        max_len = max(max_len, curr_len)\n    # If current sum is less than 0, reset current sum and length\n    elif curr_sum < 0:\n        curr_sum = 0\n        curr_len = 0\n\n# Print the result\nprint(max_len)"}
{"solution": "MOD = 998244353\n\ndef solve(n, m, k):\n    dp = [[0] * (k + 1) for _ in range(n)]\n    dp[0][0] = m\n\n    for i in range(1, n):\n        for j in range(k + 1):\n            dp[i][j] = dp[i - 1][j] * (m - 1) % MOD\n            if j > 0:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD\n\n    return sum(dp[n - 1]) % MOD\n\nn, m, k = map(int, input().split())\nprint(solve(n, m, k))"}
{"solution": "import re\n\ndef is_magic_number(n):\n    # Define the regular expression pattern for magic numbers\n    pattern = re.compile(r'^(1|14|144)+$')\n\n    # Check if the entire number matches the pattern\n    if pattern.match(str(n)):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Example usage\nn = int(input())\nprint(is_magic_number(n))"}
{"solution": "def min_moves(n, m, i, j, a, b):\n    # Calculate the distance to each corner\n    dist_to_corners = [\n        abs(i - 1) + abs(j - m),\n        abs(i - n) + abs(j - 1),\n        abs(i - n) + abs(j - m),\n        abs(i - 1) + abs(j - 1)\n    ]\n\n    # Check if it's possible to reach a corner\n    for dist in dist_to_corners:\n        if dist % (a + b) == 0:\n            return dist // (a + b)\n\n    return \"Poor Inna and pony!\"\n\n# Read input\nn, m, i, j, a, b = map(int, input().split())\n\n# Print output\nprint(min_moves(n, m, i, j, a, b))"}
{"solution": "def solve(s):\n    n = len(s)\n    prev = [0] * n\n    for i in range(1, n):\n        if ord(s[i]) - ord(s[i - 1]) == 1:\n            prev[i] = i - 1\n        else:\n            prev[i] = prev[i - 1]\n\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = dp[prev[i]] + 1\n\n    return n - max(dp)\n\nn = int(input())\ns = input()\nprint(solve(s))"}
{"solution": "def solve():\n    n, k = map(int, input().split())\n    denominations = list(map(int, input().split()))\n    q = int(input())\n\n    # dp[i][j] is True if it's possible to obtain sum j using at most i denominations\n    dp = [[False] * (k * denominations[-1] + 1) for _ in range(3)]\n    dp[0][0] = True\n\n    for i in range(1, 3):\n        for j in range(denominations[i - 1] + 1):\n            dp[i][j] = dp[i - 1][j]\n        for j in range(denominations[i - 1] + 1, k * denominations[-1] + 1):\n            dp[i][j] = dp[i - 1][j] or dp[i][j - denominations[i - 1]]\n\n    for _ in range(q):\n        x = int(input())\n        if dp[2][x]:\n            # dp[i][j] is the minimum number of bills required to obtain sum j using at most i denominations\n            count = 0\n            for i in range(2, -1, -1):\n                while x >= denominations[i] and dp[i][x - denominations[i]]:\n                    x -= denominations[i]\n                    count += 1\n            print(count)\n        else:\n            print(-1)\n\nsolve()"}
{"solution": "def min_time(s, x1, x2, t1, t2, p, d):\n    # Calculate the time it takes Igor to walk to the nearest tram stop\n    walk_time = abs(x1 - p) * t2\n\n    # Calculate the time it takes the tram to reach the destination\n    if d == 1:\n        tram_time = (s - p) * t1\n    else:\n        tram_time = p * t1\n\n    # Calculate the time it takes Igor to reach the destination by walking\n    walk_dest_time = abs(x2 - x1) * t2\n\n    # Calculate the time it takes Igor to reach the destination by taking the tram\n    if d == 1:\n        tram_dest_time = min(abs(x2 - p) * t1, (s - x2) * t1 + abs(p - x2) * t1)\n    else:\n        tram_dest_time = min(abs(x2 - p) * t1, x2 * t1 + abs(p - x2) * t1)\n\n    # Return the minimum time Igor needs to reach the destination\n    return min(walk_time + walk_dest_time, walk_time + tram_dest_time)\n\n# Read the input values\ns, x1, x2 = map(int, input().split())\nt1, t2 = map(int, input().split())\np, d = map(int, input().split())\n\n# Calculate and print the minimum time Igor needs to reach the destination\nprint(min_time(s, x1, x2, t1, t2, p, d))"}
{"solution": "# Get input\nn, x = map(int, input().split())\n\n# Initialize count\ncount = 0\n\n# Iterate over rows\nfor i in range(1, n + 1):\n    # Check if x is a multiple of i\n    if x % i == 0:\n        # Calculate the corresponding column\n        j = x // i\n        # Check if j is within the table's range\n        if j <= n:\n            # Increment count\n            count += 1\n\n# Print the result\nprint(count)"}
{"solution": "def generate_password(n, k):\n    # Determine the set of distinct lowercase Latin letters to use\n    letters = 'abcdefghijklmnopqrstuvwxyz'\n    distinct_letters = letters[:k]\n\n    # Develop a strategy to ensure that no two consecutive symbols are the same\n    password = []\n    for i in range(n):\n        if i == 0 or password[-1] != distinct_letters[i % k]:\n            password.append(distinct_letters[i % k])\n        else:\n            password.append(distinct_letters[(i + 1) % k])\n\n    # Join the list of characters into a string and return\n    return ''.join(password)\n\n# Read the input\nn, k = map(int, input().split())\n\n# Generate and print the password\nprint(generate_password(n, k))"}
{"solution": "def first_collision_time(n, directions, positions):\n    min_time = float('inf')\n    collision_found = False\n\n    for i in range(n - 1):\n        if directions[i] == 'R' and directions[i + 1] == 'L':\n            collision_time = (positions[i + 1] - positions[i]) // 2\n            min_time = min(min_time, collision_time)\n            collision_found = True\n\n    if collision_found:\n        return min_time\n    else:\n        return -1\n\nn = int(input())\ndirections = input()\npositions = list(map(int, input().split()))\nprint(first_collision_time(n, directions, positions))"}
{"solution": "def max_area(n, a, b, seals):\n    # Sort seals by their area in descending order\n    seals.sort(key=lambda x: x[0]*x[1], reverse=True)\n\n    # Initialize maximum area\n    max_area = 0\n\n    # Iterate over all pairs of seals\n    for i in range(n):\n        for j in range(i+1, n):\n            # Get dimensions of the current pair of seals\n            x1, y1 = seals[i]\n            x2, y2 = seals[j]\n\n            # Check if the seals can be placed without overlapping\n            if (x1 <= a and y1 <= b and x2 <= a and y2 <= b) or \\\n               (x1 <= b and y1 <= a and x2 <= b and y2 <= a):\n                # Update maximum area\n                max_area = max(max_area, x1*y1 + x2*y2)\n\n    return max_area\n\n# Read input\nn, a, b = map(int, input().split())\nseals = [list(map(int, input().split())) for _ in range(n)]\n\n# Print output\nprint(max_area(n, a, b, seals))"}
{"solution": "# Read the number of points on each side of the square\nn = int(input())\n\n# Initialize empty lists to store the x and y coordinates\nx_coords = []\ny_coords = []\n\n# Read the coordinates and store them in the lists\nfor _ in range(4*n + 1):\n    x, y = map(int, input().split())\n    x_coords.append(x)\n    y_coords.append(y)\n\n# Find the unique x and y coordinates\nunique_x_coords = list(set(x_coords))\nunique_y_coords = list(set(y_coords))\n\n# Sort the unique coordinates\nunique_x_coords.sort()\nunique_y_coords.sort()\n\n# The point that is not on the boundary of the square will be the one that is not in the sorted list of unique coordinates\nfor x in x_coords:\n    if x not in unique_x_coords:\n        non_boundary_x = x\n        break\n\nfor y in y_coords:\n    if y not in unique_y_coords:\n        non_boundary_y = y\n        break\n\n# Print the coordinates of the point that is not on the boundary of the square\nprint(non_boundary_x, non_boundary_y)"}
{"solution": "def max_product(n):\n    if n < 10:\n        return n\n\n    product = 1\n    while n > 0:\n        if n >= 9:\n            product *= 9\n            n -= 9\n        else:\n            product *= n\n            n = 0\n\n    return product\n\nn = int(input())\nprint(max_product(n))"}
{"solution": "# Read the number of students\nn = int(input())\n\n# Read the votes for Elodreip\nvotes = list(map(int, input().split()))\n\n# Calculate the total votes for Elodreip\ntotal_elodreip_votes = sum(votes)\n\n# Initialize k as the maximum value in the list of votes\nk = max(votes)\n\n# Calculate the total votes for Awruk\ntotal_awruk_votes = sum(k - vote for vote in votes)\n\n# Increment k until Awruk's votes exceed Elodreip's votes\nwhile total_awruk_votes <= total_elodreip_votes:\n    k += 1\n    total_awruk_votes = sum(k - vote for vote in votes)\n\n# Print the smallest winning number k\nprint(k)"}
{"solution": "def count_operations(colors):\n    # Initialize operations count\n    operations = 0\n\n    # Loop until no more operations can be performed\n    while True:\n        # Initialize a flag to check if any deletions were made\n        deleted = False\n\n        # Initialize an empty list to store the new colors\n        new_colors = []\n\n        # Iterate over the colors\n        for i in range(len(colors)):\n            # If the point has a neighbor of a different color\n            if i > 0 and i < len(colors) - 1 and colors[i] != colors[i - 1] and colors[i] != colors[i + 1]:\n                # Mark the point for deletion\n                deleted = True\n            else:\n                # Keep the point\n                new_colors.append(colors[i])\n\n        # If no deletions were made, break the loop\n        if not deleted:\n            break\n\n        # Increment the operations count\n        operations += 1\n\n        # Update the colors\n        colors = new_colors\n\n    # Return the operations count\n    return operations\n\n# Read the input\ncolors = input()\n\n# Print the output\nprint(count_operations(colors))"}
{"solution": "# Read the input\nn = int(input())\na = list(map(int, input().split()))\n\n# Sort the array\na.sort()\n\n# Initialize the count of triples\ncount = 0\n\n# Find the minimum product\nmin_product = a[0] * a[1] * a[2]\n\n# Iterate over the array\nfor i in range(n - 2):\n    for j in range(i + 1, n - 1):\n        for k in range(j + 1, n):\n            # If the product is equal to the minimum product, increment the count\n            if a[i] * a[j] * a[k] == min_product:\n                count += 1\n\n# Print the count\nprint(count)"}
{"solution": "import math\n\ndef min_cuts(n):\n    # Start with the largest possible factor\n    for i in range(int(math.sqrt(n + 1)), 0, -1):\n        # If i is a factor of n + 1\n        if (n + 1) % i == 0:\n            # Return the sum of the factors minus 1 (since the pizza is already divided into i slices)\n            return i + (n + 1) // i - 1\n    # If no factors are found, return n (which means the pizza needs to be cut n times)\n    return n\n\n# Get the input\nn = int(input())\n# Print the output\nprint(min_cuts(n))"}
{"solution": "def maximize_bank_account(n):\n    if n < 0:\n        # If the number is negative, we want to remove the smallest digit\n        # to minimize the absolute value of the number\n        n = str(n)\n        if len(n) == 2:\n            return int(n[0])\n        elif int(n[-1]) < int(n[-2]):\n            return int(n[:-1])\n        else:\n            return int(n[:-2] + n[-1])\n    else:\n        # If the number is positive or zero, we don't need to remove any digit\n        return n\n\n# Read the input\nn = int(input())\n\n# Print the output\nprint(maximize_bank_account(n))"}
{"solution": "# Define the spinner positions and their relationships\npositions = ['v', '>', '^', '<']\nrelationships = {\n    'v>': 'cw',\n    '>^': 'cw',\n    '^<': 'cw',\n    '<v': 'cw',\n    'v<': 'ccw',\n    '<^': 'ccw',\n    '^>': 'ccw',\n    '>v': 'ccw'\n}\n\n# Get the input\nstart, end = input().split()\nn = int(input())\n\n# Determine the direction\ndirection = relationships.get(start + end, 'undefined')\n\n# If the direction is undefined, check if the start and end positions are the same\nif direction == 'undefined' and start == end:\n    direction = 'cw' if n % 4 == 1 else 'undefined'\n\n# Print the result\nprint(direction)"}
{"solution": "n = int(input())\ns = input()\n\n# Initialize an array to store the state of each domino\ndominoes = ['S'] * n\n\n# Iterate over the input string\nfor i in range(n):\n    if s[i] == 'L':\n        # If the domino is pushed to the left, all dominoes to its right that are not pushed to the right will fall\n        j = i + 1\n        while j < n and s[j] != 'R':\n            dominoes[j] = 'L'\n            j += 1\n    elif s[i] == 'R':\n        # If the domino is pushed to the right, all dominoes to its left that are not pushed to the left will fall\n        j = i - 1\n        while j >= 0 and s[j] != 'L':\n            dominoes[j] = 'R'\n            j -= 1\n\n# Count the number of dominoes that remain standing vertically\ncount = dominoes.count('S')\nprint(count)"}
{"solution": "def solve_game(n, m, leaders):\n    # Initialize the permutation with -1\n    permutation = [-1] * n\n\n    # Iterate over the leaders in reverse order\n    for i in range(m - 1, 0, -1):\n        # Calculate the difference between the current and previous leader\n        diff = (leaders[i] - leaders[i - 1]) % n\n\n        # If the difference is 0 or already assigned, return -1\n        if diff == 0 or permutation[(leaders[i - 1] - 1) % n] != -1:\n            return -1\n\n        # Assign the difference to the previous leader's position\n        permutation[(leaders[i - 1] - 1) % n] = diff\n\n    # Calculate the difference between the first leader and the last position\n    diff = (leaders[0] - permutation[-1]) % n\n\n    # If the difference is 0 or already assigned, return -1\n    if diff == 0 or permutation[-1] != -1:\n        return -1\n\n    # Assign the difference to the last position\n    permutation[-1] = diff\n\n    # Return the permutation\n    return permutation\n\n# Read the input\nn, m = map(int, input().split())\nleaders = list(map(int, input().split()))\n\n# Solve the game\nresult = solve_game(n, m, leaders)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(*result)"}
{"solution": "def max_number(a, k):\n    # Convert the number to a list of digits\n    digits = list(str(a))\n\n    # Iterate through the digits\n    for i in range(len(digits)):\n        # If no more swaps are allowed, break\n        if k == 0:\n            break\n\n        # Find the best possible digit to swap with\n        max_digit = max(digits[i:])\n        max_index = digits[i:].index(max_digit) + i\n\n        # If the best digit is not the current digit and swapping is beneficial\n        if max_index != i and max_digit > digits[i]:\n            # Perform the swap\n            digits[i], digits[max_index] = digits[max_index], digits[i]\n            k -= 1\n\n    # Convert the list of digits back to a number\n    return int(''.join(digits))\n\n# Read the input\na, k = map(int, input().split())\n\n# Print the maximum number that Pasha can get\nprint(max_number(a, k))"}
{"solution": "def find_next_number(sequence):\n    # Check if the sequence is arithmetic\n    if sequence[1] - sequence[0] == sequence[2] - sequence[1] == sequence[3] - sequence[2]:\n        return sequence[-1] + (sequence[1] - sequence[0])\n\n    # Check if the sequence is geometric\n    if sequence[1] / sequence[0] == sequence[2] / sequence[1] == sequence[3] / sequence[2]:\n        return sequence[-1] * (sequence[1] / sequence[0])\n\n    # If the sequence is neither arithmetic nor geometric\n    return 42\n\n# Get the input sequence\nsequence = list(map(int, input().split()))\n\n# Print the next number in the sequence\nprint(find_next_number(sequence))"}
{"solution": "def max_distance(n, colors):\n    # Find the first and last occurrence of each color\n    first_occurrence = {}\n    last_occurrence = {}\n\n    for i in range(n):\n        color = colors[i]\n        if color not in first_occurrence:\n            first_occurrence[color] = i\n        last_occurrence[color] = i\n\n    # Get the list of unique colors\n    unique_colors = list(first_occurrence.keys())\n\n    # Calculate the maximum distance\n    max_dist = 0\n\n    # Compare distances from the first house to the last house of a different color\n    for color in unique_colors:\n        if colors[0] != color:\n            max_dist = max(max_dist, last_occurrence[color])\n        if colors[-1] != color:\n            max_dist = max(max_dist, n - 1 - first_occurrence[color])\n\n    return max_dist\n\n# Read input\nn = int(input())\ncolors = list(map(int, input().split()))\n\n# Print output\nprint(max_distance(n, colors))"}
{"solution": "# Get the input\nn, m, k = map(int, input().split())\n\n# Calculate the lane\nlane = (k - 1) // (2 * m) + 1\n\n# Calculate the desk\ndesk = ((k - 1) % (2 * m)) // 2 + 1\n\n# Calculate the side\nside = 'L' if (k - 1) % 2 == 0 else 'R'\n\n# Print the output\nprint(lane, desk, side)"}
{"solution": "n = int(input())\ns = input()\n\n# Count the number of 'B', 'G', and 'R'\nb_count = s.count('B')\ng_count = s.count('G')\nr_count = s.count('R')\n\n# Determine the parity of the counts\nb_parity = b_count % 2\ng_parity = g_count % 2\nr_parity = r_count % 2\n\n# Determine the possible final colors\nif b_parity == 0 and g_parity == 0 and r_parity == 0:\n    final_colors = 'BGR'\nelif b_parity == 1 and g_parity == 0 and r_parity == 0:\n    final_colors = 'B'\nelif b_parity == 0 and g_parity == 1 and r_parity == 0:\n    final_colors = 'G'\nelif b_parity == 0 and g_parity == 0 and r_parity == 1:\n    final_colors = 'R'\nelif b_parity == 1 and g_parity == 1 and r_parity == 0:\n    final_colors = 'BR'\nelif b_parity == 1 and g_parity == 0 and r_parity == 1:\n    final_colors = 'GR'\nelif b_parity == 0 and g_parity == 1 and r_parity == 1:\n    final_colors = 'BG'\nelse:\n    final_colors = 'BGR'\n\n# Print the possible final colors in alphabetical order\nprint(''.join(sorted(final_colors)))"}
