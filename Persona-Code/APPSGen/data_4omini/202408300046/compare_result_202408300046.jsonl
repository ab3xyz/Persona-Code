{"solution": "def max_accordion_length(s):\n    # Initialize variables to track the positions of the first and last brackets and colons\n    first_open = s.find('[')\n    last_close = s.rfind(']')\n    first_colon = s.find(':')\n    last_colon = s.rfind(':')\n\n    # Check if we have valid positions for the accordion structure\n    if first_open == -1 or last_close == -1 or first_colon == -1 or last_colon == -1:\n        return -1\n\n    # Ensure the positions are in the correct order\n    if first_open < first_colon < last_colon < last_close:\n        # Count the number of vertical lines between the colons\n        vertical_lines = s[first_colon + 1:last_colon].count('|')\n        # The length of the accordion is the fixed length (4) plus the number of vertical lines\n        return 4 + vertical_lines\n    else:\n        return -1\n\n# Read input\ns = input().strip()\n# Output the result\nprint(max_accordion_length(s))"}
{"solution": "def max_digit_sum(x):\n    str_x = str(x)\n    n = len(str_x)\n    \n    # Start with the original number\n    max_sum = sum(int(d) for d in str_x)\n    best_number = x\n    \n    # Try to create numbers by reducing digits\n    for i in range(n):\n        if str_x[i] == '0':\n            continue\n        \n        # Create a new number by reducing the current digit and setting all following digits to 9\n        new_number = str_x[:i] + str(int(str_x[i]) - 1) + '9' * (n - i - 1)\n        new_number = int(new_number)\n        \n        if new_number > 0:\n            current_sum = sum(int(d) for d in str(new_number))\n            if current_sum > max_sum or (current_sum == max_sum and new_number > best_number):\n                max_sum = current_sum\n                best_number = new_number\n    \n    return best_number\n\nx = int(input().strip())\nprint(max_digit_sum(x))"}
{"solution": "n = int(input())\n\ndef is_lucky_year(year):\n    non_zero_digits = [digit for digit in str(year) if digit != '0']\n    return len(non_zero_digits) <= 1\n\nnext_year = n + 1\nwhile not is_lucky_year(next_year):\n    next_year += 1\n\nprint(next_year - n)"}
{"solution": "def max_painted_sections(n, q, painters):\n    def count_painted(painters):\n        painted = [0] * (n + 1)\n        for l, r in painters:\n            for i in range(l, r + 1):\n                painted[i] = 1\n        return sum(painted)\n\n    max_sections = 0\n    for i in range(q):\n        for j in range(i + 1, q):\n            selected_painters = [painters[k] for k in range(q) if k != i and k != j]\n            max_sections = max(max_sections, count_painted(selected_painters))\n\n    return max_sections\n\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\nprint(max_painted_sections(n, q, painters))"}
{"solution": "def is_lucky(hh, mm):\n    return '7' in f\"{hh:02d}{mm:02d}\"\n\ndef time_before(hh, mm, x):\n    mm -= x\n    if mm < 0:\n        mm += 60\n        hh -= 1\n        if hh < 0:\n            hh += 24\n    return hh, mm\n\ndef minimum_snooze_presses(x, hh, mm):\n    presses = 0\n    while not is_lucky(hh, mm):\n        hh, mm = time_before(hh, mm, x)\n        presses += 1\n    return presses\n\nx = int(input().strip())\nhh, mm = map(int, input().strip().split())\nprint(minimum_snooze_presses(x, hh, mm))"}
{"solution": "def min_seconds_to_close_tabs(n, pos, l, r):\n    if l == 1 and r == n:\n        return 0  # No tabs to close\n\n    seconds = 0\n\n    # Close tabs to the left of l\n    if pos > l:\n        seconds += (pos - l) + 1  # Move to l and close left\n    else:\n        seconds += (l - pos)  # Just move to l\n\n    # Close tabs to the right of r\n    if pos < r:\n        seconds += (r - pos) + 1  # Move to r and close right\n    else:\n        seconds += (pos - r)  # Just move to r\n\n    return seconds\n\n# Input reading\nn, pos, l, r = map(int, input().split())\n# Output the result\nprint(min_seconds_to_close_tabs(n, pos, l, r))"}
{"solution": "def min_blows_to_defeat_zmei(t, queries):\n    results = []\n    \n    for query in queries:\n        n, x, blows = query\n        min_blows = float('inf')\n        \n        for d, h in blows:\n            if d >= x:\n                min_blows = min(min_blows, 1)\n            else:\n                # Calculate the effective damage and growth\n                effective_damage = d - h\n                if effective_damage > 0:\n                    # Calculate the number of blows needed\n                    blows_needed = (x - d + effective_damage - 1) // effective_damage + 1\n                    min_blows = min(min_blows, blows_needed)\n        \n        results.append(min_blows if min_blows != float('inf') else -1)\n    \n    return results\n\n# Read input\nt = int(input())\nqueries = []\nfor _ in range(t):\n    n, x = map(int, input().split())\n    blows = [tuple(map(int, input().split())) for _ in range(n)]\n    queries.append((n, x, blows))\n\n# Get results\nresults = min_blows_to_defeat_zmei(t, queries)\n\n# Print output\nfor result in results:\n    print(result)"}
{"solution": "def day_when_barn_empty(n, m):\n    day = 0\n    grains = n\n    \n    while grains > 0:\n        day += 1\n        grains += m  # grains brought to the barn\n        if grains > n:\n            grains = n  # barn can't exceed its capacity\n        grains -= day  # sparrows eat grains\n        \n    return day\n\n# Read input\nn, m = map(int, input().split())\n# Output the result\nprint(day_when_barn_empty(n, m))"}
{"solution": "def min_tiles_to_draw(tiles):\n    from collections import defaultdict\n\n    # Parse the input tiles\n    hand = tiles.split()\n    counts = defaultdict(int)\n    suits = defaultdict(list)\n\n    for tile in hand:\n        num = int(tile[0])\n        suit = tile[1]\n        counts[tile] += 1\n        suits[suit].append(num)\n\n    # Check for koutsu (triplet)\n    for tile, count in counts.items():\n        if count >= 3:\n            return 0  # Already has a koutsu\n\n    # Check for shuntsu (sequence)\n    for suit, numbers in suits.items():\n        numbers.sort()\n        for i in range(len(numbers)):\n            if i + 2 < len(numbers) and numbers[i] + 1 == numbers[i + 1] and numbers[i] + 2 == numbers[i + 2]:\n                return 0  # Already has a shuntsu\n\n        # Check for possible shuntsu with one draw\n        for num in numbers:\n            if num - 1 >= 1 and num + 1 <= 9:\n                if (num - 1 not in numbers) or (num + 1 not in numbers):\n                    return 1  # Can form a shuntsu with one draw\n\n    # If no koutsu or shuntsu can be formed, check for drawing two tiles\n    return 2\n\n# Read input\ntiles = input().strip()\n# Output the result\nprint(min_tiles_to_draw(tiles))"}
{"solution": "def find_grandpa_sofa(d, n, m, sofas, cnt_l, cnt_r, cnt_t, cnt_b):\n    positions = []\n    \n    for i in range(d):\n        x1, y1, x2, y2 = sofas[i]\n        positions.append((x1, y1, x2, y2))\n    \n    for i in range(d):\n        x1, y1, x2, y2 = positions[i]\n        left_count = right_count = top_count = bottom_count = 0\n        \n        for j in range(d):\n            if i == j:\n                continue\n            x1_j, y1_j, x2_j, y2_j = positions[j]\n            \n            if x2 < x1_j:  # Sofa i is to the left of sofa j\n                left_count += 1\n            elif x1 > x2_j:  # Sofa i is to the right of sofa j\n                right_count += 1\n            if y2 < y1_j:  # Sofa i is above sofa j\n                top_count += 1\n            elif y1 > y2_j:  # Sofa i is below sofa j\n                bottom_count += 1\n        \n        if (left_count == cnt_l and right_count == cnt_r and \n            top_count == cnt_t and bottom_count == cnt_b):\n            return i + 1  # Return 1-based index\n    \n    return -1\n\n# Input reading\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nd = int(data[0])\nn, m = map(int, data[1].split())\nsofas = [tuple(map(int, line.split())) for line in data[2:d+2]]\ncnt_l, cnt_r, cnt_t, cnt_b = map(int, data[d+2].split())\n\n# Output the result\nprint(find_grandpa_sofa(d, n, m, sofas, cnt_l, cnt_r, cnt_t, cnt_b))"}
{"solution": "n = int(input())\n\n# Calculate maximum days off\nmax_days_off = (n // 7) * 2 + min(2, n % 7)\n\n# Calculate minimum days off\nif n < 5:\n    min_days_off = 0\nelse:\n    min_days_off = (n // 7) * 2\n\nprint(min_days_off, max_days_off)"}
{"solution": "def max_chocolates(n, a, b, p, q):\n    count_a = n // a\n    count_b = n // b\n    count_ab = n // (a * b)\n\n    # Calculate chocolates if we prioritize Red tiles\n    chocolates_red_first = (count_a - count_ab) * p + (count_b - count_ab) * q\n\n    # Calculate chocolates if we prioritize Blue tiles\n    chocolates_blue_first = (count_b - count_ab) * q + (count_a - count_ab) * p\n\n    # Return the maximum of both strategies\n    return max(chocolates_red_first, chocolates_blue_first)\n\n# Input reading\nn, a, b, p, q = map(int, input().split())\nprint(max_chocolates(n, a, b, p, q))"}
{"solution": "def max_beauty_with_one_swap(n, trophies):\n    # Find the lengths of segments of golden trophies\n    segments = []\n    current_length = 0\n    \n    for trophy in trophies:\n        if trophy == 'G':\n            current_length += 1\n        else:\n            if current_length > 0:\n                segments.append(current_length)\n            current_length = 0\n    \n    if current_length > 0:\n        segments.append(current_length)\n    \n    # If there are no golden trophies\n    if not segments:\n        return 0\n    \n    # Calculate the maximum length of golden trophies without any swap\n    max_length = max(segments)\n    \n    # If there is only one segment, we cannot increase its length by swapping\n    if len(segments) == 1:\n        return max_length\n    \n    # Check for possible increase by swapping\n    max_possible_length = max_length\n    \n    for i in range(len(segments) - 1):\n        # If we swap one silver trophy between two segments of golden trophies\n        max_possible_length = max(max_possible_length, segments[i] + segments[i + 1])\n    \n    # If we can swap a silver trophy with a golden trophy at the ends\n    if 'S' in trophies:\n        max_possible_length += 1\n    \n    return max_possible_length\n\n# Input reading\nn = int(input().strip())\ntrophies = input().strip()\n\n# Output the result\nprint(max_beauty_with_one_swap(n, trophies))"}
{"solution": "from collections import deque, defaultdict\nimport sys\n\ninput = sys.stdin.read\ndata = input().splitlines()\n\nn, k = map(int, data[0].split())\nmain_courses = list(map(int, data[1].split()))\ndependencies = defaultdict(list)\nin_degree = [0] * (n + 1)\n\n# Read dependencies\nfor i in range(2, n + 2):\n    line = list(map(int, data[i].split()))\n    t_i = line[0]\n    for j in range(1, t_i + 1):\n        dependencies[line[j]].append(i - 1)  # i - 2 + 1 = i - 1 (0-indexed)\n        in_degree[i - 1] += 1\n\n# Topological sort using Kahn's algorithm\nqueue = deque()\nfor course in range(n):\n    if in_degree[course] == 0:\n        queue.append(course)\n\norder = []\npassed_courses = set()\n\nwhile queue:\n    current = queue.popleft()\n    order.append(current + 1)  # Store 1-indexed course number\n    passed_courses.add(current + 1)\n\n    for dependent in dependencies[current + 1]:\n        in_degree[dependent] -= 1\n        if in_degree[dependent] == 0:\n            queue.append(dependent)\n\n# Check if all main courses can be passed\nfor main in main_courses:\n    if main not in passed_courses:\n        print(-1)\n        sys.exit()\n\n# Collect all courses that need to be passed\nresult = []\nfor course in order:\n    if course in main_courses or any(dep in passed_courses for dep in dependencies[course]):\n        result.append(course)\n\nprint(len(result))\nprint(\" \".join(map(str, result)))"}
{"solution": "def is_stack_sortable(n, k, p):\n    # Initialize the stack and the result array\n    stack = []\n    result = p[:]\n    \n    # Create a set of used numbers\n    used = set(p)\n    \n    # The next number to place in the permutation\n    next_number = n\n    \n    # Iterate over the first k elements\n    for i in range(k):\n        # While the stack is not empty and the top of the stack is the next number to append to result\n        while stack and stack[-1] == next_number:\n            result.append(stack.pop())\n            next_number -= 1\n        \n        # If the current number is not the next number, we need to push numbers onto the stack\n        if p[i] != next_number:\n            # Push the next number onto the stack if it's not used\n            while next_number in used:\n                next_number -= 1\n            if next_number < 1:\n                return -1\n            stack.append(next_number)\n            used.add(next_number)\n            next_number -= 1\n        \n        # Append the current number to the result\n        result.append(p[i])\n    \n    # After processing the first k elements, we need to empty the stack\n    while stack:\n        if stack[-1] != next_number:\n            return -1\n        result.append(stack.pop())\n        next_number -= 1\n    \n    return result\n\n# Read input\nn, k = map(int, input().split())\np = list(map(int, input().split()))\n\n# Get the result\nresult = is_stack_sortable(n, k, p)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))"}
{"solution": "a, b, c = map(int, input().split())\n\nif c == 0:\n    if a == b:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    if (b - a) % c == 0 and (b - a) // c >= 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "cnt_1 = int(input().strip())\ncnt_2 = int(input().strip())\ncnt_3 = int(input().strip())\ncnt_4 = int(input().strip())\n\n# Check if it's possible to form a regular bracket sequence\nif cnt_1 + cnt_2 < cnt_3 + cnt_4:\n    print(0)\nelse:\n    # Check if the excess of opening brackets can be balanced\n    if cnt_1 > cnt_4 + 1:\n        print(0)\n    else:\n        print(1)"}
{"solution": "n, k, t = map(int, input().split())\n\nif t <= k:\n    print(t)\nelif t <= n:\n    print(k)\nelse:\n    print(n + k - t)"}
{"solution": "def minimal_lexicographic_string(s):\n    t = []\n    u = []\n    \n    for char in s:\n        t.append(char)\n        while t:\n            if not u or t[-1] <= u[-1]:\n                u.append(t.pop())\n            else:\n                break\n    \n    return ''.join(u)\n\ns = input().strip()\nresult = minimal_lexicographic_string(s)\nprint(result)"}
{"solution": "def check_records(test_cases):\n    results = []\n    for case in test_cases:\n        n = case[0]\n        records = case[1]\n        \n        valid = True\n        prev_p, prev_c = 0, 0\n        \n        for p, c in records:\n            if p < prev_p or c < prev_c or c > p:\n                valid = False\n                break\n            if p - prev_p < c - prev_c:\n                valid = False\n                break\n            \n            prev_p, prev_c = p, c\n        \n        results.append(\"YES\" if valid else \"NO\")\n    \n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nT = int(data[0])\ntest_cases = []\nindex = 1\n\nfor _ in range(T):\n    n = int(data[index])\n    records = []\n    for j in range(n):\n        p, c = map(int, data[index + j + 1].split())\n        records.append((p, c))\n    test_cases.append((n, records))\n    index += n + 1\n\n# Get results\nresults = check_records(test_cases)\n\n# Print output\nfor result in results:\n    print(result)"}
{"solution": "def is_palindrome(time):\n    return time == time[::-1]\n\ndef next_palindrome_time(hh, mm):\n    minutes_passed = 0\n    while True:\n        mm += 1\n        if mm == 60:\n            mm = 0\n            hh += 1\n            if hh == 24:\n                hh = 0\n        minutes_passed += 1\n        time_str = f\"{hh:02}:{mm:02}\"\n        if is_palindrome(time_str):\n            return minutes_passed\n\ntime_input = input().strip()\nhh, mm = map(int, time_input.split(':'))\nresult = next_palindrome_time(hh, mm)\nprint(result)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nmin_index = a.index(1)\nmax_index = a.index(n)\n\n# Calculate the current distance\ncurrent_distance = abs(min_index - max_index)\n\n# Calculate the maximum possible distance after one swap\nmax_distance = max(abs(min_index - 0), abs(min_index - (n - 1)), abs(max_index - 0), abs(max_index - (n - 1)))\n\n# The result is the maximum of the current distance and the calculated max distance\nresult = max(current_distance, max_distance)\nprint(result)"}
{"solution": "def is_s_palindrome(s):\n    mirror_chars = {\n        'A': 'A', 'b': 'd', 'd': 'b', 'H': 'H', 'I': 'I', 'M': 'M', \n        'O': 'O', 'o': 'o', 'p': 'q', 'q': 'p', 'R': 'R', 'S': 'S', \n        'T': 'T', 'U': 'U', 'v': 'v', 'V': 'V', 'W': 'W', 'x': 'x', \n        'Y': 'Y'\n    }\n    \n    n = len(s)\n    for i in range((n + 1) // 2):\n        if s[i] not in mirror_chars or mirror_chars[s[i]] != s[n - 1 - i]:\n            print(\"NIE\")\n            return\n    print(\"TAK\")\n\ns = input().strip()\nis_s_palindrome(s)"}
{"solution": "def max_permutation_not_exceeding(a, b):\n    from itertools import permutations\n\n    a_str = str(a)\n    b_str = str(b)\n\n    # Generate all unique permutations of the digits of a\n    permuted_numbers = set(int(''.join(p)) for p in permutations(a_str))\n\n    # Filter out numbers that are greater than b and have the same length as a\n    valid_numbers = [num for num in permuted_numbers if num <= b and len(str(num)) == len(a_str)]\n\n    # Return the maximum valid number\n    return max(valid_numbers)\n\n# Input reading\na = int(input().strip())\nb = int(input().strip())\n\n# Get the result and print it\nresult = max_permutation_not_exceeding(a, b)\nprint(result)"}
{"solution": "def can_alice_win(board):\n    directions = [(1, 0), (0, 1), (1, 1), (1, -1)]  # vertical, horizontal, diagonal down-right, diagonal down-left\n    n = 10\n\n    def check_win(x, y):\n        for dx, dy in directions:\n            count = 1  # count the current position\n            # Check in the positive direction\n            for step in range(1, 5):\n                nx, ny = x + step * dx, y + step * dy\n                if 0 <= nx < n and 0 <= ny < n and board[nx][ny] == 'X':\n                    count += 1\n                else:\n                    break\n            # Check in the negative direction\n            for step in range(1, 5):\n                nx, ny = x - step * dx, y - step * dy\n                if 0 <= nx < n and 0 <= ny < n and board[nx][ny] == 'X':\n                    count += 1\n                else:\n                    break\n            if count >= 5:\n                return True\n        return False\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == '.':\n                board[i][j] = 'X'  # Place Alice's cross\n                if check_win(i, j):\n                    return \"YES\"\n                board[i][j] = '.'  # Undo the move\n    return \"NO\"\n\n# Read input\nboard = [input().strip() for _ in range(10)]\nprint(can_alice_win(board))"}
{"solution": "def create_symmetric_matrix(n, k):\n    if k > n * n or (n % 2 == 0 and k % 2 != 0):\n        return -1\n\n    matrix = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        if k <= 0:\n            break\n        for j in range(i, n):\n            if i == j:  # Diagonal element\n                if k > 0:\n                    matrix[i][j] = 1\n                    k -= 1\n            else:  # Symmetric pair\n                if k >= 2:\n                    matrix[i][j] = 1\n                    matrix[j][i] = 1\n                    k -= 2\n\n    if k > 0:\n        return -1\n\n    return matrix\n\nn, k = map(int, input().split())\nresult = create_symmetric_matrix(n, k)\n\nif result == -1:\n    print(-1)\nelse:\n    for row in result:\n        print(' '.join(map(str, row)))"}
{"solution": "import sys\n\n# Read input\nx, y, z = map(float, sys.stdin.readline().strip().split())\n\n# Define the expressions\nexpressions = [\n    (x ** (y ** z), \"x^y^z\"),\n    (x ** (z ** y), \"x^z^y\"),\n    ((x ** y) ** z, \"(x^y)^z\"),\n    ((x ** z) ** y, \"(x^z)^y\"),\n    (y ** (x ** z), \"y^x^z\"),\n    (y ** (z ** x), \"y^z^x\"),\n    ((y ** x) ** z, \"(y^x)^z\"),\n    ((y ** z) ** x, \"(y^z)^x\"),\n    (z ** (x ** y), \"z^x^y\"),\n    (z ** (y ** x), \"z^y^x\"),\n    ((z ** x) ** y, \"(z^x)^y\"),\n    ((z ** y) ** x, \"(z^y)^x\"),\n]\n\n# Find the maximum value and its corresponding expression\nmax_value, max_expression = max(expressions, key=lambda item: item[0])\n\n# Print the result\nprint(max_expression)"}
{"solution": "n = int(input())\ns = input()\n\nmin_operations = n  # Start with the maximum operations (typing all characters one by one)\n\n# Check for every possible prefix length\nfor i in range(1, n + 1):\n    prefix = s[:i]\n    # Check if the string can be formed by prefix + copy + remaining characters\n    if s.startswith(prefix * 2):\n        # Calculate operations: type prefix + copy + remaining characters\n        operations = i + 1 + (n - 2 * i)\n        min_operations = min(min_operations, operations)\n\nprint(min_operations)"}
{"solution": "n = int(input())\nfiles = [input().split() for _ in range(n)]\n\nexamples = []\nregulars = []\n\nfor name, type_ in files:\n    if type_ == '1':\n        examples.append(name)\n    else:\n        regulars.append(name)\n\ne = len(examples)\nmoves = []\n\n# Move examples to their new positions\nfor i in range(e):\n    moves.append(f\"move {examples[i]} {i + 1}\")\n\n# Move regular tests to their new positions\nfor i in range(len(regulars)):\n    moves.append(f\"move {regulars[i]} {e + i + 1}\")\n\nprint(len(moves))\nfor move in moves:\n    print(move)"}
{"solution": "def min_replacements_to_lucky_ticket(ticket):\n    first_half = list(map(int, ticket[:3]))\n    second_half = list(map(int, ticket[3:]))\n    \n    sum_first = sum(first_half)\n    sum_second = sum(second_half)\n    \n    if sum_first == sum_second:\n        return 0\n    \n    # Calculate the difference\n    diff = abs(sum_first - sum_second)\n    \n    # Create a list of possible changes\n    changes = []\n    \n    if sum_first > sum_second:\n        # We need to decrease the first half or increase the second half\n        changes = [9 - digit for digit in first_half] + [digit for digit in second_half]\n    else:\n        # We need to increase the first half or decrease the second half\n        changes = [digit for digit in first_half] + [9 - digit for digit in second_half]\n    \n    # Sort changes in descending order\n    changes.sort(reverse=True)\n    \n    count = 0\n    for change in changes:\n        diff -= change\n        count += 1\n        if diff <= 0:\n            break\n    \n    return count\n\nticket = input().strip()\nprint(min_replacements_to_lucky_ticket(ticket))"}
{"solution": "def minimum_traps(m, x):\n    # Since GCD(x, m) = 1, the x-mouse will visit all rooms\n    # The number of unique rooms visited is equal to m - 1\n    # We need to place traps in a way that covers all possible starting positions\n    # The number of traps needed is m - 1\n    return m - 1\n\n# Read input\nm, x = map(int, input().split())\n# Calculate and print the result\nprint(minimum_traps(m, x))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef birthday_paradox(n, k):\n    days = 1 << n  # 2^n\n    if k > days:\n        return 1, 1  # Guaranteed collision\n\n    # Calculate the probability of no shared birthdays\n    numerator = 1\n    denominator = 1\n    for i in range(k):\n        numerator *= (days - i)\n        denominator *= days\n\n    # The probability of at least one shared birthday\n    A = denominator - numerator\n    B = denominator\n\n    # Reduce A/B to irreducible form\n    common_gcd = gcd(A, B)\n    A //= common_gcd\n    B //= common_gcd\n\n    # Modulo operation\n    MOD = 1000003\n    A %= MOD\n    B %= MOD\n\n    return A, B\n\nn, k = map(int, input().split())\nA, B = birthday_paradox(n, k)\nprint(A, B)"}
{"solution": "def is_valid_journey(n, journey):\n    position = 0  # Start at North Pole (0 km)\n    \n    for t, direction in journey:\n        if position == 0 and direction != \"South\":\n            return \"NO\"\n        if position == 20000 and direction != \"North\":\n            return \"NO\"\n        \n        if direction == \"North\":\n            position -= t\n        elif direction == \"South\":\n            position += t\n        elif direction == \"West\" or direction == \"East\":\n            # Moving West or East does not change the position in terms of North/South\n            continue\n        \n        if position < 0 or position > 20000:\n            return \"NO\"\n    \n    return \"YES\" if position == 0 else \"NO\"\n\n# Input reading\nn = int(input())\njourney = [tuple(input().split()) for _ in range(n)]\njourney = [(int(t), dir) for t, dir in journey]\n\n# Output the result\nprint(is_valid_journey(n, journey))"}
{"solution": "def count_common_terms(a1, b1, a2, b2, L, R):\n    from math import gcd\n\n    # Calculate the step size and the offset\n    step = abs(a1 * a2 // gcd(a1, a2))\n    \n    # Find the first valid x in the range [L, R]\n    def first_valid_x():\n        for k in range(0, step):\n            x = a1 * k + b1\n            if L <= x <= R:\n                return x\n            if x > R:\n                break\n        return None\n\n    # Find the first valid x\n    x_start = first_valid_x()\n    if x_start is None:\n        return 0\n\n    # Calculate the last valid x in the range [L, R]\n    last_valid_x = (R - b2) // a2 * a2 + b2\n    if last_valid_x < L:\n        return 0\n\n    # Count the number of valid x's\n    count = (last_valid_x - x_start) // step + 1\n    return count\n\n# Read input\na1, b1, a2, b2, L, R = map(int, input().split())\n# Get the result\nresult = count_common_terms(a1, b1, a2, b2, L, R)\n# Print the result\nprint(result)"}
{"solution": "def max_min_pieces(n, a, b):\n    def can_distribute(x):\n        plates_for_a = (a + x - 1) // x  # ceil(a / x)\n        plates_for_b = (b + x - 1) // x  # ceil(b / x)\n        return plates_for_a + plates_for_b <= n\n\n    left, right = 1, max(a, b)\n    while left < right:\n        mid = (left + right + 1) // 2\n        if can_distribute(mid):\n            left = mid\n        else:\n            right = mid - 1\n    return left\n\nn, a, b = map(int, input().split())\nprint(max_min_pieces(n, a, b))"}
{"solution": "def is_valid_flag(n, m, field):\n    colors = set()\n    \n    # Check for horizontal stripes\n    stripe_height = n // 3\n    if n % 3 != 0:\n        return \"NO\"\n    \n    for i in range(3):\n        stripe_color = field[i * stripe_height][0]\n        if stripe_color not in 'RGB' or stripe_color in colors:\n            return \"NO\"\n        colors.add(stripe_color)\n        for j in range(stripe_height):\n            if field[i * stripe_height + j] != stripe_color * m:\n                return \"NO\"\n    \n    # Check for vertical stripes\n    colors.clear()\n    stripe_width = m // 3\n    if m % 3 != 0:\n        return \"NO\"\n    \n    for i in range(3):\n        stripe_color = field[0][i * stripe_width]\n        if stripe_color not in 'RGB' or stripe_color in colors:\n            return \"NO\"\n        colors.add(stripe_color)\n        for j in range(stripe_width):\n            for k in range(n):\n                if field[k][i * stripe_width + j] != stripe_color:\n                    return \"NO\"\n    \n    return \"YES\"\n\nn, m = map(int, input().split())\nfield = [input().strip() for _ in range(n)]\nprint(is_valid_flag(n, m, field))"}
{"solution": "def find_coordinates(n):\n    if n == 0:\n        return (0, 0)\n\n    layer = 0\n    moves_in_layer = 6 * layer\n\n    while n > moves_in_layer:\n        n -= moves_in_layer\n        layer += 1\n        moves_in_layer = 6 * layer\n\n    # The coordinates for the current layer\n    x, y = layer, 0\n\n    # Determine the direction and the position in the layer\n    for i in range(n):\n        if i < layer:\n            x -= 1\n        elif i < 2 * layer:\n            x -= 1\n            y += 1\n        elif i < 3 * layer:\n            y += 1\n        elif i < 4 * layer:\n            x += 1\n            y += 1\n        elif i < 5 * layer:\n            x += 1\n        else:\n            x += 1\n            y -= 1\n\n    return (x, y)\n\nn = int(input().strip())\nx, y = find_coordinates(n)\nprint(x, y)"}
{"solution": "def can_deal_exact_damage(a, b, c):\n    for i in range(c // a + 1):\n        if (c - a * i) % b == 0:\n            return \"Yes\"\n    return \"No\"\n\n# Read input\na, b, c = map(int, input().split())\n# Output the result\nprint(can_deal_exact_damage(a, b, c))"}
{"solution": "def can_tracks_coincide(n, L, kefa_distances, sasha_distances):\n    # Calculate the distances between consecutive barriers for Kefa\n    kefa_diffs = [(kefa_distances[(i + 1) % n] - kefa_distances[i]) % L for i in range(n)]\n    # Calculate the distances between consecutive barriers for Sasha\n    sasha_diffs = [(sasha_distances[(i + 1) % n] - sasha_distances[i]) % L for i in range(n)]\n    \n    # Check if Kefa's differences can be rotated to match Sasha's differences\n    for i in range(n):\n        if kefa_diffs == sasha_diffs[i:] + sasha_diffs[:i]:\n            return \"YES\"\n    return \"NO\"\n\n# Input reading\nn, L = map(int, input().split())\nkefa_distances = list(map(int, input().split()))\nsasha_distances = list(map(int, input().split()))\n\n# Output the result\nprint(can_tracks_coincide(n, L, kefa_distances, sasha_distances))"}
{"solution": "def is_palindrome(s):\n    return s == s[::-1]\n\ndef longest_non_palindrome_substring(s):\n    n = len(s)\n    \n    if not is_palindrome(s):\n        return n\n    \n    for length in range(n - 1, 0, -1):\n        for start in range(n - length + 1):\n            substring = s[start:start + length]\n            if not is_palindrome(substring):\n                return length\n    \n    return 0\n\ns = input().strip()\nprint(longest_non_palindrome_substring(s))"}
{"solution": "n = int(input())\nratings = [tuple(map(int, input().split())) for _ in range(n)]\n\nrated = False\nunrated = False\n\nfor a, b in ratings:\n    if a != b:\n        rated = True\n        break\n\nif rated:\n    print(\"rated\")\nelse:\n    for i in range(n - 1):\n        if ratings[i][0] < ratings[i + 1][0]:\n            unrated = True\n            break\n\n    if unrated:\n        print(\"unrated\")\n    else:\n        print(\"maybe\")"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nd = [0] * n\nlast_zero = -float('inf')\n\n# Forward pass to find distances to the nearest zero on the left\nfor i in range(n):\n    if a[i] == 0:\n        last_zero = i\n    d[i] = i - last_zero\n\nlast_zero = float('inf')\n\n# Backward pass to find distances to the nearest zero on the right\nfor i in range(n - 1, -1, -1):\n    if a[i] == 0:\n        last_zero = i\n    d[i] = min(d[i], last_zero - i)\n\nprint(' '.join(map(str, d)))"}
{"solution": "def count_cyclic_strings(n, s):\n    from itertools import product\n\n    len_s = len(s)\n    total_count = 0\n    seen = set()\n\n    for bits in product('01', repeat=n):\n        t = ''.join(bits)\n        if s in t + t:  # Check if s is a substring in the cyclic version of t\n            # Normalize the cyclic string by finding its lexicographically smallest rotation\n            min_rotation = min(t[i:] + t[:i] for i in range(n))\n            seen.add(min_rotation)\n\n    return len(seen)\n\nn = int(input().strip())\ns = input().strip()\nprint(count_cyclic_strings(n, s))"}
{"solution": "import sys\nimport math\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n = int(data[0])\n    vectors = []\n    \n    for i in range(1, n + 1):\n        x, y = map(int, data[i].split())\n        angle = math.atan2(y, x)\n        vectors.append((angle, i))\n    \n    vectors.sort()\n    \n    min_angle = float('inf')\n    best_pair = (0, 0)\n    \n    for i in range(n):\n        angle1, index1 = vectors[i]\n        angle2, index2 = vectors[(i + 1) % n]\n        \n        # Calculate the non-oriented angle\n        angle_diff = abs(angle2 - angle1)\n        if angle_diff > math.pi:\n            angle_diff = 2 * math.pi - angle_diff\n        \n        if angle_diff < min_angle:\n            min_angle = angle_diff\n            best_pair = (index1, index2)\n    \n    print(best_pair[0], best_pair[1])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def minimal_time_to_post_office(d, k, a, b, t):\n    # Calculate the number of full segments the car can drive\n    full_segments = d // k\n    remaining_distance = d % k\n\n    # Time if Vasiliy drives the full segments and walks the remaining distance\n    time_using_car = full_segments * (k * a + t) + remaining_distance * a\n    if full_segments > 0:\n        time_using_car -= t  # Remove the last repair time since he doesn't need to repair after the last segment\n\n    # Time if Vasiliy walks the entire distance\n    time_walking = d * b\n\n    # Time if Vasiliy drives as much as possible and then walks\n    time_mixed = 0\n    if full_segments > 0:\n        time_mixed += full_segments * (k * a + t)  # Driving full segments\n        time_mixed += remaining_distance * a  # Driving remaining distance\n        time_mixed -= t  # Remove the last repair time\n    time_mixed += (d - (full_segments * k + remaining_distance)) * b  # Walking the rest\n\n    # Calculate the minimum time\n    min_time = min(time_using_car, time_walking, time_mixed)\n\n    return min_time\n\n# Input reading\nd, k, a, b, t = map(int, input().split())\nprint(minimal_time_to_post_office(d, k, a, b, t))"}
{"solution": "def find_sequence(n, k):\n    if k * (k + 1) // 2 > n:\n        return -1\n    \n    # The maximum GCD we can use is n // k\n    max_gcd = n // k\n    \n    # Calculate the sum of the first k natural numbers\n    sum_of_first_k = k * (k + 1) // 2\n    \n    # The remaining part to distribute\n    remaining = n - sum_of_first_k\n    \n    # If remaining is negative, we cannot form the sequence\n    if remaining < 0:\n        return -1\n    \n    # Create the sequence\n    sequence = [i + max_gcd for i in range(1, k + 1)]\n    \n    # Distribute the remaining value to the last element\n    sequence[-1] += remaining\n    \n    return sequence\n\nn, k = map(int, input().split())\nresult = find_sequence(n, k)\n\nif result == -1:\n    print(-1)\nelse:\n    print(\" \".join(map(str, result)))"}
{"solution": "def count_pairs(n, m):\n    count_x = [0] * 5\n    count_y = [0] * 5\n    \n    for i in range(1, n + 1):\n        count_x[i % 5] += 1\n        \n    for j in range(1, m + 1):\n        count_y[j % 5] += 1\n        \n    result = 0\n    for i in range(5):\n        result += count_x[i] * count_y[(5 - i) % 5]\n        \n    return result\n\nn, m = map(int, input().split())\nprint(count_pairs(n, m))"}
{"solution": "def max_beauty_with_subarray(n, x, a):\n    # Function to calculate maximum subarray sum using Kadane's algorithm\n    def kadane(arr):\n        max_ending_here = max_so_far = 0\n        for value in arr:\n            max_ending_here = max(0, max_ending_here + value)\n            max_so_far = max(max_so_far, max_ending_here)\n        return max_so_far\n\n    # Calculate the beauty of the original array\n    original_beauty = kadane(a)\n\n    # If x is 1, multiplying by x does not change the array\n    if x == 1:\n        return original_beauty\n\n    # Calculate the maximum beauty after multiplying a subarray by x\n    max_gain = 0\n    current_gain = 0\n    for i in range(n):\n        current_gain += a[i] * (x - 1)\n        max_gain = max(max_gain, current_gain)\n        if current_gain < 0:\n            current_gain = 0\n\n    # The maximum beauty will be the original beauty plus the best gain we can achieve\n    return original_beauty + max_gain\n\n# Input reading\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_beauty_with_subarray(n, x, a))"}
{"solution": "def kth_largest_in_multiplication_table(n, m, k):\n    left, right = 1, n * m\n    \n    while left < right:\n        mid = (left + right) // 2\n        count = 0\n        \n        for i in range(1, n + 1):\n            count += min(mid // i, m)\n        \n        if count < k:\n            left = mid + 1\n        else:\n            right = mid\n            \n    return left\n\n# Read input\nn, m, k = map(int, input().split())\n# Get the k-th largest number\nresult = kth_largest_in_multiplication_table(n, m, k)\n# Print the result\nprint(result)"}
{"solution": "def find_kth_digit(k):\n    length = 1\n    count = 9\n    start = 1\n\n    while k > length * count:\n        k -= length * count\n        length += 1\n        count *= 10\n        start *= 10\n\n    start += (k - 1) // length\n    num_str = str(start)\n    return int(num_str[(k - 1) % length])\n\nk = int(input().strip())\nprint(find_kth_digit(k))"}
{"solution": "def max_bourles_after_trading(n, m, r, buy_prices, sell_prices):\n    min_buy_price = min(buy_prices)\n    max_sell_price = max(sell_prices)\n\n    if max_sell_price <= min_buy_price:\n        return r  # No profit can be made\n\n    # Calculate the maximum shares that can be bought\n    max_shares = r // min_buy_price\n    # Calculate the total cost of buying those shares\n    total_cost = max_shares * min_buy_price\n    # Calculate the remaining bourles after buying shares\n    remaining_bourles = r - total_cost\n    # Calculate the total bourles after selling the shares\n    total_bourles_after_selling = remaining_bourles + (max_shares * max_sell_price)\n\n    return total_bourles_after_selling\n\n# Input reading\nn, m, r = map(int, input().split())\nbuy_prices = list(map(int, input().split()))\nsell_prices = list(map(int, input().split()))\n\n# Output the result\nprint(max_bourles_after_trading(n, m, r, buy_prices, sell_prices))"}
{"solution": "def find_possible_message(t):\n    n = len(t)\n    \n    for i in range(1, n // 2 + 1):\n        if t[:i] == t[n-i:n] and n - i > i:\n            return \"YES\\n\" + t[:n-i]\n    \n    return \"NO\"\n\nt = input().strip()\nprint(find_possible_message(t))"}
{"solution": "def total_games(teams):\n    games = 0\n    while teams > 1:\n        if teams % 2 == 0:\n            games += teams // 2\n            teams //= 2\n        else:\n            games += (teams - 1) // 2\n            teams = (teams + 1) // 2\n    return games\n\ndef find_teams(n):\n    possible_teams = []\n    for i in range(1, 2 * n + 1):\n        if total_games(i) == n:\n            possible_teams.append(i)\n    \n    if possible_teams:\n        return possible_teams\n    else:\n        return [-1]\n\nn = int(input().strip())\nresult = find_teams(n)\nfor r in result:\n    print(r)"}
{"solution": "def max_antipalindromic_beauty(n, s, beauties):\n    from collections import Counter\n\n    # Count the frequency of each character\n    char_count = Counter(s)\n    \n    # Create two halves for the antipalindromic string\n    half1 = []\n    half2 = []\n    \n    # Fill the halves with characters\n    for char, count in char_count.items():\n        half1.extend([char] * (count // 2))\n        half2.extend([char] * (count // 2))\n    \n    # Sort halves to maximize beauty\n    half1.sort()\n    half2.sort(reverse=True)\n    \n    # Create the antipalindromic string\n    t = half1 + half2\n    \n    # Calculate the maximum beauty\n    max_beauty = 0\n    for i in range(n):\n        if s[i] == t[i]:\n            max_beauty += beauties[i]\n    \n    return max_beauty\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\nbeauties = list(map(int, input().strip().split()))\n\n# Get the result and print it\nresult = max_antipalindromic_beauty(n, s, beauties)\nprint(result)"}
{"solution": "def can_balance(w, m):\n    while m > 0:\n        remainder = m % w\n        if remainder > 1:\n            return \"NO\"\n        m //= w\n    return \"YES\"\n\nw, m = map(int, input().split())\nprint(can_balance(w, m))"}
{"solution": "def find_sequence(n, k):\n    # Step 1: Decompose n into powers of 2\n    powers = []\n    for i in range(60):  # 2^60 > 10^18\n        if n & (1 << i):\n            powers.append(i)\n\n    # Step 2: Check if we can form a sequence of length k\n    if len(powers) > k:\n        print(\"No\")\n        return\n\n    # Step 3: Fill the sequence to reach length k\n    while len(powers) < k:\n        # Take the largest power and split it into two smaller powers\n        largest = powers.pop()\n        if largest == 0:\n            print(\"No\")\n            return\n        powers.append(largest - 1)\n        powers.append(largest - 1)\n\n    # Step 4: Sort the powers in descending order to get the lexicographically largest sequence\n    powers.sort(reverse=True)\n\n    print(\"Yes\")\n    print(\" \".join(map(str, powers)))\n\n# Read input\nn, k = map(int, input().split())\nfind_sequence(n, k)"}
{"solution": "def champagne_pyramid(n, t):\n    # Create a 2D list to represent the glasses in the pyramid\n    glasses = [[0] * (i + 1) for i in range(n)]\n    \n    # Pour champagne into the top glass\n    glasses[0][0] = t\n    \n    # Distribute champagne\n    for i in range(n):\n        for j in range(i + 1):\n            if glasses[i][j] > 1:\n                overflow = glasses[i][j] - 1\n                glasses[i][j] = 1\n                if i + 1 < n:\n                    glasses[i + 1][j] += overflow / 2\n                    glasses[i + 1][j + 1] += overflow / 2\n    \n    # Count the number of completely full glasses\n    full_glasses = sum(1 for i in range(n) for j in range(i + 1) if glasses[i][j] == 1)\n    \n    return full_glasses\n\n# Read input\nn, t = map(int, input().split())\n# Get the result and print it\nprint(champagne_pyramid(n, t))"}
{"solution": "def calculate_rectangle_area(n, points):\n    if n == 1:\n        return -1\n    elif n == 2:\n        x1, y1 = points[0]\n        x2, y2 = points[1]\n        return abs(x2 - x1) * abs(y2 - y1)\n    elif n == 3:\n        x_coords = {points[0][0], points[1][0], points[2][0]}\n        y_coords = {points[0][1], points[1][1], points[2][1]}\n        if len(x_coords) == 2 and len(y_coords) == 2:\n            width = max(x_coords) - min(x_coords)\n            height = max(y_coords) - min(y_coords)\n            return width * height\n        else:\n            return -1\n    elif n == 4:\n        x_coords = {point[0] for point in points}\n        y_coords = {point[1] for point in points}\n        if len(x_coords) == 2 and len(y_coords) == 2:\n            width = max(x_coords) - min(x_coords)\n            height = max(y_coords) - min(y_coords)\n            return width * height\n        else:\n            return -1\n\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\narea = calculate_rectangle_area(n, points)\nprint(area)"}
{"solution": "def min_wooden_bars(n, a, b):\n    # Total lengths needed for two doors\n    total_length = 2 * (2 * a + b)  # 2 verticals and 1 top for each door\n    \n    # Calculate the minimum number of bars needed\n    min_bars = (total_length + n - 1) // n  # Ceiling division\n    \n    return min_bars\n\n# Input reading\nn = int(input())\na = int(input())\nb = int(input())\n\n# Output the result\nprint(min_wooden_bars(n, a, b))"}
{"solution": "def can_sort_array(n, a, s):\n    # Create a list of segments where swaps are allowed\n    segments = []\n    start = 0\n    \n    for i in range(n - 1):\n        if s[i] == '0':\n            segments.append((start, i + 1))\n            start = i + 1\n            \n    segments.append((start, n))  # Add the last segment\n    \n    # Check each segment if it can be sorted\n    for start, end in segments:\n        segment = a[start:end]\n        if sorted(segment) != segment:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\ns = input().strip()\n\n# Output the result\nprint(can_sort_array(n, a, s))"}
{"solution": "def time_to_get_lunch(seat_info):\n    n = int(seat_info[:-1])\n    s = seat_info[-1]\n    \n    # Calculate the time taken to serve rows before Vasya's row\n    time_spent = 0\n    \n    # Determine the number of complete cycles of 4 rows before row n\n    complete_cycles = (n - 1) // 4\n    time_spent += complete_cycles * (6 * 4 + 3)  # 6 seconds per row for 4 rows + 3 seconds for moving\n    \n    # Determine the remaining rows after the last complete cycle\n    remaining_rows = (n - 1) % 4\n    \n    # Add time for the remaining rows\n    for i in range(remaining_rows + 1):\n        time_spent += 6  # 6 seconds to serve each row\n        if i < remaining_rows:\n            time_spent += 1  # 1 second to move to the next row\n    \n    # Add time for serving Vasya's seat\n    if s in 'def':\n        time_spent += 'fed'.index(s) + 1  # Time to serve right side (d, e, f)\n    else:\n        time_spent += 6 + 'cba'.index(s) + 1  # Time to serve left side (a, b, c) after serving right side\n    \n    return time_spent\n\n# Read input\nseat_info = input().strip()\n# Calculate and print the result\nprint(time_to_get_lunch(seat_info))"}
{"solution": "def convert_to_decimal(digits, base):\n    value = 0\n    for digit in digits:\n        value = value * base + digit\n    return value\n\nn, b_x = map(int, input().split())\nx_digits = list(map(int, input().split()))\nm, b_y = map(int, input().split())\ny_digits = list(map(int, input().split()))\n\nx_value = convert_to_decimal(x_digits, b_x)\ny_value = convert_to_decimal(y_digits, b_y)\n\nif x_value < y_value:\n    print('<')\nelif x_value > y_value:\n    print('>')\nelse:\n    print('=')"}
{"solution": "def determine_winner(n, a):\n    # Calculate the nim-sum (xor sum) of the array\n    nim_sum = 0\n    for num in a:\n        nim_sum ^= num\n    \n    # If nim-sum is 0, BitAryo wins, otherwise BitLGM wins\n    return \"BitAryo\" if nim_sum == 0 else \"BitLGM\"\n\n# Read input\nn = int(input().strip())\na = list(map(int, input().strip().split()))\n\n# Determine and print the winner\nprint(determine_winner(n, a))"}
{"solution": "def count_valid_decks(n, k, a):\n    from math import gcd\n    from functools import reduce\n\n    def prime_factors(x):\n        factors = {}\n        d = 2\n        while d * d <= x:\n            while (x % d) == 0:\n                if d in factors:\n                    factors[d] += 1\n                else:\n                    factors[d] = 1\n                x //= d\n            d += 1\n        if x > 1:\n            factors[x] = 1\n        return factors\n\n    k_factors = prime_factors(k)\n    k_factorization = {p: k_factors[p] for p in k_factors}\n\n    prefix_factors = [{} for _ in range(n + 1)]\n    for i in range(n):\n        current_factors = prime_factors(a[i])\n        for p in k_factorization:\n            prefix_factors[i + 1][p] = prefix_factors[i].get(p, 0) + current_factors.get(p, 0)\n\n    total_ways = 0\n\n    for x in range(n):\n        for p in k_factorization:\n            required = k_factorization[p] - prefix_factors[x].get(p, 0)\n            if required > 0:\n                break\n        else:\n            total_ways += n - x\n\n    for y in range(n):\n        for p in k_factorization:\n            required = k_factorization[p] - (prefix_factors[n - y].get(p, 0) - prefix_factors[n - y - 1].get(p, 0))\n            if required > 0:\n                break\n        else:\n            total_ways += n - y\n\n    return total_ways\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nprint(count_valid_decks(n, k, a))"}
{"solution": "n, k = map(int, input().split())\ns = input().strip()\n\ncolor_count = {}\nfor color in s:\n    if color in color_count:\n        color_count[color] += 1\n    else:\n        color_count[color] = 1\n\nmax_balloons_of_one_color = max(color_count.values())\n\nif max_balloons_of_one_color > k:\n    print(\"NO\")\nelse:\n    print(\"YES\")"}
{"solution": "n = int(input())\narray = list(map(int, input().split()))\n\nmin_value = min(array)\nlast_index = -1\nmin_distance = float('inf')\n\nfor i in range(n):\n    if array[i] == min_value:\n        if last_index != -1:\n            min_distance = min(min_distance, i - last_index)\n        last_index = i\n\nprint(min_distance)"}
{"solution": "from math import gcd\n\ndef probability_of_tie(t, w, b):\n    # Calculate the maximum distance each athlete can run without falling into the abyss\n    max_willman = t // w\n    max_bolt = t // b\n    \n    # The number of lengths where they tie is the minimum of the two maximum distances\n    tie_count = min(max_willman, max_bolt)\n    \n    # The total possible lengths of the racetrack is t\n    total_count = t\n    \n    # The probability of a tie as a fraction\n    p = tie_count\n    q = total_count\n    \n    # Reduce the fraction\n    divisor = gcd(p, q)\n    p //= divisor\n    q //= divisor\n    \n    return f\"{p}/{q}\"\n\n# Input reading\nt, w, b = map(int, input().split())\nprint(probability_of_tie(t, w, b))"}
{"solution": "x, y, z = map(int, input().split())\n\nmin_upvotes = x\nmax_upvotes = x + z\nmin_downvotes = y\nmax_downvotes = y + z\n\nif max_upvotes < min_downvotes:\n    print(\"-\")\nelif max_downvotes < min_upvotes:\n    print(\"+\")\nelif min_upvotes == max_downvotes and min_downvotes == max_upvotes:\n    print(\"0\")\nelse:\n    print(\"?\")"}
{"solution": "def min_change_length(n, operations, x, y):\n    # Count the number of each operation\n    count_U = operations.count('U')\n    count_D = operations.count('D')\n    count_L = operations.count('L')\n    count_R = operations.count('R')\n\n    # Calculate the required moves\n    required_U = max(0, y)\n    required_D = max(0, -y)\n    required_L = max(0, -x)\n    required_R = max(0, x)\n\n    # Check if it's possible to reach (x, y)\n    if required_U > count_U + required_D or required_D > count_D + required_U or \\\n       required_L > count_L + required_R or required_R > count_R + required_L:\n        return -1\n\n    # Calculate the excess moves\n    excess_U = count_U - required_U\n    excess_D = count_D - required_D\n    excess_L = count_L - required_L\n    excess_R = count_R - required_R\n\n    # Calculate the minimum length of the segment to change\n    changes_needed = 0\n    if excess_U < 0:\n        changes_needed += -excess_U\n    if excess_D < 0:\n        changes_needed += -excess_D\n    if excess_L < 0:\n        changes_needed += -excess_L\n    if excess_R < 0:\n        changes_needed += -excess_R\n\n    return changes_needed\n\n# Input reading\nn = int(input().strip())\noperations = input().strip()\nx, y = map(int, input().strip().split())\n\n# Output the result\nprint(min_change_length(n, operations, x, y))"}
{"solution": "def count_prefixes(T, test_cases):\n    results = []\n    \n    for n, x, s in test_cases:\n        cnt0 = s.count('0')\n        cnt1 = s.count('1')\n        balance = cnt0 - cnt1\n        \n        # Calculate the balance of prefixes of s\n        current_balance = 0\n        prefix_balances = {}\n        prefix_balances[0] = 1  # empty prefix\n        \n        for char in s:\n            if char == '0':\n                current_balance += 1\n            else:\n                current_balance -= 1\n            \n            if current_balance in prefix_balances:\n                prefix_balances[current_balance] += 1\n            else:\n                prefix_balances[current_balance] = 1\n        \n        # Check for infinite solutions\n        if balance == 0:\n            if x in prefix_balances:\n                results.append(-1)  # infinite solutions\n            else:\n                results.append(0)  # no solutions\n        else:\n            # Calculate the number of valid prefixes\n            count = 0\n            for k in prefix_balances:\n                if (x - k) % balance == 0 and (x - k) // balance >= 0:\n                    count += prefix_balances[k]\n            results.append(count)\n    \n    return results\n\n# Input reading\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nT = int(data[0])\ntest_cases = []\n\nfor i in range(1, 2 * T, 2):\n    n, x = map(int, data[i].split())\n    s = data[i + 1]\n    test_cases.append((n, x, s))\n\n# Get results\nresults = count_prefixes(T, test_cases)\n\n# Output results\nfor result in results:\n    print(result)"}
{"solution": "def min_deletions_to_divisible(n, k):\n    n_str = str(n)\n    target_zeros = '0' * k\n    count = 0\n    found_zeros = 0\n\n    for digit in reversed(n_str):\n        if found_zeros < k and digit == '0':\n            found_zeros += 1\n        elif found_zeros == k:\n            break\n        else:\n            count += 1\n\n    return count + (len(n_str) - found_zeros - k)\n\nn, k = map(int, input().split())\nprint(min_deletions_to_divisible(n, k))"}
{"solution": "def count_questions(n, m, k, x, y):\n    total_questions_per_cycle = n * m * 2 - m\n    full_cycles = k // total_questions_per_cycle\n    remaining_questions = k % total_questions_per_cycle\n\n    max_questions = full_cycles\n    min_questions = full_cycles\n\n    if n == 1:\n        max_questions += (remaining_questions + m - 1) // m\n        min_questions += remaining_questions // m\n        sergei_questions = (remaining_questions + m - 1) // m\n    else:\n        for row in range(1, n + 1):\n            if row == 1 or row == n:\n                max_questions += (remaining_questions + m - 1) // m\n                min_questions += remaining_questions // m\n            elif 1 < row < n:\n                if remaining_questions >= m:\n                    max_questions += 1\n                    min_questions += 1\n                    remaining_questions -= m\n                else:\n                    break\n\n        sergei_questions = full_cycles\n        if x == 1 or x == n:\n            sergei_questions += (remaining_questions + m - 1) // m\n        else:\n            if remaining_questions >= (x - 1) * m:\n                sergei_questions += 1\n            if remaining_questions >= (n - x) * m:\n                sergei_questions += 1\n\n    max_questions += (1 if x == 1 or x == n else 0)\n    min_questions += (1 if x == 1 or x == n else 0)\n\n    return max_questions, min_questions, sergei_questions\n\n# Input reading\nn, m, k, x, y = map(int, input().split())\nmax_q, min_q, sergei_q = count_questions(n, m, k, x, y)\nprint(max_q, min_q, sergei_q)"}
{"solution": "def max_beauty_after_turns(n, ribbons):\n    max_length = len(ribbons[0])\n    \n    # Calculate the current maximum frequency of any character in each ribbon\n    def current_max_frequency(ribbon):\n        frequency = {}\n        for char in ribbon:\n            if char in frequency:\n                frequency[char] += 1\n            else:\n                frequency[char] = 1\n        return max(frequency.values())\n    \n    beauties = []\n    for ribbon in ribbons:\n        current_max = current_max_frequency(ribbon)\n        # Calculate the maximum beauty achievable after n turns\n        max_beauty = min(max_length, current_max + n)\n        beauties.append(max_beauty)\n    \n    # Determine the winner\n    max_beauty_value = max(beauties)\n    winners = [i for i, beauty in enumerate(beauties) if beauty == max_beauty_value]\n    \n    if len(winners) > 1:\n        return \"Draw\"\n    else:\n        return [\"Kuro\", \"Shiro\", \"Katie\"][winners[0]]\n\n# Input reading\nn = int(input().strip())\nribbons = [input().strip() for _ in range(3)]\n\n# Output the result\nprint(max_beauty_after_turns(n, ribbons))"}
{"solution": "c, v_0, v_1, a, l = map(int, input().split())\n\ndays = 0\npages_read = 0\n\nwhile pages_read < c:\n    days += 1\n    if days == 1:\n        pages_today = v_0\n    else:\n        pages_today = min(v_0 + (days - 1) * a, v_1)\n    \n    if days > 1:\n        pages_today -= l\n    \n    pages_read += pages_today\n\nprint(days)"}
{"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef find_primes(n):\n    if n % 2 == 1:\n        if is_prime(n):\n            return 1, [n]\n        if is_prime(n - 2):\n            return 2, [2, n - 2]\n        for i in range(3, n, 2):\n            if is_prime(i) and is_prime(n - i):\n                return 2, [i, n - i]\n        for i in range(3, n, 2):\n            for j in range(i, n, 2):\n                if is_prime(i) and is_prime(j) and is_prime(n - i - j):\n                    return 3, [i, j, n - i - j]\n\nn = int(input().strip())\nk, primes = find_primes(n)\nprint(k)\nprint(' '.join(map(str, primes)))"}
{"solution": "def can_wipe_out_walls(n, m, field):\n    total_walls = sum(row.count('*') for row in field)\n    \n    for i in range(n):\n        for j in range(m):\n            # Count walls in the current row and column\n            row_walls = field[i].count('*')\n            col_walls = sum(1 for k in range(n) if field[k][j] == '*')\n            \n            # Total walls that would be destroyed if bomb is placed at (i, j)\n            destroyed_walls = row_walls + col_walls\n            \n            # If the bomb is placed on a wall, we need to subtract 1\n            if field[i][j] == '*':\n                destroyed_walls -= 1\n            \n            # Check if all walls can be destroyed\n            if destroyed_walls == total_walls:\n                return \"YES\", (i + 1, j + 1)  # Return 1-based index\n    \n    return \"NO\", None\n\n# Read input\nn, m = map(int, input().split())\nfield = [input().strip() for _ in range(n)]\n\n# Get the result\nresult, coordinates = can_wipe_out_walls(n, m, field)\n\n# Print output\nprint(result)\nif coordinates:\n    print(coordinates[0], coordinates[1])"}
{"solution": "def min_cost_to_adjust_boxes(n, m, a, b):\n    remainder = n % m\n    \n    if remainder == 0:\n        return 0\n    \n    # Cost to build boxes to the next multiple of m\n    boxes_to_build = m - remainder\n    cost_to_build = boxes_to_build * a\n    \n    # Cost to demolish boxes to the previous multiple of m\n    boxes_to_demolish = remainder\n    cost_to_demolish = boxes_to_demolish * b\n    \n    return min(cost_to_build, cost_to_demolish)\n\n# Input reading\nn, m, a, b = map(int, input().split())\n# Output the result\nprint(min_cost_to_adjust_boxes(n, m, a, b))"}
{"solution": "def max_odd_subsequence_sum(n, a):\n    total_sum = sum(x for x in a if x > 0)\n    min_odd = float('inf')\n    \n    for x in a:\n        if x % 2 != 0 and x < min_odd:\n            min_odd = x\n            \n    if total_sum % 2 != 0:\n        return total_sum\n    elif min_odd != float('inf'):\n        return total_sum - min_odd\n    else:\n        return 0\n\nn = int(input())\na = list(map(int, input().split()))\nresult = max_odd_subsequence_sum(n, a)\nprint(result)"}
{"solution": "def count_playlists(n, T, songs):\n    MOD = 10**9 + 7\n    dp = [[[0] * 4 for _ in range(T + 1)] for _ in range(n + 1)]\n    dp[0][0][0] = 1  # Base case: 1 way to have 0 songs and 0 time\n\n    for i in range(1, n + 1):\n        t_i, g_i = songs[i - 1]\n        for j in range(T + 1):\n            for k in range(4):  # Previous genre\n                dp[i][j][k] = dp[i - 1][j][k]  # Not taking the current song\n                if j >= t_i and k != g_i:  # If we can take the song and it's not the same genre\n                    for m in range(1, n + 1):\n                        if m != i:  # Ensure we are not repeating the song\n                            dp[i][j][k] += dp[i - 1][j - t_i][g_i]\n                            dp[i][j][k] %= MOD\n\n    result = 0\n    for k in range(1, 4):  # Sum over all genres\n        result += dp[n][T][k]\n        result %= MOD\n\n    return result\n\n# Input reading\nn, T = map(int, input().split())\nsongs = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(count_playlists(n, T, songs))"}
{"solution": "def mod_inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef expected_length(m):\n    MOD = 10**9 + 7\n    expected = 0\n    for g in range(1, m + 1):\n        count = m // g\n        expected += count * mod_inverse(count, MOD)\n        expected %= MOD\n    expected = (expected * mod_inverse(m, MOD)) % MOD\n    return expected\n\nm = int(input())\nprint(expected_length(m))"}
{"solution": "def count_good_pairs(l, r, x, y):\n    if y % x != 0:\n        return 0\n    \n    k = y // x\n    count = 0\n    \n    for i in range(1, int(k**0.5) + 1):\n        if k % i == 0:\n            a1, b1 = i * x, (k // i) * x\n            a2, b2 = (k // i) * x, i * x\n            \n            if l <= a1 <= r and l <= b1 <= r:\n                count += 1\n            if a1 != b1 and l <= a2 <= r and l <= b2 <= r:\n                count += 1\n    \n    return count\n\nl, r, x, y = map(int, input().split())\nprint(count_good_pairs(l, r, x, y))"}
{"solution": "import math\n\ndef smallest_k(a, b):\n    if a > b:\n        a, b = b, a\n    \n    # The difference between b and a\n    d = b - a\n    \n    # If a and b are the same, the answer is 0\n    if d == 0:\n        return 0\n    \n    # To store the minimum LCM and the corresponding k\n    min_lcm = float('inf')\n    best_k = 0\n    \n    # Iterate over all divisors of d\n    for i in range(1, int(math.sqrt(d)) + 1):\n        if d % i == 0:\n            # Check both divisors i and d // i\n            for divisor in (i, d // i):\n                k = (divisor - a % divisor) % divisor\n                lcm = (a + k) * (b + k) // math.gcd(a + k, b + k)\n                \n                if lcm < min_lcm or (lcm == min_lcm and k < best_k):\n                    min_lcm = lcm\n                    best_k = k\n    \n    return best_k\n\n# Read input\na, b = map(int, input().split())\n# Get the result\nresult = smallest_k(a, b)\n# Print the result\nprint(result)"}
{"solution": "import math\n\ndef minimal_additional_marks(n, k, marks):\n    current_sum = sum(marks)\n    current_count = n\n    \n    while True:\n        average = current_sum / current_count\n        rounded_average = math.ceil(average)\n        \n        if rounded_average >= k:\n            return current_count - n\n        \n        current_sum += k\n        current_count += 1\n\n# Read input\nn, k = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(minimal_additional_marks(n, k, marks))"}
{"solution": "import math\n\nn = int(input())\na = list(map(int, input().split()))\n\nrequired_positive_count = math.ceil(n / 2)\n\n# Check for positive d\nfor d in range(1, 1001):\n    positive_count = sum(1 for x in a if x / d > 0)\n    if positive_count >= required_positive_count:\n        print(d)\n        break\nelse:\n    # Check for negative d\n    for d in range(-1, -1001, -1):\n        positive_count = sum(1 for x in a if x / d > 0)\n        if positive_count >= required_positive_count:\n            print(d)\n            break\n    else:\n        print(0)"}
{"solution": "def count_pairs_with_max_nines(n):\n    # The maximum number of nines at the end of the sum can be determined\n    # by finding the largest number less than or equal to n that is a multiple of 10\n    # and then pairing it with the corresponding shovel.\n    \n    # The maximum sum that ends with the most nines is when we have a sum of the form 99...9\n    # This occurs when we pair (n-1) with (n) if n is even, or (n-1) with (n) and (n-2) with (n-1) if n is odd.\n    \n    if n % 10 == 0:\n        return (n // 10) - 1\n    else:\n        return n // 10\n\nn = int(input())\nprint(count_pairs_with_max_nines(n))"}
{"solution": "def min_minutes_to_equal_bars(a1, b1, a2, b2):\n    def possible_sizes(a, b):\n        sizes = set()\n        sizes.add((a, b))\n        if a % 2 == 0:\n            sizes.add((a // 2, b))\n        if b % 2 == 0:\n            sizes.add((a, b // 2))\n        if a % 3 == 0:\n            sizes.add((a // 3, b))\n        if b % 3 == 0:\n            sizes.add((a, b // 3))\n        return sizes\n\n    sizes1 = possible_sizes(a1, b1)\n    sizes2 = possible_sizes(a2, b2)\n\n    common_sizes = sizes1.intersection(sizes2)\n\n    if not common_sizes:\n        return -1\n\n    min_minutes = float('inf')\n    result_sizes = None\n\n    for size in common_sizes:\n        a, b = size\n        minutes = (a1 * b1 - a * b) // (a1 * b1 // 2) + (a2 * b2 - a * b) // (a2 * b2 // 2)\n        if minutes < min_minutes:\n            min_minutes = minutes\n            result_sizes = (a1, b1), (a2, b2)\n\n    return min_minutes, result_sizes\n\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\n\nresult = min_minutes_to_equal_bars(a1, b1, a2, b2)\n\nif result == -1:\n    print(-1)\nelse:\n    min_minutes, sizes = result\n    print(min_minutes)\n    print(sizes[0][0], sizes[0][1])\n    print(sizes[1][0], sizes[1][1])"}
{"solution": "def determine_winner(x_p, y_p, x_v, y_v):\n    # Calculate the distance to (0, 0) for both players\n    polycarp_distance = x_p + y_p\n    vasiliy_distance = x_v + y_v\n    \n    # Determine the winner based on the distances\n    if polycarp_distance <= vasiliy_distance:\n        return \"Polycarp\"\n    else:\n        return \"Vasiliy\"\n\n# Read input\nx_p, y_p, x_v, y_v = map(int, input().split())\n\n# Get the winner\nwinner = determine_winner(x_p, y_p, x_v, y_v)\n\n# Print the winner\nprint(winner)"}
{"solution": "def number_of_columns(m, d):\n    # Days in each month for a non-leap year\n    days_in_month = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    \n    # Get the number of days in the given month\n    days = days_in_month[m]\n    \n    # Calculate the number of columns needed\n    # d is the weekday of the first day (1 = Monday, ..., 7 = Sunday)\n    # We need to find out how many weeks (columns) are needed to fit all days\n    # The first day occupies the (d-1)th position in the first week\n    first_week_days = 7 - (d - 1)\n    \n    # Remaining days after the first week\n    remaining_days = days - first_week_days\n    \n    # Calculate the number of full weeks needed for the remaining days\n    if remaining_days > 0:\n        columns = 1 + (remaining_days + 6) // 7  # +6 to round up\n    else:\n        columns = 1\n    \n    return columns\n\n# Read input\nm, d = map(int, input().split())\n# Print the result\nprint(number_of_columns(m, d))"}
{"solution": "def count_years_with_one_zero(a, b):\n    count = 0\n    for year in range(a, b + 1):\n        binary_representation = bin(year)[2:]  # Get binary representation without '0b' prefix\n        if binary_representation.count('0') == 1:\n            count += 1\n    return count\n\n# Read input\na, b = map(int, input().split())\n# Get the result\nresult = count_years_with_one_zero(a, b)\n# Print the result\nprint(result)"}
{"solution": "def min_layers(N):\n    return (N + 1) // 2 * (N // 2 + 1) + (N // 2) * (N // 2)\n\nN = int(input().strip())\nprint(min_layers(N))"}
{"solution": "from itertools import combinations\n\ndef factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n    return result\n\ndef count_ways(n, k, S, cubes):\n    total_ways = 0\n    for r in range(1, n + 1):\n        for indices in combinations(range(n), r):\n            chosen_cubes = [cubes[i] for i in indices]\n            m = len(chosen_cubes)\n            for mask in range(1 << m):\n                if bin(mask).count('1') > k:\n                    continue\n                current_sum = sum(chosen_cubes[i] if not (mask & (1 << i)) else factorial(chosen_cubes[i]) for i in range(m))\n                if current_sum == S:\n                    total_ways += 1\n    return total_ways\n\n# Input reading\nn, k, S = map(int, input().split())\ncubes = list(map(int, input().split()))\n\n# Output the result\nprint(count_ways(n, k, S, cubes))"}
{"solution": "def can_achieve_array(test_cases):\n    results = []\n    for n, k, a in test_cases:\n        powers = []\n        current_power = 1\n        while current_power <= 10**16:\n            powers.append(current_power)\n            current_power *= k\n        \n        count = {}\n        for num in a:\n            if num == 0:\n                continue\n            for power in powers:\n                if num == 0:\n                    break\n                if num >= power:\n                    if power in count:\n                        count[power] += 1\n                    else:\n                        count[power] = 1\n                    num -= power\n            \n            if num > 0:\n                results.append(\"NO\")\n                break\n        else:\n            if all(count.get(power, 0) <= 1 for power in count):\n                results.append(\"YES\")\n            else:\n                results.append(\"NO\")\n    \n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nT = int(data[0])\ntest_cases = []\n\nfor i in range(T):\n    n, k = map(int, data[2 * i + 1].split())\n    a = list(map(int, data[2 * i + 2].split()))\n    test_cases.append((n, k, a))\n\n# Get results\nresults = can_achieve_array(test_cases)\n\n# Print output\nfor result in results:\n    print(result)"}
{"solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count\n\ndef calculate_sum(a, b, c):\n    total_sum = 0\n    for i in range(1, a + 1):\n        for j in range(1, b + 1):\n            for k in range(1, c + 1):\n                total_sum += count_divisors(i * j * k)\n                total_sum %= 1073741824\n    return total_sum\n\na, b, c = map(int, input().split())\nresult = calculate_sum(a, b, c)\nprint(result)"}
{"solution": "def can_reach_same_configuration(bessie, elsie):\n    def get_positions(grid):\n        return tuple(sorted((grid[i][j], (i, j)) for i in range(2) for j in range(2) if grid[i][j] != 'X'))\n\n    bessie_positions = get_positions(bessie)\n    elsie_positions = get_positions(elsie)\n\n    return bessie_positions == elsie_positions\n\nbessie = [input().strip() for _ in range(2)]\nelsie = [input().strip() for _ in range(2)]\n\nif can_reach_same_configuration(bessie, elsie):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def convert_to_decimal(n, k):\n    decimal_value = 0\n    length = len(k)\n    \n    for i in range(length):\n        digit = int(k[length - 1 - i])\n        decimal_value += digit * (n ** i)\n    \n    return decimal_value\n\nn = int(input().strip())\nk = input().strip()\n\nresult = convert_to_decimal(n, k)\nprint(result)"}
{"solution": "def is_unimodal(arr):\n    n = len(arr)\n    if n == 0:\n        return False\n\n    i = 0\n\n    # Increasing part\n    while i < n - 1 and arr[i] < arr[i + 1]:\n        i += 1\n\n    # Constant part\n    while i < n - 1 and arr[i] == arr[i + 1]:\n        i += 1\n\n    # Decreasing part\n    while i < n - 1 and arr[i] > arr[i + 1]:\n        i += 1\n\n    return i == n - 1\n\nn = int(input())\narr = list(map(int, input().split()))\n\nif is_unimodal(arr):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def max_y_in_k_paths(n, k):\n    def count_paths(y):\n        count = 0\n        for x in range(y, n + 1):\n            temp = x\n            while temp >= y:\n                if temp == y:\n                    count += 1\n                    break\n                temp = temp // 2 if temp % 2 == 0 else temp - 1\n        return count\n\n    left, right = 1, n\n    answer = 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if count_paths(mid) >= k:\n            answer = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return answer\n\nn, k = map(int, input().split())\nprint(max_y_in_k_paths(n, k))"}
{"solution": "def find_pocket(n, m, x, y, v_x, v_y):\n    if v_x == 0 and v_y == 0:\n        return -1\n    \n    # Calculate time to hit the walls\n    if v_x > 0:\n        t_x = (n - x) / v_x\n    elif v_x < 0:\n        t_x = x / -v_x\n    else:\n        t_x = float('inf')\n    \n    if v_y > 0:\n        t_y = (m - y) / v_y\n    elif v_y < 0:\n        t_y = y / -v_y\n    else:\n        t_y = float('inf')\n    \n    # Determine the time of the next collision\n    t = min(t_x, t_y)\n    \n    # Calculate new position after time t\n    new_x = x + v_x * t\n    new_y = y + v_y * t\n    \n    # Check if it falls into a pocket\n    if new_x == 0 and new_y == 0:\n        return (0, 0)\n    elif new_x == n and new_y == 0:\n        return (n, 0)\n    elif new_x == 0 and new_y == m:\n        return (0, m)\n    elif new_x == n and new_y == m:\n        return (n, m)\n    \n    return -1\n\n# Read input\nn, m, x, y, v_x, v_y = map(int, input().split())\nresult = find_pocket(n, m, x, y, v_x, v_y)\n\n# Print output\nif result == -1:\n    print(result)\nelse:\n    print(result[0], result[1])"}
{"solution": "def can_place_paintings(a1, b1, a2, b2, a3, b3):\n    # Check all combinations of orientations for the board and paintings\n    for (w1, h1) in [(a1, b1), (b1, a1)]:  # Board orientations\n        for (w2, h2) in [(a2, b2), (b2, a2)]:  # First painting orientations\n            for (w3, h3) in [(a3, b3), (b3, a3)]:  # Second painting orientations\n                # Check if both paintings can fit side by side\n                if (w2 + w3 <= w1 and max(h2, h3) <= h1) or (h2 + h3 <= h1 and max(w2, w3) <= w1):\n                    return \"YES\"\n                # Check if both paintings can fit one above the other\n                if (max(w2, w3) <= w1 and h2 + h3 <= h1) or (max(h2, h3) <= h1 and w2 + w3 <= w1):\n                    return \"YES\"\n    return \"NO\"\n\n# Input reading\na1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\na3, b3 = map(int, input().split())\n\n# Output the result\nprint(can_place_paintings(a1, b1, a2, b2, a3, b3))"}
{"solution": "def count_geometric_progression_terms(b1, q, l, m, bad_integers):\n    if abs(b1) > l:\n        return 0\n    \n    bad_set = set(bad_integers)\n    count = 0\n    \n    if q == 0:\n        if b1 not in bad_set and abs(b1) <= l:\n            return 1\n        return 0\n    \n    if q == 1:\n        if b1 not in bad_set and abs(b1) <= l:\n            return float('inf')\n        return 0\n    \n    if q == -1:\n        if abs(b1) <= l:\n            if b1 not in bad_set:\n                count += 1\n            if -b1 not in bad_set and b1 != 0:\n                count += 1\n            return count\n    \n    current = b1\n    while abs(current) <= l:\n        if current not in bad_set:\n            count += 1\n        current *= q\n    \n    return count\n\n# Input reading\nb1, q, l, m = map(int, input().split())\nbad_integers = list(map(int, input().split()))\n\n# Output the result\nresult = count_geometric_progression_terms(b1, q, l, m, bad_integers)\nif result == float('inf'):\n    print(\"inf\")\nelse:\n    print(result)"}
{"solution": "def find_frame(n, m, monitor):\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n\n    # Find the bounding box of all 'w' pixels\n    for i in range(n):\n        for j in range(m):\n            if monitor[i][j] == 'w':\n                min_row = min(min_row, i)\n                max_row = max(max_row, i)\n                min_col = min(min_col, j)\n                max_col = max(max_col, j)\n\n    # If no 'w' pixels found, return -1\n    if max_row == -1:\n        return -1\n\n    # Check if the frame can be formed\n    frame_possible = True\n    for i in range(min_row, max_row + 1):\n        for j in range(min_col, max_col + 1):\n            if (i == min_row or i == max_row or j == min_col or j == max_col) and monitor[i][j] == '.':\n                continue\n            if (i == min_row or i == max_row or j == min_col or j == max_col) and monitor[i][j] == 'w':\n                continue\n            if monitor[i][j] == 'w':\n                frame_possible = False\n\n    if not frame_possible:\n        return -1\n\n    # Create the output monitor with the frame\n    output_monitor = [list(row) for row in monitor]\n\n    # Draw the frame\n    for j in range(min_col, max_col + 1):\n        output_monitor[min_row][j] = '+'  # Top edge\n        output_monitor[max_row][j] = '+'  # Bottom edge\n    for i in range(min_row, max_row + 1):\n        output_monitor[i][min_col] = '+'  # Left edge\n        output_monitor[i][max_col] = '+'  # Right edge\n\n    # Convert list of lists back to strings\n    return [''.join(row) for row in output_monitor]\n\n# Read input\nn, m = map(int, input().split())\nmonitor = [input().strip() for _ in range(n)]\n\n# Find the frame and print the result\nresult = find_frame(n, m, monitor)\nif result == -1:\n    print(-1)\nelse:\n    for line in result:\n        print(line)"}
{"solution": "n = int(input())\na = int(input())\nb = int(input())\n\nfound = False\nfor x in range(n // a + 1):\n    if (n - x * a) % b == 0:\n        y = (n - x * a) // b\n        print(\"YES\")\n        print(x, y)\n        found = True\n        break\n\nif not found:\n    print(\"NO\")"}
{"solution": "def number_to_words(s):\n    if s < 0 or s > 99:\n        return \"\"\n    \n    ones = [\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n    \n    if s < 10:\n        return ones[s]\n    elif 10 <= s < 20:\n        return teens[s - 10]\n    else:\n        ten_part = tens[s // 10]\n        one_part = ones[s % 10]\n        if one_part:\n            return f\"{ten_part}-{one_part}\"\n        else:\n            return ten_part\n\ns = int(input().strip())\nprint(number_to_words(s))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nmax_erase = 0\n\nfor i in range(n):\n    for j in range(i, n):\n        if i > 0 and j < n - 1:\n            if a[j + 1] - a[i - 1] <= j - i + 1:\n                max_erase = max(max_erase, j - i + 1)\n        elif i == 0 and j < n - 1:\n            if a[j + 1] - a[i] <= j - i + 1:\n                max_erase = max(max_erase, j - i + 1)\n        elif i > 0 and j == n - 1:\n            if a[j] - a[i - 1] <= j - i + 1:\n                max_erase = max(max_erase, j - i + 1)\n\nprint(max_erase)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\ntotal_problems = sum(a)\nhalf_problems = total_problems / 2\n\nsolved_problems = 0\nfor i in range(n):\n    solved_problems += a[i]\n    if solved_problems >= half_problems:\n        print(i + 1)\n        break"}
{"solution": "from collections import deque\n\ndef knight_moves(x, y, N):\n    moves = [\n        (2, 1), (2, -1), (-2, 1), (-2, -1),\n        (1, 2), (1, -2), (-1, 2), (-1, -2)\n    ]\n    return [(x + dx, y + dy) for dx, dy in moves if 0 <= x + dx < N and 0 <= y + dy < N]\n\ndef bishop_moves(x, y, N):\n    moves = []\n    for dx in range(-N, N):\n        for dy in range(-N, N):\n            if abs(dx) == abs(dy) and (dx != 0 or dy != 0):\n                if 0 <= x + dx < N and 0 <= y + dy < N:\n                    moves.append((x + dx, y + dy))\n    return moves\n\ndef rook_moves(x, y, N):\n    moves = []\n    for dx in range(-N + 1, N):\n        if dx != 0:\n            if 0 <= x + dx < N:\n                moves.append((x + dx, y))\n        for dy in range(-N + 1, N):\n            if dy != 0:\n                if 0 <= y + dy < N:\n                    moves.append((x, y + dy))\n    return moves\n\ndef bfs(N, board):\n    positions = {}\n    for i in range(N):\n        for j in range(N):\n            positions[board[i][j]] = (i, j)\n\n    directions = {\n        'knight': knight_moves,\n        'bishop': bishop_moves,\n        'rook': rook_moves\n    }\n\n    queue = deque()\n    for piece in directions.keys():\n        queue.append((1, piece, positions[1][0], positions[1][1], 0))  # (steps, piece, x, y, replacements)\n\n    visited = {}\n    for piece in directions.keys():\n        visited[(1, piece)] = (0, 0)  # (steps, replacements)\n\n    while queue:\n        steps, piece, x, y, replacements = queue.popleft()\n\n        if piece == 'knight':\n            next_moves = directions['knight'](x, y, N)\n        elif piece == 'bishop':\n            next_moves = directions['bishop'](x, y, N)\n        else:  # rook\n            next_moves = directions['rook'](x, y, N)\n\n        for nx, ny in next_moves:\n            number = board[nx][ny]\n            if number == steps + 1:\n                if (number, piece) not in visited or visited[(number, piece)] > (steps + 1, replacements):\n                    visited[(number, piece)] = (steps + 1, replacements)\n                    queue.append((steps + 1, piece, nx, ny, replacements))\n\n        for new_piece in directions.keys():\n            if new_piece != piece:\n                if (steps + 1, new_piece) not in visited or visited[(steps + 1, new_piece)] > (steps + 1, replacements + 1):\n                    visited[(steps + 1, new_piece)] = (steps + 1, replacements + 1)\n                    queue.append((steps + 1, new_piece, x, y, replacements + 1))\n\n    min_steps = float('inf')\n    min_replacements = float('inf')\n\n    for piece in directions.keys():\n        if (N * N, piece) in visited:\n            steps, replacements = visited[(N * N, piece)]\n            if steps < min_steps or (steps == min_steps and replacements < min_replacements):\n                min_steps = steps\n                min_replacements = replacements\n\n    return min_steps, min_replacements\n\nN = int(input().strip())\nboard = [list(map(int, input().strip().split())) for _ in range(N)]\n\nresult = bfs(N, board)\nprint(result[0], result[1])"}
{"solution": "def calculate_min_time(n, m, k, a, b):\n    def apartment_to_position(apartment):\n        # Calculate the entrance, floor, and position in the floor\n        entrance = (apartment - 1) // (m * k) + 1\n        floor = ((apartment - 1) % (m * k)) // k + 1\n        return entrance, floor\n\n    def time_to_floor(entrance, floor):\n        return (floor - 1) * 5\n\n    def time_to_move_between_entrances(start, end):\n        distance = abs(start - end)\n        return min(distance, n - distance) * 15\n\n    entrance_a, floor_a = apartment_to_position(a)\n    entrance_b, floor_b = apartment_to_position(b)\n\n    # Time using stairs\n    time_stairs = time_to_floor(entrance_a, floor_a) + time_to_move_between_entrances(entrance_a, entrance_b) + time_to_floor(entrance_b, floor_b)\n\n    # Time using elevator\n    time_elevator = 10 + (floor_a - 1) + time_to_move_between_entrances(entrance_a, entrance_b) + time_to_floor(entrance_b, floor_b)\n\n    return min(time_stairs, time_elevator)\n\n# Input reading\nn, m, k = map(int, input().split())\na, b = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_min_time(n, m, k, a, b))"}
{"solution": "def can_form_divisible_by_64(s):\n    # A number is divisible by 64 in binary if it ends with at least 6 zeros\n    count_of_zeros = 0\n    found_one = False\n    \n    for char in reversed(s):\n        if char == '0':\n            count_of_zeros += 1\n        elif char == '1':\n            found_one = True\n            break\n    \n    return \"yes\" if found_one and count_of_zeros >= 6 else \"no\"\n\n# Read input\ns = input().strip()\n# Print the result\nprint(can_form_divisible_by_64(s))"}
{"solution": "def can_form_alphabet_subsequence(s):\n    target = \"abcdefghijklmnopqrstuvwxyz\"\n    target_index = 0\n    result = []\n\n    for char in s:\n        if target_index < len(target) and char <= target[target_index]:\n            result.append(target[target_index])\n            target_index += 1\n        else:\n            result.append(char)\n\n        if target_index == len(target):\n            break\n\n    if target_index < len(target):\n        return \"-1\"\n    \n    return ''.join(result)\n\ns = input().strip()\nprint(can_form_alphabet_subsequence(s))"}
{"solution": "def max_expected_fishes(n, m, r, k):\n    # Total number of positions the scoop can be placed\n    total_positions = (n - r + 1) * (m - r + 1)\n    \n    # If k is greater than the total positions, we can only catch as many fishes as positions\n    if k >= total_positions:\n        return total_positions\n    \n    # Calculate the maximum expected number of caught fishes\n    # Each fish can be caught in r * r positions\n    # The expected value is k * (r * r / total_positions)\n    expected_value = k * (r * r) / total_positions\n    \n    return expected_value\n\n# Read input\nn, m, r, k = map(int, input().split())\n\n# Calculate and print the result\nresult = max_expected_fishes(n, m, r, k)\nprint(f\"{result:.10f}\")"}
{"solution": "def maximize_product(n, a):\n    for i in range(n):\n        if a[i] < -1:\n            a[i] = -a[i] - 1\n        elif a[i] == -1:\n            a[i] = 0\n    return a\n\nn = int(input())\na = list(map(int, input().split()))\nresult = maximize_product(n, a)\nprint(' '.join(map(str, result)))"}
{"solution": "def kth_smallest_divisor(n, k):\n    divisors = []\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    \n    divisors.sort()\n    \n    if k > len(divisors):\n        return -1\n    else:\n        return divisors[k - 1]\n\nn, k = map(int, input().split())\nprint(kth_smallest_divisor(n, k))"}
{"solution": "def can_form_number(cubes, number):\n    str_num = str(number)\n    if len(str_num) > len(cubes):\n        return False\n    \n    from itertools import permutations\n    \n    for perm in permutations(cubes, len(str_num)):\n        if all(int(digit) in perm[i] for i, digit in enumerate(str_num)):\n            return True\n    return False\n\ndef max_natural_x(n, cubes):\n    x = 1\n    while can_form_number(cubes, x):\n        x += 1\n    return x - 1\n\nn = int(input().strip())\ncubes = [list(map(int, input().strip().split())) for _ in range(n)]\n\nresult = max_natural_x(n, cubes)\nprint(result)"}
{"solution": "def k_rounding(n, k):\n    if k == 0:\n        return n\n    \n    # Calculate the factor to make the number end with k zeros\n    factor = 10 ** k\n    \n    # Find the smallest multiple of n that is also a multiple of factor\n    x = n\n    while x % factor != 0:\n        x += n\n    \n    return x\n\n# Read input\nn, k = map(int, input().split())\n# Calculate and print the k-rounding of n\nprint(k_rounding(n, k))"}
{"solution": "def can_transform(n, m, A):\n    operations = []\n    \n    for i in range(n - 1):\n        for j in range(m - 1):\n            if A[i][j] == 1 and A[i][j + 1] == 1 and A[i + 1][j] == 1 and A[i + 1][j + 1] == 1:\n                operations.append((i + 1, j + 1))  # Store 1-based index\n                # Mark the 2x2 area as filled\n                A[i][j] = A[i][j + 1] = A[i + 1][j] = A[i + 1][j + 1] = 0\n\n    # Check if A is now all zeros\n    for i in range(n):\n        for j in range(m):\n            if A[i][j] == 1:\n                return -1\n\n    # Output the result\n    print(len(operations))\n    for op in operations:\n        print(op[0], op[1])\n\n# Read input\nn, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\n\n# Process and output the result\ncan_transform(n, m, A)"}
{"solution": "def bad_luck_island_probabilities(r, s, p):\n    total = r + s + p\n    if total == 0:\n        return (0.0, 0.0, 0.0)\n\n    # Probabilities of each species surviving\n    prob_r = r / total\n    prob_s = s / total\n    prob_p = p / total\n\n    # Normalize the probabilities\n    total_prob = prob_r + prob_s + prob_p\n    return (prob_r / total_prob, prob_s / total_prob, prob_p / total_prob)\n\n# Read input\nr, s, p = map(int, input().split())\n\n# Calculate probabilities\nprobabilities = bad_luck_island_probabilities(r, s, p)\n\n# Print the results\nprint(f\"{probabilities[0]:.12f} {probabilities[1]:.12f} {probabilities[2]:.12f}\")"}
{"solution": "def calculate_meeting_time(l1, r1, l2, r2, k):\n    # Calculate the overlap between Sonya's awake time and Filya's visiting time\n    start = max(l1, l2)\n    end = min(r1, r2)\n    \n    if start > end:\n        return 0  # No overlap\n    \n    # Calculate the total minutes they can spend together\n    total_minutes = end - start + 1\n    \n    # Check if the prinking time k is within the overlapping time\n    if start <= k <= end:\n        total_minutes -= 1  # Subtract the minute when Sonya is prinking\n    \n    return total_minutes\n\n# Read input\nl1, r1, l2, r2, k = map(int, input().split())\n# Calculate and print the result\nprint(calculate_meeting_time(l1, r1, l2, r2, k))"}
{"solution": "def cow_reach_area(N, M, vertical_lines, horizontal_lines):\n    from collections import defaultdict\n\n    # Create a set to store the boundaries\n    vertical_boundaries = []\n    horizontal_boundaries = []\n\n    # Collect vertical lines\n    for A, B, C in vertical_lines:\n        vertical_boundaries.append((A, C, 'L'))  # Left boundary\n        vertical_boundaries.append((B, C, 'R'))  # Right boundary\n\n    # Collect horizontal lines\n    for D, E, F in horizontal_lines:\n        horizontal_boundaries.append((E, D, 'B'))  # Bottom boundary\n        horizontal_boundaries.append((F, D, 'T'))  # Top boundary\n\n    # Sort boundaries\n    vertical_boundaries.sort()\n    horizontal_boundaries.sort()\n\n    # Initialize the area\n    area = 0\n    last_x = -float('inf')\n    last_y = -float('inf')\n\n    # Process vertical boundaries\n    for x, y, typ in vertical_boundaries:\n        if last_x != -float('inf'):\n            if last_x < x:\n                # Calculate the height of the rectangle\n                height = last_y - (-float('inf') if last_y == -float('inf') else last_y)\n                if height > 0:\n                    area += (x - last_x) * height\n\n        if typ == 'L':\n            last_y = y if last_y == -float('inf') else min(last_y, y)\n        else:  # 'R'\n            last_y = y if last_y == -float('inf') else max(last_y, y)\n\n        last_x = x\n\n    # Reset for horizontal boundaries\n    last_x = -float('inf')\n    last_y = -float('inf')\n\n    # Process horizontal boundaries\n    for y, x, typ in horizontal_boundaries:\n        if last_y != -float('inf'):\n            if last_y < y:\n                # Calculate the width of the rectangle\n                width = last_x - (-float('inf') if last_x == -float('inf') else last_x)\n                if width > 0:\n                    area += (y - last_y) * width\n\n        if typ == 'B':\n            last_x = x if last_x == -float('inf') else min(last_x, x)\n        else:  # 'T'\n            last_x = x if last_x == -float('inf') else max(last_x, x)\n\n        last_y = y\n\n    # Check for infinite area\n    if last_x == -float('inf') or last_y == -float('inf'):\n        return \"INF\"\n\n    return area\n\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nN, M = map(int, data[0].split())\nvertical_lines = [tuple(map(int, line.split())) for line in data[1:N+1]]\nhorizontal_lines = [tuple(map(int, line.split())) for line in data[N+1:N+1+M]]\n\nresult = cow_reach_area(N, M, vertical_lines, horizontal_lines)\nprint(result)"}
{"solution": "t, s, x = map(int, input().split())\n\nif x == t:\n    print(\"YES\")\nelif x > t:\n    if (x - t) % s == 0 or (x - t - 1) % s == 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    print(\"NO\")"}
{"solution": "def find_nested_segments(n, segments):\n    indexed_segments = [(l, r, i + 1) for i, (l, r) in enumerate(segments)]\n    indexed_segments.sort(key=lambda x: (x[0], -x[1]))\n\n    for i in range(n):\n        l1, r1, idx1 = indexed_segments[i]\n        for j in range(i + 1, n):\n            l2, r2, idx2 = indexed_segments[j]\n            if l1 >= l2 and r1 <= r2:\n                return idx1, idx2\n\n    return -1, -1\n\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\nresult = find_nested_segments(n, segments)\nprint(result[0], result[1])"}
{"solution": "def decode_genome(n, s):\n    count_A = s.count('A')\n    count_C = s.count('C')\n    count_G = s.count('G')\n    count_T = s.count('T')\n    count_Q = s.count('?')\n\n    # Each nucleotide should appear n // 4 times\n    target_count = n // 4\n\n    # Calculate how many more of each nucleotide we need\n    need_A = max(0, target_count - count_A)\n    need_C = max(0, target_count - count_C)\n    need_G = max(0, target_count - count_G)\n    need_T = max(0, target_count - count_T)\n\n    # Total needed nucleotides should not exceed the number of '?'\n    if need_A + need_C + need_G + need_T > count_Q:\n        print(\"===\")\n        return\n\n    # Replace '?' with the needed nucleotides\n    result = list(s)\n    for i in range(n):\n        if result[i] == '?':\n            if need_A > 0:\n                result[i] = 'A'\n                need_A -= 1\n            elif need_C > 0:\n                result[i] = 'C'\n                need_C -= 1\n            elif need_G > 0:\n                result[i] = 'G'\n                need_G -= 1\n            elif need_T > 0:\n                result[i] = 'T'\n                need_T -= 1\n\n    # Join the list back into a string and print the result\n    print(''.join(result))\n\n# Read input\nn = int(input().strip())\ns = input().strip()\n\n# Decode the genome\ndecode_genome(n, s)"}
{"solution": "def can_win(board):\n    # Check all possible winning positions\n    for i in range(4):\n        for j in range(4):\n            if board[i][j] == '.':\n                # Temporarily place 'x' in the empty cell\n                board[i][j] = 'x'\n                \n                # Check for a win\n                if (check_win(board, i, j)):\n                    return \"YES\"\n                \n                # Restore the cell\n                board[i][j] = '.'\n    return \"NO\"\n\ndef check_win(board, row, col):\n    # Check horizontal\n    if col <= 1 and board[row][col + 1] == 'x' and board[row][col + 2] == 'x':\n        return True\n    if col >= 2 and board[row][col - 1] == 'x' and board[row][col - 2] == 'x':\n        return True\n    if 0 < col < 3 and board[row][col - 1] == 'x' and board[row][col + 1] == 'x':\n        return True\n\n    # Check vertical\n    if row <= 1 and board[row + 1][col] == 'x' and board[row + 2][col] == 'x':\n        return True\n    if row >= 2 and board[row - 1][col] == 'x' and board[row - 2][col] == 'x':\n        return True\n    if 0 < row < 3 and board[row - 1][col] == 'x' and board[row + 1][col] == 'x':\n        return True\n\n    # Check diagonal (top-left to bottom-right)\n    if row <= 1 and col <= 1 and board[row + 1][col + 1] == 'x' and board[row + 2][col + 2] == 'x':\n        return True\n    if row >= 2 and col >= 2 and board[row - 1][col - 1] == 'x' and board[row - 2][col - 2] == 'x':\n        return True\n    if 0 < row < 3 and 0 < col < 3 and board[row - 1][col - 1] == 'x' and board[row + 1][col + 1] == 'x':\n        return True\n\n    # Check diagonal (top-right to bottom-left)\n    if row <= 1 and col >= 2 and board[row + 1][col - 1] == 'x' and board[row + 2][col - 2] == 'x':\n        return True\n    if row >= 2 and col <= 1 and board[row - 1][col + 1] == 'x' and board[row - 2][col + 2] == 'x':\n        return True\n    if 0 < row < 3 and 1 < col < 4 and board[row - 1][col + 1] == 'x' and board[row + 1][col - 1] == 'x':\n        return True\n\n    return False\n\n# Read input\nboard = [list(input().strip()) for _ in range(4)]\nprint(can_win(board))"}
{"solution": "def can_divide_array(n, a):\n    total_sum = sum(a)\n    prefix_sum = 0\n    \n    for i in range(n):\n        prefix_sum += a[i]\n        suffix_sum = total_sum - prefix_sum\n        \n        if prefix_sum == suffix_sum:\n            return \"YES\"\n        \n        # Check if moving the current element can balance the sums\n        if i < n - 1:\n            # If we move a[i] to the end, we need to check if the new prefix sum\n            # (without a[i]) can equal the new suffix sum (with a[i] added)\n            new_prefix_sum = prefix_sum - a[i]\n            new_suffix_sum = suffix_sum + a[i]\n            if new_prefix_sum == new_suffix_sum:\n                return \"YES\"\n    \n    return \"NO\"\n\nn = int(input())\na = list(map(int, input().split()))\nprint(can_divide_array(n, a))"}
{"solution": "def can_form_non_increasing_sequence(n, k, a, b):\n    # Replace zeros in a with elements from b\n    zero_indices = [i for i in range(n) if a[i] == 0]\n    \n    # Sort b in descending order to maximize the chance of creating a non-increasing sequence\n    b.sort(reverse=True)\n    \n    # Fill the zeros in a with elements from b\n    for idx, zero_index in enumerate(zero_indices):\n        a[zero_index] = b[idx]\n    \n    # Check if the resulting sequence is non-increasing\n    for i in range(1, n):\n        if a[i] > a[i - 1]:\n            return \"Yes\"\n    \n    return \"No\"\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Get the result and print it\nresult = can_form_non_increasing_sequence(n, k, a, b)\nprint(result)"}
{"solution": "def can_distribute_grapes(x, y, z, a, b, c):\n    # Check if Andrew can get enough green grapes\n    if a < x:\n        return \"NO\"\n    \n    # Remaining green grapes after Andrew's share\n    remaining_green = a - x\n    \n    # Dmitry can take from remaining green and purple grapes\n    # Total grapes available for Dmitry\n    total_for_dmitry = remaining_green + b\n    \n    if total_for_dmitry < y:\n        return \"NO\"\n    \n    # Remaining grapes after Dmitry's share\n    remaining_after_dmitry = total_for_dmitry - y\n    \n    # Michal can take from remaining grapes (green, purple, black)\n    total_for_michal = remaining_after_dmitry + c\n    \n    if total_for_michal < z:\n        return \"NO\"\n    \n    return \"YES\"\n\n# Input reading\nx, y, z = map(int, input().split())\na, b, c = map(int, input().split())\n\n# Output the result\nprint(can_distribute_grapes(x, y, z, a, b, c))"}
{"solution": "def is_accident_possible(traffic_lights):\n    for i in range(4):\n        l, s, r, p = traffic_lights[i]\n        # Check if pedestrian light is green\n        if p == 1:\n            # Check if any car light in the same part is green\n            if l == 1 or s == 1 or r == 1:\n                return \"YES\"\n            # Check if cars from adjacent parts can hit the pedestrian\n            if i == 0:  # Part 1\n                if s == 1 or r == 1 and traffic_lights[1][l] == 1:  # Part 2\n                    return \"YES\"\n                if l == 1 and traffic_lights[3][r] == 1:  # Part 4\n                    return \"YES\"\n            elif i == 1:  # Part 2\n                if l == 1 or s == 1 and traffic_lights[2][r] == 1:  # Part 3\n                    return \"YES\"\n                if r == 1 and traffic_lights[0][l] == 1:  # Part 1\n                    return \"YES\"\n            elif i == 2:  # Part 3\n                if l == 1 or s == 1 and traffic_lights[3][r] == 1:  # Part 4\n                    return \"YES\"\n                if r == 1 and traffic_lights[1][l] == 1:  # Part 2\n                    return \"YES\"\n            elif i == 3:  # Part 4\n                if l == 1 or s == 1 and traffic_lights[0][r] == 1:  # Part 1\n                    return \"YES\"\n                if r == 1 and traffic_lights[2][l] == 1:  # Part 3\n                    return \"YES\"\n    return \"NO\"\n\ntraffic_lights = [list(map(int, input().split())) for _ in range(4)]\nprint(is_accident_possible(traffic_lights))"}
{"solution": "def can_be_sure(n, number):\n    # Define the positions of the keys on the keypad\n    key_positions = {\n        '0': (1, 3), '1': (0, 0), '2': (0, 1), '3': (0, 2),\n        '4': (1, 0), '5': (1, 1), '6': (1, 2),\n        '7': (2, 0), '8': (2, 1), '9': (2, 2)\n    }\n    \n    # Calculate the movements based on the input number\n    movements = []\n    for i in range(1, n):\n        x1, y1 = key_positions[number[i - 1]]\n        x2, y2 = key_positions[number[i]]\n        movements.append((x2 - x1, y2 - y1))\n    \n    # Check for unique movements\n    unique_movements = set(movements)\n    \n    # If the number of unique movements is equal to the number of movements,\n    # it means there are no repeated movements, hence it can be sure\n    if len(unique_movements) == len(movements):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Input reading\nn = int(input().strip())\nnumber = input().strip()\n\n# Output the result\nprint(can_be_sure(n, number))"}
{"solution": "def max_sold_products(n, f, days):\n    sales = []\n    \n    for k, l in days:\n        sales.append(min(k, l))\n    \n    if f == 0:\n        return sum(sales)\n    \n    potential_increase = []\n    \n    for i in range(n):\n        k, l = days[i]\n        if k > 0:\n            original_sales = min(k, l)\n            doubled_sales = min(2 * k, l)\n            increase = doubled_sales - original_sales\n            potential_increase.append(increase)\n        else:\n            potential_increase.append(0)\n    \n    potential_increase.sort(reverse=True)\n    \n    max_increase = sum(potential_increase[:f])\n    \n    return sum(sales) + max_increase\n\n# Input reading\nn, f = map(int, input().split())\ndays = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_sold_products(n, f, days))"}
{"solution": "def max_messiness(n, k):\n    # The maximum number of pairs (i, j) such that i < j is n * (n - 1) // 2\n    max_pairs = n * (n - 1) // 2\n    \n    # The maximum messiness we can achieve is limited by the number of swaps we can make\n    # Each swap can increase the messiness by at most 1, but we can only swap distinct pairs\n    # Therefore, the maximum messiness is the minimum of max_pairs and k * 2\n    return min(max_pairs, k * 2)\n\n# Read input\nn, k = map(int, input().split())\n# Output the result\nprint(max_messiness(n, k))"}
{"solution": "def minimum_coins(N, M, K, L):\n    # Check if it's possible to satisfy the conditions\n    if M > N:\n        return -1  # More friends than different coins\n    if L > (N - K):\n        return -1  # Not enough new coins possible\n    \n    # Calculate the minimum number of coins each friend can gift\n    # We need at least L new coins, and M friends must gift the same amount\n    # Let x be the number of coins each friend gifts\n    # Total coins gifted = M * x\n    # We need M * x >= L + (M - 1) * (x - 1)\n    # Rearranging gives us: M * x >= L + M * x - M\n    # Thus, we need M * x >= L + M - 1\n    # Therefore, x >= (L + M - 1) / M\n    min_coins_per_friend = (L + M - 1) // M\n    \n    # Check if the total number of coins gifted does not exceed the available coins\n    if min_coins_per_friend * M > N:\n        return -1\n    \n    return min_coins_per_friend\n\n# Read input\nN, M, K, L = map(int, input().split())\n# Get the result\nresult = minimum_coins(N, M, K, L)\n# Print the result\nprint(result)"}
{"solution": "def min_cells_to_paint(n, m, grid):\n    # Find the bounds of the black cells\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'B':\n                min_row = min(min_row, i)\n                max_row = max(max_row, i)\n                min_col = min(min_col, j)\n                max_col = max(max_col, j)\n    \n    # If no black cells are found\n    if max_row == -1:\n        return 1  # Need to paint at least one cell black\n    \n    # Calculate the size of the square needed\n    side_length = max(max_row - min_row + 1, max_col - min_col + 1)\n    \n    # Check if the square can fit within the grid\n    if min_row + side_length > n or min_col + side_length > m:\n        return -1\n    \n    # Count how many cells need to be painted\n    cells_to_paint = 0\n    for i in range(min_row, min_row + side_length):\n        for j in range(min_col, min_col + side_length):\n            if grid[i][j] == 'W':\n                cells_to_paint += 1\n    \n    return cells_to_paint\n\n# Input reading\nn, m = map(int, input().split())\ngrid = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(min_cells_to_paint(n, m, grid))"}
{"solution": "def can_records_be_consistent(n, x, y):\n    total_x = sum(x)\n    total_y = sum(y)\n    \n    # The total number of stones can only decrease or stay the same\n    if total_y > total_x:\n        return \"No\"\n    \n    return \"Yes\"\n\n# Input reading\nn = int(input().strip())\nx = list(map(int, input().strip().split()))\ny = list(map(int, input().strip().split()))\n\n# Output the result\nprint(can_records_be_consistent(n, x, y))"}
{"solution": "def minimal_difference(n, angles):\n    total_angle = sum(angles)\n    min_diff = total_angle  # Start with the maximum possible difference\n\n    # We will use a prefix sum to calculate the angles of continuous sectors\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + angles[i]\n\n    # Check all possible continuous sectors\n    for start in range(n):\n        for length in range(1, n + 1):  # length of the sector\n            end = (start + length - 1) % n\n            if end >= start:\n                sector_angle = prefix_sum[end + 1] - prefix_sum[start]\n            else:\n                sector_angle = prefix_sum[n] - (prefix_sum[start] - prefix_sum[end + 1])\n\n            other_sector_angle = total_angle - sector_angle\n            min_diff = min(min_diff, abs(sector_angle - other_sector_angle))\n\n    return min_diff\n\n# Input reading\nn = int(input())\nangles = list(map(int, input().split()))\n\n# Output the result\nprint(minimal_difference(n, angles))"}
{"solution": "def count_ways(n, m):\n    MOD = 10**9 + 7\n    # Calculate (2^m - 1)^n % MOD\n    ways = pow(2, m, MOD) - 1\n    ways = (ways + MOD) % MOD  # Ensure it's non-negative\n    result = pow(ways, n, MOD)\n    return result\n\n# Read input\nn, m = map(int, input().split())\n# Calculate and print the result\nprint(count_ways(n, m))"}
{"solution": "def find_pythagorean_triple(n):\n    if n <= 0:\n        return -1\n    \n    if n % 2 == 0:\n        m = (n // 2) ** 2 - 1\n        k = (n // 2) ** 2 + 1\n    else:\n        m = (n ** 2 - 1) // 2\n        k = (n ** 2 + 1) // 2\n    \n    if m > 0 and k > 0:\n        return m, k\n    else:\n        return -1\n\nn = int(input().strip())\nresult = find_pythagorean_triple(n)\n\nif result == -1:\n    print(-1)\nelse:\n    print(result[0], result[1])"}
{"solution": "def are_remainders_distinct(n, k):\n    if k > n:\n        return \"Yes\"\n    \n    remainders = set()\n    for i in range(1, k + 1):\n        remainder = n % i\n        if remainder in remainders:\n            return \"No\"\n        remainders.add(remainder)\n    \n    return \"Yes\"\n\nn, k = map(int, input().split())\nprint(are_remainders_distinct(n, k))"}
{"solution": "import sys\n\ndef compare_large_numbers():\n    a = sys.stdin.readline().strip()\n    b = sys.stdin.readline().strip()\n    \n    # Remove leading zeros\n    a = a.lstrip('0')\n    b = b.lstrip('0')\n    \n    # Compare lengths first\n    if len(a) < len(b):\n        print(\"<\")\n    elif len(a) > len(b):\n        print(\">\")\n    else:\n        # If lengths are equal, compare lexicographically\n        if a < b:\n            print(\"<\")\n        elif a > b:\n            print(\">\")\n        else:\n            print(\"=\")\n\ncompare_large_numbers()"}
{"solution": "def count_ways(n, p, colors):\n    MOD = 10**9 + 7\n\n    # Count fixed colors\n    count_black = colors.count(0)\n    count_white = colors.count(1)\n    count_unpainted = colors.count(-1)\n\n    # Total ways to color unpainted pieces\n    total_colorings = pow(2, count_unpainted, MOD)\n\n    # Dynamic programming table for paths\n    dp = [[0, 0] for _ in range(n + 1)]\n    dp[0][0] = 1  # 1 way to have an empty path with even count\n\n    # Fill dp table\n    for i in range(1, n + 1):\n        for j in range(i):\n            if colors[j] == -1 or colors[i - 1] == -1 or colors[j] == colors[i - 1]:\n                dp[i][0] = (dp[i][0] + dp[j][0]) % MOD\n                dp[i][1] = (dp[i][1] + dp[j][1]) % MOD\n            elif (colors[j] + colors[i - 1]) % 2 == 1:\n                dp[i][0] = (dp[i][0] + dp[j][1]) % MOD\n                dp[i][1] = (dp[i][1] + dp[j][0]) % MOD\n\n    # Count total paths\n    total_paths = sum(dp[i][0] + dp[i][1] for i in range(1, n + 1)) % MOD\n\n    # Calculate the final answer based on the desired parity\n    if p == 0:\n        return (total_colorings * (total_paths // 2)) % MOD\n    else:\n        return (total_colorings * ((total_paths + 1) // 2)) % MOD\n\n# Input reading\nn, p = map(int, input().split())\ncolors = list(map(int, input().split()))\n\n# Output the result\nprint(count_ways(n, p, colors))"}
{"solution": "def min_rubles(n, a, b, c):\n    remainder = n % 4\n    if remainder == 0:\n        return 0\n    \n    # Calculate the number of copybooks needed to make n + k divisible by 4\n    k_needed = 4 - remainder\n    \n    # Calculate the minimum cost for each possible k\n    min_cost = float('inf')\n    \n    # Check for k = 1\n    if k_needed >= 1:\n        min_cost = min(min_cost, a)\n    \n    # Check for k = 2\n    if k_needed >= 2:\n        min_cost = min(min_cost, b)\n    \n    # Check for k = 3\n    if k_needed >= 3:\n        min_cost = min(min_cost, c)\n    \n    return min_cost\n\n# Input reading\nn, a, b, c = map(int, input().split())\n# Output the result\nprint(min_rubles(n, a, b, c))"}
{"solution": "def can_make_acyclic(n, m, edges):\n    from collections import defaultdict, deque\n\n    graph = defaultdict(list)\n    in_degree = [0] * (n + 1)\n\n    for u, v in edges:\n        graph[u].append(v)\n        in_degree[v] += 1\n\n    def has_cycle():\n        queue = deque()\n        for i in range(1, n + 1):\n            if in_degree[i] == 0:\n                queue.append(i)\n\n        count = 0\n        while queue:\n            node = queue.popleft()\n            count += 1\n            for neighbor in graph[node]:\n                in_degree[neighbor] -= 1\n                if in_degree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        return count != n\n\n    if not has_cycle():\n        return \"YES\"\n\n    for u, v in edges:\n        graph[u].remove(v)\n        in_degree[v] -= 1\n\n        if not has_cycle():\n            return \"YES\"\n\n        graph[u].append(v)\n        in_degree[v] += 1\n\n    return \"NO\"\n\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nprint(can_make_acyclic(n, m, edges))"}
{"solution": "def min_coins_to_cover(n, m, antennas):\n    # Create a list to track the coverage of positions from 1 to m\n    coverage = [0] * (m + 1)\n\n    # Mark the initial coverage of each antenna\n    for x, s in antennas:\n        left = max(1, x - s)\n        right = min(m, x + s)\n        for i in range(left, right + 1):\n            coverage[i] = 1\n\n    # Calculate the minimum coins needed\n    coins = 0\n    for position in range(1, m + 1):\n        if coverage[position] == 0:\n            # Find the nearest antenna to the left and right\n            left_distance = float('inf')\n            right_distance = float('inf')\n\n            for x, s in antennas:\n                if x < position:\n                    left_distance = min(left_distance, position - (x + s))\n                elif x > position:\n                    right_distance = min(right_distance, (x - s) - position)\n\n            # We need to increase the scope of the nearest antenna\n            if left_distance != float('inf') and right_distance != float('inf'):\n                coins += min(left_distance, right_distance)\n            elif left_distance != float('inf'):\n                coins += left_distance\n            elif right_distance != float('inf'):\n                coins += right_distance\n\n            # Update the coverage for this position\n            coverage[position] = 1\n\n    return coins\n\n# Read input\nn, m = map(int, input().split())\nantennas = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nresult = min_coins_to_cover(n, m, antennas)\nprint(result)"}
{"solution": "def max_good_subset_weight(W, counts):\n    total_weight = 0\n    \n    for weight in range(1, 9):\n        count = counts[weight - 1]\n        max_items = min(count, W // weight)\n        total_weight += max_items * weight\n        W -= max_items * weight\n        \n        if W <= 0:\n            break\n            \n    return total_weight\n\nW = int(input().strip())\ncounts = list(map(int, input().strip().split()))\nresult = max_good_subset_weight(W, counts)\nprint(result)"}
{"solution": "def min_cost_to_buy_lemonade(n, L, costs):\n    volumes = [(1 << i) - 1 for i in range(n)]  # Calculate volumes: 2^i - 1\n    dp = [float('inf')] * (L + 1)\n    dp[0] = 0  # Cost to buy 0 liters is 0\n\n    for i in range(n):\n        volume = volumes[i]\n        cost = costs[i]\n        for j in range(volume, L + 1):\n            dp[j] = min(dp[j], dp[j - volume] + cost)\n\n    # Find the minimum cost for at least L liters\n    return min(dp[L:])\n\n# Read input\nn, L = map(int, input().split())\ncosts = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_cost_to_buy_lemonade(n, L, costs))"}
{"solution": "def maximum_mex(n, a):\n    # Create a set to store unique values from the array\n    unique_values = set(a)\n    \n    # Initialize mex to 1\n    mex = 1\n    \n    # Increment mex until we find a value that is not in the unique values\n    while mex in unique_values:\n        mex += 1\n    \n    return mex\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Get the result and print it\nresult = maximum_mex(n, a)\nprint(result)"}
{"solution": "def is_lucky_ticket(n, ticket):\n    digits = list(map(int, ticket))\n    total_sum = sum(digits)\n\n    for segment_sum in range(1, total_sum // 2 + 1):\n        current_sum = 0\n        count_segments = 0\n        \n        for digit in digits:\n            current_sum += digit\n            if current_sum == segment_sum:\n                count_segments += 1\n                current_sum = 0\n            elif current_sum > segment_sum:\n                break\n        \n        if count_segments >= 2:\n            return \"YES\"\n    \n    return \"NO\"\n\nn = int(input().strip())\nticket = input().strip()\nprint(is_lucky_ticket(n, ticket))"}
{"solution": "def determine_gender(username):\n    distinct_characters = set(username)\n    if len(distinct_characters) % 2 == 0:\n        return \"CHAT WITH HER!\"\n    else:\n        return \"IGNORE HIM!\"\n\nusername = input().strip()\nprint(determine_gender(username))"}
{"solution": "def max_absolute_difference(n, k, tabs):\n    max_diff = 0\n    \n    for b in range(1, n + 1):\n        closed = set()\n        \n        # Close tabs based on the chosen b\n        for i in range(-n, n + 1):\n            c = b + i * k\n            if 1 <= c <= n:\n                closed.add(c)\n        \n        # Count remaining tabs\n        e = sum(1 for i in range(1, n + 1) if i not in closed and tabs[i - 1] == 1)\n        s = sum(1 for i in range(1, n + 1) if i not in closed and tabs[i - 1] == -1)\n        \n        max_diff = max(max_diff, abs(e - s))\n    \n    return max_diff\n\n# Input reading\nn, k = map(int, input().split())\ntabs = list(map(int, input().split()))\n\n# Output the result\nprint(max_absolute_difference(n, k, tabs))"}
{"solution": "def minimum_cost(n, c0, c1):\n    # Calculate the number of bits needed\n    bits_needed = 0\n    while (1 << bits_needed) < n:\n        bits_needed += 1\n\n    # Calculate the number of '0's and '1's used\n    total_zeros = 0\n    total_ones = 0\n\n    # Distribute the letters in a binary tree fashion\n    for i in range(bits_needed):\n        if (1 << i) <= n:\n            total_zeros += (1 << i) // 2\n            total_ones += (1 << i) // 2\n        else:\n            total_zeros += (n - (1 << (i - 1))) // 2\n            total_ones += (n - (1 << (i - 1))) // 2\n\n    # If n is odd, we need to add one more to the total_ones\n    if n % 2 == 1:\n        total_ones += 1\n\n    # Calculate the total cost\n    total_cost = total_zeros * c0 + total_ones * c1\n    return total_cost\n\n# Read input\nn, c0, c1 = map(int, input().split())\n# Get the minimum cost\nresult = minimum_cost(n, c0, c1)\n# Print the result\nprint(result)"}
{"solution": "n, a, x, b, y = map(int, input().split())\n\nwhile a != x and b != y:\n    if a == b:\n        print(\"YES\")\n        break\n    a = a + 1 if a < n else 1\n    b = b - 1 if b > 1 else n\nelse:\n    if a == b:\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "def find_unlucky_years(x, y, l, r):\n    unlucky_years = set()\n    \n    # Generate all powers of x and y within the range\n    a = 0\n    while True:\n        x_power = x ** a\n        if x_power > r:\n            break\n        b = 0\n        while True:\n            y_power = y ** b\n            year = x_power + y_power\n            if year > r:\n                break\n            if year >= l:\n                unlucky_years.add(year)\n            b += 1\n        a += 1\n    \n    return unlucky_years\n\ndef max_golden_age_length(x, y, l, r):\n    unlucky_years = find_unlucky_years(x, y, l, r)\n    \n    if not unlucky_years:\n        return r - l + 1\n    \n    max_length = 0\n    current_start = l\n    \n    for year in sorted(unlucky_years):\n        if year > current_start:\n            max_length = max(max_length, year - current_start)\n        current_start = year + 1\n    \n    if current_start <= r + 1:\n        max_length = max(max_length, r + 1 - current_start)\n    \n    return max_length\n\n# Input reading\nx, y, l, r = map(int, input().split())\n# Output the result\nprint(max_golden_age_length(x, y, l, r))"}
{"solution": "def max_divisor(n):\n    for i in range(int(n**0.5), 1, -1):\n        if n % i == 0:\n            return n // i\n    return 1\n\ndef min_tax(n):\n    if n % 2 == 0:\n        return n // 2\n    else:\n        return max_divisor(n)\n\nn = int(input())\nprint(min_tax(n))"}
{"solution": "def is_consonant(c):\n    return c not in 'aeiou'\n\ndef has_typo(word):\n    count = 0\n    last_char = ''\n    for char in word:\n        if is_consonant(char):\n            if char == last_char:\n                count += 1\n            else:\n                count = 1\n            last_char = char\n            if count >= 3:\n                return True\n        else:\n            last_char = ''\n            count = 0\n    return False\n\ndef fix_typos(word):\n    result = []\n    count = 0\n    last_char = ''\n    \n    for char in word:\n        if is_consonant(char):\n            if char == last_char:\n                count += 1\n            else:\n                count = 1\n            last_char = char\n        else:\n            last_char = ''\n            count = 0\n        \n        result.append(char)\n        \n        if count == 3 and is_consonant(char):\n            result.pop()  # Remove the last character\n            result.append(' ')  # Add a space\n            result.append(char)  # Add the character again\n            count = 1  # Reset count for the new segment\n    \n    return ''.join(result)\n\nword = input().strip()\nif has_typo(word):\n    print(fix_typos(word))\nelse:\n    print(word)"}
{"solution": "def min_time_to_prepare_potions(n, m, k, x, s, a, b, c, d):\n    # Initialize the minimum time to prepare potions without any spells\n    min_time = n * x\n    \n    # Check all combinations of spells of the first type and the second type\n    for i in range(m):\n        if b[i] <= s:  # Check if we can afford the first type spell\n            potion_time = a[i]\n            remaining_potions = n\n            \n            # Calculate the maximum number of potions we can create with the second type spells\n            for j in range(k):\n                if d[j] + b[i] <= s:  # Check if we can afford the second type spell\n                    remaining_potions -= c[j]\n                    if remaining_potions <= 0:\n                        min_time = min(min_time, 0)  # All potions are prepared\n                        break\n                    # Calculate the time needed for the remaining potions\n                    time_needed = remaining_potions * potion_time\n                    min_time = min(min_time, time_needed)\n                else:\n                    break  # No need to check further as spells are sorted by cost\n\n    # Check only the second type spells without the first type spell\n    for j in range(k):\n        if d[j] <= s:  # Check if we can afford the second type spell\n            remaining_potions = n - c[j]\n            if remaining_potions <= 0:\n                min_time = min(min_time, 0)  # All potions are prepared\n                continue\n            # Calculate the time needed for the remaining potions\n            time_needed = remaining_potions * x\n            min_time = min(min_time, time_needed)\n\n    return min_time\n\n# Input reading\nn, m, k = map(int, input().split())\nx, s = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\nd = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = min_time_to_prepare_potions(n, m, k, x, s, a, b, c, d)\nprint(result)"}
{"solution": "def max_points(n, k, M, t):\n    total_points = 0\n    \n    # Calculate the total time to complete all subtasks of a task\n    total_time_per_task = sum(t)\n    \n    # Try to complete as many tasks as possible\n    for completed_tasks in range(n + 1):\n        time_spent = completed_tasks * total_time_per_task\n        if time_spent > M:\n            break\n        \n        points = completed_tasks * (k + 1)  # Points for completed tasks\n        \n        remaining_time = M - time_spent\n        \n        # Calculate how many additional subtasks can be solved with the remaining time\n        additional_points = 0\n        for j in range(k):\n            if remaining_time <= 0:\n                break\n            max_subtasks = remaining_time // t[j]\n            if max_subtasks > n - completed_tasks:\n                max_subtasks = n - completed_tasks\n            additional_points += max_subtasks\n            remaining_time -= max_subtasks * t[j]\n        \n        total_points = max(total_points, points + additional_points)\n    \n    return total_points\n\n# Input reading\nn, k, M = map(int, input().split())\nt = list(map(int, input().split()))\n\n# Output the result\nprint(max_points(n, k, M, t))"}
{"solution": "def mod_inv(a, p):\n    return pow(a, p - 2, p)\n\ndef count_perfectly_balanced_striped_bst(n):\n    MOD = 998244353\n    \n    if n % 2 == 1:\n        return 0\n    \n    half_n = n // 2\n    \n    # Precompute factorials and inverse factorials\n    fact = [1] * (n + 1)\n    for i in range(2, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    \n    inv_fact = [1] * (n + 1)\n    inv_fact[n] = mod_inv(fact[n], MOD)\n    for i in range(n - 1, 0, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n    \n    # Calculate the number of perfectly balanced striped BSTs\n    result = (fact[n] * inv_fact[half_n] % MOD * inv_fact[half_n] % MOD) * mod_inv(half_n + 1, MOD) % MOD\n    return result\n\nn = int(input())\nprint(count_perfectly_balanced_striped_bst(n))"}
{"solution": "def lara_position(n, m, k):\n    if k < m:\n        return (1, k + 1)\n    \n    k -= m\n    full_snake_moves = k // (m - 1)\n    position_in_snake = k % (m - 1)\n\n    row = 2 + full_snake_moves * 2\n    if full_snake_moves % 2 == 0:\n        col = position_in_snake + 1\n    else:\n        col = m - position_in_snake\n\n    return (row, col)\n\nn, m, k = map(int, input().split())\nresult = lara_position(n, m, k)\nprint(result[0], result[1])"}
{"solution": "import math\n\ndef find_min_max_lcm_pair(X):\n    min_max_value = float('inf')\n    best_a, best_b = 1, X\n    \n    for a in range(1, int(math.sqrt(X)) + 1):\n        if X % a == 0:\n            b = X // a\n            max_ab = max(a, b)\n            if max_ab < min_max_value:\n                min_max_value = max_ab\n                best_a, best_b = a, b\n                \n    return best_a, best_b\n\nX = int(input().strip())\na, b = find_min_max_lcm_pair(X)\nprint(a, b)"}
{"solution": "a = int(input())\nb = int(input())\nc = int(input())\n\n# Calculate the maximum number of complete sets of fruits we can use\nmax_sets = min(a, b // 2, c // 4)\n\n# Calculate the total number of fruits used\ntotal_fruits = max_sets * (1 + 2 + 4)\n\nprint(total_fruits)"}
{"solution": "def can_divide_teams(n, ratings):\n    ratings.sort()\n    team1 = ratings[:n]\n    team2 = ratings[n:]\n\n    for i in range(n):\n        if team1[i] >= team2[i]:\n            return \"NO\"\n    return \"YES\"\n\nn = int(input())\nratings = list(map(int, input().split()))\nprint(can_divide_teams(n, ratings))"}
{"solution": "from math import gcd\nfrom sys import stdin, stdout\n\ndef make_coprime_array(n, a):\n    result = []\n    count = 0\n    \n    result.append(a[0])\n    \n    for i in range(1, n):\n        if gcd(result[-1], a[i]) != 1:\n            count += 1\n            # Insert a number that is co-prime with both adjacent numbers\n            # We can use 1, as it is co-prime with any number\n            result.append(1)\n        \n        result.append(a[i])\n    \n    return count, result\n\ndef main():\n    input = stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:n+1]))\n    \n    k, new_array = make_coprime_array(n, a)\n    \n    stdout.write(f\"{k}\\n\")\n    stdout.write(\" \".join(map(str, new_array)) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def max_divisor_after_operations(N, K, A):\n    total_sum = sum(A)\n    min_A = min(A)\n    \n    # The maximum possible divisor we can achieve is limited by the total sum and the minimum element\n    max_possible_divisor = (total_sum + K) // N\n    \n    # We need to find the maximum divisor that is less than or equal to min_A + K\n    # because we can only increase the minimum element by K at most\n    max_divisor = min(min_A + K, max_possible_divisor)\n    \n    # We will check for the largest divisor from max_divisor down to 1\n    for d in range(max_divisor, 0, -1):\n        # Check if d can divide all elements after performing operations\n        needed_operations = 0\n        for a in A:\n            if a % d != 0:\n                # Calculate how much we need to add to make a multiple of d\n                remainder = a % d\n                needed_operations += (d - remainder)  # We need this much to make it a multiple of d\n        \n        # If the total needed operations is less than or equal to K, we can achieve this divisor\n        if needed_operations <= K:\n            return d\n    \n    return 1  # If no other divisor is found, return 1\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nK = int(data[1])\nA = list(map(int, data[2:]))\n\nresult = max_divisor_after_operations(N, K, A)\nprint(result)"}
{"solution": "def perfect_longcat_transform(x):\n    # Check if x is already a perfect longcat\n    if (x & (x + 1)) == 0:\n        print(0)\n        return\n\n    operations = []\n    \n    # Function to find the highest set bit position\n    def highest_set_bit(n):\n        return n.bit_length() - 1\n\n    # Perform operations\n    while len(operations) < 40:\n        # Find the highest set bit\n        n = highest_set_bit(x)\n        operations.append(n)\n        # Perform Operation A: x = x XOR (2^n - 1)\n        x ^= (1 << n) - 1\n        \n        # Check if we reached a perfect longcat\n        if (x & (x + 1)) == 0:\n            break\n        \n        # Perform Operation B: x = x + 1\n        x += 1\n\n    # Output the results\n    print(len(operations))\n    if operations:\n        print(\" \".join(map(str, operations)))\n\n# Read input\nx = int(input().strip())\nperfect_longcat_transform(x)"}
{"solution": "def min_hours_to_water_garden(n, k, a):\n    min_hours = float('inf')\n    \n    for length in a:\n        if k % length == 0:\n            hours = k // length\n            min_hours = min(min_hours, hours)\n    \n    return min_hours\n\n# Input reading\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(min_hours_to_water_garden(n, k, a))"}
{"solution": "n, k = map(int, input().split())\nline = input().strip()\n\ng_index = line.index('G')\nt_index = line.index('T')\n\nif g_index < t_index:\n    step = k\nelse:\n    step = -k\n\nfor i in range(g_index, t_index + step, step):\n    if line[i] == '#':\n        print(\"NO\")\n        break\nelse:\n    print(\"YES\")"}
{"solution": "def find_aim_point(y1, y2, yw, xb, yb, r):\n    # Calculate the effective y-coordinates for the ball's center\n    yb_eff = yb + r\n    yb_eff_goal = yb - r\n\n    # Check if the ball can bounce off the wall and go into the goal\n    if yb_eff >= yw or yb_eff_goal <= y1 or yb_eff_goal >= y2:\n        return -1\n\n    # Calculate the potential y-coordinate of the ball after bouncing\n    # The line from (xb, yb) to (xw, yw) must intersect the goal area\n    # The slope of the line from the ball to the wall\n    slope = (yw - yb) / (xb - 0)\n\n    # The y-coordinate of the ball after bouncing off the wall\n    # y = slope * (xw - xb) + yb\n    # We need to find xw such that the ball goes into the goal area\n    # The goal area is between y1 and y2\n\n    # Calculate the x-coordinate of the wall that would allow the ball to go into the goal\n    # We need to find xw such that:\n    # y1 <= slope * (xw - xb) + yb <= y2\n\n    # Rearranging gives us:\n    # (y1 - yb) * (xb) / slope + xb <= xw <= (y2 - yb) * (xb) / slope + xb\n\n    # Calculate the xw for the lower and upper bounds\n    xw_lower = (y1 - yb) * (xb) / slope + xb\n    xw_upper = (y2 - yb) * (xb) / slope + xb\n\n    # The wall must be to the right of the ball\n    if xw_lower <= 0:\n        xw_lower = 0\n\n    # Check if there is a valid xw\n    if xw_lower < xw_upper:\n        return xw_lower\n    else:\n        return -1\n\n# Read input\ny1, y2, yw, xb, yb, r = map(int, input().split())\n\n# Get the result\nresult = find_aim_point(y1, y2, yw, xb, yb, r)\n\n# Print the result\nif result == -1:\n    print(result)\nelse:\n    print(f\"{result:.10f}\")"}
{"solution": "b, d, s = map(int, input().split())\n\n# Calculate the maximum number of complete days based on the meals\nmax_days = max(b, d, s)\n\n# Calculate the total meals that should have been consumed in those days\ntotal_meals = max_days * 3\n\n# Calculate the total meals that Vasiliy had\ntotal_had = b + d + s\n\n# The minimum missed meals would be the difference\nmissed_meals = total_meals - total_had\n\nprint(missed_meals)"}
{"solution": "def find_matrix_dimensions(n, path):\n    # Create a dictionary to store the positions of each number\n    position = {}\n    \n    for idx in range(n):\n        position[path[idx]] = idx\n    \n    # Determine the minimum and maximum row and column indices\n    min_row = float('inf')\n    max_row = float('-inf')\n    min_col = float('inf')\n    max_col = float('-inf')\n    \n    for num in path:\n        # Calculate the row and column based on the formula\n        row = (num - 1) // max_col + 1\n        col = (num - 1) % max_col + 1\n        \n        min_row = min(min_row, row)\n        max_row = max(max_row, row)\n        min_col = min(min_col, col)\n        max_col = max(max_col, col)\n    \n    # Calculate the dimensions of the matrix\n    x = max_row\n    y = max_col\n    \n    # Check if the path is valid\n    for i in range(1, n):\n        num1 = path[i - 1]\n        num2 = path[i]\n        \n        row1 = (num1 - 1) // y + 1\n        col1 = (num1 - 1) % y + 1\n        row2 = (num2 - 1) // y + 1\n        col2 = (num2 - 1) % y + 1\n        \n        if not ((abs(row1 - row2) == 1 and col1 == col2) or (abs(col1 - col2) == 1 and row1 == row2)):\n            return \"NO\"\n    \n    return \"YES\", x, y\n\nn = int(input())\npath = list(map(int, input().split()))\n\nresult = find_matrix_dimensions(n, path)\n\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    print(result[1], result[2])"}
{"solution": "def longest_subsequence(a, b):\n    n, m = len(a), len(b)\n    \n    # Create a table to store the longest subsequence lengths\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    \n    # Fill the dp table\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if a[i - 1] == b[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])\n    \n    # Find the length of the longest subsequence\n    length = dp[n][m]\n    \n    # If there's no common subsequence\n    if length == 0:\n        return \"-\"\n    \n    # Reconstruct the longest subsequence\n    subsequence = []\n    i, j = n, m\n    while i > 0 and j > 0:\n        if a[i - 1] == b[j - 1]:\n            subsequence.append(a[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i][j - 1] >= dp[i - 1][j]:\n            j -= 1\n        else:\n            i -= 1\n    \n    # The subsequence is constructed in reverse order\n    subsequence.reverse()\n    \n    return ''.join(subsequence)\n\n# Input reading\na = input().strip()\nb = input().strip()\n\n# Output the result\nprint(longest_subsequence(a, b))"}
{"solution": "n = int(input())\ns = input().strip()\n\nplus_count = s.count('+')\nminus_count = s.count('-')\n\n# The minimum number of stones needed to ensure no negative operations\nmin_stones_needed = max(0, minus_count)\n\n# The final number of stones after all operations\nfinal_stones = min_stones_needed + plus_count\n\nprint(final_stones)"}
{"solution": "def max_kefir_liters(n, a, b, c):\n    # Calculate the maximum liters of kefir Kolya can drink\n    max_liters = 0\n    \n    # Option 1: Buy only plastic bottles\n    max_liters = n // a\n    \n    # Option 2: Buy glass bottles and return them\n    if b <= n:\n        # Calculate how many glass bottles can be bought\n        glass_bottles = n // b\n        remaining_money = n % b\n        \n        # Each glass bottle gives back c rubles\n        # Total money after buying glass bottles and returning them\n        total_money_after_glass = remaining_money + glass_bottles * c\n        \n        # Calculate how many additional plastic bottles can be bought with the remaining money\n        additional_plastic = total_money_after_glass // a\n        \n        # Total liters from glass and additional plastic\n        max_liters = max(max_liters, glass_bottles + additional_plastic)\n    \n    return max_liters\n\n# Input reading\nn = int(input().strip())\na = int(input().strip())\nb = int(input().strip())\nc = int(input().strip())\n\n# Output the result\nprint(max_kefir_liters(n, a, b, c))"}
{"solution": "from collections import deque\n\ndef card_war(n, soldier1_cards, soldier2_cards):\n    soldier1 = deque(soldier1_cards)\n    soldier2 = deque(soldier2_cards)\n    seen_states = set()\n    fights = 0\n\n    while soldier1 and soldier2:\n        fights += 1\n        state = (tuple(soldier1), tuple(soldier2))\n        \n        if state in seen_states:\n            return -1\n        seen_states.add(state)\n\n        card1 = soldier1.popleft()\n        card2 = soldier2.popleft()\n\n        if card1 > card2:\n            soldier1.append(card2)\n            soldier1.append(card1)\n        else:\n            soldier2.append(card1)\n            soldier2.append(card2)\n\n    winner = 1 if soldier1 else 2\n    return fights, winner\n\n# Input reading\nn = int(input().strip())\nk1_data = list(map(int, input().strip().split()))\nk1 = k1_data[0]\nsoldier1_cards = k1_data[1:]\n\nk2_data = list(map(int, input().strip().split()))\nk2 = k2_data[0]\nsoldier2_cards = k2_data[1:]\n\n# Function call and output\nresult = card_war(n, soldier1_cards, soldier2_cards)\nprint(result if result == -1 else f\"{result[0]} {result[1]}\")"}
{"solution": "def check_password_complexity(password):\n    if len(password) < 5:\n        return \"Too weak\"\n    \n    has_upper = any(c.isupper() for c in password)\n    has_lower = any(c.islower() for c in password)\n    has_digit = any(c.isdigit() for c in password)\n    \n    if has_upper and has_lower and has_digit:\n        return \"Correct\"\n    else:\n        return \"Too weak\"\n\npassword = input().strip()\nprint(check_password_complexity(password))"}
{"solution": "def min_exchanges(n, group_a, group_b):\n    count_a = [0] * 6\n    count_b = [0] * 6\n\n    for score in group_a:\n        count_a[score] += 1\n    for score in group_b:\n        count_b[score] += 1\n\n    excess_a = [0] * 6\n    excess_b = [0] * 6\n    total_excess = 0\n\n    for i in range(1, 6):\n        if count_a[i] > count_b[i]:\n            excess_a[i] = (count_a[i] - count_b[i]) // 2\n            total_excess += excess_a[i]\n        elif count_b[i] > count_a[i]:\n            excess_b[i] = (count_b[i] - count_a[i]) // 2\n            total_excess += excess_b[i]\n\n    total_needed = sum(excess_a) + sum(excess_b)\n\n    if total_needed % 2 != 0:\n        return -1\n\n    return total_needed // 2\n\n# Input reading\nn = int(input())\ngroup_a = list(map(int, input().split()))\ngroup_b = list(map(int, input().split()))\n\n# Output the result\nprint(min_exchanges(n, group_a, group_b))"}
{"solution": "def can_reach_all_junctions(n, m, horizontal, vertical):\n    # Create a grid to represent the junctions\n    grid = [[False] * m for _ in range(n)]\n    \n    # Mark reachable junctions based on horizontal street directions\n    for i in range(n):\n        if horizontal[i] == '>':\n            for j in range(m):\n                grid[i][j] = True\n        elif horizontal[i] == '<':\n            for j in range(m-1, -1, -1):\n                grid[i][j] = True\n\n    # Mark reachable junctions based on vertical street directions\n    for j in range(m):\n        if vertical[j] == 'v':\n            for i in range(n):\n                grid[i][j] = True\n        elif vertical[j] == '^':\n            for i in range(n-1, -1, -1):\n                grid[i][j] = True\n\n    # Check if all junctions are reachable\n    for i in range(n):\n        for j in range(m):\n            if not grid[i][j]:\n                return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, m = map(int, input().split())\nhorizontal = input().strip()\nvertical = input().strip()\n\n# Get the result and print it\nresult = can_reach_all_junctions(n, m, horizontal, vertical)\nprint(result)"}
{"solution": "def can_place_brackets(n, a):\n    if n == 1:\n        if a[0] == 0:\n            return \"YES\\n0\"\n        else:\n            return \"NO\"\n    \n    if a.count(1) == n:\n        return \"NO\"\n    \n    # We can create a false expression by using the first 0 and the last 1\n    # Example: 0 -> (1 -> (1 -> ...))\n    # We can also use the first 1 and the last 0\n    # Example: (1 -> (1 -> ...)) -> 0\n    \n    # Find the first 0 and the last 1\n    first_zero = a.index(0)\n    last_one = n - 1 - a[::-1].index(1)\n    \n    if first_zero < last_one:\n        # We can use the first 0 and the last 1\n        expression = \"(\" + \"->\".join(map(str, a[:last_one + 1])) + \")\"\n        expression += \"->\" + str(a[last_one + 1])\n        return f\"YES\\n{expression}\"\n    else:\n        # We can use the first 1 and the last 0\n        expression = \"(\" + \"->\".join(map(str, a[:first_zero])) + \")\"\n        expression += \"->\" + str(a[first_zero])\n        return f\"YES\\n{expression}\"\n\nn = int(input().strip())\na = list(map(int, input().strip().split()))\nresult = can_place_brackets(n, a)\nprint(result)"}
{"solution": "def process_values(n, m):\n    a, b = n, m\n    while a > 0 and b > 0:\n        if a >= 2 * b:\n            a %= 2 * b\n        elif b >= 2 * a:\n            b %= 2 * a\n        else:\n            break\n    return a, b\n\nn, m = map(int, input().split())\nresult = process_values(n, m)\nprint(result[0], result[1])"}
{"solution": "k, a, b = map(int, input().split())\n\ndef count_k_divisible(k, a, b):\n    if a % k == 0:\n        start = a // k\n    else:\n        start = (a // k) + 1\n    \n    end = b // k\n    \n    return end - start + 1\n\nresult = count_k_divisible(k, a, b)\nprint(result)"}
{"solution": "k = int(input())\n\n# Initialize variables\nlength = 1  # Current length of numbers (1 for 1-9, 2 for 10-99, etc.)\ncount = 9   # Count of numbers with the current length\nstart = 1   # Starting number with the current length\n\n# Find the range where the k-th digit lies\nwhile k > length * count:\n    k -= length * count\n    length += 1\n    count *= 10\n    start *= 10\n\n# Find the actual number that contains the k-th digit\nstart += (k - 1) // length\nnumber = str(start)\n\n# Find the specific digit\ndigit_index = (k - 1) % length\nprint(number[digit_index])"}
{"solution": "def can_vasya_win(n, s):\n    # Count the number of '8's in the string\n    count_eights = s.count('8')\n    \n    # Vasya needs to ensure that there are enough '8's left after both players play\n    # After Vasya's first move, there will be (n - 1) characters left\n    # To form a valid telephone number, we need at least 11 characters, and the first must be '8'\n    # Therefore, we need at least 11 characters remaining after both players have played\n    # Since n is odd, after both players play, there will be (n - 1) // 2 moves for each player\n    # Thus, Vasya can guarantee a win if there are at least 11 '8's in the remaining characters\n    # after accounting for the moves.\n    \n    # The maximum number of moves each player can make\n    moves = (n - 11) // 2\n    \n    # Vasya can win if there are at least 11 characters left and at least 1 '8' in those characters\n    if count_eights > moves:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(can_vasya_win(n, s))"}
{"solution": "def factorial_mod(n, mod):\n    fact = [1] * (n + 1)\n    for i in range(2, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n    return fact\n\ndef count_valid_permutations(n, x, pos):\n    mod = 10**9 + 7\n    fact = factorial_mod(n, mod)\n\n    # Count numbers less than x and greater than x\n    less_count = x - 1\n    greater_count = n - x\n\n    # Determine the number of valid permutations\n    valid_permutations = 0\n\n    # Check how many numbers can be placed to the left of `pos`\n    for left in range(max(0, pos - greater_count), min(less_count, pos) + 1):\n        right = pos - left\n        if right < 0 or right > greater_count:\n            continue\n        \n        # Calculate the number of ways to arrange the remaining numbers\n        remaining = n - 1 - (left + right)\n        ways = (fact[less_count] * fact[greater_count]) % mod\n        ways = (ways * fact[remaining]) % mod\n        \n        valid_permutations = (valid_permutations + ways) % mod\n\n    return valid_permutations\n\n# Read input\nn, x, pos = map(int, input().split())\n# Calculate and print the result\nprint(count_valid_permutations(n, x, pos))"}
{"solution": "def decode_message(encoded_string, k):\n    result = []\n    i = 0\n    n = len(encoded_string)\n\n    while i < n:\n        char = encoded_string[i]\n        result.append(char)\n        \n        if i + 1 < n:\n            if encoded_string[i + 1] == '?':\n                # Candy cane: can remove or keep the last character\n                result.append(char)  # Keep the character\n            elif encoded_string[i + 1] == '*':\n                # Snowflake: can remove, keep, or repeat the last character\n                result.append(char)  # Keep the character\n                result.append(char)  # Repeat the character\n            i += 1  # Move past the special character\n        i += 1  # Move to the next character\n\n    # Now we have a list of characters that can be used to form the message\n    # We need to check if we can form a message of length k\n    if len(result) < k:\n        print(\"Impossible\")\n        return\n\n    # We can form a message of length k\n    message = []\n    count = 0\n\n    for char in result:\n        if count < k:\n            message.append(char)\n            count += 1\n        if count == k:\n            break\n\n    # If we have exactly k characters, we can print the message\n    if len(message) == k:\n        print(''.join(message))\n    else:\n        print(\"Impossible\")\n\n# Read input\nencoded_string = input().strip()\nk = int(input().strip())\n\n# Call the function\ndecode_message(encoded_string, k)"}
{"solution": "def min_rotations(x):\n    # Normalize the angle to be within [0, 360)\n    x = x % 360\n    if x < 0:\n        x += 360\n    \n    # Calculate the minimum deviation for 0, 90, 180, and 270 degrees\n    deviations = [(x - angle) % 360 for angle in [0, 90, 180, 270]]\n    \n    # Find the minimum deviation and its corresponding number of 90-degree turns\n    min_deviation = min(deviations)\n    min_turns = deviations.index(min_deviation)\n    \n    return min_turns\n\n# Read input\nx = int(input().strip())\n# Output the result\nprint(min_rotations(x))"}
{"solution": "def can_obtain_spheres(a, b, c, x, y, z):\n    # Calculate the surplus spheres\n    surplus_blue = a - x\n    surplus_violet = b - y\n    surplus_orange = c - z\n    \n    # If any required spheres are more than available, return \"No\"\n    if surplus_blue < 0 or surplus_violet < 0 or surplus_orange < 0:\n        return \"No\"\n    \n    # Calculate total surplus spheres\n    total_surplus = surplus_blue + surplus_violet + surplus_orange\n    \n    # Calculate total needed transformations\n    needed_transformations = (x - a) + (y - b) + (z - c)\n    \n    # Each transformation requires 2 surplus spheres\n    if total_surplus // 2 >= needed_transformations:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read input\na, b, c = map(int, input().split())\nx, y, z = map(int, input().split())\n\n# Get the result and print it\nresult = can_obtain_spheres(a, b, c, x, y, z)\nprint(result)"}
{"solution": "def count_valid_numbers(n, k, m):\n    # Count how many integers y > 0 exist such that y % k == 0\n    count_y = 0\n    for i in range(1, 10 * k):  # Check multiples of k\n        if i % k == 0:\n            count_y += 1\n\n    # Total numbers with n digits\n    total_numbers = 9 * (10 ** (n - 1))\n\n    # Calculate the result\n    result = (total_numbers * count_y) % m\n    return result\n\n# Read input\nn, k, m = map(int, input().split())\n# Get the result\nresult = count_valid_numbers(n, k, m)\n# Print the result\nprint(result)"}
{"solution": "l, r, a = map(int, input().split())\n\n# Balance the left and right players using ambidexters\nif l > r:\n    l, r = r, l  # Ensure l is always the smaller or equal to r\n\n# Use ambidexters to balance the teams\nneeded = (r - l) // 2\nif a <= needed:\n    l += a\n    a = 0\nelse:\n    l += needed\n    a -= needed\n\n# Now l and r are balanced, use remaining ambidexters\nl += a // 2\nr += a // 2\n\n# The total team size is twice the number of players on one side\nprint((l + r) * 2)"}
{"solution": "def min_moves(n, k):\n    # Calculate the total moves required\n    total_moves = 0\n    \n    # Moves to throw stones from each manhole\n    total_moves += (n - 1) * 2  # Each manhole needs to throw its stone to another\n    \n    # Moves to open each manhole\n    total_moves += n  # Opening each manhole\n    \n    # Moves to go to each manhole\n    # We need to go to the leftmost and rightmost manholes\n    if k == 1:\n        total_moves += (n - 1)  # Only go to the right\n    elif k == n:\n        total_moves += (n - 1)  # Only go to the left\n    else:\n        total_moves += (k - 1) + (n - k)  # Go to the leftmost and then to the rightmost\n    \n    return total_moves\n\n# Read input\nn, k = map(int, input().split())\n# Print the result\nprint(min_moves(n, k))"}
{"solution": "def minimum_tower_height(n, m):\n    max_height_two_blocks = n * (n + 1)  # Sum of first n natural numbers multiplied by 2\n    max_height_three_blocks = m * (m + 1) * 3 // 2  # Sum of first m natural numbers multiplied by 3\n\n    return max(max_height_two_blocks, max_height_three_blocks)\n\nn, m = map(int, input().split())\nprint(minimum_tower_height(n, m))"}
{"solution": "n = int(input())\ncards = [int(input()) for _ in range(n)]\n\nfrom collections import Counter\n\ncount = Counter(cards)\n\nif len(count) < 2:\n    print(\"NO\")\nelse:\n    items = list(count.items())\n    if len(items) == 2 and items[0][1] == items[1][1]:\n        print(\"YES\")\n        print(items[0][0], items[1][0])\n    else:\n        for i in range(len(items)):\n            for j in range(i + 1, len(items)):\n                if items[i][1] + items[j][1] == n and items[i][1] == items[j][1]:\n                    print(\"YES\")\n                    print(items[i][0], items[j][0])\n                    exit()\n        print(\"NO\")"}
{"solution": "def can_arrange_soldiers(n, k, groups):\n    # Sort groups in descending order\n    groups.sort(reverse=True)\n    \n    # Calculate the maximum number of soldiers that can be placed in the airplane\n    max_soldiers = n * 8\n    \n    # Check if the largest group can fit in the available seats\n    if groups[0] > (n * 4):\n        return \"NO\"\n    \n    # Check if the total number of soldiers can fit in the airplane\n    if sum(groups) > max_soldiers:\n        return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, k = map(int, input().split())\ngroups = list(map(int, input().split()))\n\n# Get the result and print it\nresult = can_arrange_soldiers(n, k, groups)\nprint(result)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nmin_cost = float('inf')\nbest_t = -1\n\nfor t in range(1, 101):\n    cost = 0\n    for length in a:\n        if length < t - 1:\n            cost += (t - 1) - length\n        elif length > t + 1:\n            cost += length - (t + 1)\n    if cost < min_cost:\n        min_cost = cost\n        best_t = t\n\nprint(best_t, min_cost)"}
{"solution": "n, m = map(int, input().split())\nsky_map = [input().strip() for _ in range(n)]\n\nmin_row = n\nmax_row = -1\nmin_col = m\nmax_col = -1\n\nfor i in range(n):\n    for j in range(m):\n        if sky_map[i][j] == '*':\n            if i < min_row:\n                min_row = i\n            if i > max_row:\n                max_row = i\n            if j < min_col:\n                min_col = j\n            if j > max_col:\n                max_col = j\n\nside_length = max(max_row - min_row + 1, max_col - min_col + 1)\nprint(side_length)"}
{"solution": "def gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef mod_inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef probability_of_sorted_array(n, k, a):\n    MOD = 10**9 + 7\n    count_0 = a.count(0)\n    count_1 = n - count_0\n\n    if count_0 == 0 or count_1 == 0:\n        return 1  # Already sorted\n\n    if k == 0:\n        return 0  # No operations, not sorted\n\n    total_pairs = n * (n - 1) // 2\n    if total_pairs == 0:\n        return 0  # No pairs to swap\n\n    # Calculate the number of ways to choose k pairs\n    total_ways = pow(total_pairs, k, MOD)\n\n    # Calculate the number of ways to end up with a sorted array\n    if count_0 > 0 and count_1 > 0:\n        sorted_ways = 1  # Only one way to be sorted: all 0s followed by all 1s\n    else:\n        sorted_ways = 0\n\n    if sorted_ways == 0:\n        return 0\n\n    # Reduce the fraction sorted_ways / total_ways\n    P = sorted_ways\n    Q = total_ways\n\n    common_divisor = gcd(P, Q)\n    P //= common_divisor\n    Q //= common_divisor\n\n    # Calculate the result\n    result = (P * mod_inverse(Q, MOD)) % MOD\n    return result\n\n# Input reading\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(probability_of_sorted_array(n, k, a))"}
{"solution": "def min_seconds_to_devolve_triangle(x, y):\n    # The number of seconds required is the difference between the starting and ending side lengths\n    return (x - y) * 2 - 3\n\n# Read input\nx, y = map(int, input().split())\n# Calculate and print the result\nprint(min_seconds_to_devolve_triangle(x, y))"}
{"solution": "def minimum_norm_degenerate_matrix(a, b, c, d):\n    # Calculate the determinant of matrix A\n    det_A = a * d - b * c\n    \n    # If the determinant is already zero, the matrix is degenerate\n    if det_A == 0:\n        return 0.0\n    \n    # Calculate the norm of matrix A\n    norm_A = max(abs(a), abs(b), abs(c), abs(d))\n    \n    # Calculate the minimum possible value of ||A - B||\n    min_norm = abs(det_A) / (2 * norm_A)\n    \n    return min_norm\n\n# Input reading\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Calculate and print the result\nresult = minimum_norm_degenerate_matrix(a, b, c, d)\nprint(f\"{result:.10f}\")"}
{"solution": "def restaurant_service(n, a, b, groups):\n    denied_service = 0\n\n    for group in groups:\n        if group == 1:  # Group of one person\n            if a > 0:\n                a -= 1  # Seat at one-seater table\n            elif b > 0:\n                b -= 1  # Seat at two-seater table\n            elif b > 0:  # Seat at two-seater table with one person already\n                b -= 1\n            else:\n                denied_service += 1  # Deny service\n        else:  # Group of two people\n            if b > 0:\n                b -= 1  # Seat at two-seater table\n            else:\n                denied_service += 2  # Deny service to both\n\n    return denied_service\n\n# Input reading\nn, a, b = map(int, input().split())\ngroups = list(map(int, input().split()))\n\n# Output the result\nprint(restaurant_service(n, a, b, groups))"}
{"solution": "def calculate_failed_students(A, B, C, N):\n    # Calculate the number of students who passed the exam\n    passed_students = (A - C) + (B - C) + C\n    \n    # Check if the number of passed students is valid\n    if passed_students > N or C < 0 or A < C or B < C:\n        return -1\n    \n    # Calculate the number of students who didn't pass the exam\n    failed_students = N - passed_students\n    \n    # Ensure at least one student (Vasya) didn't pass\n    if failed_students < 1:\n        return -1\n    \n    return failed_students\n\n# Read input\nA, B, C, N = map(int, input().split())\n# Calculate and print the result\nprint(calculate_failed_students(A, B, C, N))"}
{"solution": "def expected_dresses(x, k):\n    MOD = 10**9 + 7\n    \n    if k == 0:\n        return (x * 2) % MOD\n    \n    # Calculate 2^(k+1) % MOD\n    power_of_two = pow(2, k + 1, MOD)\n    \n    # Calculate the expected number of dresses\n    expected_value = (x * power_of_two - (power_of_two - 1) * (1 if x > 0 else 0) // 2) % MOD\n    \n    return expected_value\n\n# Read input\nx, k = map(int, input().split())\n# Print the result\nprint(expected_dresses(x, k))"}
{"solution": "def mod_inverse(a, p):\n    return pow(a, p - 2, p)\n\ndef calculate_probability(n, ranges):\n    total_ways = 1\n    valid_ways = 0\n\n    for l, r in ranges:\n        total_ways *= (r - l + 1)\n        total_ways %= MOD\n\n    # Count valid arrangements\n    from itertools import permutations\n\n    for perm in permutations(range(n)):\n        valid = True\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if ranges[perm[i]][1] < ranges[perm[j]][0]:\n                    continue\n                if ranges[perm[i]][0] > ranges[perm[j]][1]:\n                    continue\n                if ranges[perm[i]][1] < ranges[perm[j]][0]:\n                    continue\n                if ranges[perm[i]][0] > ranges[perm[j]][1]:\n                    continue\n                valid = False\n                break\n            if not valid:\n                break\n        if valid:\n            valid_ways += 1\n\n    # Calculate the probability\n    x = valid_ways\n    y = total_ways\n\n    # Reduce x/y to irreducible form\n    from math import gcd\n    g = gcd(x, y)\n    x //= g\n    y //= g\n\n    # Calculate result as x * y^(-1) mod MOD\n    result = (x * mod_inverse(y, MOD)) % MOD\n    return result\n\nMOD = 998244353\n\nn = int(input())\nranges = [tuple(map(int, input().split())) for _ in range(n)]\nprint(calculate_probability(n, ranges))"}
{"solution": "def count_ways(n):\n    if n < 8:\n        return 0\n    count = 0\n    for a in range(1, (n // 2) + 1):\n        b = (n - 2 * a) // 2\n        if b > 0 and a != b:\n            count += 1\n    return count\n\nn = int(input())\nprint(count_ways(n))"}
{"solution": "def fair_nut_kvass(n, s, volumes):\n    total_kvass = sum(volumes)\n    \n    if total_kvass < s:\n        return -1\n    \n    left, right = 0, min(volumes)\n    \n    while left < right:\n        mid = (left + right + 1) // 2\n        needed = sum(max(0, v - mid) for v in volumes)\n        \n        if needed >= s:\n            left = mid\n        else:\n            right = mid - 1\n            \n    return left\n\n# Input reading\nn, s = map(int, input().split())\nvolumes = list(map(int, input().split()))\n\n# Output the result\nprint(fair_nut_kvass(n, s, volumes))"}
{"solution": "h1, h2 = map(int, input().split())\na, b = map(int, input().split())\n\n# Calculate the effective height gain per day\nday_hours = 12\nnight_hours = 12\n\n# Initial height of the caterpillar\ncurrent_height = h1\n\n# Check if the caterpillar can reach the apple on the first day\nif current_height + a * (day_hours - 2) >= h2:\n    print(0)\n    exit()\n\n# Calculate the net gain per day\nnet_gain_per_day = a * day_hours - b * night_hours\n\n# If the caterpillar cannot make progress\nif net_gain_per_day <= 0:\n    print(-1)\n    exit()\n\n# Days counter\ndays = 0\n\n# Simulate the days until the caterpillar reaches the apple\nwhile current_height < h2:\n    days += 1\n    current_height += net_gain_per_day\n\n# After the last day, check if it reaches the apple during the day\nif current_height >= h2:\n    print(days)\nelse:\n    # Check if it can reach the apple on the next day\n    current_height -= b * night_hours  # Caterpillar slips down at night\n    if current_height >= h2:\n        print(days + 1)\n    else:\n        print(-1)"}
{"solution": "def max_joy_units(C, H_r, H_b, W_r, W_b):\n    max_joy = 0\n    \n    # Try all possible counts of red candies\n    for r in range(C // W_r + 1):\n        remaining_weight = C - r * W_r\n        b = remaining_weight // W_b\n        joy = r * H_r + b * H_b\n        max_joy = max(max_joy, joy)\n    \n    # Try all possible counts of blue candies\n    for b in range(C // W_b + 1):\n        remaining_weight = C - b * W_b\n        r = remaining_weight // W_r\n        joy = b * H_b + r * H_r\n        max_joy = max(max_joy, joy)\n    \n    return max_joy\n\n# Read input\nC, H_r, H_b, W_r, W_b = map(int, input().split())\n# Calculate and print the result\nprint(max_joy_units(C, H_r, H_b, W_r, W_b))"}
{"solution": "x1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\n\ndx = abs(x2 - x1)\ndy = abs(y2 - y1)\n\nprint(max(dx, dy))"}
{"solution": "def predict_vote_outcome(n, employees):\n    d_count = employees.count('D')\n    r_count = employees.count('R')\n    \n    # The outcome will be determined by the fraction with the majority\n    if d_count > r_count:\n        return 'D'\n    else:\n        return 'R'\n\n# Input reading\nn = int(input().strip())\nemployees = input().strip()\n\n# Output the result\nprint(predict_vote_outcome(n, employees))"}
{"solution": "def count_tv_sets(a, b, x, y):\n    # Calculate the greatest common divisor of x and y\n    from math import gcd\n    g = gcd(x, y)\n    x //= g\n    y //= g\n    \n    # Initialize the count of valid (w, h) pairs\n    count = 0\n    \n    # Find the maximum k such that (k * x <= a) and (k * y <= b)\n    k_max = min(a // x, b // y)\n    \n    # The number of valid pairs is k_max\n    count = k_max\n    \n    return count\n\n# Read input\na, b, x, y = map(int, input().split())\n\n# Get the result\nresult = count_tv_sets(a, b, x, y)\n\n# Print the result\nprint(result)"}
{"solution": "def prime_factors(b):\n    factors = {}\n    d = 2\n    while d * d <= b:\n        while (b % d) == 0:\n            if d in factors:\n                factors[d] += 1\n            else:\n                factors[d] = 1\n            b //= d\n        d += 1\n    if b > 1:\n        factors[b] = 1\n    return factors\n\ndef count_factors_in_factorial(n, p):\n    count = 0\n    power = p\n    while power <= n:\n        count += n // power\n        power *= p\n    return count\n\ndef trailing_zeros_in_base(n, b):\n    factors = prime_factors(b)\n    min_trailing_zeros = float('inf')\n    \n    for p, k in factors.items():\n        count = count_factors_in_factorial(n, p)\n        min_trailing_zeros = min(min_trailing_zeros, count // k)\n    \n    return min_trailing_zeros\n\nn, b = map(int, input().split())\nprint(trailing_zeros_in_base(n, b))"}
{"solution": "def gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n\ndef f(m, a, b):\n    if a == b:\n        return m // a + 1\n    g = gcd(a, b)\n    return (m // g) + 1\n\ndef sum_f(m, a, b):\n    total = 0\n    for i in range(m + 1):\n        total += f(i, a, b)\n    return total\n\nm, a, b = map(int, input().split())\nresult = sum_f(m, a, b)\nprint(result)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nif n % 2 == 1 and a[0] % 2 == 1 and a[-1] % 2 == 1:\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "x1, y1, x2, y2 = map(int, input().split())\n\nif x1 == x2:\n    # Same x-coordinate, vertical line\n    side_length = abs(y2 - y1)\n    x3, y3 = x1 + side_length, y1\n    x4, y4 = x2 + side_length, y2\nelif y1 == y2:\n    # Same y-coordinate, horizontal line\n    side_length = abs(x2 - x1)\n    x3, y3 = x1, y1 + side_length\n    x4, y4 = x2, y2 + side_length\nelif abs(x2 - x1) == abs(y2 - y1):\n    # Diagonal points of a square\n    x3, y3 = x1, y2\n    x4, y4 = x2, y1\nelse:\n    print(-1)\n    exit()\n\nprint(x3, y3, x4, y4)"}
{"solution": "def calculate_f_n(x, y, n):\n    MOD = 1000000007\n    \n    if n == 1:\n        return x % MOD\n    elif n == 2:\n        return y % MOD\n    else:\n        # The sequence is periodic with a period of 6\n        f_n = [x % MOD, y % MOD, (y - x) % MOD, (-x) % MOD, (-y) % MOD, (x - y) % MOD]\n        return f_n[(n - 1) % 6]\n\nx, y = map(int, input().split())\nn = int(input())\nprint(calculate_f_n(x, y, n))"}
{"solution": "n = int(input())\nA = list(map(int, input().split()))\n\ntotal_sum = sum(A)\n\nif total_sum != 0:\n    print(\"YES\")\n    print(1)\n    print(1, n)\nelse:\n    prefix_sum = 0\n    for i in range(n):\n        prefix_sum += A[i]\n        if prefix_sum != 0:\n            print(\"YES\")\n            print(2)\n            print(1, i + 1)\n            print(i + 2, n)\n            break\n    else:\n        print(\"NO\")"}
{"solution": "def minimum_score(n, m, k):\n    MOD = 1000000009\n    \n    if m == 0:\n        return 0\n    \n    # Calculate the number of full groups of k correct answers\n    full_groups = m // k\n    remaining_correct = m % k\n    \n    # Calculate the minimum score\n    score = (full_groups * (2 * k - 1) + remaining_correct) % MOD\n    \n    return score\n\n# Read input\nn, m, k = map(int, input().split())\n# Print the result\nprint(minimum_score(n, m, k))"}
{"solution": "n = input().strip()\n\n# Check single digit numbers\nfor digit in n:\n    if int(digit) % 8 == 0:\n        print(\"YES\")\n        print(digit)\n        exit()\n\n# Check two digit combinations\nfor i in range(len(n)):\n    for j in range(i + 1, len(n)):\n        if int(n[i] + n[j]) % 8 == 0:\n            print(\"YES\")\n            print(n[i] + n[j])\n            exit()\n\n# Check three digit combinations\nfor i in range(len(n)):\n    for j in range(i + 1, len(n)):\n        for k in range(j + 1, len(n)):\n            if int(n[i] + n[j] + n[k]) % 8 == 0:\n                print(\"YES\")\n                print(n[i] + n[j] + n[k])\n                exit()\n\nprint(\"NO\")"}
{"solution": "def find_floor(n, m, memories):\n    possible_floors = set()\n    \n    for k, f in memories:\n        # Calculate the number of flats per floor\n        flats_per_floor = (k - 1) // (f - 1) if f > 1 else k\n        if flats_per_floor > 0:\n            possible_floors.add(flats_per_floor)\n    \n    valid_floors = set()\n    \n    for flats_per_floor in possible_floors:\n        floor_of_n = (n - 1) // flats_per_floor + 1\n        if (n - 1) % flats_per_floor < flats_per_floor:\n            valid_floors.add(floor_of_n)\n    \n    if len(valid_floors) == 1:\n        return valid_floors.pop()\n    else:\n        return -1\n\n# Input reading\nn, m = map(int, input().split())\nmemories = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output the result\nprint(find_floor(n, m, memories))"}
{"solution": "def max_bishwocks(board1, board2):\n    n = len(board1)\n    count = 0\n    i = 0\n    \n    while i < n:\n        if board1[i] == '0' and board2[i] == '0':\n            if i + 1 < n and board1[i + 1] == '0':\n                count += 1\n                i += 2  # Place a bishwock in horizontal position\n            elif i + 1 < n and board2[i + 1] == '0':\n                count += 1\n                i += 2  # Place a bishwock in horizontal position\n            elif i + 1 < n and board1[i + 1] == '0' and board2[i + 1] == '0':\n                count += 1\n                i += 2  # Place a bishwock in vertical position\n            else:\n                count += 1\n                i += 1  # Place a single bishwock\n        else:\n            i += 1  # Move to the next column\n    \n    return count\n\n# Read input\nboard1 = input().strip()\nboard2 = input().strip()\n\n# Calculate and print the result\nprint(max_bishwocks(board1, board2))"}
{"solution": "def max_pretty_set(n, s):\n    max_count = 0\n    current_set = set()\n\n    for char in s:\n        if char.islower():\n            current_set.add(char)\n        else:\n            max_count = max(max_count, len(current_set))\n            current_set.clear()\n\n    max_count = max(max_count, len(current_set))\n    return max_count\n\nn = int(input().strip())\ns = input().strip()\nprint(max_pretty_set(n, s))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nB = sum(x for x in a if x > 0)\nC = sum(x for x in a if x < 0)\n\nmax_value = B - C\nprint(max_value)"}
{"solution": "def min_refuels(a, b, f, k):\n    distance_per_journey = 2 * a\n    total_distance = k * distance_per_journey\n    \n    if b < a:\n        return -1\n    \n    if b >= total_distance:\n        return 0\n    \n    # Calculate the distance to the gas station and back\n    distance_to_gas_station = f\n    distance_from_gas_station_to_a = a - f\n    \n    # Check if we can reach the gas station\n    if b < distance_to_gas_station:\n        return -1\n    \n    # Calculate the number of refuels needed\n    refuels = 0\n    remaining_distance = total_distance\n    \n    # While there is distance left to cover\n    while remaining_distance > 0:\n        # If we can reach the gas station on the current fuel\n        if remaining_distance >= distance_to_gas_station + distance_from_gas_station_to_a:\n            # We can reach the gas station and then go to a\n            remaining_distance -= distance_to_gas_station + distance_from_gas_station_to_a\n            refuels += 1\n        else:\n            # We cannot reach the gas station, check if we can reach the end of the journey\n            if remaining_distance > b:\n                return -1\n            else:\n                break\n    \n    # After reaching the gas station, we can continue to the next journey\n    while remaining_distance > 0:\n        if remaining_distance >= distance_per_journey:\n            remaining_distance -= distance_per_journey\n            refuels += 1\n        else:\n            break\n    \n    return refuels\n\n# Input reading\na, b, f, k = map(int, input().split())\nprint(min_refuels(a, b, f, k))"}
{"solution": "def split_string(n, p, q, s):\n    for i in range(n // p + 1):\n        remaining_length = n - i * p\n        if remaining_length >= 0 and remaining_length % q == 0:\n            k = i + remaining_length // q\n            print(k)\n            for _ in range(i):\n                print(s[:p])\n                s = s[p:]\n            for _ in range(remaining_length // q):\n                print(s[:q])\n                s = s[q:]\n            return\n    print(-1)\n\n# Read input\nn, p, q = map(int, input().split())\ns = input().strip()\n\nsplit_string(n, p, q, s)"}
{"solution": "def can_reach_finish(n, m, s, d, obstacles):\n    obstacles.sort()\n    obstacles = [0] + obstacles + [m]  # Add start and finish points\n    current_position = 0\n    commands = []\n    \n    for i in range(len(obstacles) - 1):\n        start = obstacles[i]\n        end = obstacles[i + 1]\n        \n        # Check if we can run to the next obstacle\n        if end - start > d + s:\n            return \"IMPOSSIBLE\"\n        \n        # Calculate the distance we can run\n        run_distance = min(end - start - d, s)\n        if run_distance > 0:\n            commands.append(f\"RUN {run_distance}\")\n            current_position += run_distance\n        \n        # Now we need to jump over the obstacle\n        jump_distance = end - current_position\n        if jump_distance > d:\n            return \"IMPOSSIBLE\"\n        \n        commands.append(f\"JUMP {jump_distance}\")\n        current_position = end  # We land on the next obstacle\n    \n    return \"\\n\".join(commands)\n\n# Input reading\nn, m, s, d = map(int, input().split())\nobstacles = list(map(int, input().split()))\n\n# Get the result\nresult = can_reach_finish(n, m, s, d, obstacles)\n\n# Print the result\nprint(result)"}
{"solution": "def count_pairs(s, x):\n    if (s < x) or ((s - x) % 2 != 0):\n        return 0\n    \n    a = (s - x) // 2\n    b = a + x\n    \n    if a <= 0 or b <= 0:\n        return 0\n    \n    # Count the number of set bits in a and b\n    count = 0\n    for i in range(64):\n        if (a & (1 << i)) == 0 and (b & (1 << i)) == 0:\n            count += 1\n            \n    return 1 << count\n\ns, x = map(int, input().split())\nprint(count_pairs(s, x))"}
{"solution": "def turn_skewers(n, k):\n    actions = []\n    for i in range(1, n + 1, k + 1):\n        actions.append(i)\n    return actions\n\nn, k = map(int, input().split())\nactions = turn_skewers(n, k)\nprint(len(actions))\nprint(' '.join(map(str, actions)))"}
{"solution": "def min_operations_to_square(n):\n    n_str = str(n)\n    max_square_root = int(n**0.5) + 1\n    squares = [str(i * i) for i in range(1, max_square_root + 1)]\n    \n    min_operations = float('inf')\n    \n    for square in squares:\n        square_len = len(square)\n        n_len = len(n_str)\n        \n        # Two pointers to check if square can be formed from n_str\n        i, j = 0, 0\n        while i < n_len and j < square_len:\n            if n_str[i] == square[j]:\n                j += 1\n            i += 1\n        \n        if j == square_len:  # Found a valid subsequence\n            operations = n_len - square_len\n            min_operations = min(min_operations, operations)\n    \n    return min_operations if min_operations != float('inf') else -1\n\nn = int(input().strip())\nprint(min_operations_to_square(n))"}
{"solution": "def count_permutations_with_max_f(n):\n    MOD = 1000000007\n    \n    # Calculate factorials and their modular inverses\n    fact = [1] * (n + 1)\n    for i in range(2, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    \n    # The maximum value of f(p) is the number of distinct prime factors of n\n    def count_distinct_prime_factors(x):\n        count = 0\n        for i in range(2, int(x**0.5) + 1):\n            if x % i == 0:\n                count += 1\n                while x % i == 0:\n                    x //= i\n        if x > 1:\n            count += 1\n        return count\n    \n    # The number of permutations with f(p) = f_max(n) is n! / (n - k)!\n    k = count_distinct_prime_factors(n)\n    result = fact[n] * pow(fact[n - k], MOD - 2, MOD) % MOD\n    \n    return result\n\nn = int(input().strip())\nprint(count_permutations_with_max_f(n))"}
{"solution": "def min_jump_ability(s):\n    vowels = set('AEIOUY')\n    positions = [i for i, char in enumerate(s) if char in vowels]\n    \n    if not positions:\n        return len(s) + 1  # If there are no vowels, jump ability is beyond the string length\n    \n    max_jump = 0\n    # Include the start (0) and the end (len(s)) in the positions\n    positions = [0] + positions + [len(s)]\n    \n    for i in range(1, len(positions)):\n        max_jump = max(max_jump, positions[i] - positions[i - 1])\n    \n    return max_jump\n\n# Read input\ninput_string = input().strip()\n# Get the result\nresult = min_jump_ability(input_string)\n# Print the result\nprint(result)"}
{"solution": "def can_distribute_candies(a):\n    total = sum(a)\n    if total % 2 != 0:\n        return \"NO\"\n    \n    target = total // 2\n    n = len(a)\n    \n    # Check all combinations of bags\n    for i in range(1 << n):\n        current_sum = 0\n        for j in range(n):\n            if i & (1 << j):\n                current_sum += a[j]\n        if current_sum == target:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\na = list(map(int, input().split()))\nprint(can_distribute_candies(a))"}
{"solution": "def optimal_pie_distribution(n, slices):\n    alice_sum = 0\n    bob_sum = 0\n    turn = 0  # 0 for Bob's turn, 1 for Alice's turn\n\n    for size in slices:\n        if turn == 0:  # Bob's turn\n            bob_sum += size\n            turn = 1  # Pass the decider token to Alice\n        else:  # Alice's turn\n            alice_sum += size\n            turn = 0  # Pass the decider token to Bob\n\n    return alice_sum, bob_sum\n\n# Read input\nn = int(input())\nslices = list(map(int, input().split()))\n\n# Get the result\nalice, bob = optimal_pie_distribution(n, slices)\n\n# Print the output\nprint(alice, bob)"}
{"solution": "def min_variables(n, a):\n    a.sort()\n    max_a = a[-1]\n    \n    # Check if we can form the sequence\n    for i in range(n):\n        if a[i] > 2 * max_a:\n            return -1\n    \n    # We will use a greedy approach to find the minimum number of variables\n    m = 0\n    current_sums = {0}\n    \n    for value in a:\n        if value in current_sums:\n            continue\n        \n        # We need to find the minimum number of variables to represent 'value'\n        m += 1\n        new_sums = set()\n        \n        for s in current_sums:\n            new_sums.add(s + value)\n        \n        current_sums.update(new_sums)\n        current_sums.add(value)\n    \n    return m\n\n# Input reading\nn = int(input().strip())\na = list(map(int, input().strip().split()))\n\n# Output the result\nprint(min_variables(n, a))"}
{"solution": "def determine_winner(n, piles):\n    # Sort the piles in descending order\n    piles.sort(reverse=True)\n    \n    # Calculate the nim-sum (XOR of all piles)\n    nim_sum = 0\n    for pile in piles:\n        nim_sum ^= pile\n    \n    # If the nim-sum is 0, Bob wins; otherwise, Alice wins\n    return \"Bob\" if nim_sum == 0 else \"Alice\"\n\n# Read input\nn = int(input().strip())\npiles = list(map(int, input().strip().split()))\n\n# Determine and print the winner\nprint(determine_winner(n, piles))"}
{"solution": "def can_make_equal(n, a):\n    unique_values = set(a)\n    \n    if len(unique_values) > 3:\n        return \"NO\"\n    elif len(unique_values) == 3:\n        min_val = min(unique_values)\n        max_val = max(unique_values)\n        mid_val = sum(unique_values) - min_val - max_val\n        if mid_val * 2 != min_val + max_val:\n            return \"NO\"\n    return \"YES\"\n\nn = int(input())\na = list(map(int, input().split()))\nprint(can_make_equal(n, a))"}
{"solution": "def max_repeated_substring_length(N, S):\n    def check_length(length):\n        seen = set()\n        for i in range(N - length + 1):\n            substring = S[i:i + length]\n            if substring in seen:\n                return True\n            seen.add(substring)\n        return False\n\n    left, right = 1, N\n    result = 0\n\n    while left <= right:\n        mid = (left + right) // 2\n        if check_length(mid):\n            result = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return result\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nS = data[1]\n\nprint(max_repeated_substring_length(N, S))"}
{"solution": "def minimum_time_to_house(n, a):\n    if a % 2 == 1:  # a is odd\n        return (a // 2) + 1\n    else:  # a is even\n        return (n - a) // 2 + 1\n\nn, a = map(int, input().split())\nprint(minimum_time_to_house(n, a))"}
{"solution": "def can_select_jedi(n, m, colors, k):\n    from collections import Counter\n\n    # Create a target counter for the required counts of each color\n    target_count = Counter()\n    for color in range(1, m + 1):\n        target_count[color] = k[color - 1]\n\n    # Check all possible contiguous intervals\n    for start in range(n):\n        current_count = Counter()\n        for end in range(start, n):\n            current_count[colors[end]] += 1\n            \n            # Check if current_count matches target_count\n            if all(current_count[color] == target_count[color] for color in range(1, m + 1)):\n                return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\ncolors = list(map(int, input().split()))\nk = list(map(int, input().split()))\n\n# Get the result and print it\nresult = can_select_jedi(n, m, colors, k)\nprint(result)"}
{"solution": "n = int(input())\nmishka_wins = 0\nchris_wins = 0\n\nfor _ in range(n):\n    m, c = map(int, input().split())\n    if m > c:\n        mishka_wins += 1\n    elif c > m:\n        chris_wins += 1\n\nif mishka_wins > chris_wins:\n    print(\"Mishka\")\nelif chris_wins > mishka_wins:\n    print(\"Chris\")\nelse:\n    print(\"Friendship is magic!^^\")"}
{"solution": "def is_valid_minesweeper_field(n, m, field):\n    directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n    \n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                continue\n            \n            bomb_count = 0\n            for di, dj in directions:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < n and 0 <= nj < m and field[ni][nj] == '*':\n                    bomb_count += 1\n            \n            if field[i][j] == '.':\n                if bomb_count != 0:\n                    return \"NO\"\n            elif field[i][j].isdigit():\n                if bomb_count != int(field[i][j]):\n                    return \"NO\"\n    \n    return \"YES\"\n\nn, m = map(int, input().split())\nfield = [input().strip() for _ in range(n)]\nprint(is_valid_minesweeper_field(n, m, field))"}
{"solution": "def min_k_to_eat_half_candies(n):\n    left, right = 1, n\n    while left < right:\n        k = (left + right) // 2\n        candies = n\n        vasya_eaten = 0\n        \n        while candies > 0:\n            vasya_eaten += min(k, candies)\n            candies -= min(k, candies)\n            candies -= candies // 10\n        \n        if vasya_eaten * 2 >= n:\n            right = k\n        else:\n            left = k + 1\n            \n    return left\n\nn = int(input())\nprint(min_k_to_eat_half_candies(n))"}
{"solution": "s = input().strip()\n\n# Count the number of pearls and links\npearls = s.count('o')\nlinks = s.count('-')\n\n# If there are no pearls, the answer is YES\nif pearls == 0:\n    print(\"YES\")\n# If there is one pearl, the answer is YES\nelif pearls == 1:\n    print(\"YES\")\n# If there are multiple pearls, check if links can be evenly distributed\nelse:\n    if links % pearls == 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")"}
{"solution": "def max_pillows(n, m, k):\n    left_hobbits = k - 1\n    right_hobbits = n - k\n    low, high = 1, m\n\n    while low < high:\n        mid = (low + high + 1) // 2\n        total_pillows = mid + max(0, mid - 1) * left_hobbits + max(0, mid - 1) * right_hobbits\n        if total_pillows <= m:\n            low = mid\n        else:\n            high = mid - 1\n\n    return low\n\n# Read input\nn, m, k = map(int, input().split())\n# Print output\nprint(max_pillows(n, m, k))"}
{"solution": "import sys\nimport math\n\ndef max_subarray_cost(n, m, k, a):\n    max_cost = 0\n    current_sum = 0\n    for r in range(n):\n        current_sum += a[r]\n        length = r + 1\n        cost = current_sum - k * math.ceil(length / m)\n        max_cost = max(max_cost, cost)\n        \n        # Reset current_sum if it becomes negative\n        if current_sum < 0:\n            current_sum = 0\n            \n    return max_cost\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    m = int(data[1])\n    k = int(data[2])\n    a = list(map(int, data[3:]))\n    \n    result = max_subarray_cost(n, m, k, a)\n    print(result)"}
{"solution": "def longest_polyline(n, m):\n    # The four points that will create the longest polyline\n    points = [\n        (0, 0),    # Bottom-left corner\n        (n, 0),    # Bottom-right corner\n        (n, m),    # Top-right corner\n        (0, m)     # Top-left corner\n    ]\n    \n    return points\n\n# Read input\nn, m = map(int, input().split())\n\n# Get the points for the longest polyline\nresult_points = longest_polyline(n, m)\n\n# Print the result\nfor point in result_points:\n    print(point[0], point[1])"}
{"solution": "def find_smallest_n(received, remembered):\n    from collections import Counter\n\n    # Count the digits in the received string\n    count_received = Counter(received)\n    \n    # Count the digits in the remembered substring\n    count_remembered = Counter(remembered)\n    \n    # Remove the remembered digits from the received count\n    for digit in count_remembered:\n        count_received[digit] -= count_remembered[digit]\n    \n    # Create the remaining digits string\n    remaining_digits = []\n    for digit in sorted(count_received.keys()):\n        remaining_digits.append(digit * count_received[digit])\n    \n    remaining_digits = ''.join(remaining_digits)\n    \n    # We need to insert the remembered substring into the remaining digits\n    # We will try to find the smallest possible n\n    smallest_n = None\n    \n    # Try to insert the remembered substring at every possible position\n    for i in range(len(remaining_digits) + 1):\n        candidate = remaining_digits[:i] + remembered + remaining_digits[i:]\n        if candidate[0] != '0' or candidate == '0':  # Check for leading zeros\n            if smallest_n is None or candidate < smallest_n:\n                smallest_n = candidate\n    \n    # Calculate the length of the original number n\n    k = len(remembered)\n    smallest_n += str(k)\n    \n    return smallest_n\n\n# Input reading\nreceived = input().strip()\nremembered = input().strip()\n\n# Get the result and print it\nresult = find_smallest_n(received, remembered)\nprint(result)"}
{"solution": "n, m, min_temp, max_temp = map(int, input().split())\ntemperatures = list(map(int, input().split()))\n\ncurrent_min = min(temperatures)\ncurrent_max = max(temperatures)\n\nif current_min > min_temp or current_max < max_temp:\n    print(\"Incorrect\")\nelse:\n    needed_min = min_temp not in temperatures\n    needed_max = max_temp not in temperatures\n    if needed_min + needed_max <= n - m:\n        print(\"Correct\")\n    else:\n        print(\"Incorrect\")"}
{"solution": "def count_trailing_zeroes(n):\n    count = 0\n    while n > 0:\n        n //= 5\n        count += n\n    return count\n\ndef find_numbers_with_m_zeroes(m):\n    low, high = 0, 5 * (m + 1)\n    result = []\n\n    while low <= high:\n        mid = (low + high) // 2\n        zeroes = count_trailing_zeroes(mid)\n\n        if zeroes < m:\n            low = mid + 1\n        elif zeroes > m:\n            high = mid - 1\n        else:\n            result.append(mid)\n            # Check for other numbers with the same number of trailing zeroes\n            left = mid - 1\n            right = mid + 1\n            \n            while left >= 0 and count_trailing_zeroes(left) == m:\n                result.append(left)\n                left -= 1\n            \n            while count_trailing_zeroes(right) == m:\n                result.append(right)\n                right += 1\n            \n            break\n\n    result = sorted(result)\n    return result\n\nm = int(input().strip())\nnumbers = find_numbers_with_m_zeroes(m)\nprint(len(numbers))\nif numbers:\n    print(\" \".join(map(str, numbers)))"}
{"solution": "import sys\nimport heapq\nfrom collections import defaultdict\n\ndef dijkstra_max_cost(n, graph, start):\n    max_cost = [float('inf')] * (n + 1)\n    max_cost[start] = 0\n    pq = [(0, start)]  # (cost, vertex)\n    \n    while pq:\n        current_cost, u = heapq.heappop(pq)\n        \n        if current_cost > max_cost[u]:\n            continue\n        \n        for v, weight in graph[u]:\n            new_cost = max(current_cost, weight)\n            if new_cost < max_cost[v]:\n                max_cost[v] = new_cost\n                heapq.heappush(pq, (new_cost, v))\n    \n    return max_cost\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    m = int(data[index + 1])\n    k = int(data[index + 2])\n    index += 3\n    \n    special_vertices = list(map(int, data[index:index + k]))\n    index += k\n    \n    graph = defaultdict(list)\n    \n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        w = int(data[index + 2])\n        index += 3\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    \n    results = []\n    \n    for sv in special_vertices:\n        max_costs = dijkstra_max_cost(n, graph, sv)\n        max_distance = max(max_costs[v] for v in special_vertices)\n        results.append(max_distance)\n    \n    print(\" \".join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def initial_position(n, x):\n    # The position of the ball after n moves can be traced back\n    # by reversing the operations.\n    for i in range(n, 0, -1):\n        if i % 2 == 1:  # Odd move: swap 0 and 1\n            if x == 0:\n                x = 1\n            elif x == 1:\n                x = 0\n        else:  # Even move: swap 1 and 2\n            if x == 1:\n                x = 2\n            elif x == 2:\n                x = 1\n    return x\n\nn = int(input())\nx = int(input())\nprint(initial_position(n, x))"}
{"solution": "def rectangles_form_square(n, rectangles):\n    total_area = 0\n    min_x = min_y = float('inf')\n    max_x = max_y = float('-inf')\n\n    for x1, y1, x2, y2 in rectangles:\n        total_area += (x2 - x1) * (y2 - y1)\n        min_x = min(min_x, x1)\n        min_y = min(min_y, y1)\n        max_x = max(max_x, x2)\n        max_y = max(max_y, y2)\n\n    side_length = max_x - min_x\n    if side_length != (max_y - min_y):\n        return \"NO\"\n\n    if total_area == side_length * side_length:\n        return \"YES\"\n    else:\n        return \"NO\"\n\nn = int(input())\nrectangles = [tuple(map(int, input().split())) for _ in range(n)]\nprint(rectangles_form_square(n, rectangles))"}
{"solution": "def sum_of_digits(x):\n    return sum(int(d) for d in str(x))\n\ndef count_really_big_numbers(n, s):\n    count = 0\n    for x in range(s, n + 1):\n        if x - sum_of_digits(x) >= s:\n            count += 1\n    return count\n\nn, s = map(int, input().split())\nresult = count_really_big_numbers(n, s)\nprint(result)"}
{"solution": "def can_draw_two_lines(points):\n    def check_line(p1, p2, points):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p1[0] * p2[1] - p2[0] * p1[1]\n        return [(a * x + b * y - c) == 0 for x, y in points]\n\n    def check_with_fixed_line(p1, p2, points):\n        on_line = check_line(p1, p2, points)\n        remaining_points = [points[i] for i in range(len(points)) if not on_line[i]]\n        if not remaining_points:\n            return True\n        if len(remaining_points) == 1:\n            return True\n        return check_line(remaining_points[0], remaining_points[1], remaining_points)\n\n    if n <= 2:\n        return True\n\n    for i in range(1, 3):\n        if check_with_fixed_line(points[0], points[i], points):\n            return True\n\n    return False\n\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\nif can_draw_two_lines(points):\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def count_winning_games(a, b, k, t):\n    MOD = 10**9 + 7\n    \n    # Dynamic programming table\n    dp = [[0] * (2 * t * k + 1) for _ in range(t + 1)]\n    dp[0][0] = 1  # Base case: 1 way to have score difference of 0 at turn 0\n\n    for turn in range(1, t + 1):\n        for score_diff in range(-turn * k, turn * k + 1):\n            for delta in range(-k, k + 1):\n                if -turn * k <= score_diff - delta <= turn * k:\n                    dp[turn][score_diff] = (dp[turn][score_diff] + dp[turn - 1][score_diff - delta]) % MOD\n\n    total_games = pow(2 * k + 1, t, MOD)\n    winning_games = 0\n\n    for score_diff in range(1, 2 * t * k + 1):\n        winning_games = (winning_games + dp[t][score_diff]) % MOD\n\n    return winning_games\n\n# Input reading\na, b, k, t = map(int, input().split())\nresult = count_winning_games(a, b, k, t)\nprint(result)"}
{"solution": "def min_marks_to_add(n, l, x, y, marks):\n    marks_set = set(marks)\n    needed_marks = []\n\n    # Check if we can measure x\n    can_measure_x = any((mark + x) in marks_set for mark in marks)\n    if not can_measure_x:\n        needed_marks.append(x)\n\n    # Check if we can measure y\n    can_measure_y = any((mark + y) in marks_set for mark in marks)\n    if not can_measure_y:\n        needed_marks.append(y)\n\n    # Check if we can measure y - x\n    if (y - x) not in marks_set:\n        if x in marks_set and (x + (y - x)) <= l:\n            needed_marks.append(y - x)\n\n    # Output the result\n    print(len(needed_marks))\n    if needed_marks:\n        print(\" \".join(map(str, needed_marks)))\n\n# Input reading\nn, l, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\n\nmin_marks_to_add(n, l, x, y, marks)"}
{"solution": "import sys\nimport math\n\ndef calculate_volume(r, h):\n    return math.pi * r * r * h\n\ndef max_cake_volume(n, cakes):\n    # Calculate volumes and sort by volume\n    volumes = [(calculate_volume(r, h), r, h) for r, h in cakes]\n    volumes.sort()\n\n    # Dynamic programming array to store maximum volume ending with each cake\n    dp = [0] * n\n\n    for i in range(n):\n        dp[i] = volumes[i][0]  # Start with the volume of the cake itself\n        for j in range(i):\n            if volumes[j][0] < volumes[i][0]:  # Volume of cake j must be less than cake i\n                dp[i] = max(dp[i], dp[j] + volumes[i][0])\n\n    return max(dp)\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    n = int(data[0])\n    cakes = [tuple(map(int, line.split())) for line in data[1:n+1]]\n    \n    result = max_cake_volume(n, cakes)\n    print(f\"{result:.12f}\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def min_good_slices(n, k, heights):\n    heights.sort()\n    unique_heights = sorted(set(heights))\n    total_slices = 0\n    current_height = unique_heights[-1]\n    \n    for i in range(len(unique_heights) - 1, -1, -1):\n        next_height = unique_heights[i - 1] if i > 0 else 0\n        cost = sum(max(0, h - next_height) for h in heights)\n        \n        if cost <= k:\n            total_slices += 1\n            current_height = next_height\n        else:\n            break\n            \n    return total_slices\n\n# Input reading\nn, k = map(int, input().split())\nheights = list(map(int, input().split()))\n\n# Output the result\nprint(min_good_slices(n, k, heights))"}
{"solution": "def max_score(n, a):\n    max_score = 0\n    \n    for l in range(n):\n        current_sum = 0\n        max_remove = float('-inf')\n        \n        for r in range(l, n):\n            current_sum += a[r]\n            max_remove = max(max_remove, a[r])\n            score = current_sum - max_remove\n            \n            max_score = max(max_score, score)\n    \n    return max_score\n\nn = int(input())\na = list(map(int, input().split()))\nprint(max_score(n, a))"}
{"solution": "def can_light_garlands(k1, k2, k3):\n    # Sort the intervals\n    k = sorted([k1, k2, k3])\n    \n    # Check if the sum of the two smallest intervals is greater than or equal to the largest interval\n    if k[0] + k[1] >= k[2]:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nk1, k2, k3 = map(int, input().split())\n# Print the result\nprint(can_light_garlands(k1, k2, k3))"}
{"solution": "def min_operations_to_delete(s):\n    n = len(s)\n    dp = [[float('inf')] * n for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][i] = 1  # Single character can be removed in one operation\n    \n    for length in range(2, n + 1):  # length of the substring\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                dp[i][j] = dp[i][j - 1]  # If the ends are the same, we can consider them together\n            for k in range(i, j):\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j])  # Split the substring\n            \n    return dp[0][n - 1]\n\nn = int(input())\ns = input().strip()\nprint(min_operations_to_delete(s))"}
{"solution": "def max_pairs(n, boys, m, girls):\n    boys.sort()\n    girls.sort()\n    \n    i, j = 0, 0\n    pairs = 0\n    \n    while i < n and j < m:\n        if abs(boys[i] - girls[j]) <= 1:\n            pairs += 1\n            i += 1\n            j += 1\n        elif boys[i] < girls[j]:\n            i += 1\n        else:\n            j += 1\n            \n    return pairs\n\n# Input reading\nn = int(input())\nboys = list(map(int, input().split()))\nm = int(input())\ngirls = list(map(int, input().split()))\n\n# Output the result\nprint(max_pairs(n, boys, m, girls))"}
{"solution": "def can_team_win(a1, b1, a2, b2):\n    return a1 > b2 and b1 > a2\n\ndef main():\n    players = [tuple(map(int, input().split())) for _ in range(4)]\n    \n    # Team 1 players\n    a1, b1 = players[0]  # Player 1\n    a2, b2 = players[1]  # Player 2\n    \n    # Team 2 players\n    a3, b3 = players[2]  # Player 3\n    a4, b4 = players[3]  # Player 4\n    \n    team1_wins = (\n        can_team_win(a1, b2, a3, b4) or\n        can_team_win(a2, b1, a3, b4) or\n        can_team_win(a1, b2, a4, b3) or\n        can_team_win(a2, b1, a4, b3)\n    )\n    \n    team2_wins = (\n        can_team_win(a3, b4, a1, b2) or\n        can_team_win(a4, b3, a1, b2) or\n        can_team_win(a3, b4, a2, b1) or\n        can_team_win(a4, b3, a2, b1)\n    )\n    \n    if team1_wins and not team2_wins:\n        print(\"Team 1\")\n    elif team2_wins and not team1_wins:\n        print(\"Team 2\")\n    else:\n        print(\"Draw\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "import sys\nimport math\nfrom scipy.optimize import minimize\n\ndef time_to_grill(XY, meats, K):\n    X, Y = XY\n    times = []\n    for x_i, y_i, c_i in meats:\n        time = c_i * math.sqrt((X - x_i) ** 2 + (Y - y_i) ** 2)\n        times.append(time)\n    times.sort()\n    return max(times[:K])\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    N, K = map(int, data[0].split())\n    meats = [tuple(map(int, line.split())) for line in data[1:N+1]]\n    \n    # Initial guess for the position of the heat source\n    initial_guess = (0.0, 0.0)\n    \n    # Minimize the time to grill K pieces of meat\n    result = minimize(time_to_grill, initial_guess, args=(meats, K), method='Nelder-Mead')\n    \n    # Output the minimum time found\n    print(f\"{result.fun:.10f}\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def determine_winner(n, ticket):\n    half_n = n // 2\n    left_sum = 0\n    right_sum = 0\n    left_questions = 0\n    right_questions = 0\n\n    for i in range(half_n):\n        if ticket[i] == '?':\n            left_questions += 1\n        else:\n            left_sum += int(ticket[i])\n\n    for i in range(half_n, n):\n        if ticket[i] == '?':\n            right_questions += 1\n        else:\n            right_sum += int(ticket[i])\n\n    total_questions = left_questions + right_questions\n    diff = abs(left_sum - right_sum)\n\n    if diff > 9 * total_questions:\n        return \"Monocarp\"\n    \n    if (diff + total_questions) % 2 == 0:\n        return \"Bicarp\"\n    else:\n        return \"Monocarp\"\n\nn = int(input().strip())\nticket = input().strip()\nprint(determine_winner(n, ticket))"}
{"solution": "n, t = map(int, input().split())\nbuses = []\n\nfor i in range(n):\n    s, d = map(int, input().split())\n    if s >= t:\n        buses.append((s, i + 1))\n    else:\n        # Calculate the next bus time after t\n        if (t - s) % d == 0:\n            buses.append((t, i + 1))\n        else:\n            next_bus_time = s + ((t - s) // d + 1) * d\n            buses.append((next_bus_time, i + 1))\n\n# Find the bus with the minimum time\nbuses.sort()\nprint(buses[0][1])"}
{"solution": "def count_numbers_with_k_ones(n, k):\n    count = 0\n    for i in range(n + 1, 2 * n + 1):\n        if bin(i).count('1') == k:\n            count += 1\n    return count\n\ndef find_n(m, k):\n    n = 1\n    while True:\n        if count_numbers_with_k_ones(n, k) == m:\n            return n\n        n += 1\n\nm, k = map(int, input().split())\nresult = find_n(m, k)\nprint(result)"}
{"solution": "n = int(input())\nlevel = input().strip()\n\nplatforms = [i for i in range(n) if level[i] == '*']\n\nfor i in range(len(platforms)):\n    for j in range(i + 1, len(platforms)):\n        d = platforms[j] - platforms[i]\n        if platforms[i] + 2 * d in platforms and platforms[i] + 3 * d in platforms:\n            print(\"yes\")\n            exit()\n\nprint(\"no\")"}
{"solution": "def find_magic_number(n, grid):\n    empty_row, empty_col = -1, -1\n    total_sum = 0\n    row_sums = [0] * n\n    col_sums = [0] * n\n    main_diag_sum = 0\n    sec_diag_sum = 0\n    \n    # Find the empty cell and calculate sums\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 0:\n                empty_row, empty_col = i, j\n            else:\n                total_sum += grid[i][j]\n                row_sums[i] += grid[i][j]\n                col_sums[j] += grid[i][j]\n                if i == j:\n                    main_diag_sum += grid[i][j]\n                if i + j == n - 1:\n                    sec_diag_sum += grid[i][j]\n    \n    # The target magic sum\n    target_sum = None\n    for i in range(n):\n        if i != empty_row:\n            if target_sum is None:\n                target_sum = row_sums[i]\n            elif target_sum != row_sums[i]:\n                return -1\n    \n    # Calculate the required number to fill in the empty cell\n    required_number = target_sum - row_sums[empty_row]\n    \n    # Check if the required number is positive\n    if required_number <= 0:\n        return -1\n    \n    # Check if filling the required number maintains the magic square properties\n    new_row_sum = row_sums[empty_row] + required_number\n    new_col_sum = col_sums[empty_col] + required_number\n    new_main_diag_sum = main_diag_sum\n    new_sec_diag_sum = sec_diag_sum\n    \n    if empty_row == empty_col:\n        new_main_diag_sum += required_number\n    if empty_row + empty_col == n - 1:\n        new_sec_diag_sum += required_number\n    \n    if (new_row_sum == target_sum and\n        new_col_sum == target_sum and\n        new_main_diag_sum == target_sum and\n        new_sec_diag_sum == target_sum):\n        return required_number\n    \n    return -1\n\n# Input reading\nn = int(input())\ngrid = [list(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(find_magic_number(n, grid))"}
{"solution": "n = int(input())\nm = int(input())\na = [int(input()) for _ in range(n)]\n\n# Calculate maximum possible k\nmax_k = max(a) + m\n\n# Calculate minimum possible k\n# Distribute m people as evenly as possible\ntotal_people = sum(a) + m\nmin_k = (total_people + n - 1) // n  # Ceiling division\n\nprint(min_k, max_k)"}
{"solution": "def count_boarding_ways(n, m):\n    MOD = 10**9 + 7\n    \n    # Calculate the total number of ways to assign seats and entrances\n    total_ways = pow(n, m, MOD) * pow(2, m, MOD) % MOD\n    \n    # Calculate the number of invalid ways (where at least one person gets angry)\n    invalid_ways = 0\n    for i in range(1, m + 1):\n        invalid_ways += (pow(n - 1, i, MOD) * pow(2, i, MOD)) % MOD\n        invalid_ways %= MOD\n    \n    # Valid ways are total ways minus invalid ways\n    valid_ways = (total_ways - invalid_ways + MOD) % MOD\n    \n    return valid_ways\n\n# Read input\nn, m = map(int, input().split())\n# Print the result\nprint(count_boarding_ways(n, m))"}
{"solution": "def main():\n    import sys\n    from itertools import combinations\n\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    n, m = map(int, data[0].split())\n    \n    friends_favorites = []\n    for i in range(1, n + 1):\n        line = list(map(int, data[i].split()))\n        friends_favorites.append(set(line[1:]))\n    \n    pizzas = []\n    for j in range(n + 1, n + m + 1):\n        line = list(map(int, data[j].split()))\n        price = line[0]\n        ingredients = set(line[2:])\n        pizzas.append((price, ingredients))\n    \n    max_happy_friends = 0\n    best_pair = (0, 1)\n    min_cost = float('inf')\n    \n    for i, j in combinations(range(m), 2):\n        combined_ingredients = pizzas[i][1] | pizzas[j][1]\n        happy_count = sum(1 for favorites in friends_favorites if favorites.issubset(combined_ingredients))\n        \n        total_cost = pizzas[i][0] + pizzas[j][0]\n        \n        if (happy_count > max_happy_friends) or (happy_count == max_happy_friends and total_cost < min_cost):\n            max_happy_friends = happy_count\n            min_cost = total_cost\n            best_pair = (i + 1, j + 1)  # +1 for 1-based index\n    \n    print(best_pair[0], best_pair[1])\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def find_min_max_numbers(m, s):\n    if (s == 0 and m > 1) or (s > 9 * m):\n        return \"-1 -1\"\n\n    # Finding the minimum number\n    min_number = [0] * m\n    sum_remaining = s\n\n    for i in range(m):\n        for digit in range(10):\n            if (i > 0 or digit > 0 or (m == 1 and digit == 0)) and sum_remaining - digit >= 0 and sum_remaining - digit <= 9 * (m - i - 1):\n                min_number[i] = digit\n                sum_remaining -= digit\n                break\n\n    # Finding the maximum number\n    max_number = [0] * m\n    sum_remaining = s\n\n    for i in range(m):\n        for digit in range(9, -1, -1):\n            if (i > 0 or digit > 0 or (m == 1 and digit == 0)) and sum_remaining - digit >= 0 and sum_remaining - digit <= 9 * (m - i - 1):\n                max_number[i] = digit\n                sum_remaining -= digit\n                break\n\n    return ''.join(map(str, min_number)), ''.join(map(str, max_number))\n\nm, s = map(int, input().split())\nmin_num, max_num = find_min_max_numbers(m, s)\nprint(min_num, max_num)"}
{"solution": "def count_valid_numbers_with_k_digits(l, r, k):\n    def is_valid(num):\n        return len(set(str(num))) <= k\n\n    total_sum = 0\n    for num in range(l, r + 1):\n        if is_valid(num):\n            total_sum += num\n            total_sum %= 998244353\n    return total_sum\n\nl, r, k = map(int, input().split())\nresult = count_valid_numbers_with_k_digits(l, r, k)\nprint(result)"}
{"solution": "def can_distribute_pencils(n, k, d, saturations):\n    saturations.sort()\n    count = 0\n    i = 0\n    \n    while i < n:\n        count += 1\n        start = saturations[i]\n        while i < n and saturations[i] - start <= d:\n            i += 1\n            \n    return \"YES\" if count * k <= n else \"NO\"\n\n# Input reading\nn, k, d = map(int, input().split())\nsaturations = list(map(int, input().split()))\n\n# Output the result\nprint(can_distribute_pencils(n, k, d, saturations))"}
{"solution": "def count_dead_bulbs(s):\n    color_map = {'R': 0, 'B': 1, 'Y': 2, 'G': 3}\n    dead_count = [0, 0, 0, 0]\n    \n    # Find the last known positions of each color\n    last_positions = [-1, -1, -1, -1]\n    \n    for i, bulb in enumerate(s):\n        if bulb in color_map:\n            last_positions[color_map[bulb]] = i\n    \n    # Determine the dead bulbs based on the last known positions\n    for i in range(len(s)):\n        if s[i] == '!':\n            # Determine which color should be here\n            color_index = (i % 4)\n            if last_positions[color_index] == -1 or last_positions[color_index] < i:\n                dead_count[color_index] += 1\n    \n    print(dead_count[0], dead_count[1], dead_count[2], dead_count[3])\n\n# Example usage\ns = input().strip()\ncount_dead_bulbs(s)"}
{"solution": "def expected_passages(N, M, passages):\n    from collections import defaultdict\n    import sys\n\n    # Create adjacency list for the graph\n    graph = defaultdict(list)\n    for s, t in passages:\n        graph[s].append(t)\n\n    # Calculate expected passages without blocking\n    E = [0] * (N + 1)\n    for room in range(N - 1, 0, -1):\n        if room in graph:\n            num_passages = len(graph[room])\n            E[room] = 1 + sum(E[next_room] for next_room in graph[room]) / num_passages\n\n    # Now consider blocking each passage from room 1\n    min_E = E[1]  # Start with the expected value without blocking\n    if 1 in graph:\n        for next_room in graph[1]:\n            # Temporarily block the passage from 1 to next_room\n            num_passages = len(graph[1]) - 1  # One less passage\n            if num_passages > 0:\n                new_E = 1 + sum(E[room] for room in graph[1] if room != next_room) / num_passages\n                min_E = min(min_E, new_E)\n\n    return min_E\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\nN, M = map(int, data[0].split())\npassages = [tuple(map(int, line.split())) for line in data[1:M + 1]]\n\n# Calculate the expected number of passages\nresult = expected_passages(N, M, passages)\n\n# Print the result with the required precision\nprint(f\"{result:.10f}\")"}
{"solution": "n = int(input().strip())\n\nif n % 10 == 0:\n    print(n)\nelse:\n    lower = n - (n % 10)\n    upper = lower + 10\n    if (n - lower) < (upper - n):\n        print(lower)\n    else:\n        print(upper)"}
{"solution": "def find_swappable_pairs(s, t):\n    if len(s) != len(t):\n        return -1\n\n    pairs = {}\n    for char_s, char_t in zip(s, t):\n        if char_s != char_t:\n            if char_s in pairs:\n                if pairs[char_s] != char_t:\n                    return -1\n            elif char_t in pairs:\n                if pairs[char_t] != char_s:\n                    return -1\n            else:\n                pairs[char_s] = char_t\n                pairs[char_t] = char_s\n\n    seen = set()\n    result = []\n    for char_s, char_t in pairs.items():\n        if char_s < char_t and (char_s, char_t) not in seen:\n            result.append((char_s, char_t))\n            seen.add((char_s, char_t))\n            seen.add((char_t, char_s))\n\n    return result\n\ns = input().strip()\nt = input().strip()\n\nresult = find_swappable_pairs(s, t)\n\nif result == -1:\n    print(-1)\nelse:\n    print(len(result))\n    for a, b in result:\n        print(a, b)"}
{"solution": "def earliest_login(first_name, last_name):\n    earliest = None\n    for i in range(1, len(first_name) + 1):\n        for j in range(1, len(last_name) + 1):\n            login = first_name[:i] + last_name[:j]\n            if earliest is None or login < earliest:\n                earliest = login\n    return earliest\n\nif __name__ == \"__main__\":\n    first_name, last_name = input().split()\n    print(earliest_login(first_name, last_name))"}
{"solution": "def draw_brackets(n, sequence):\n    height = sequence.count('[') + 1\n    width = 0\n    stack = []\n    positions = []\n\n    for char in sequence:\n        if char == '[':\n            stack.append(len(positions))\n            positions.append((width, height - len(stack)))\n            width += 3  # \"+-\" for the bracket and space\n        else:\n            start = stack.pop()\n            positions[start] = (positions[start][0], positions[start][1])  # Update position\n            width += 1  # Space after closing bracket\n\n    # Create the output grid\n    output = [[' ' for _ in range(width)] for _ in range(height)]\n\n    # Draw the brackets\n    for i, (x, y) in enumerate(positions):\n        if sequence[i] == '[':\n            output[y][x] = '+'\n            output[y][x + 1] = '-'\n            output[y + 1][x] = '|'\n            output[y + 1][x + 1] = ' '\n            output[y + 1][x + 2] = '|'\n        else:\n            start = stack.pop()\n            output[y][x - 3] = '-'\n            output[y][x - 2] = '+'\n            output[y + 1][x - 3] = '|'\n            output[y + 1][x - 2] = ' '\n            output[y + 1][x - 1] = '|'\n\n    # Print the output\n    for row in output:\n        print(''.join(row).rstrip())\n\n# Input reading\nn = int(input().strip())\nsequence = input().strip()\ndraw_brackets(n, sequence)"}
{"solution": "import sys\n\ndef golden_value(s):\n    n = len(s)\n    value = 0\n    q = (5 ** 0.5 + 1) / 2\n    for i in range(n):\n        if s[i] == '1':\n            value += q ** (n - 1 - i)\n    return value\n\ndef compare_golden_numbers(num1, num2):\n    value1 = golden_value(num1)\n    value2 = golden_value(num2)\n    \n    if value1 > value2:\n        return \">\"\n    elif value1 < value2:\n        return \"<\"\n    else:\n        return \"=\"\n\nif __name__ == \"__main__\":\n    num1 = sys.stdin.readline().strip()\n    num2 = sys.stdin.readline().strip()\n    result = compare_golden_numbers(num1, num2)\n    print(result)"}
{"solution": "def find_absent_gems(n, colors):\n    gem_colors = {\n        \"Power\": \"purple\",\n        \"Time\": \"green\",\n        \"Space\": \"blue\",\n        \"Soul\": \"orange\",\n        \"Reality\": \"red\",\n        \"Mind\": \"yellow\"\n    }\n    \n    present_colors = set(colors)\n    absent_gems = [name for name, color in gem_colors.items() if color not in present_colors]\n    \n    print(len(absent_gems))\n    for gem in absent_gems:\n        print(gem)\n\n# Input reading\nn = int(input())\ncolors = [input().strip() for _ in range(n)]\nfind_absent_gems(n, colors)"}
{"solution": "def find_round(n, a, b):\n    round_number = 1\n    while n > 1:\n        if (a + 1) // 2 == (b + 1) // 2:\n            if n == 2:\n                return \"Final!\"\n            return round_number\n        a = (a + 1) // 2\n        b = (b + 1) // 2\n        n //= 2\n        round_number += 1\n    return \"Final!\"\n\nn, a, b = map(int, input().split())\nprint(find_round(n, a, b))"}
{"solution": "def min_changes(n, p, b):\n    visited = [False] * n\n    cycles = 0\n\n    # Count cycles in the permutation\n    for i in range(n):\n        if not visited[i]:\n            cycles += 1\n            x = i\n            while not visited[x]:\n                visited[x] = True\n                x = p[x] - 1\n\n    # Count the number of 1s in b\n    ones_count = sum(b)\n\n    # To ensure every skewer visits each of the 2n placements,\n    # we need at least `cycles` reversals (1 for each cycle)\n    # and we need at least `n` total reversals (to cover all skewers)\n    # Thus, we need to change at least max(cycles, n - ones_count) elements\n    return max(cycles, n - ones_count)\n\n# Input reading\nn = int(input())\np = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Output the result\nprint(min_changes(n, p, b))"}
{"solution": "v1, v2 = map(int, input().split())\nt, d = map(int, input().split())\n\nspeeds = [0] * t\nspeeds[0] = v1\nspeeds[-1] = v2\n\nfor i in range(1, t - 1):\n    speeds[i] = speeds[i - 1] + d\n\nfor i in range(t - 2, 0, -1):\n    speeds[i] = min(speeds[i], speeds[i + 1] + d)\n\ntotal_distance = sum(speeds)\nprint(total_distance)"}
{"solution": "from itertools import permutations\nimport sys\n\ndef can_cross_bridge(camels, bridge_parts):\n    for l, v in bridge_parts:\n        current_weight = 0\n        for i in range(len(camels)):\n            current_weight += camels[i]\n            if current_weight > v:\n                return False\n            current_weight -= camels[i]  # Remove the weight of the current camel for the next iteration\n    return True\n\ndef min_distance_between_camels(camels, bridge_parts):\n    total_length = sum(l for l, v in bridge_parts)\n    return total_length\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    N, M = map(int, data[0].split())\n    weights = list(map(int, data[1].split()))\n    bridge_parts = [tuple(map(int, line.split())) for line in data[2:M+2]]\n    \n    # Check if any arrangement of camels can cross the bridge\n    for perm in permutations(weights):\n        if can_cross_bridge(perm, bridge_parts):\n            print(min_distance_between_camels(perm, bridge_parts))\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def last_digit_of_factorial_ratio(a, b):\n    if a == b:\n        return 1  # a! / a! = 1\n    \n    # Calculate the last digit of the product of numbers from (a+1) to b\n    last_digit = 1\n    for i in range(a + 1, b + 1):\n        last_digit *= i\n        last_digit %= 10  # Keep only the last digit\n    \n    return last_digit\n\n# Read input\na, b = map(int, input().split())\n# Output the result\nprint(last_digit_of_factorial_ratio(a, b))"}
{"solution": "def min_jumps_to_home(n, d, s):\n    current_position = 0\n    jumps = 0\n    \n    while current_position < n - 1:\n        next_position = current_position\n        \n        # Try to find the farthest reachable lily\n        for jump in range(1, d + 1):\n            if current_position + jump < n and s[current_position + jump] == '1':\n                next_position = current_position + jump\n        \n        # If we can't move forward, return -1\n        if next_position == current_position:\n            return -1\n        \n        current_position = next_position\n        jumps += 1\n    \n    return jumps\n\n# Read input\nn, d = map(int, input().split())\ns = input().strip()\n\n# Get the result and print it\nresult = min_jumps_to_home(n, d, s)\nprint(result)"}
{"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\nn = int(input().strip())\n\nfor m in range(1, 1001):\n    if not is_prime(n * m + 1):\n        print(m)\n        break"}
{"solution": "def can_spend_all_coins(n):\n    house_price = 1234567\n    car_price = 123456\n    computer_price = 1234\n\n    for a in range(n // house_price + 1):\n        remaining_after_houses = n - a * house_price\n        for b in range(remaining_after_houses // car_price + 1):\n            remaining_after_cars = remaining_after_houses - b * car_price\n            if remaining_after_cars >= 0 and remaining_after_cars % computer_price == 0:\n                return \"YES\"\n    return \"NO\"\n\nn = int(input())\nprint(can_spend_all_coins(n))"}
{"solution": "def can_intersect(n, x1, x2, lines):\n    # Sort lines based on their slopes (k_i)\n    lines.sort()\n    \n    # Check for intersections in the sorted lines\n    for i in range(n - 1):\n        k1, b1 = lines[i]\n        k2, b2 = lines[i + 1]\n        \n        # If the slopes are different, they will intersect\n        if k1 != k2:\n            # Calculate the x-coordinate of the intersection\n            x_intersection = (b2 - b1) / (k1 - k2)\n            # Check if the intersection is strictly between x1 and x2\n            if x1 < x_intersection < x2:\n                return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn = int(input())\nx1, x2 = map(int, input().split())\nlines = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Get the result and print it\nresult = can_intersect(n, x1, x2, lines)\nprint(result)"}
{"solution": "def count_different_weights(n):\n    return (n + 1) // 2\n\nn = int(input().strip())\nprint(count_different_weights(n))"}
{"solution": "def good_apartments(n, k):\n    if k == 0:\n        return 0, 0\n    if k >= n:\n        return 0, 0\n    \n    # Minimum good apartments\n    min_good = 1 if k < n else 0\n    \n    # Maximum good apartments\n    max_good = min(n - k, 2 * k)\n    \n    return min_good, max_good\n\n# Input reading\nn, k = map(int, input().split())\nmin_good, max_good = good_apartments(n, k)\nprint(min_good, max_good)"}
{"solution": "def max_games(n):\n    games = 0\n    while n > 1:\n        games += 1\n        n = (n + 1) // 2\n    return games\n\nn = int(input())\nprint(max_games(n))"}
{"solution": "def max_vk_occurrences(s):\n    original_count = sum(1 for i in range(len(s) - 1) if s[i:i + 2] == \"VK\")\n    max_count = original_count\n\n    for i in range(len(s)):\n        if s[i] == 'V':\n            # Change 'V' to 'K'\n            new_s = s[:i] + 'K' + s[i + 1:]\n            new_count = sum(1 for j in range(len(new_s) - 1) if new_s[j:j + 2] == \"VK\")\n            max_count = max(max_count, new_count)\n        elif s[i] == 'K':\n            # Change 'K' to 'V'\n            new_s = s[:i] + 'V' + s[i + 1:]\n            new_count = sum(1 for j in range(len(new_s) - 1) if new_s[j:j + 2] == \"VK\")\n            max_count = max(max_count, new_count)\n\n    return max_count\n\ns = input().strip()\nprint(max_vk_occurrences(s))"}
{"solution": "def minimum_segments(n):\n    if n == 1:\n        return 2\n    return (n + 1) // 2 + 1\n\nn = int(input())\nprint(minimum_segments(n))"}
{"solution": "a, b = map(int, input().split())\nyears = 0\n\nwhile a <= b:\n    a *= 3\n    b *= 2\n    years += 1\n\nprint(years)"}
{"solution": "def count_visited_nodes(h, n):\n    visited = set()\n    current_node = 1\n    visited.add(current_node)\n    command_index = 0\n    skip_count = 0\n    total_visited = 0\n\n    while True:\n        if current_node == n:\n            break\n        \n        command = 'L' if command_index % 2 == 0 else 'R'\n        command_index += 1\n        \n        if command == 'L':\n            next_node = current_node * 2\n        else:\n            next_node = current_node * 2 + 1\n        \n        if next_node > 2 ** h:\n            continue\n        \n        if next_node in visited:\n            skip_count += 1\n            if skip_count == 2:\n                current_node //= 2\n                skip_count = 0\n            continue\n        \n        visited.add(next_node)\n        total_visited += 1\n        \n        if next_node > 2 ** (h - 1):\n            if next_node != n:\n                current_node //= 2\n            else:\n                break\n        else:\n            current_node = next_node\n            skip_count = 0\n\n    return total_visited\n\nh, n = map(int, input().split())\nprint(count_visited_nodes(h, n))"}
{"solution": "def count_squares(n, m):\n    total = 0\n    for size in range(1, min(n, m) + 1):\n        total += (n - size + 1) * (m - size + 1)\n    return total\n\ndef find_tables_with_squares(x):\n    results = []\n    for n in range(1, int(x**0.5) + 2):\n        for m in range(1, x + 1):\n            if count_squares(n, m) == x:\n                results.append((n, m))\n            if n != m and count_squares(m, n) == x:\n                results.append((m, n))\n    return results\n\nx = int(input())\ntables = find_tables_with_squares(x)\nprint(len(tables))\nfor n, m in sorted(tables):\n    print(n, m)"}
{"solution": "def is_valid_month_sequence(n, days):\n    # Days in months for non-leap and leap years\n    non_leap_year = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    leap_year = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    # Check for both non-leap and leap year sequences\n    for start in range(12):\n        for year in (non_leap_year, leap_year):\n            valid = True\n            for i in range(n):\n                if year[(start + i) % 12] != days[i]:\n                    valid = False\n                    break\n            if valid:\n                return \"YES\"\n    return \"NO\"\n\n# Input reading\nn = int(input().strip())\ndays = list(map(int, input().strip().split()))\n\n# Output the result\nprint(is_valid_month_sequence(n, days))"}
{"solution": "def find_fractions(n):\n    if n == 2:\n        print(\"NO\")\n        return\n    \n    target = n - 1\n    fractions = []\n    \n    for b in range(2, n):\n        if n % b == 0:\n            a = b - 1\n            fractions.append((a, b))\n            target -= a\n            if target <= 0:\n                break\n    \n    if target > 0:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(len(fractions))\n        for a, b in fractions:\n            print(a, b)\n\nn = int(input().strip())\nfind_fractions(n)"}
{"solution": "def min_unattractiveness(n, a, b, heights):\n    # Initialize DP table\n    dp = [[float('inf')] * (a + 1) for _ in range(b + 1)]\n    dp[0][0] = 0  # No boards painted, no unattractiveness\n\n    for i in range(n):\n        h = heights[i]\n        for j in range(a + 1):\n            for k in range(b + 1):\n                if dp[k][j] == float('inf'):\n                    continue\n                # Paint current board red\n                if j + h <= a:\n                    dp[k][j + h] = min(dp[k][j + h], dp[k][j])\n                # Paint current board green\n                if k + h <= b:\n                    dp[k + h][j] = min(dp[k + h][j], dp[k][j])\n                # Paint current board red and previous green\n                if j + h <= a and k > 0:\n                    dp[k][j + h] = min(dp[k][j + h], dp[k - h][j] + h)\n                # Paint current board green and previous red\n                if k + h <= b and j > 0:\n                    dp[k + h][j] = min(dp[k + h][j], dp[k][j - h] + h)\n\n    # Find the minimum unattractiveness\n    min_unattractiveness_value = float('inf')\n    for j in range(a + 1):\n        for k in range(b + 1):\n            if dp[k][j] != float('inf'):\n                min_unattractiveness_value = min(min_unattractiveness_value, dp[k][j])\n\n    return min_unattractiveness_value if min_unattractiveness_value != float('inf') else -1\n\n# Input reading\nn = int(input().strip())\na, b = map(int, input().strip().split())\nheights = list(map(int, input().strip().split()))\n\n# Output the result\nprint(min_unattractiveness(n, a, b, heights))"}
{"solution": "def find_triangle_points(n, m, k):\n    area = (n * m) / k\n    \n    if area != int(area) or area < 0:\n        print(\"NO\")\n        return\n    \n    area = int(area)\n    \n    # We need to find points such that the area is equal to the calculated area\n    # Area of triangle = 0.5 * base * height\n    # Let's choose base = n and height = m\n    # Then we need to find a height such that 0.5 * n * height = area\n    # => height = (2 * area) / n\n    height = (2 * area) / n\n    \n    if height > m or height < 0:\n        print(\"NO\")\n        return\n    \n    # We can choose the points as follows:\n    # (0, 0), (n, 0), (0, height)\n    print(\"YES\")\n    print(0, 0)\n    print(n, 0)\n    print(0, int(height))\n\n# Read input\nn, m, k = map(int, input().split())\nfind_triangle_points(n, m, k)"}
{"solution": "n, k = map(int, input().split())\ntotal_moves = n // k\nif total_moves % 2 == 1:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nchest = 0\nbiceps = 0\nback = 0\n\nfor i in range(n):\n    if i % 3 == 0:\n        chest += a[i]\n    elif i % 3 == 1:\n        biceps += a[i]\n    else:\n        back += a[i]\n\nif chest > biceps and chest > back:\n    print(\"chest\")\nelif biceps > chest and biceps > back:\n    print(\"biceps\")\nelse:\n    print(\"back\")"}
{"solution": "import math\n\ndef minimum_redos(n, grades):\n    current_sum = sum(grades)\n    target_average = 5\n    required_sum = target_average * n\n    \n    if current_sum >= required_sum:\n        return 0\n    \n    grades.sort()  # Sort grades to redo the lowest ones first\n    redos = 0\n    \n    for grade in grades:\n        current_sum += (5 - grade)  # Increase the grade to 5\n        redos += 1\n        \n        if current_sum >= required_sum:\n            return redos\n            \n    return redos\n\n# Input reading\nn = int(input())\ngrades = list(map(int, input().split()))\n\n# Output the result\nprint(minimum_redos(n, grades))"}
{"solution": "def find_array(u, v):\n    if u > v or (v - u) % 2 != 0:\n        return -1\n    \n    if u == 0 and v == 0:\n        return (0, [])\n    \n    a = (v - u) // 2\n    x = a + u\n    return (2, [a, x])\n\nu, v = map(int, input().split())\nresult = find_array(u, v)\n\nif result == -1:\n    print(-1)\nelse:\n    n, array = result\n    print(n)\n    print(' '.join(map(str, array)))"}
{"solution": "n = int(input())\ncount_of_ones = 0\n\nwhile n > 0:\n    count_of_ones += n % 10\n    n //= 10\n\nprint(count_of_ones)"}
{"solution": "def can_reach_treasure(x1, y1, x2, y2, x, y):\n    dx = abs(x2 - x1)\n    dy = abs(y2 - y1)\n\n    if dx % x == 0 and dy % y == 0:\n        if (dx // x) % 2 == (dy // y) % 2:\n            return \"YES\"\n    return \"NO\"\n\nx1, y1, x2, y2 = map(int, input().split())\nx, y = map(int, input().split())\n\nprint(can_reach_treasure(x1, y1, x2, y2, x, y))"}
{"solution": "from itertools import permutations\n\ndef count_bus_variants(n):\n    str_n = str(n)\n    unique_permutations = set(permutations(str_n))\n    valid_numbers = set()\n\n    for perm in unique_permutations:\n        # Join the tuple to form the number\n        num_str = ''.join(perm)\n        # Check if it doesn't start with '0'\n        if num_str[0] != '0':\n            valid_numbers.add(int(num_str))\n\n    return len(valid_numbers)\n\nn = int(input().strip())\nprint(count_bus_variants(n))"}
{"solution": "a = int(input())\nb = int(input())\nc = int(input())\nd = int(input())\ne = int(input())\nf = int(input())\n\n# Calculate the maximum number of suits of each type\nmax_type1 = min(a, d)  # Ties and jackets for type 1 suits\nmax_type2 = min(b, c, d)  # Scarves, vests, and jackets for type 2 suits\n\n# Calculate the total cost for all combinations\ntotal_cost = 0\n\n# Try to maximize the profit by checking both combinations\nif e > f:\n    # Prioritize type 1 suits first\n    suits_type1 = max_type1\n    remaining_jackets = d - suits_type1\n    suits_type2 = min(b, c, remaining_jackets)\nelse:\n    # Prioritize type 2 suits first\n    suits_type2 = max_type2\n    remaining_jackets = d - suits_type2\n    suits_type1 = min(a, remaining_jackets)\n\n# Calculate the total cost\ntotal_cost = suits_type1 * e + suits_type2 * f\n\nprint(total_cost)"}
{"solution": "def count_satisfying_n(a, b, p, x):\n    count = 0\n    for n in range(1, min(x, p) + 1):\n        if (n * pow(a, n, p)) % p == b:\n            count += 1\n    return count\n\nif __name__ == \"__main__\":\n    a, b, p, x = map(int, input().split())\n    result = count_satisfying_n(a, b, p, x)\n    print(result)"}
{"solution": "k_2, k_3, k_5, k_6 = map(int, input().split())\n\n# Calculate how many 256 can be formed\ncount_256 = min(k_2, k_5, k_6)\n\n# Calculate how many 32 can be formed\ncount_32 = min(k_2, k_3)\n\n# Calculate the total sum\ntotal_sum = count_256 * 256 + count_32 * 32\n\nprint(total_sum)"}
{"solution": "def time_to_happiness(n, x, y, c):\n    if c == 1:\n        return 0\n    \n    # Calculate the maximum number of cells that can be turned on\n    max_cells = 1\n    seconds = 0\n    \n    while max_cells < c:\n        seconds += 1\n        max_cells += 4 * seconds\n    \n    return seconds\n\n# Read input\nn, x, y, c = map(int, input().split())\nresult = time_to_happiness(n, x, y, c)\nprint(result)"}
{"solution": "def max_xor(l, r):\n    xor = l ^ r\n    max_xor_value = 1\n    while xor > 0:\n        max_xor_value <<= 1\n        xor >>= 1\n    return max_xor_value - 1\n\nl, r = map(int, input().split())\nprint(max_xor(l, r))"}
{"solution": "def minimum_height(n, k):\n    # The maximum area that can be achieved with height h is n * h\n    # We need to find the minimum height h such that n * h >= k\n    # This means h >= k / n\n    # Since h must be an integer, we take the ceiling of k / n\n    if k <= n:\n        return 1\n    else:\n        return (k + n - 1) // n  # This is equivalent to ceil(k / n)\n\n# Read input\nn, k = map(int, input().split())\n# Calculate and print the minimum height\nprint(minimum_height(n, k))"}
{"solution": "x, y, z, t1, t2, t3 = map(int, input().split())\n\n# Calculate time using stairs\ntime_stairs = abs(x - y) * t1\n\n# Calculate time using elevator\ntime_elevator = (abs(z - x) * t2) + t3 + t3 + (abs(x - y) * t2) + t3\n\n# Determine which option is better\nif time_elevator <= time_stairs:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def best_choice(n, m):\n    if m == 1:\n        return 2\n    elif m == n:\n        return n - 1\n    else:\n        return m - 1 if (m - 1) <= (n - m) else m + 1\n\nn, m = map(int, input().split())\nprint(best_choice(n, m))"}
{"solution": "n = int(input())\nlessons = list(map(int, input().split()))\n\nstay_count = 0\ni = 0\n\n# Find the first lesson\nwhile i < n and lessons[i] == 0:\n    i += 1\n\n# If there are no lessons\nif i == n:\n    print(0)\nelse:\n    # Count the time spent at university\n    stay_count += 1  # For the first lesson\n    i += 1\n\n    while i < n:\n        if lessons[i] == 1:\n            stay_count += 1\n            i += 1\n        else:\n            # Check for breaks\n            break_length = 0\n            while i < n and lessons[i] == 0:\n                break_length += 1\n                i += 1\n            \n            if break_length >= 2:\n                # Alena goes home, so we don't count the breaks\n                continue\n            else:\n                # Alena waits for the next lesson\n                stay_count += break_length\n\n    print(stay_count)"}
{"solution": "def min_days_to_give_candies(n, k, candies):\n    total_given = 0\n    for day in range(n):\n        total_given += min(candies[day], 8)\n        if total_given >= k:\n            return day + 1\n    return -1\n\n# Input reading\nn, k = map(int, input().split())\ncandies = list(map(int, input().split()))\n\n# Output the result\nprint(min_days_to_give_candies(n, k, candies))"}
{"solution": "def min_additional_walks(n, k, a):\n    b = [0] * n\n    additional_walks = 0\n    \n    # Set the first day's walks\n    b[0] = max(a[0], k)\n    \n    for i in range(1, n):\n        # Calculate the required walks for the current day\n        required_walks = k - b[i - 1]\n        b[i] = max(a[i], required_walks)\n        additional_walks += b[i] - a[i]\n    \n    # Print the results\n    print(additional_walks)\n    print(' '.join(map(str, b)))\n\n# Input reading\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nmin_additional_walks(n, k, a)"}
{"solution": "n = int(input())\n\nif n == 1:\n    print(1)\nelse:\n    cells = 1 + 4 * (n - 1) * n // 2\n    print(cells)"}
{"solution": "n = int(input().strip())\ns = input().strip()\n\n# Convert the string to lowercase and create a set of characters\nunique_chars = set(s.lower())\n\n# Check if the set contains all 26 letters of the alphabet\nif len(unique_chars) >= 26:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "def time_after_minutes(current_time, minutes_to_add):\n    hh, mm = map(int, current_time.split(':'))\n    total_minutes = hh * 60 + mm + minutes_to_add\n    new_hh = (total_minutes // 60) % 24\n    new_mm = total_minutes % 60\n    return f\"{new_hh:02}:{new_mm:02}\"\n\ncurrent_time = input().strip()\nminutes_to_add = int(input().strip())\nresult = time_after_minutes(current_time, minutes_to_add)\nprint(result)"}
{"solution": "def can_ignore_switch(n, m, switches):\n    # Convert the input into a list of sets for easier manipulation\n    lamp_sets = [set() for _ in range(m)]\n    \n    for i in range(n):\n        for j in range(m):\n            if switches[i][j] == '1':\n                lamp_sets[j].add(i)\n    \n    # Check each switch to see if it can be ignored\n    for i in range(n):\n        # Create a set of lamps that can be turned on without the i-th switch\n        lamps_on = set()\n        for j in range(n):\n            if j != i:\n                for k in range(m):\n                    if switches[j][k] == '1':\n                        lamps_on.add(k)\n        \n        # Check if all lamps are covered\n        if len(lamps_on) == m:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\nswitches = [input().strip() for _ in range(n)]\n\n# Get the result and print it\nresult = can_ignore_switch(n, m, switches)\nprint(result)"}
{"solution": "n = int(input())\ndominoes = [tuple(map(int, input().split())) for _ in range(n)]\n\nsum_upper = sum(x for x, y in dominoes)\nsum_lower = sum(y for x, y in dominoes)\n\nif sum_upper % 2 == 0 and sum_lower % 2 == 0:\n    print(0)\nelse:\n    odd_count = sum(1 for x, y in dominoes if (x + y) % 2 == 1)\n    if odd_count > 0:\n        print(1)\n    else:\n        print(-1)"}
{"solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nt = int(input())\nresults = []\nfor _ in range(t):\n    a, b = map(int, input().split())\n    area = a * a - b * b\n    if is_prime(area):\n        results.append(\"YES\")\n    else:\n        results.append(\"NO\")\n\nprint(\"\\n\".join(results))"}
{"solution": "def can_remove_point(n, points):\n    left_count = 0\n    right_count = 0\n    \n    for x, y in points:\n        if x < 0:\n            left_count += 1\n        else:\n            right_count += 1\n            \n    # If all points are on one side or if we can remove one to make it so\n    if left_count <= 1 or right_count <= 1:\n        return \"Yes\"\n    else:\n        return \"No\"\n\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\nresult = can_remove_point(n, points)\nprint(result)"}
{"solution": "import math\nimport sys\n\ndef gcd_of_factorials(A, B):\n    min_factorial = min(A, B)\n    return math.factorial(min_factorial)\n\nif __name__ == \"__main__\":\n    A, B = map(int, sys.stdin.readline().strip().split())\n    result = gcd_of_factorials(A, B)\n    print(result)"}
{"solution": "def is_composite(num):\n    if num < 4:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return True\n    return False\n\ndef find_composite_pair(n):\n    a = n + 8  # Start with a known composite number\n    b = 8     # 8 is a composite number\n    while not (is_composite(a) and is_composite(b)):\n        a += 1\n    return a, b\n\nn = int(input())\na, b = find_composite_pair(n)\nprint(a, b)"}
{"solution": "import sys\nimport heapq\n\ndef max_score(N, M, P, edges):\n    graph = [[] for _ in range(N + 1)]\n    for A, B, C in edges:\n        graph[A].append((B, C))\n\n    # Dijkstra-like approach to find maximum coins collected at each vertex\n    max_coins = [-float('inf')] * (N + 1)\n    max_coins[1] = 0\n    pq = [(-max_coins[1], 1)]  # (negative coins, vertex)\n\n    while pq:\n        current_coins, u = heapq.heappop(pq)\n        current_coins = -current_coins\n\n        for v, coins in graph[u]:\n            new_coins = current_coins + coins\n            if new_coins > max_coins[v]:\n                max_coins[v] = new_coins\n                heapq.heappush(pq, (-new_coins, v))\n\n    max_score = -1\n    for t in range(1, N + 1):\n        if max_coins[N] >= t * P:\n            score = max_coins[N] - t * P\n            max_score = max(max_score, score)\n\n    return max_score if max_score != -1 else -1\n\ndef main():\n    input = sys.stdin.read\n    data = input().splitlines()\n    N, M, P = map(int, data[0].split())\n    edges = [tuple(map(int, line.split())) for line in data[1:M + 1]]\n    \n    result = max_score(N, M, P, edges)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def is_palindrome(s):\n    return s == s[::-1]\n\ndef min_cost_to_form_palindrome(n, strings_costs):\n    from collections import defaultdict\n    \n    cost_map = defaultdict(int)\n    used_strings = set()\n    \n    for s, c in strings_costs:\n        if is_palindrome(s):\n            cost_map[s] = min(cost_map[s], c) if s in cost_map else c\n        rev_s = s[::-1]\n        if rev_s in cost_map:\n            used_strings.add(rev_s)\n    \n    total_cost = 0\n    for s in used_strings:\n        total_cost += cost_map[s]\n    \n    return total_cost if total_cost > 0 else -1\n\nimport sys\ninput = sys.stdin.read\n\ndata = input().strip().splitlines()\nN = int(data[0])\nstrings_costs = [line.split() for line in data[1:N+1]]\nstrings_costs = [(s, int(c)) for s, c in strings_costs]\n\nresult = min_cost_to_form_palindrome(N, strings_costs)\nprint(result)"}
{"solution": "def largest_xor_sum(n, k):\n    if k == n:\n        return n ^ (n - 1)  # If we can take all candies, return the xor of all\n    else:\n        # The largest xor-sum we can get is from the largest k numbers\n        # which are n, n-1, ..., n-k+1\n        result = 0\n        for i in range(k):\n            result ^= (n - i)\n        return result\n\n# Read input\nn, k = map(int, input().strip().split())\n# Output the result\nprint(largest_xor_sum(n, k))"}
{"solution": "def minimum_length_of_triangle(n, points):\n    max_x = max(point[0] for point in points)\n    max_y = max(point[1] for point in points)\n    \n    return max(max_x, max_y) * 2\n\n# Input reading\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nresult = minimum_length_of_triangle(n, points)\nprint(result)"}
{"solution": "from collections import Counter\n\ndef max_nineteens(s):\n    # Count the occurrences of each letter in the string\n    letter_count = Counter(s)\n    \n    # The word \"nineteen\" consists of:\n    # n: 2, i: 1, e: 2, t: 1\n    needed_count = {\n        'n': 2,\n        'i': 1,\n        'e': 2,\n        't': 1\n    }\n    \n    # Calculate the maximum number of \"nineteen\" that can be formed\n    max_count = float('inf')\n    for letter, count in needed_count.items():\n        if letter in letter_count:\n            max_count = min(max_count, letter_count[letter] // count)\n        else:\n            max_count = 0\n            break\n    \n    return max_count\n\n# Read input\ns = input().strip()\n# Print the result\nprint(max_nineteens(s))"}
{"solution": "def highest_safe_branch(p, y):\n    if y <= p:\n        return -1\n    \n    for branch in range(y, p, -1):\n        if all(branch % i != 0 for i in range(2, int(branch**0.5) + 1)):\n            return branch\n        if branch <= p:\n            break\n    \n    return -1\n\np, y = map(int, input().split())\nprint(highest_safe_branch(p, y))"}
{"solution": "n, m, k = map(int, input().split())\na = list(map(int, input().split()))\n\nmin_distance = float('inf')\n\nfor i in range(n):\n    if a[i] != 0 and a[i] <= k:\n        distance = abs(m - (i + 1)) * 10\n        min_distance = min(min_distance, distance)\n\nprint(min_distance)"}
{"solution": "def can_transform(n, m, A, B):\n    from collections import defaultdict\n\n    # Create a mapping of values to their positions in A and B\n    positions_A = defaultdict(list)\n    positions_B = defaultdict(list)\n\n    for i in range(n):\n        for j in range(m):\n            positions_A[A[i][j]].append((i, j))\n            positions_B[B[i][j]].append((i, j))\n\n    # Check if the positions of each value in A can match those in B\n    for value in positions_A:\n        if sorted(positions_A[value]) != sorted(positions_B[value]):\n            return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, m = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(n)]\nB = [list(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(can_transform(n, m, A, B))"}
{"solution": "a = input().strip()\nb = input().strip()\n\nif a == b:\n    print(-1)\nelse:\n    print(max(len(a), len(b)))"}
{"solution": "def first_common_scream(a, b, c, d):\n    # We will use a set to track Rick's scream times\n    rick_screams = set()\n    \n    # Generate Rick's scream times\n    for i in range(10000):  # Arbitrarily large limit to ensure we cover enough time\n        rick_scream_time = b + i * a\n        rick_screams.add(rick_scream_time)\n    \n    # Check Morty's scream times against Rick's\n    for j in range(10000):  # Arbitrarily large limit to ensure we cover enough time\n        morty_scream_time = d + j * c\n        if morty_scream_time in rick_screams:\n            return morty_scream_time\n    \n    return -1\n\n# Read input\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# Get the result and print it\nresult = first_common_scream(a, b, c, d)\nprint(result)"}
{"solution": "n = int(input())\n\nif n % 3 == 0:\n    a = 1\n    b = 1\n    c = n - 2\nelif n % 3 == 1:\n    a = 1\n    b = 2\n    c = n - 3\nelse:  # n % 3 == 2\n    a = 2\n    b = 2\n    c = n - 4\n\nprint(a, b, c)"}
{"solution": "def count_valid_squares(n, a, b, c, d):\n    # Calculate the sum of the top left 2x2 square\n    S = a + b + c + d\n    \n    # The possible values for the unknown cells\n    valid_count = 0\n    \n    # Iterate through all possible values for the unknown cells\n    for x1 in range(1, n + 1):\n        for x2 in range(1, n + 1):\n            for x3 in range(1, n + 1):\n                for x4 in range(1, n + 1):\n                    # Check if the sums of the 2x2 squares are equal\n                    if (x1 + a + x2 + b == S and\n                        b + x3 + d + x4 == S and\n                        a + x2 + c + x4 == S and\n                        x1 + b + x3 + d == S):\n                        valid_count += 1\n    \n    return valid_count\n\n# Read input\nn, a, b, c, d = map(int, input().split())\n# Get the result\nresult = count_valid_squares(n, a, b, c, d)\n# Print the result\nprint(result)"}
{"solution": "w, h = map(int, input().split())\nu1, d1 = map(int, input().split())\nu2, d2 = map(int, input().split())\n\nstones = {d1: u1, d2: u2}\n\nfor current_height in range(h, 0, -1):\n    w += current_height\n    if current_height in stones:\n        w -= stones[current_height]\n        if w < 0:\n            w = 0\n\nprint(w)"}
{"solution": "m = int(input())\nc = list(map(int, input().split()))\nx, y = map(int, input().split())\n\ntotal_students = sum(c)\n\nfor k in range(1, m + 1):\n    beginner_group = sum(c[:k])\n    intermediate_group = total_students - beginner_group\n    \n    if x <= beginner_group <= y and x <= intermediate_group <= y:\n        print(k)\n        break\nelse:\n    print(0)"}
{"solution": "def min_cost_to_one(n, k, A, B):\n    cost = 0\n    while n > 1:\n        if k > 1 and n % k == 0:\n            # Calculate cost to divide\n            divide_cost = B\n            # Calculate cost to subtract to the next divisible number\n            next_divisible = (n // k) * k\n            subtract_cost = (n - next_divisible) * A\n            \n            if divide_cost < subtract_cost:\n                cost += divide_cost\n                n //= k\n            else:\n                cost += subtract_cost\n                n = next_divisible\n        else:\n            # If not divisible by k, just subtract to reach 1\n            cost += (n - 1) * A\n            n = 1\n            \n    return cost\n\nn = int(input())\nk = int(input())\nA = int(input())\nB = int(input())\n\nprint(min_cost_to_one(n, k, A, B))"}
{"solution": "import math\nfrom collections import deque\n\ndef min_value_and_operations(n):\n    # To store the minimum value and the number of operations\n    min_value = n\n    min_operations = 0\n    \n    # BFS to explore all possible values and operations\n    queue = deque([(n, 0)])  # (current value, operations count)\n    visited = set([n])\n    \n    while queue:\n        current, operations = queue.popleft()\n        \n        # Check if we can take the square root\n        if current > 1:\n            sqrt_value = int(math.isqrt(current))\n            if sqrt_value * sqrt_value == current and sqrt_value not in visited:\n                visited.add(sqrt_value)\n                queue.append((sqrt_value, operations + 1))\n                if sqrt_value < min_value:\n                    min_value = sqrt_value\n                    min_operations = operations + 1\n                elif sqrt_value == min_value:\n                    min_operations = min(min_operations, operations + 1)\n        \n        # Check for multiplication by factors\n        for i in range(2, int(math.sqrt(current)) + 1):\n            if current % i == 0:\n                new_value = current * i\n                if new_value not in visited:\n                    visited.add(new_value)\n                    queue.append((new_value, operations + 1))\n                    if new_value < min_value:\n                        min_value = new_value\n                        min_operations = operations + 1\n                    elif new_value == min_value:\n                        min_operations = min(min_operations, operations + 1)\n                \n                # Also consider the complementary factor\n                complementary_factor = current // i\n                if complementary_factor != i:  # Avoid duplicate for perfect squares\n                    new_value = current * complementary_factor\n                    if new_value not in visited:\n                        visited.add(new_value)\n                        queue.append((new_value, operations + 1))\n                        if new_value < min_value:\n                            min_value = new_value\n                            min_operations = operations + 1\n                        elif new_value == min_value:\n                            min_operations = min(min_operations, operations + 1)\n\n    return min_value, min_operations\n\nn = int(input().strip())\nresult = min_value_and_operations(n)\nprint(result[0], result[1])"}
{"solution": "def max_score(N, K, R, S, P, T):\n    dp = [[0] * 3 for _ in range(N + 1)]\n    hand_map = {'r': 0, 'p': 1, 's': 2}\n    \n    for i in range(1, N + 1):\n        for j in range(3):\n            if i > K:\n                dp[i][j] = max(dp[i - 1][(j + 1) % 3], dp[i - 1][(j + 2) % 3])\n            else:\n                dp[i][j] = max(dp[i - 1])\n        \n            if (j == 0 and T[i - 1] == 's') or (j == 1 and T[i - 1] == 'r') or (j == 2 and T[i - 1] == 'p'):\n                dp[i][j] += 0\n            elif j == 0 and T[i - 1] == 'r':\n                dp[i][j] += R\n            elif j == 1 and T[i - 1] == 's':\n                dp[i][j] += S\n            elif j == 2 and T[i - 1] == 'p':\n                dp[i][j] += P\n\n    return max(dp[N])\n\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\nN, K = map(int, data[0].split())\nR, S, P = map(int, data[1].split())\nT = data[2]\n\nprint(max_score(N, K, R, S, P, T))"}
{"solution": "def max_good_string_length(a, b, c):\n    # Calculate the maximum length of the good string\n    if a > b:\n        a, b = b, a  # Ensure a <= b\n\n    # Use all 'ab' strings\n    length = c * 2\n    \n    # After using 'ab' strings, we can use the remaining 'a' and 'b'\n    remaining_a = a\n    remaining_b = b - c\n    \n    if remaining_b < 0:\n        remaining_b = 0\n    \n    # We can use pairs of 'a' and 'b' after 'ab' strings\n    pairs = min(remaining_a, remaining_b)\n    length += pairs * 2\n    \n    # If there's an extra 'a' or 'b' left, we can add one more character\n    if remaining_a > pairs or remaining_b > pairs:\n        length += 1\n    \n    return length\n\n# Input reading\na, b, c = map(int, input().split())\n# Output the result\nprint(max_good_string_length(a, b, c))"}
{"solution": "def can_achieve_marks(n, k, p, x, y, marks):\n    current_sum = sum(marks)\n    remaining_tests = n - k\n    required_median_position = (n // 2) + 1\n    current_marks = sorted(marks)\n\n    # Calculate how many marks need to be at least y to achieve the median requirement\n    count_y_or_more = sum(1 for mark in current_marks if mark >= y)\n    needed_y_marks = max(0, required_median_position - count_y_or_more)\n\n    # If we need more marks than we can fill, it's impossible\n    if needed_y_marks > remaining_tests:\n        return -1\n\n    # Fill the remaining tests with y to ensure median condition\n    result_marks = [y] * needed_y_marks\n\n    # Fill the rest with the minimum possible marks (1) to not exceed the sum limit\n    remaining_tests -= needed_y_marks\n    result_marks += [1] * remaining_tests\n\n    # Check if the total sum exceeds x\n    total_sum = current_sum + sum(result_marks)\n    if total_sum > x:\n        return -1\n\n    return result_marks\n\n# Read input\nn, k, p, x, y = map(int, input().split())\nmarks = list(map(int, input().split()))\n\n# Get the result\nresult = can_achieve_marks(n, k, p, x, y, marks)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(\" \".join(map(str, result)))"}
{"solution": "def is_berlanese(s):\n    vowels = {'a', 'o', 'u', 'i', 'e'}\n    n = len(s)\n    \n    for i in range(n):\n        if s[i] not in vowels:  # If it's a consonant\n            if s[i] != 'n':  # If it's not 'n'\n                if i + 1 >= n or s[i + 1] not in vowels:  # Check next character\n                    return \"NO\"\n    return \"YES\"\n\ns = input().strip()\nprint(is_berlanese(s))"}
{"solution": "def max_dominoes(n, m, edges):\n    from itertools import combinations\n    \n    # Create a graph representation\n    graph = {i: [] for i in range(1, n + 1)}\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    # All possible domino types\n    dominoes = [(i, j) for i in range(1, 7) for j in range(i, 7)]\n    \n    # To store the maximum number of dominoes that can be placed\n    max_count = 0\n    \n    # Check all combinations of dominoes\n    for k in range(1, len(dominoes) + 1):\n        for combo in combinations(dominoes, k):\n            # Create a mapping of vertex to the number of dots\n            vertex_dots = {i: set() for i in range(1, n + 1)}\n            valid = True\n            \n            for (a, b) in combo:\n                for u, v in edges:\n                    if (u, v) in combo or (v, u) in combo:\n                        # Check if we can place domino (a, b) on edge (u, v)\n                        if a in vertex_dots[u] or b in vertex_dots[v]:\n                            valid = False\n                            break\n                        vertex_dots[u].add(a)\n                        vertex_dots[v].add(b)\n                if not valid:\n                    break\n            \n            if valid:\n                max_count = max(max_count, len(combo))\n    \n    return max_count\n\n# Input reading\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output the result\nprint(max_dominoes(n, m, edges))"}
{"solution": "def max_points(n, m, prices, auction_indices):\n    auction_prices = [prices[i - 1] for i in auction_indices]\n    regular_prices = [prices[i] for i in range(n) if (i + 1) not in auction_indices]\n\n    # Sort auction prices in descending order\n    auction_prices.sort(reverse=True)\n    # Sort regular prices in descending order\n    regular_prices.sort(reverse=True)\n\n    # Calculate the total points\n    total_points = 0\n\n    # First, answer all auction questions\n    current_points = 0\n    for price in auction_prices:\n        current_points += price\n        total_points += price\n\n    # Then, answer all regular questions\n    for price in regular_prices:\n        total_points += price\n\n    return total_points\n\n# Read input\nn, m = map(int, input().split())\nprices = list(map(int, input().split()))\nauction_indices = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = max_points(n, m, prices, auction_indices)\nprint(result)"}
{"solution": "def calculate_score(m, w, h_s, h_u):\n    max_points = [500, 1000, 1500, 2000, 2500]\n    total_score = 0\n\n    for i in range(5):\n        x = max_points[i]\n        m_i = m[i]\n        w_i = w[i]\n        score_i = max(0.3 * x, (1 - m_i / 250) * x - 50 * w_i)\n        total_score += score_i\n\n    total_score += 100 * h_s\n    total_score -= 50 * h_u\n\n    return int(total_score)\n\n# Input reading\nm = list(map(int, input().split()))\nw = list(map(int, input().split()))\nh_s, h_u = map(int, input().split())\n\n# Calculate and print the final score\nfinal_score = calculate_score(m, w, h_s, h_u)\nprint(final_score)"}
{"solution": "def count_valid_grids(n, m, L, R):\n    MOD = 998244353\n    \n    # Total number of cells\n    total_cells = n * m\n    \n    # The minimum and maximum possible sum of cubes\n    min_sum = total_cells * L\n    max_sum = total_cells * R\n    \n    # The number of valid total sums that can be achieved\n    valid_sums = max(0, max_sum - min_sum + 1)\n    \n    # The answer is the number of valid total sums modulo MOD\n    return valid_sums % MOD\n\n# Read input\nn, m, L, R = map(int, input().split())\n\n# Calculate and print the result\nprint(count_valid_grids(n, m, L, R))"}
{"solution": "def is_possible(n, m, matrix_a, matrix_b):\n    for i in range(n):\n        for j in range(m):\n            # Get the values from both matrices at position (i, j)\n            a_val = matrix_a[i][j]\n            b_val = matrix_b[i][j]\n            # We need to ensure that the minimum value is at the current position\n            # and the maximum value is at the next position in the row and column\n            if i > 0:\n                if not (min(a_val, b_val) > min(matrix_a[i-1][j], matrix_b[i-1][j])):\n                    return \"Impossible\"\n            if j > 0:\n                if not (min(a_val, b_val) > min(matrix_a[i][j-1], matrix_b[i][j-1])):\n                    return \"Impossible\"\n            if i < n - 1:\n                if not (max(a_val, b_val) < min(matrix_a[i+1][j], matrix_b[i+1][j])):\n                    return \"Impossible\"\n            if j < m - 1:\n                if not (max(a_val, b_val) < min(matrix_a[i][j+1], matrix_b[i][j+1])):\n                    return \"Impossible\"\n    return \"Possible\"\n\n# Read input\nn, m = map(int, input().split())\nmatrix_a = [list(map(int, input().split())) for _ in range(n)]\nmatrix_b = [list(map(int, input().split())) for _ in range(n)]\n\n# Check if it's possible to make both matrices increasing\nresult = is_possible(n, m, matrix_a, matrix_b)\nprint(result)"}
{"solution": "def max_length_string(n, a):\n    a.sort(reverse=True)\n    used_counts = set()\n    total_length = 0\n\n    for count in a:\n        while count > 0 and count in used_counts:\n            count -= 1\n        if count > 0:\n            used_counts.add(count)\n            total_length += count\n\n    return total_length\n\nn = int(input())\na = list(map(int, input().split()))\nresult = max_length_string(n, a)\nprint(result)"}
{"solution": "def min_problems_to_solve(n, k, difficulties):\n    difficulties.sort()\n    count = 0\n    for difficulty in difficulties:\n        if k < difficulty / 2:\n            # We need to solve a problem with difficulty at least difficulty / 2\n            # Find the minimum difficulty we can solve\n            while k < difficulty / 2:\n                k *= 2  # Solve a problem with difficulty k\n                count += 1\n        # Now we can solve the current problem\n        k = max(k, difficulty)  # Update k to the maximum difficulty solved\n    return count\n\n# Input reading\nn, k = map(int, input().split())\ndifficulties = list(map(int, input().split()))\n\n# Output the result\nprint(min_problems_to_solve(n, k, difficulties))"}
{"solution": "n = int(input())\nmin_1, max_1 = map(int, input().split())\nmin_2, max_2 = map(int, input().split())\nmin_3, max_3 = map(int, input().split())\n\n# Start with the minimum required diplomas\nd1 = min_1\nd2 = min_2\nd3 = min_3\n\n# Calculate the remaining diplomas to distribute\nremaining = n - (d1 + d2 + d3)\n\n# Try to maximize the first degree diplomas\nif remaining > 0:\n    additional_d1 = min(max_1 - d1, remaining)\n    d1 += additional_d1\n    remaining -= additional_d1\n\n# Try to maximize the second degree diplomas\nif remaining > 0:\n    additional_d2 = min(max_2 - d2, remaining)\n    d2 += additional_d2\n    remaining -= additional_d2\n\n# The rest goes to the third degree diplomas\nd3 += remaining\n\nprint(d1, d2, d3)"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    print(-1)\nelse:\n    last = a[-1]\n    second_last = a[-2]\n\n    if last == 0:\n        print(\"UP\")\n    elif last == 15:\n        print(\"DOWN\")\n    elif last > second_last:\n        print(\"UP\")\n    elif last < second_last:\n        print(\"DOWN\")\n    else:\n        print(-1)"}
{"solution": "def can_transform(s, t):\n    if len(s) != len(t):\n        return \"No\"\n    \n    vowels = set('aeiou')\n    \n    for char_s, char_t in zip(s, t):\n        if (char_s in vowels) != (char_t in vowels):\n            return \"No\"\n    \n    return \"Yes\"\n\ns = input().strip()\nt = input().strip()\nprint(can_transform(s, t))"}
{"solution": "def pawn_chess_winner(board):\n    white_positions = []\n    black_positions = []\n    \n    for r in range(8):\n        for c in range(8):\n            if board[r][c] == 'W':\n                white_positions.append(r)\n            elif board[r][c] == 'B':\n                black_positions.append(r)\n    \n    # Calculate the minimum moves for player A (white) to reach row 1\n    min_white_moves = min(white_positions) if white_positions else float('inf')\n    # Calculate the minimum moves for player B (black) to reach row 8\n    min_black_moves = 8 - max(black_positions) if black_positions else float('inf')\n    \n    if min_white_moves <= min_black_moves:\n        return 'A'\n    else:\n        return 'B'\n\n# Read the board input\nboard = [input().strip() for _ in range(8)]\nprint(pawn_chess_winner(board))"}
{"solution": "def max_equal_length(n, A, m, B):\n    from collections import defaultdict\n\n    def get_prefix_sums(arr):\n        prefix_sums = []\n        current_sum = 0\n        for num in arr:\n            current_sum += num\n            if not prefix_sums or prefix_sums[-1] != current_sum:\n                prefix_sums.append(current_sum)\n        return prefix_sums\n\n    prefix_A = get_prefix_sums(A)\n    prefix_B = get_prefix_sums(B)\n\n    count_A = defaultdict(int)\n    count_B = defaultdict(int)\n\n    for sum_A in prefix_A:\n        count_A[sum_A] += 1\n\n    for sum_B in prefix_B:\n        count_B[sum_B] += 1\n\n    max_length = 0\n    for sum_value in count_A:\n        if sum_value in count_B:\n            max_length = max(max_length, count_A[sum_value] + count_B[sum_value])\n\n    return max_length if max_length > 0 else -1\n\n# Input reading\nn = int(input().strip())\nA = list(map(int, input().strip().split()))\nm = int(input().strip())\nB = list(map(int, input().strip().split()))\n\n# Output the result\nprint(max_equal_length(n, A, m, B))"}
{"solution": "def is_problem_from_contest(problem_name):\n    friends = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\n    count = 0\n    \n    for friend in friends:\n        count += problem_name.count(friend)\n    \n    return \"YES\" if count == 1 else \"NO\"\n\nproblem_name = input().strip()\nprint(is_problem_from_contest(problem_name))"}
{"solution": "def sieve_of_eratosthenes(n):\n    is_prime = [True] * (n + 1)\n    p = 2\n    while (p * p <= n):\n        if (is_prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                is_prime[i] = False\n        p += 1\n    is_prime[0], is_prime[1] = False, False\n    return is_prime\n\ndef min_length(a, b, k):\n    is_prime = sieve_of_eratosthenes(b)\n    prime_count = [0] * (b + 1)\n\n    for i in range(a, b + 1):\n        prime_count[i] = prime_count[i - 1] + (1 if is_prime[i] else 0)\n\n    for l in range(1, b - a + 2):\n        valid = True\n        for x in range(a, b - l + 2):\n            if prime_count[x + l - 1] - prime_count[x - 1] < k:\n                valid = False\n                break\n        if valid:\n            return l\n\n    return -1\n\na, b, k = map(int, input().split())\nprint(min_length(a, b, k))"}
{"solution": "def minimum_x(a, h, w):\n    # Check if it's possible to place at least one photo\n    if a > h or a > w:\n        return -1\n    \n    # Calculate the maximum number of photos that can fit in height and width\n    max_rows = h // a\n    max_cols = w // a\n    \n    # If we can fit at least one photo in both dimensions\n    if max_rows == 0 or max_cols == 0:\n        return -1\n    \n    # Calculate the remaining space after placing the photos\n    remaining_height = h - (max_rows * a)\n    remaining_width = w - (max_cols * a)\n    \n    # Calculate the minimum x\n    x_height = remaining_height / (max_rows + 1)\n    x_width = remaining_width / (max_cols + 1)\n    \n    return min(x_height, x_width)\n\n# Input reading\na, h, w = map(int, input().split())\nresult = minimum_x(a, h, w)\n\n# Output the result\nprint(f\"{result:.10f}\")"}
{"solution": "n = int(input())\nchapters = [tuple(map(int, input().split())) for _ in range(n)]\nk = int(input())\n\nunread_chapters = 0\n\nfor l, r in chapters:\n    if k <= r:\n        unread_chapters += 1\n\nprint(unread_chapters)"}
{"solution": "def can_form_codeforces(banner):\n    target = \"CODEFORCES\"\n    n = len(banner)\n    m = len(target)\n\n    # Check all possible ways to cut the substring\n    for i in range(m + 1):\n        # Take the first i characters from target and the last (m - i) characters\n        prefix = target[:i]\n        suffix = target[i:]\n        \n        # Check if the prefix is in the beginning of the banner and suffix is at the end\n        if banner.startswith(prefix) and banner.endswith(suffix):\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nbanner = input().strip()\n# Output the result\nprint(can_form_codeforces(banner))"}
{"solution": "def min_triangulation_weight(n):\n    # Create a DP table to store the minimum weights\n    dp = [[0] * n for _ in range(n)]\n    \n    # Fill the DP table\n    for length in range(2, n):  # length of the polygon side\n        for i in range(n - length):\n            j = i + length\n            dp[i][j] = float('inf')\n            for k in range(i + 1, j):\n                weight = (i + 1) * (k + 1) * (j + 1)  # weight of triangle (i, k, j)\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + weight)\n    \n    return dp[0][n - 1]\n\nn = int(input())\nprint(min_triangulation_weight(n))"}
{"solution": "def count_digits(n):\n    digits = 0\n    length = 1\n    current_limit = 10\n    \n    while n >= current_limit:\n        digits += length * (current_limit - (current_limit // 10))\n        length += 1\n        current_limit *= 10\n    \n    digits += length * (n - (current_limit // 10) + 1)\n    \n    return digits\n\nn = int(input())\nprint(count_digits(n))"}
{"solution": "def find_winning_color(n, A, cars):\n    count_A = 0\n    count_B = {}\n    \n    for car in cars:\n        if car == A:\n            count_A += 1\n        else:\n            if car not in count_B:\n                count_B[car] = 0\n            count_B[car] += 1\n            \n    for B, count_B_value in count_B.items():\n        if B != A:\n            if count_B_value >= count_A:\n                # Check if cnt_B(i) >= cnt_A(i) for all i\n                cnt_A = 0\n                cnt_B = 0\n                valid = True\n                for car in cars:\n                    if car == A:\n                        cnt_A += 1\n                    elif car == B:\n                        cnt_B += 1\n                    if cnt_B < cnt_A:\n                        valid = False\n                        break\n                if valid:\n                    return B\n    return -1\n\n# Input reading\nn, A = map(int, input().split())\ncars = list(map(int, input().split()))\n\n# Finding the winning color\nresult = find_winning_color(n, A, cars)\nprint(result)"}
{"solution": "n, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculate the total length required for the segments and the necessary gaps\ntotal_length = sum(a)\ngaps = n - 1  # There are n-1 gaps between n segments\n\n# The total length of the crossword must equal the total length of segments plus the gaps\nif total_length + gaps == x:\n    print(\"YES\")\nelse:\n    print(\"NO\")"}
{"solution": "n, S = map(int, input().split())\nmin_coins = (S + n - 1) // n\nprint(min_coins)"}
{"solution": "def smallest_palindrome(s):\n    from collections import Counter\n\n    # Count frequency of each character\n    count = Counter(s)\n    \n    # Prepare to build the palindrome\n    half_palindrome = []\n    odd_char = None\n    \n    # Create half of the palindrome\n    for char in sorted(count.keys()):\n        if count[char] % 2 == 1:\n            if odd_char is None or char < odd_char:\n                if odd_char is not None:\n                    half_palindrome.append(odd_char)\n                odd_char = char\n            else:\n                half_palindrome.append(char)\n        half_palindrome.extend([char] * (count[char] // 2))\n    \n    # Create the first half of the palindrome\n    first_half = ''.join(half_palindrome)\n    \n    # Create the second half by reversing the first half\n    second_half = first_half[::-1]\n    \n    # If there's an odd character, add it in the middle\n    if odd_char:\n        palindrome = first_half + odd_char + second_half\n    else:\n        palindrome = first_half + second_half\n    \n    return palindrome\n\n# Read input\ns = input().strip()\n# Get the result\nresult = smallest_palindrome(s)\n# Print the result\nprint(result)"}
{"solution": "def calculate_weight(board):\n    piece_weights = {\n        'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'P': 1,\n        'q': 9, 'r': 5, 'b': 3, 'n': 3, 'p': 1\n    }\n    \n    white_weight = 0\n    black_weight = 0\n    \n    for row in board:\n        for piece in row:\n            if piece in piece_weights:\n                if piece.isupper():\n                    white_weight += piece_weights[piece]\n                else:\n                    black_weight += piece_weights[piece]\n    \n    if white_weight > black_weight:\n        return \"White\"\n    elif black_weight > white_weight:\n        return \"Black\"\n    else:\n        return \"Draw\"\n\n# Read the board input\nboard = [input().strip() for _ in range(8)]\nresult = calculate_weight(board)\nprint(result)"}
{"solution": "from collections import deque\n\ndef find_shortest_sequence(N, M, S):\n    # BFS initialization\n    queue = deque([(0, [])])  # (current square, path)\n    visited = [False] * (N + 1)\n    visited[0] = True\n    \n    while queue:\n        current_square, path = queue.popleft()\n        \n        # Try all possible moves\n        for move in range(1, M + 1):\n            next_square = current_square + move\n            \n            if next_square > N:\n                continue\n            if S[next_square] == '1':\n                continue\n            \n            if next_square == N:\n                return path + [move]\n            \n            if not visited[next_square]:\n                visited[next_square] = True\n                queue.append((next_square, path + [move]))\n    \n    return -1\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    S = data[2]\n    \n    result = find_shortest_sequence(N, M, S)\n    \n    if result == -1:\n        print(-1)\n    else:\n        print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def can_finish_game(K, X, Y):\n    # Calculate the Manhattan distance to the target\n    manhattan_distance = abs(X) + abs(Y)\n    \n    # Check if it's possible to reach the target\n    if manhattan_distance % K != 0 or manhattan_distance < K:\n        return -1\n    \n    # Calculate the number of strokes needed\n    s = manhattan_distance // K\n    \n    # Prepare the path\n    path = []\n    current_x, current_y = 0, 0\n    \n    for _ in range(s):\n        # Calculate the next point to move to\n        if abs(X - current_x) >= K:\n            next_x = current_x + K if X > current_x else current_x - K\n            next_y = current_y\n        elif abs(Y - current_y) >= K:\n            next_x = current_x\n            next_y = current_y + K if Y > current_y else current_y - K\n        else:\n            # Move diagonally if we are close enough\n            if X > current_x and Y > current_y:\n                next_x = current_x + K\n                next_y = current_y + K\n            elif X < current_x and Y < current_y:\n                next_x = current_x - K\n                next_y = current_y - K\n            elif X > current_x and Y < current_y:\n                next_x = current_x + K\n                next_y = current_y - K\n            else:\n                next_x = current_x - K\n                next_y = current_y + K\n        \n        path.append((next_x, next_y))\n        current_x, current_y = next_x, next_y\n    \n    # Add the final position\n    path.append((X, Y))\n    \n    return s + 1, path\n\nimport sys\ninput = sys.stdin.read\nK, X, Y = map(int, input().strip().split())\n\nresult = can_finish_game(K, X, Y)\n\nif result == -1:\n    print(-1)\nelse:\n    s, path = result\n    print(s)\n    for x, y in path:\n        print(x, y)"}
{"solution": "def find_min_n(m):\n    if m == 1:\n        return 8\n    \n    count = 0\n    n = 0\n    \n    for k in range(2, 10**6):\n        total = 0\n        current = 1\n        while current <= 10**15:\n            total += 1\n            current *= k\n        \n        if total > 0:\n            n_candidate = (current - 1) // (k - 1)\n            if n_candidate > 0:\n                count += 1\n                if count == m:\n                    n = n_candidate\n                    break\n    \n    return n if n > 0 else -1\n\nm = int(input().strip())\nprint(find_min_n(m))"}
{"solution": "import math\n\ndef circle_intersection_area(x1, y1, r1, x2, y2, r2):\n    d = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\n    if d >= r1 + r2:\n        return 0.0\n    if d <= abs(r1 - r2):\n        return math.pi * min(r1, r2) ** 2\n\n    r1_sq = r1 ** 2\n    r2_sq = r2 ** 2\n\n    part1 = r1_sq * math.acos((d ** 2 + r1_sq - r2_sq) / (2 * d * r1))\n    part2 = r2_sq * math.acos((d ** 2 + r2_sq - r1_sq) / (2 * d * r2))\n    part3 = 0.5 * math.sqrt((-d + r1 + r2) * (d + r1 - r2) * (d - r1 + r2) * (d + r1 + r2))\n\n    return part1 + part2 - part3\n\nx1, y1, r1 = map(int, input().split())\nx2, y2, r2 = map(int, input().split())\n\narea = circle_intersection_area(x1, y1, r1, x2, y2, r2)\nprint(f\"{area:.20f}\")"}
{"solution": "def min_value_after_operations(v):\n    if v == 1:\n        return 1\n    # The minimum value of n we can achieve is 1\n    return 1\n\nv = int(input())\nprint(min_value_after_operations(v))"}
{"solution": "def main():\n    import sys\n    from collections import defaultdict\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    p = list(map(int, data[1:n]))\n    a = list(map(int, data[n:2*n]))\n\n    # Build the tree structure\n    tree = defaultdict(list)\n    for i in range(2, n + 1):\n        tree[p[i - 2]].append(i)\n\n    # To store the maximum citizens that can be caught\n    def dfs(node):\n        total_citizens = a[node - 1]\n        children_citizens = []\n        \n        for child in tree[node]:\n            child_citizens = dfs(child)\n            children_citizens.append(child_citizens)\n        \n        if not children_citizens:\n            return total_citizens\n        \n        # Sort children by the number of citizens they can potentially catch\n        children_citizens.sort(reverse=True)\n        \n        # Citizens can be distributed among children\n        for i in range(len(children_citizens)):\n            if i < total_citizens:\n                total_citizens -= 1\n                children_citizens[i] += 1\n        \n        return sum(children_citizens)\n\n    result = dfs(1)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def count_possible_words(n, S, T):\n    count = 0\n    for i in range(n):\n        if S[i] != T[i]:\n            # Check the two possible positions for the extra character\n            if S[i+1:] == T[i:] or S[i:] == T[i+1:]:\n                count += 1\n            break\n    else:\n        # If we didn't break, it means S and T are the same until the last character\n        count += 1  # The last character can be different\n    \n    return count\n\nn = int(input().strip())\nS = input().strip()\nT = input().strip()\n\nresult = count_possible_words(n, S, T)\nprint(result)"}
{"solution": "def min_computer_strength(n, strengths, edges):\n    from collections import defaultdict, deque\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    max_strength = max(strengths)\n    min_strength = max_strength\n\n    for i in range(n):\n        if strengths[i] < 0:\n            continue\n        current_strength = strengths[i]\n        for neighbor in graph[i + 1]:\n            if strengths[neighbor - 1] > current_strength:\n                current_strength = strengths[neighbor - 1]\n        min_strength = min(min_strength, current_strength + 1)\n\n    return min_strength\n\n# Input reading\nn = int(input())\nstrengths = list(map(int, input().split()))\nedges = [tuple(map(int, input().split())) for _ in range(n - 1)]\n\n# Output the result\nprint(min_computer_strength(n, strengths, edges))"}
{"solution": "def max_groups(n, m):\n    if m == 0:\n        return 1\n    elif m >= n:\n        return 0\n    else:\n        return min(m, n - m)\n\nn, m = map(int, input().split())\nprint(max_groups(n, m))"}
{"solution": "k, r = map(int, input().split())\n\nfor n in range(1, 11):\n    total_cost = n * k\n    if total_cost % 10 == 0 or total_cost % 10 == r:\n        print(n)\n        break"}
{"solution": "def can_form_rectangle(n, m, grid):\n    # Find the bounding box of the 'X' characters\n    min_row, max_row = n, -1\n    min_col, max_col = m, -1\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'X':\n                if i < min_row:\n                    min_row = i\n                if i > max_row:\n                    max_row = i\n                if j < min_col:\n                    min_col = j\n                if j > max_col:\n                    max_col = j\n    \n    # Calculate the dimensions of the bounding box\n    height = max_row - min_row + 1\n    width = max_col - min_col + 1\n    \n    # Check if the bounding box is filled with 'X'\n    for i in range(min_row, max_row + 1):\n        for j in range(min_col, max_col + 1):\n            if grid[i][j] != 'X':\n                return \"NO\"\n    \n    # Check if the area of the bounding box can accommodate two pieces\n    if height * width % 2 == 0:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(can_form_rectangle(n, m, grid))"}
{"solution": "def min_segments(points):\n    x_coords = sorted([p[0] for p in points])\n    y_coords = sorted([p[1] for p in points])\n    \n    if x_coords[0] == x_coords[2] or y_coords[0] == y_coords[2]:\n        return 1\n    elif (x_coords[0] == x_coords[1] or x_coords[1] == x_coords[2]) or (y_coords[0] == y_coords[1] or y_coords[1] == y_coords[2]):\n        return 2\n    else:\n        return 3\n\npoints = [tuple(map(int, input().split())) for _ in range(3)]\nprint(min_segments(points))"}
{"solution": "def k_regular_graph_with_bridge(k):\n    if k == 1:\n        print(\"YES\")\n        print(2, 1)\n        print(1, 2)\n        return\n    \n    if k % 2 == 1 or k > 2 * 10**6:\n        print(\"NO\")\n        return\n    \n    n = k + 1\n    edges = []\n    \n    for i in range(1, n):\n        edges.append((i, i + 1))\n    \n    edges.append((n, 1))  # Connect the last vertex to the first to make it a cycle\n    edges.pop()  # Remove the last edge to ensure there's a bridge\n    \n    for i in range(1, n):\n        for j in range(i + 1, n + 1):\n            if len(edges) < n * k // 2:\n                edges.append((i, j))\n    \n    print(\"YES\")\n    print(n, len(edges))\n    for a, b in edges:\n        print(a, b)\n\nk = int(input().strip())\nk_regular_graph_with_bridge(k)"}
{"solution": "def count_occurrences(s, t, queries):\n    n = len(s)\n    m = len(t)\n    \n    # Precompute occurrences of t in s\n    occurrences = [0] * (n + 1)\n    \n    for i in range(n - m + 1):\n        if s[i:i + m] == t:\n            occurrences[i + 1] = 1\n    \n    # Create a prefix sum array\n    for i in range(1, n + 1):\n        occurrences[i] += occurrences[i - 1]\n    \n    results = []\n    for l, r in queries:\n        if r - l + 1 < m:\n            results.append(0)\n        else:\n            results.append(occurrences[r - m + 1] - occurrences[l - 1])\n    \n    return results\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nn, m, q = map(int, data[0].split())\ns = data[1]\nt = data[2]\nqueries = [tuple(map(int, line.split())) for line in data[3:]]\n\n# Get results\nresults = count_occurrences(s, t, queries)\n\n# Print results\nfor result in results:\n    print(result)"}
{"solution": "def count_paths(n, k, d):\n    MOD = 1000000007\n    \n    # dp[i] will store the number of ways to reach weight i without the restriction of d\n    dp = [0] * (n + 1)\n    dp[0] = 1  # There's one way to have a path of weight 0 (the empty path)\n    \n    # Calculate the number of ways to reach each weight from 1 to n\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            if i - j >= 0:\n                dp[i] = (dp[i] + dp[i - j]) % MOD\n    \n    # Now we need to calculate the number of ways to reach weight n without using any edge of weight >= d\n    dp_no_d = [0] * (n + 1)\n    dp_no_d[0] = 1  # There's one way to have a path of weight 0 (the empty path)\n    \n    # Calculate the number of ways to reach each weight from 1 to n without using edges of weight >= d\n    for i in range(1, n + 1):\n        for j in range(1, min(k, d - 1) + 1):\n            if i - j >= 0:\n                dp_no_d[i] = (dp_no_d[i] + dp_no_d[i - j]) % MOD\n    \n    # The result is the total paths minus the paths that do not use any edge of weight >= d\n    result = (dp[n] - dp_no_d[n]) % MOD\n    return result\n\n# Read input\nn, k, d = map(int, input().split())\n# Print the result\nprint(count_paths(n, k, d))"}
{"solution": "n = int(input().strip())\nrow = input().strip()\n\ngroups = []\ncount = 0\n\nfor char in row:\n    if char == 'B':\n        count += 1\n    else:\n        if count > 0:\n            groups.append(count)\n            count = 0\n\nif count > 0:\n    groups.append(count)\n\nprint(len(groups))\nif groups:\n    print(' '.join(map(str, groups)))"}
{"solution": "def find_pair(brackets):\n    stack = []\n    pairs = {}\n    for i, char in enumerate(brackets):\n        if char == '(':\n            stack.append(i)\n        else:\n            if stack:\n                opening_index = stack.pop()\n                pairs[opening_index] = i\n                pairs[i] = opening_index\n    return pairs\n\ndef process_editor(n, m, p, brackets, operations):\n    pairs = find_pair(brackets)\n    cursor = p - 1  # Convert to 0-based index\n    deleted = [False] * n\n\n    for operation in operations:\n        if operation == 'L':\n            cursor -= 1\n        elif operation == 'R':\n            cursor += 1\n        elif operation == 'D':\n            start = cursor\n            end = pairs[cursor]\n            if start > end:\n                start, end = end, start\n            \n            for i in range(start, end + 1):\n                deleted[i] = True\n            \n            # Move cursor to the nearest non-deleted bracket\n            next_cursor = cursor + 1\n            while next_cursor < n and deleted[next_cursor]:\n                next_cursor += 1\n            if next_cursor >= n:\n                next_cursor = cursor - 1\n                while next_cursor >= 0 and deleted[next_cursor]:\n                    next_cursor -= 1\n            cursor = next_cursor\n\n    result = ''.join(brackets[i] for i in range(n) if not deleted[i])\n    return result\n\n# Input reading\nn, m, p = map(int, input().split())\nbrackets = input().strip()\noperations = input().strip()\n\n# Process and output the result\nresult = process_editor(n, m, p, brackets, operations)\nprint(result)"}
{"solution": "def find_y(n, questions):\n    lower_bound = -2 * 10**9\n    upper_bound = 2 * 10**9\n\n    for sign, x, answer in questions:\n        x = int(x)\n        if sign == '>':\n            if answer == 'Y':\n                lower_bound = max(lower_bound, x + 1)\n            else:\n                upper_bound = min(upper_bound, x)\n        elif sign == '<':\n            if answer == 'Y':\n                upper_bound = min(upper_bound, x - 1)\n            else:\n                lower_bound = max(lower_bound, x)\n        elif sign == '>=':\n            if answer == 'Y':\n                lower_bound = max(lower_bound, x)\n            else:\n                upper_bound = min(upper_bound, x - 1)\n        elif sign == '<=':\n            if answer == 'Y':\n                upper_bound = min(upper_bound, x)\n            else:\n                lower_bound = max(lower_bound, x + 1)\n\n    if lower_bound <= upper_bound:\n        return lower_bound\n    else:\n        return \"Impossible\"\n\nn = int(input())\nquestions = [input().split() for _ in range(n)]\nresult = find_y(n, questions)\nprint(result)"}
{"solution": "def count_different_periods(a, b):\n    # The maximum period can be a + b\n    max_period = a + b\n    # The minimum period can be the maximum of a and b\n    min_period = max(a, b)\n    \n    # The number of different periods is the range from min_period to max_period\n    return max_period - min_period + 1\n\n# Read input\na, b = map(int, input().split())\n# Calculate and print the result\nprint(count_different_periods(a, b))"}
{"solution": "def find_soldier_names(n, k, effectiveness):\n    names = [\"\"] * n\n    current_name_index = 0\n    unique_names = []\n\n    for i in range(n - k + 1):\n        if effectiveness[i] == \"YES\":\n            # If the group is effective, we need to ensure all names are unique\n            for j in range(k):\n                if names[i + j] == \"\":\n                    while True:\n                        name = f\"Name{current_name_index + 1}\"\n                        if name not in unique_names:\n                            names[i + j] = name\n                            unique_names.append(name)\n                            current_name_index += 1\n                            break\n                else:\n                    unique_names.append(names[i + j])\n        else:\n            # If the group is not effective, we need to have at least one duplicate\n            for j in range(k):\n                if names[i + j] == \"\":\n                    names[i + j] = f\"Name{current_name_index + 1}\"\n                    unique_names.append(names[i + j])\n                    current_name_index += 1\n                elif j == 0:\n                    # Ensure the first soldier in the group is the same as the last soldier in the previous group\n                    names[i + j] = names[i - 1]\n    \n    # Fill in any remaining empty names with unique names\n    for i in range(n):\n        if names[i] == \"\":\n            while True:\n                name = f\"Name{current_name_index + 1}\"\n                if name not in unique_names:\n                    names[i] = name\n                    unique_names.append(name)\n                    current_name_index += 1\n                    break\n\n    return names\n\n# Read input\nn, k = map(int, input().split())\neffectiveness = input().split()\n\n# Get the soldier names\nresult = find_soldier_names(n, k, effectiveness)\n\n# Print the result\nprint(\" \".join(result))"}
{"solution": "def min_operations_to_equal(a, b):\n    if a == b:\n        return 0\n\n    def reduce(n):\n        operations = 0\n        while n % 2 == 0:\n            n //= 2\n            operations += 1\n        while n % 3 == 0:\n            n //= 3\n            operations += 1\n        while n % 5 == 0:\n            n //= 5\n            operations += 1\n        return n, operations\n\n    reduced_a, ops_a = reduce(a)\n    reduced_b, ops_b = reduce(b)\n\n    if reduced_a != reduced_b:\n        return -1\n\n    return ops_a + ops_b\n\na, b = map(int, input().split())\nprint(min_operations_to_equal(a, b))"}
{"solution": "def min_cost_palindrome(n, a, b, colors):\n    cost = 0\n    for i in range((n + 1) // 2):\n        left = colors[i]\n        right = colors[n - 1 - i]\n        \n        if left == 2 and right == 2:\n            cost += 2 * min(a, b)  # Buy both suits\n        elif left == 2:\n            cost += a if right == 0 else b  # Buy suit for left\n        elif right == 2:\n            cost += a if left == 0 else b  # Buy suit for right\n        elif left != right:\n            return -1  # Cannot form a palindrome\n    \n    return cost\n\n# Input reading\nn, a, b = map(int, input().split())\ncolors = list(map(int, input().split()))\n\n# Output the result\nprint(min_cost_palindrome(n, a, b, colors))"}
{"solution": "def paint_cube(k):\n    if k == 1:\n        return -1\n    \n    cube = []\n    \n    for z in range(k):\n        layer = []\n        for x in range(k):\n            row = []\n            for y in range(k):\n                if (x + y + z) % 2 == 0:\n                    row.append('b')\n                else:\n                    row.append('w')\n            layer.append(''.join(row))\n        cube.append(layer)\n    \n    return cube\n\nk = int(input().strip())\nresult = paint_cube(k)\n\nif result == -1:\n    print(-1)\nelse:\n    for layer in result:\n        for row in layer:\n            print(row)\n        print()  # Print an empty line between layers"}
{"solution": "def largest_lovely_number(n):\n    # To find the largest lovely number, we need to remove all prime factors with exponent >= 2\n    lovely_number = 1\n    factor = 2\n    \n    while factor * factor <= n:\n        if n % (factor * factor) == 0:\n            # If factor^2 divides n, we should not include this factor in the lovely number\n            while n % (factor * factor) == 0:\n                n //= (factor * factor)\n        else:\n            # If factor^2 does not divide n, we can include this factor\n            lovely_number *= factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    \n    # If there's any prime factor left in n, it can be included\n    if n > 1:\n        lovely_number *= n\n    \n    return lovely_number\n\nn = int(input().strip())\nprint(largest_lovely_number(n))"}
{"solution": "n = int(input().strip())\nseating = input().strip()\n\n# Check for adjacent occupied seats\nfor i in range(n - 1):\n    if seating[i] == '1' and seating[i + 1] == '1':\n        print(\"No\")\n        break\nelse:\n    # Check if there's a possibility to add another person\n    for i in range(n):\n        if seating[i] == '0':\n            # Check if the seat is not adjacent to an occupied seat\n            if (i == 0 or seating[i - 1] == '0') and (i == n - 1 or seating[i + 1] == '0'):\n                print(\"No\")\n                break\n    else:\n        print(\"Yes\")"}
{"solution": "def find_possible_lengths(n, a):\n    possible_lengths = []\n    \n    for k in range(1, n + 1):\n        x = [0] * k\n        valid = True\n        \n        for i in range(n):\n            idx = i % k\n            if i == 0:\n                x[idx] = a[i]\n            else:\n                expected_value = a[i] - a[i - 1]\n                if x[idx] == 0:\n                    x[idx] = expected_value\n                elif x[idx] != expected_value:\n                    valid = False\n                    break\n        \n        if valid:\n            possible_lengths.append(k)\n    \n    return possible_lengths\n\nn = int(input())\na = list(map(int, input().split()))\n\npossible_lengths = find_possible_lengths(n, a)\n\nprint(len(possible_lengths))\nprint(\" \".join(map(str, possible_lengths)))"}
{"solution": "from itertools import combinations\n\ndef can_form_equal_teams(scores):\n    total_score = sum(scores)\n    \n    if total_score % 2 != 0:\n        return \"NO\"\n    \n    target = total_score // 2\n    for team in combinations(scores, 3):\n        if sum(team) == target:\n            return \"YES\"\n    \n    return \"NO\"\n\nscores = list(map(int, input().split()))\nprint(can_form_equal_teams(scores))"}
{"solution": "def count_2_3_integers(l, r):\n    count = 0\n    power_of_2 = 1\n    \n    while power_of_2 <= r:\n        power_of_3 = 1\n        while power_of_2 * power_of_3 <= r:\n            number = power_of_2 * power_of_3\n            if l <= number <= r:\n                count += 1\n            power_of_3 *= 3\n        power_of_2 *= 2\n    \n    return count\n\nl, r = map(int, input().split())\nprint(count_2_3_integers(l, r))"}
{"solution": "def candies_eaten(n, k):\n    # Let x be the number of candies eaten\n    # The total number of candies put in the box is the sum of the first (x + 1) natural numbers\n    # Total candies put = (x + 1) * (x + 2) / 2\n    # The final number of candies in the box is given by:\n    # final_candies = total_candies_put - x\n    # Therefore, we have:\n    # k = (x + 1) * (x + 2) / 2 - x\n    # Rearranging gives us:\n    # k = (x + 1) * (x + 2) / 2 - x\n    # 2k = (x + 1)(x + 2) - 2x\n    # 2k = x^2 + 3x + 2 - 2x\n    # 2k = x^2 + x + 2\n    # x^2 + x + (2 - 2k) = 0\n    # Using the quadratic formula to solve for x:\n    \n    a = 1\n    b = 1\n    c = 2 - 2 * k\n    \n    discriminant = b * b - 4 * a * c\n    x = (-b + discriminant**0.5) / (2 * a)\n    \n    # Since x must be an integer, we take the integer part\n    x = int(x)\n    \n    # Check if x is valid\n    while x < 0 or (x + 1) * (x + 2) // 2 - x != k:\n        x += 1\n    \n    return x\n\nn, k = map(int, input().split())\nprint(candies_eaten(n, k))"}
{"solution": "def can_form_triangle(n, lengths):\n    lengths.sort()\n    for i in range(n - 2):\n        if lengths[i] + lengths[i + 1] > lengths[i + 2]:\n            return \"YES\"\n    return \"NO\"\n\nn = int(input())\nlengths = list(map(int, input().split()))\nprint(can_form_triangle(n, lengths))"}
{"solution": "def can_get_toys(x, y):\n    # Check if the number of original toys is at least 1\n    if y < 1:\n        return \"No\"\n    \n    # Calculate the maximum number of copies that can be generated\n    # The number of original toys must be at least y\n    # The number of copies must be at least x\n    # The total number of toys must be y + x\n    # The number of original toys must be at least (y - 1) to generate x copies\n    if (y - 1) * 2 < x or y + x < 1:\n        return \"No\"\n    \n    return \"Yes\"\n\n# Read input\nx, y = map(int, input().split())\n# Print the result\nprint(can_get_toys(x, y))"}
{"solution": "def max_rating(n, k, skills):\n    # Calculate initial rating\n    initial_rating = sum(skill // 10 for skill in skills)\n    \n    # Create a list to store the cost to reach the next multiple of 10 for each skill\n    costs = []\n    for skill in skills:\n        if skill < 100:\n            next_tenth = (skill // 10 + 1) * 10\n            cost = next_tenth - skill\n            if cost <= 100 - skill:\n                costs.append(cost)\n    \n    # Sort costs to use the least units first\n    costs.sort()\n    \n    # Use improvement units to maximize rating\n    additional_rating = 0\n    for cost in costs:\n        if k >= cost:\n            k -= cost\n            additional_rating += 1\n        else:\n            break\n    \n    # Each additional rating point corresponds to an increase of 10 in skill\n    return initial_rating + additional_rating\n\n# Input reading\nn, k = map(int, input().split())\nskills = list(map(int, input().split()))\n\n# Output the result\nprint(max_rating(n, k, skills))"}
{"solution": "n, m = map(int, input().split())\nlist_a = set(input().split())\nlist_b = set(input().split())\n\n# Find the intersection of both lists\ncommon_digits = list_a.intersection(list_b)\n\nif common_digits:\n    # If there are common digits, the smallest pretty integer is the smallest common digit\n    print(min(common_digits))\nelse:\n    # If there are no common digits, form the smallest pretty integer\n    smallest_a = min(list_a)\n    smallest_b = min(list_b)\n    # The smallest pretty integer can be formed by combining the smallest digits from both lists\n    print(min(int(smallest_a + smallest_b), int(smallest_b + smallest_a)))"}
{"solution": "n, k = map(int, input().split())\ntotal_time = 240 - k  # Total time available for solving problems\n\ntime_spent = 0\nproblems_solved = 0\n\nfor i in range(1, n + 1):\n    time_spent += 5 * i\n    if time_spent <= total_time:\n        problems_solved += 1\n    else:\n        break\n\nprint(problems_solved)"}
{"solution": "def can_print(teams, x, y, mid):\n    needed_x = 0\n    needed_y = 0\n    \n    for pages in teams[:mid]:\n        if pages % 2 == 0:\n            needed_x += pages // 2\n        else:\n            needed_x += pages // 2\n            needed_y += 1\n            \n    needed_x = max(0, needed_x - x)\n    \n    if needed_x > 0:\n        needed_y += needed_x\n    \n    return needed_y <= y\n\ndef max_teams(n, x, y, a):\n    left, right = 0, n\n    \n    while left < right:\n        mid = (left + right + 1) // 2\n        if can_print(a, x, y, mid):\n            left = mid\n        else:\n            right = mid - 1\n            \n    return left\n\nn, x, y = map(int, input().split())\na = list(map(int, input().split()))\n\nprint(max_teams(n, x, y, a))"}
{"solution": "def count_different_numbers(b):\n    divisors = set()\n    for i in range(1, int(b**0.5) + 1):\n        if b % i == 0:\n            divisors.add(i)\n            divisors.add(b // i)\n    \n    return len(divisors)\n\nb = int(input())\nprint(count_different_numbers(b))"}
{"solution": "def count_falling_positions(n, bumpers):\n    count = 0\n    \n    # Check positions from the left\n    for i in range(n):\n        if bumpers[i] == '<':\n            count += 1\n        else:\n            break\n    \n    # Check positions from the right\n    for i in range(n - 1, -1, -1):\n        if bumpers[i] == '>':\n            count += 1\n        else:\n            break\n    \n    return count\n\nn = int(input().strip())\nbumpers = input().strip()\nresult = count_falling_positions(n, bumpers)\nprint(result)"}
{"solution": "def max_rectangle_area(n, lengths):\n    from collections import Counter\n\n    # Count the occurrences of each length\n    count = Counter(lengths)\n    \n    # Prepare a list to store pairs of lengths that can form rectangles\n    pairs = []\n    \n    # Check for each length and its count\n    for length in sorted(count.keys()):\n        # Calculate how many pairs we can form with the current length\n        pairs_count = count[length] // 2\n        if pairs_count > 0:\n            pairs.extend([length] * pairs_count)\n        \n        # Check if we can form pairs with the length reduced by 1\n        if length > 1:\n            reduced_length = length - 1\n            if reduced_length in count:\n                pairs_count = count[reduced_length] // 2\n                if pairs_count > 0:\n                    pairs.extend([reduced_length] * pairs_count)\n\n    # Now we have a list of lengths that can form pairs\n    total_area = 0\n    # We can form rectangles from pairs of pairs\n    for i in range(0, len(pairs) - 1, 2):\n        total_area += pairs[i] * pairs[i + 1]\n\n    return total_area\n\n# Input reading\nn = int(input())\nlengths = list(map(int, input().split()))\n\n# Calculate and print the maximum total area\nprint(max_rectangle_area(n, lengths))"}
{"solution": "def min_sum_after_restoration(n, strings):\n    from collections import defaultdict\n\n    # To store the contribution of each letter\n    letter_value = defaultdict(int)\n    leading_letters = set()\n\n    # Calculate the contribution of each letter\n    for s in strings:\n        length = len(s)\n        for i, char in enumerate(s):\n            # The position of the character determines its weight\n            letter_value[char] += 10 ** (length - i - 1)\n            if i == 0:\n                leading_letters.add(char)\n\n    # Sort letters by their contribution in descending order\n    sorted_letters = sorted(letter_value.items(), key=lambda x: -x[1])\n    \n    # Assign digits to letters\n    digit_assignment = {}\n    used_digits = set()\n    \n    # Assign the first digit (1-9) to leading letters if any\n    digit = 1\n    for char, _ in sorted_letters:\n        if char in leading_letters:\n            digit_assignment[char] = digit\n            used_digits.add(digit)\n            digit += 1\n            break\n\n    # Assign remaining digits (0-9) to the rest of the letters\n    for char, _ in sorted_letters:\n        if char not in digit_assignment:\n            while digit in used_digits:\n                digit += 1\n            digit_assignment[char] = digit\n            used_digits.add(digit)\n            digit += 1\n\n    # Calculate the minimum sum\n    total_sum = 0\n    for s in strings:\n        number = 0\n        for char in s:\n            number = number * 10 + digit_assignment[char]\n        total_sum += number\n\n    return total_sum\n\n# Input reading\nn = int(input().strip())\nstrings = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(min_sum_after_restoration(n, strings))"}
{"solution": "def max_teams(n, m):\n    # The maximum number of teams is limited by the total number of participants divided by 3\n    # and also by the specific requirements of each team type.\n    return min((n + m) // 3, n, m // 2)\n\n# Read input\nn, m = map(int, input().split())\n# Calculate and print the maximum number of teams\nprint(max_teams(n, m))"}
{"solution": "def contains_non_overlapping_AB_BA(s):\n    ab_index = s.find(\"AB\")\n    ba_index = s.find(\"BA\")\n    \n    while ab_index != -1:\n        if ba_index != -1 and abs(ab_index - ba_index) > 1:\n            return \"YES\"\n        ab_index = s.find(\"AB\", ab_index + 1)\n    \n    while ba_index != -1:\n        if ab_index != -1 and abs(ab_index - ba_index) > 1:\n            return \"YES\"\n        ba_index = s.find(\"BA\", ba_index + 1)\n    \n    return \"NO\"\n\ns = input().strip()\nprint(contains_non_overlapping_AB_BA(s))"}
{"solution": "def can_eat_monsters(n, a, k, b):\n    from collections import deque\n\n    # Initial queue of monsters\n    queue = deque(a)\n    actions = []\n\n    # Process the final weights\n    for weight in b:\n        if not queue or weight > queue[-1]:\n            return \"NO\"\n        \n        # Find the monster that can match the current weight\n        while queue and queue[-1] < weight:\n            queue.pop()\n        \n        if not queue or queue[-1] != weight:\n            return \"NO\"\n        \n        # We have found the monster with the required weight\n        current_weight = queue.pop()\n        \n        # Now we need to eat monsters to reach the current weight\n        while current_weight < weight:\n            if len(queue) < 1:\n                return \"NO\"\n            \n            # Check if we can eat from the left\n            if len(queue) > 1 and queue[-2] < queue[-1]:\n                actions.append((len(queue), 'L'))\n                current_weight += queue.pop()\n            # Check if we can eat from the right\n            elif queue[-1] < queue[-2]:\n                actions.append((len(queue) - 1, 'R'))\n                current_weight += queue.pop()\n            else:\n                return \"NO\"\n\n    # If we have remaining monsters in the queue, they should be eaten\n    while len(queue) > 1:\n        if queue[-1] > queue[-2]:\n            actions.append((len(queue), 'L'))\n            queue[-2] += queue.pop()\n        else:\n            return \"NO\"\n\n    # If we successfully processed all weights\n    result = [\"YES\"]\n    for action in actions:\n        result.append(f\"{action[0]} {action[1]}\")\n    \n    return \"\\n\".join(result)\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\nk = int(input())\nb = list(map(int, input().split()))\n\n# Output the result\nprint(can_eat_monsters(n, a, k, b))"}
{"solution": "def do_intersect(p1, q1, p2, q2):\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def on_segment(p, q, r):\n        return (min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and\n                min(p[1], r[1]) <= q[1] <= max(p[1], r[1]))\n\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    if o1 != o2 and o3 != o4:\n        return True\n\n    return False\n\ndef is_valid_matching(spaceships, bases):\n    for i in range(len(spaceships)):\n        for j in range(len(bases)):\n            for k in range(len(spaceships)):\n                for l in range(len(bases)):\n                    if (i != k or j != l) and do_intersect(spaceships[i], bases[j], spaceships[k], bases[l]):\n                        return False\n    return True\n\nR, B = map(int, input().split())\nspaceships = [tuple(map(int, input().split())) for _ in range(R)]\nbases = [tuple(map(int, input().split())) for _ in range(B)]\n\nif R != B:\n    print(\"No\")\nelse:\n    if is_valid_matching(spaceships, bases):\n        print(\"Yes\")\n    else:\n        print(\"No\")"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nmax_power_of_two = 1\ncount = 0\n\nfor number in a:\n    power = 1\n    while number % 2 == 0:\n        number //= 2\n        power *= 2\n    if power > max_power_of_two:\n        max_power_of_two = power\n\nfor number in a:\n    if number % max_power_of_two == 0:\n        count += 1\n\nprint(max_power_of_two, count)"}
{"solution": "def min_button_clicks(n, m):\n    clicks = 0\n    while n < m:\n        if m % 2 == 0:\n            m //= 2\n        else:\n            m += 1\n        clicks += 1\n    return clicks + (n - m)\n\nn, m = map(int, input().split())\nprint(min_button_clicks(n, m))"}
{"solution": "def is_tree(n, segments):\n    from collections import defaultdict, deque\n\n    # Create adjacency list for the graph\n    graph = defaultdict(list)\n\n    # Sort segments by their left endpoint\n    segments.sort()\n\n    # Build the graph based on the intersection criteria\n    active_segments = []\n    \n    for i in range(n):\n        l_i, r_i = segments[i]\n        \n        # Remove segments that end before the current segment starts\n        active_segments = [seg for seg in active_segments if seg[1] > l_i]\n        \n        # Check for intersections with active segments\n        for l_j, r_j in active_segments:\n            if not (r_i <= l_j or r_j <= l_i):  # They intersect\n                graph[i].append(segments.index((l_j, r_j)))\n                graph[segments.index((l_j, r_j))].append(i)\n        \n        # Add the current segment to the active list\n        active_segments.append((l_i, r_i))\n\n    # Check if the graph is a tree\n    visited = [False] * n\n    parent = [-1] * n\n    queue = deque([0])\n    visited[0] = True\n    count_edges = 0\n\n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                parent[neighbor] = node\n                queue.append(neighbor)\n            elif neighbor != parent[node]:  # Found a back edge\n                return \"NO\"\n            count_edges += 1\n\n    # A tree must have exactly n-1 edges\n    if count_edges // 2 == n - 1 and all(visited):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Input reading\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(is_tree(n, segments))"}
{"solution": "n = int(input())\nrequests = list(map(int, input().split()))\n\nmax_length = 0\n\nfor start in range(n):\n    total_requests = 0\n    for end in range(start, n):\n        total_requests += requests[end]\n        time_period = end - start + 1\n        if total_requests > 100 * time_period:\n            max_length = max(max_length, time_period)\n\nprint(max_length)"}
{"solution": "def can_dissatisfaction_be_exact(n, k, episodes):\n    # Count the maximum consecutive 'N's\n    max_consecutive_n = 0\n    current_consecutive_n = 0\n    \n    for episode in episodes:\n        if episode == 'N':\n            current_consecutive_n += 1\n        else:\n            max_consecutive_n = max(max_consecutive_n, current_consecutive_n)\n            current_consecutive_n = 0\n            \n    max_consecutive_n = max(max_consecutive_n, current_consecutive_n)\n    \n    # Count the number of '?' and check the conditions\n    question_marks = episodes.count('?')\n    \n    # Check if we can achieve exactly k dissatisfaction\n    if max_consecutive_n > k:\n        return \"NO\"\n    elif max_consecutive_n == k:\n        return \"YES\"\n    else:\n        # max_consecutive_n < k\n        if (k - max_consecutive_n) <= question_marks:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n# Input reading\nn, k = map(int, input().split())\nepisodes = input().strip()\n\n# Output the result\nprint(can_dissatisfaction_be_exact(n, k, episodes))"}
{"solution": "def possible_values(N, X, D):\n    # Calculate the first and last elements of the sequence\n    A1 = X\n    AN = X + (N - 1) * D\n    \n    # The total sum of the sequence\n    total_sum = (N * (A1 + AN)) // 2\n    \n    # The possible values of S - T can be derived from the sums of subsets\n    # The difference S - T can be expressed as 2S - total_sum\n    # S can take values from 0 to total_sum, hence S - T can take values from -total_sum to total_sum\n    # The number of distinct values is total_sum - (-total_sum) + 1 = 2 * total_sum + 1\n    return 2 * total_sum + 1\n\nimport sys\ninput = sys.stdin.read\nN, X, D = map(int, input().strip().split())\nprint(possible_values(N, X, D))"}
{"solution": "n = int(input())\ngood_performance = False\n\nfor _ in range(n):\n    data = input().split()\n    handle = data[0]\n    before_rating = int(data[1])\n    after_rating = int(data[2])\n    \n    if before_rating >= 2400 and after_rating > before_rating:\n        good_performance = True\n\nprint(\"YES\" if good_performance else \"NO\")"}
{"solution": "s = input().strip()\ns_decimal = int(s, 2)\n\ncount = 0\npower_of_four = 1  # This represents 4^k, starting with k=0\n\nwhile power_of_four < s_decimal:\n    count += 1\n    power_of_four *= 4  # Move to the next power of 4\n\nprint(count)"}
{"solution": "def min_rows_for_mirroring(n, m, a):\n    # Create a set to store unique rows\n    unique_rows = set()\n    \n    # Add each row to the set\n    for row in a:\n        unique_rows.add(tuple(row))\n    \n    # The minimum number of rows in matrix b is the number of unique rows\n    return len(unique_rows)\n\n# Read input\nn, m = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\n\n# Get the result\nresult = min_rows_for_mirroring(n, m, a)\n\n# Print the result\nprint(result)"}
{"solution": "def max_orders(n, orders):\n    # Sort orders by their finish time\n    orders.sort(key=lambda x: x[1])\n    \n    count = 0\n    last_end_time = 0\n    \n    for start, end in orders:\n        if start > last_end_time:\n            count += 1\n            last_end_time = end\n            \n    return count\n\n# Input reading\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nn = int(data[0])\norders = [tuple(map(int, line.split())) for line in data[1:n+1]]\n\n# Output the result\nprint(max_orders(n, orders))"}
{"solution": "def can_rearrange(n, k, x, y):\n    total_tables = sum(x)\n    total_formulas = sum(y)\n    \n    # Calculate the maximum number of blocks we can have\n    max_blocks_tables = (total_tables + k - 1) // k\n    max_blocks_formulas = (total_formulas + k - 1) // k\n    \n    # The total number of pages is n\n    if max_blocks_tables + max_blocks_formulas <= n:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input\nn, k = map(int, input().split())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\n# Get the result and print it\nresult = can_rearrange(n, k, x, y)\nprint(result)"}
{"solution": "def can_human_win(n, k, coefficients):\n    # Calculate the current value of the polynomial at x = k\n    current_value = 0\n    undefined_count = 0\n    \n    for i in range(n + 1):\n        if coefficients[i] == '?':\n            undefined_count += 1\n        else:\n            current_value += coefficients[i] * (k ** i)\n    \n    # If there are no undefined coefficients, check divisibility\n    if undefined_count == 0:\n        return current_value == 0\n    \n    # If there are undefined coefficients, the human can always adjust\n    # the polynomial to make it divisible by (x - k)\n    return True\n\n# Read input\nn, k = map(int, input().split())\ncoefficients = [input().strip() for _ in range(n + 1)]\n\n# Determine if the human can guarantee a win\nif can_human_win(n, k, coefficients):\n    print(\"Yes\")\nelse:\n    print(\"No\")"}
{"solution": "def smallest_starting_number(X2):\n    # Function to generate all primes less than a given number using Sieve of Eratosthenes\n    def sieve(n):\n        is_prime = [True] * (n + 1)\n        p = 2\n        while (p * p <= n):\n            if (is_prime[p] == True):\n                for i in range(p * p, n + 1, p):\n                    is_prime[i] = False\n            p += 1\n        return [p for p in range(2, n) if is_prime[p]]\n\n    # Generate all primes less than X2\n    primes = sieve(X2)\n\n    # Initialize the minimum possible starting number\n    min_X0 = float('inf')\n\n    # Check all primes less than X2\n    for p in primes:\n        # Calculate the previous number X1\n        if X2 % p == 0:\n            X1 = X2\n        else:\n            X1 = (X2 // p + 1) * p\n        \n        # Now we need to find the smallest X0 such that Alice can reach X1\n        for q in primes:\n            if q < X1:\n                if X1 % q == 0:\n                    X0 = X1\n                else:\n                    X0 = (X1 // q + 1) * q\n                \n                # Update the minimum starting number\n                min_X0 = min(min_X0, X0)\n\n    return min_X0\n\n# Read input\nX2 = int(input().strip())\n# Output the result\nprint(smallest_starting_number(X2))"}
{"solution": "def min_p_binary_numbers(n, p):\n    if p > n:\n        return -1\n    \n    count = 0\n    while n > 0:\n        if n % 2 == 1:\n            count += 1\n        n = (n - p) // 2\n        if n < 0:\n            return -1\n    \n    return count\n\nn, p = map(int, input().split())\nresult = min_p_binary_numbers(n, p)\nprint(result)"}
{"solution": "def minimize_number(n, k, S):\n    S = list(S)\n    \n    if k > 0 and S[0] != '1':\n        S[0] = '1'\n        k -= 1\n\n    for i in range(1, n):\n        if k <= 0:\n            break\n        if S[i] != '0':\n            S[i] = '0'\n            k -= 1\n\n    for i in range(n):\n        if k <= 0:\n            break\n        if S[i] != '1' and (i > 0 or n == 1):\n            S[i] = '1'\n            k -= 1\n\n    return ''.join(S)\n\nn, k = map(int, input().split())\nS = input().strip()\nresult = minimize_number(n, k, S)\nprint(result)"}
{"solution": "def min_value(cnt_1, cnt_2, x, y):\n    left, right = 1, cnt_1 + cnt_2\n\n    while left < right:\n        mid = (left + right) // 2\n        total = mid - (mid // x) - (mid // y) + (mid // (x * y))\n        \n        if total >= cnt_1 + cnt_2:\n            right = mid\n        else:\n            left = mid + 1\n\n    return left\n\ncnt_1, cnt_2, x, y = map(int, input().split())\nprint(min_value(cnt_1, cnt_2, x, y))"}
{"solution": "def bear_final_position(n, sx, sy, dx, dy, t):\n    x, y = sx, sy\n    \n    for _ in range(t):\n        bushes = x + y\n        dx += bushes\n        dy += bushes\n        \n        x = (x + dx - 1) % n + 1\n        y = (y + dy - 1) % n + 1\n        \n    return x, y\n\n# Read input\nn, sx, sy, dx, dy, t = map(int, input().split())\nresult = bear_final_position(n, sx, sy, dx, dy, t)\nprint(result[0], result[1])"}
{"solution": "def is_nice_word_possible(s):\n    n = len(s)\n    if n < 26:\n        return -1\n\n    for i in range(n - 25):\n        substring = s[i:i + 26]\n        if can_form_nice_word(substring):\n            return fill_nice_word(s, i)\n    \n    return -1\n\ndef can_form_nice_word(substring):\n    seen = set()\n    question_marks = 0\n    for char in substring:\n        if char == '?':\n            question_marks += 1\n        else:\n            seen.add(char)\n    \n    missing_letters = 26 - len(seen)\n    return missing_letters <= question_marks\n\ndef fill_nice_word(s, start_index):\n    substring = list(s[start_index:start_index + 26])\n    seen = set(char for char in substring if char != '?')\n    alphabet = set(chr(i) for i in range(ord('A'), ord('Z') + 1))\n    missing_letters = list(alphabet - seen)\n    \n    j = 0\n    for i in range(26):\n        if substring[i] == '?':\n            substring[i] = missing_letters[j]\n            j += 1\n    \n    result = list(s)\n    result[start_index:start_index + 26] = substring\n    for i in range(len(result)):\n        if result[i] == '?':\n            result[i] = 'A'  # Fill remaining '?' with 'A'\n    \n    return ''.join(result)\n\ns = input().strip()\nresult = is_nice_word_possible(s)\nprint(result)"}
{"solution": "def can_divide_apples(n, weights):\n    count_100 = weights.count(100)\n    count_200 = weights.count(200)\n    \n    total_weight = sum(weights)\n    \n    if total_weight % 2 != 0:\n        return \"NO\"\n    \n    half_weight = total_weight // 2\n    \n    # Try to use 200g apples first\n    max_200_used = min(count_200, half_weight // 200)\n    remaining_weight = half_weight - max_200_used * 200\n    \n    # Check if we can fulfill the remaining weight with 100g apples\n    if remaining_weight <= count_100 * 100:\n        return \"YES\"\n    \n    return \"NO\"\n\nn = int(input())\nweights = list(map(int, input().split()))\nprint(can_divide_apples(n, weights))"}
{"solution": "def min_time_to_turn_off_lights(n, m, building):\n    total_time = 0\n\n    for floor in range(n):\n        lights_on = [i for i in range(1, m + 1) if building[floor][i] == '1']\n        \n        if lights_on:\n            leftmost = lights_on[0]\n            rightmost = lights_on[-1]\n            time_to_turn_off = (rightmost - 1) + (rightmost - leftmost) + 1  # to rightmost, back to leftmost, and go to stairs\n            total_time += time_to_turn_off + 1  # +1 for going to the stairs after finishing the floor\n            \n            if floor < n - 1:  # if not the last floor, go up to the next floor\n                total_time += 1\n\n    return total_time\n\n# Input reading\nn, m = map(int, input().split())\nbuilding = [input().strip() for _ in range(n)]\n\n# Calculate and print the result\nresult = min_time_to_turn_off_lights(n, m, building)\nprint(result)"}
{"solution": "def minimal_trap_cost(n, costs, a):\n    visited = [False] * n\n    in_cycle = [False] * n\n    total_cost = 0\n\n    def find_cycle(start):\n        nonlocal total_cost\n        current = start\n        path = []\n        while not visited[current]:\n            visited[current] = True\n            path.append(current)\n            current = a[current] - 1  # Move to the next room (0-indexed)\n\n        if current in path:\n            cycle_start = path.index(current)\n            cycle = path[cycle_start:]\n            min_cost = min(costs[i] for i in cycle)\n            total_cost += min_cost\n            for i in cycle:\n                in_cycle[i] = True\n\n    for i in range(n):\n        if not visited[i]:\n            find_cycle(i)\n\n    return total_cost\n\n# Input reading\nn = int(input())\ncosts = list(map(int, input().split()))\na = list(map(int, input().split()))\n\n# Output the result\nprint(minimal_trap_cost(n, costs, a))"}
{"solution": "n, a, b = map(int, input().split())\nfinal_position = (a + b - 1) % n + 1\nprint(final_position)"}
{"solution": "def min_arithmetic_progressions(n, a):\n    progressions = 0\n    i = 0\n    \n    while i < n:\n        if a[i] == -1:\n            # Start a new progression\n            progressions += 1\n            # Move to the next known value or end\n            while i < n and a[i] == -1:\n                i += 1\n            if i < n:\n                # We found a known value, continue from here\n                start_value = a[i]\n                i += 1\n                # Continue the progression\n                while i < n and (a[i] == -1 or a[i] == start_value + (i - (i - 1)) * (a[i - 1] - start_value)):\n                    if a[i] != -1:\n                        start_value = a[i]\n                    i += 1\n        else:\n            # Start a new progression\n            progressions += 1\n            start_value = a[i]\n            i += 1\n            # Continue the progression\n            while i < n and (a[i] == -1 or a[i] == start_value + (i - (i - 1)) * (a[i - 1] - start_value)):\n                if a[i] != -1:\n                    start_value = a[i]\n                i += 1\n\n    return progressions\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(min_arithmetic_progressions(n, a))"}
{"solution": "def max_beauty(n, k, s):\n    def max_length_with_char(target_char):\n        left = 0\n        max_length = 0\n        count_changes = 0\n        \n        for right in range(n):\n            if s[right] != target_char:\n                count_changes += 1\n            \n            while count_changes > k:\n                if s[left] != target_char:\n                    count_changes -= 1\n                left += 1\n            \n            max_length = max(max_length, right - left + 1)\n        \n        return max_length\n\n    max_a = max_length_with_char('a')\n    max_b = max_length_with_char('b')\n    \n    return max(max_a, max_b)\n\n# Input reading\nn, k = map(int, input().split())\ns = input().strip()\n\n# Output the result\nprint(max_beauty(n, k, s))"}
{"solution": "def find_coalition(n, a):\n    total_seats = sum(a)\n    majority = total_seats // 2 + 1\n    alice_seats = a[0]\n    \n    coalition = [1]  # Start with Alice's party\n    coalition_seats = alice_seats\n    \n    for i in range(1, n):\n        if alice_seats >= 2 * a[i]:  # Check if Alice can invite this party\n            coalition.append(i + 1)  # Store the index (1-based)\n            coalition_seats += a[i]\n    \n    if coalition_seats >= majority:\n        print(len(coalition))\n        print(\" \".join(map(str, coalition)))\n    else:\n        print(0)\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\nfind_coalition(n, a)"}
{"solution": "def maximum_prize(n):\n    total_reward = 0.0\n    for s in range(n, 0, -1):\n        total_reward += 1 / s\n    return total_reward\n\nn = int(input().strip())\nresult = maximum_prize(n)\nprint(f\"{result:.12f}\")"}
{"solution": "n = int(input())\nk = 0\ncandies = []\n\n# Find the maximum number of distinct positive integers that sum up to n\nwhile n > 0:\n    k += 1\n    if n >= k:\n        candies.append(k)\n        n -= k\n    else:\n        candies[-1] += n\n        break\n\nprint(len(candies))\nprint(' '.join(map(str, candies)))"}
{"solution": "n = int(input())\nm = int(input())\n\nmod_value = 1 << n  # This is equivalent to 2 ** n\nresult = m % mod_value\n\nprint(result)"}
{"solution": "def correct_word(n, s):\n    vowels = set('aeiouy')\n    result = []\n    \n    for char in s:\n        if result and char in vowels and result[-1] in vowels:\n            continue\n        result.append(char)\n    \n    return ''.join(result)\n\nn = int(input().strip())\ns = input().strip()\nprint(correct_word(n, s))"}
{"solution": "def max_students(n, a, b, seats):\n    segments = seats.split('*')\n    total_students = 0\n\n    for segment in segments:\n        length = len(segment)\n        if length == 0:\n            continue\n        \n        # Calculate the maximum number of students that can be seated in this segment\n        if a > b:\n            # Start with programmers\n            programmers_to_seat = (length + 1) // 2\n            athletes_to_seat = length // 2\n        else:\n            # Start with athletes\n            athletes_to_seat = (length + 1) // 2\n            programmers_to_seat = length // 2\n        \n        # Seat as many programmers as possible\n        seated_programmers = min(programmers_to_seat, a)\n        a -= seated_programmers\n        total_students += seated_programmers\n        \n        # Seat as many athletes as possible\n        seated_athletes = min(athletes_to_seat, b)\n        b -= seated_athletes\n        total_students += seated_athletes\n\n    return total_students\n\n# Input reading\nn, a, b = map(int, input().split())\nseats = input().strip()\n\n# Output the result\nprint(max_students(n, a, b, seats))"}
{"solution": "def find_xy(r):\n    for x in range(1, int(r**0.5) + 1):\n        # Calculate the value of H(x, y) = r\n        # Rearranging gives us: y = (r - x^2 - x - 1) / (2x)\n        numerator = r - (x**2 + x + 1)\n        if numerator <= 0:\n            continue\n        if numerator % (2 * x) == 0:\n            y = numerator // (2 * x)\n            if y > 0:\n                return x, y\n    return \"NO\"\n\nr = int(input().strip())\nresult = find_xy(r)\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0], result[1])"}
{"solution": "def divide_balloons(n, a):\n    if n == 1:\n        return -1\n    \n    total_balloons = sum(a)\n    \n    # If all packets have the same number of balloons\n    if len(set(a)) == 1:\n        return -1\n    \n    # Give the first packet to Grigory\n    grigory_packets = [1]\n    grigory_sum = a[0]\n    \n    # Check if we can give one more packet to Grigory\n    if n > 2:\n        grigory_packets.append(2)\n        grigory_sum += a[1]\n    \n    # Output the result\n    return (len(grigory_packets), grigory_packets)\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\nresult = divide_balloons(n, a)\n\nif result == -1:\n    print(-1)\nelse:\n    k, indices = result\n    print(k)\n    print(' '.join(map(str, indices)))"}
{"solution": "n = int(input())\n\n# The maximum digit we can use is 9\nif n % 9 == 0:\n    k = n // 9\n    digits = [9] * k\nelse:\n    k = n // 9 + 1\n    digits = [9] * (k - 1) + [n % 9]\n\nprint(k)\nprint(' '.join(map(str, digits)))"}
{"solution": "def is_prime(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef find_simple_subset(n, a):\n    odd_count = sum(1 for x in a if x % 2 == 1)\n    even_count = n - odd_count\n    \n    if odd_count >= 2:\n        return odd_count, [x for x in a if x % 2 == 1]\n    elif even_count >= 2:\n        return even_count, [x for x in a if x % 2 == 0]\n    elif odd_count == 1:\n        return 1, [next(x for x in a if x % 2 == 1)]\n    elif even_count == 1:\n        return 1, [next(x for x in a if x % 2 == 0)]\n    else:\n        return 0, []\n\nn = int(input())\na = list(map(int, input().split()))\n\nm, subset = find_simple_subset(n, a)\nprint(m)\nprint(' '.join(map(str, subset)))"}
{"solution": "def is_beautiful(num):\n    k = 1\n    while True:\n        beautiful_number = (2**k - 1) * (2**k - 1)\n        if beautiful_number > num:\n            break\n        if num % beautiful_number == 0:\n            max_beautiful = beautiful_number\n        k += 1\n    return max_beautiful\n\nn = int(input())\nprint(is_beautiful(n))"}
{"solution": "def is_d_magic(num_str, d):\n    for i in range(len(num_str)):\n        if (i % 2 == 1 and num_str[i] == str(d)) or (i % 2 == 0 and num_str[i] != str(d)):\n            return False\n    return True\n\ndef count_d_magic_numbers(m, d, a, b):\n    MOD = 10**9 + 7\n    count = 0\n    \n    a_int = int(a)\n    b_int = int(b)\n    \n    for num in range(a_int, b_int + 1):\n        if num % m == 0 and is_d_magic(str(num), d):\n            count = (count + 1) % MOD\n            \n    return count\n\nm, d = map(int, input().split())\na = input().strip()\nb = input().strip()\n\nresult = count_d_magic_numbers(m, d, a, b)\nprint(result)"}
{"solution": "from collections import deque\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\nqueue = deque([(i + 1, a[i]) for i in range(n)])  # (child_index, candies_needed)\n\nlast_child = -1\n\nwhile queue:\n    child_index, candies_needed = queue.popleft()\n    candies_needed -= m\n    if candies_needed > 0:\n        queue.append((child_index, candies_needed))\n    else:\n        last_child = child_index\n\nprint(last_child)"}
{"solution": "def min_bills(n):\n    denominations = [100, 20, 10, 5, 1]\n    count = 0\n    \n    for bill in denominations:\n        count += n // bill\n        n %= bill\n    \n    return count\n\nn = int(input())\nprint(min_bills(n))"}
{"solution": "def count_permutations(n, k):\n    MOD = 1000000007\n\n    # dp[i][j] will store the number of permutations of size i with exactly j good positions\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case: 1 way to arrange 0 elements with 0 good positions\n\n    for i in range(1, n + 1):\n        for j in range(i + 1):\n            # Case 1: The last element is not in a good position\n            dp[i][j] = (dp[i - 1][j] * (i - j)) % MOD\n            \n            # Case 2: The last element is in a good position\n            if j > 0:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD\n\n    return dp[n][k]\n\n# Read input\nn, k = map(int, input().split())\n# Calculate and print the result\nprint(count_permutations(n, k))"}
{"solution": "def max_beauty_bouquet(n, k, beauties, colors):\n    from collections import defaultdict\n    \n    # Group roses by color\n    color_groups = defaultdict(list)\n    for beauty, color in zip(beauties, colors):\n        color_groups[color].append(beauty)\n    \n    # Sort each color group in descending order of beauty\n    for color in color_groups:\n        color_groups[color].sort(reverse=True)\n    \n    # If we have only one color, we cannot form a valid bouquet\n    if len(color_groups) == 1:\n        return -1\n    \n    max_beauty = -1\n    \n    # Try combinations of two different colors\n    for color1 in color_groups:\n        for color2 in color_groups:\n            if color1 != color2:\n                # Take the top k beauties from both colors\n                beauties1 = color_groups[color1][:k]\n                beauties2 = color_groups[color2][:k]\n                \n                # If we can take all k from one color and at least one from the other\n                if len(beauties1) + len(beauties2) >= k:\n                    # We need to take k roses, we can take from both colors\n                    total_beauty = 0\n                    if len(beauties1) >= k:\n                        total_beauty = sum(beauties1[:k])\n                    else:\n                        total_beauty = sum(beauties1) + sum(beauties2[:k - len(beauties1)])\n                    \n                    max_beauty = max(max_beauty, total_beauty)\n    \n    return max_beauty\n\n# Input reading\nn, k = map(int, input().split())\nbeauties = list(map(int, input().split()))\ncolors = input().strip()\n\n# Output the result\nprint(max_beauty_bouquet(n, k, beauties, colors))"}
{"solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef fraction_from_continued_fraction(a):\n    n = len(a)\n    if n == 0:\n        return (0, 1)\n    \n    numerator = 1\n    denominator = a[-1]\n    \n    for i in range(n - 2, -1, -1):\n        numerator, denominator = denominator, a[i] * denominator + numerator\n    \n    return (denominator, numerator)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    p = int(data[0])\n    q = int(data[1])\n    n = int(data[2])\n    a = list(map(int, data[3:3+n]))\n    \n    # Get the fraction from the continued fraction representation\n    cf_numerator, cf_denominator = fraction_from_continued_fraction(a)\n    \n    # Cross multiply to check equality\n    if p * cf_denominator == q * cf_numerator:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()"}
{"solution": "def count_sticks(expression):\n    # Split the expression into parts\n    parts = expression.split('+')\n    A = parts[0].count('|')\n    B, C = parts[1].split('=')\n    B = B.count('|')\n    C = C.count('|')\n\n    # Check if the current expression is already correct\n    if A + B == C:\n        return expression\n\n    # Try shifting one stick from A, B, or C\n    for i in range(1, A + 1):\n        if A - i + (B + i) == C:\n            return '|' * (A - i) + '+' + '|' * (B + i) + '=' + '|' * C\n\n    for i in range(1, B + 1):\n        if (A + i) + (B - i) == C:\n            return '|' * (A + i) + '+' + '|' * (B - i) + '=' + '|' * C\n\n    for i in range(1, C + 1):\n        if A + B == C - i:\n            return '|' * A + '+' + '|' * B + '=' + '|' * (C - i)\n\n    return \"Impossible\"\n\n# Read input\nexpression = input().strip()\n# Get the result\nresult = count_sticks(expression)\n# Print the result\nprint(result)"}
{"solution": "def count_permutations_with_oddness(n, k):\n    MOD = 10**9 + 7\n    \n    # dp[i][j] will store the number of permutations of {1, 2, ..., i} with oddness j\n    dp = [[0] * (n * n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case: one way to arrange zero elements with oddness 0\n\n    for i in range(1, n + 1):\n        for j in range(n * n + 1):\n            for m in range(1, i + 1):\n                oddness = abs(m - i)  # The contribution of placing i at position m\n                if j >= oddness:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - oddness]) % MOD\n\n    return dp[n][k]\n\nimport sys\ninput = sys.stdin.read\nn, k = map(int, input().strip().split())\nprint(count_permutations_with_oddness(n, k))"}
{"solution": "def can_construct_robot_arm(N, points):\n    # Calculate the total distance needed in x and y directions\n    total_x = sum(x for x, y in points)\n    total_y = sum(y for x, y in points)\n\n    # The maximum distance in x and y directions\n    max_x = max(abs(x) for x, y in points)\n    max_y = max(abs(y) for x, y in points)\n\n    # The number of sections needed\n    m = max(max_x, max_y)\n\n    # The distances for each section\n    d = [1] * m  # Each section has a length of 1\n\n    # Prepare the output\n    output = []\n    output.append(str(m))\n    output.append(\" \".join(map(str, d)))\n\n    # For each point, determine the path\n    for x, y in points:\n        path = []\n        current_x, current_y = 0, 0\n\n        # Move in x direction\n        if x > 0:\n            path.append('R' * x)\n        elif x < 0:\n            path.append('L' * (-x))\n\n        # Move in y direction\n        if y > 0:\n            path.append('U' * y)\n        elif y < 0:\n            path.append('D' * (-y))\n\n        # Fill the remaining sections with 'R' (or any valid direction)\n        remaining_sections = m - len(path[0]) - len(path[1])\n        if remaining_sections > 0:\n            path.append('R' * remaining_sections)\n\n        # Join the path and add to output\n        output.append(''.join(path))\n\n    return output\n\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nN = int(data[0])\npoints = [tuple(map(int, line.split())) for line in data[1:N + 1]]\n\nresult = can_construct_robot_arm(N, points)\nprint(\"\\n\".join(result))"}
{"solution": "def replace_fillers(n, s):\n    i = 0\n    result = []\n    \n    while i < n:\n        if s[i:i+3] == \"ogo\":\n            # Found a filler, replace it with ***\n            result.append(\"***\")\n            i += 3\n            \n            # Check for additional \"go\" at the end\n            while s[i:i+2] == \"go\":\n                result.append(\"***\")\n                i += 2\n        else:\n            result.append(s[i])\n            i += 1\n            \n    print(\"\".join(result))\n\n# Input reading\nn = int(input().strip())\ns = input().strip()\nreplace_fillers(n, s)"}
{"solution": "def prime_factors(x):\n    factors = set()\n    d = 2\n    while d * d <= x:\n        while (x % d) == 0:\n            factors.add(d)\n            x //= d\n        d += 1\n    if x > 1:\n        factors.add(x)\n    return factors\n\ndef g(y, p):\n    k = 0\n    while y % p == 0:\n        y //= p\n        k += 1\n    return p ** k\n\ndef f(x, y):\n    primes = prime_factors(x)\n    product = 1\n    for p in primes:\n        product *= g(y, p)\n        product %= (10**9 + 7)\n    return product\n\ndef calculate_result(x, n):\n    result = 1\n    for i in range(1, n + 1):\n        result *= f(x, i)\n        result %= (10**9 + 7)\n    return result\n\nx, n = map(int, input().split())\nif n > 10**9:\n    n = 10**9  # Limit n to avoid excessive computation\nresult = calculate_result(x, n)\nprint(result)"}
{"solution": "def digit_sum(x):\n    return sum(int(d) for d in str(x))\n\ndef find_solutions(a, b, c):\n    solutions = []\n    for s in range(1, 82):  # The maximum digit sum for numbers < 10^9 is 81 (for 999999999)\n        x = b * (s ** a) + c\n        if 0 < x < 10**9 and digit_sum(x) == s:\n            solutions.append(x)\n    return sorted(solutions)\n\na, b, c = map(int, input().split())\nsolutions = find_solutions(a, b, c)\nprint(len(solutions))\nif solutions:\n    print(' '.join(map(str, solutions)))"}
{"solution": "def can_solve_with_one_rotation(cube):\n    # Count occurrences of each color\n    color_count = [0] * 7  # Index 0 is unused, colors are 1 to 6\n    for color in cube:\n        color_count[color] += 1\n\n    # Check the counts\n    count_of_four = color_count.count(4)\n    count_of_three = color_count.count(3)\n    count_of_two = color_count.count(2)\n    count_of_one = color_count.count(1)\n\n    # To solve the cube with one rotation, we can have:\n    # - One color with 4 (already solved) and three colors with 2 (two pairs)\n    # - Two colors with 3 (two pairs) and two colors with 1 (two singles)\n    if (count_of_four == 1 and count_of_two == 3) or (count_of_three == 2 and count_of_one == 2):\n        return \"YES\"\n    return \"NO\"\n\n# Read input\ncube_state = list(map(int, input().split()))\n# Output the result\nprint(can_solve_with_one_rotation(cube_state))"}
{"solution": "def get_tshirt_places():\n    places = set()\n    for s in range(20001):\n        i = (s // 50) % 475\n        for _ in range(25):\n            i = (i * 96 + 42) % 475\n            places.add(26 + i)\n    return places\n\ndef min_successful_hacks(p, x, y):\n    tshirt_places = get_tshirt_places()\n    \n    # Ensure we have at least y points\n    if x < y:\n        return float('inf')  # Not possible if we can't reach y\n    \n    # Check for the minimum successful hacks needed\n    successful_hacks = 0\n    while True:\n        score = x + successful_hacks * 100\n        if score >= y:\n            if any((score // 50) % 475 == (place - 26) for place in tshirt_places if place >= p):\n                return successful_hacks\n        successful_hacks += 1\n\np, x, y = map(int, input().split())\nprint(min_successful_hacks(p, x, y))"}
{"solution": "def minimum_distance(n, a, b, c):\n    if n == 1:\n        return 0\n    \n    # Distances for each possible sequence of visits\n    distances = []\n    \n    # Starting at Rabbit's house\n    # 1. Rabbit -> Owl -> Eeyore\n    if n > 1:\n        distances.append(a + c * ((n - 2) // 2) + (b if (n - 2) % 2 else 0))\n    \n    # 2. Rabbit -> Eeyore -> Owl\n    if n > 1:\n        distances.append(b + c * ((n - 2) // 2) + (a if (n - 2) % 2 else 0))\n    \n    # 3. Owl -> Rabbit -> Eeyore\n    if n > 1:\n        distances.append(a + b * ((n - 2) // 2) + (c if (n - 2) % 2 else 0))\n    \n    # 4. Owl -> Eeyore -> Rabbit\n    if n > 1:\n        distances.append(c + b * ((n - 2) // 2) + (a if (n - 2) % 2 else 0))\n    \n    # 5. Eeyore -> Rabbit -> Owl\n    if n > 1:\n        distances.append(b + a * ((n - 2) // 2) + (c if (n - 2) % 2 else 0))\n    \n    # 6. Eeyore -> Owl -> Rabbit\n    if n > 1:\n        distances.append(c + a * ((n - 2) // 2) + (b if (n - 2) % 2 else 0))\n    \n    return min(distances)\n\n# Input reading\nn = int(input().strip())\na = int(input().strip())\nb = int(input().strip())\nc = int(input().strip())\n\n# Output the result\nprint(minimum_distance(n, a, b, c))"}
{"solution": "x1, x2, x3 = map(int, input().split())\nfriends = [x1, x2, x3]\nfriends.sort()\nmeeting_point = friends[1]\ntotal_distance = sum(abs(friend - meeting_point) for friend in friends)\nprint(total_distance)"}
{"solution": "def min_operations_to_equal_elements(n, x, a):\n    count = {}\n    for num in a:\n        count[num] = count.get(num, 0) + 1\n    \n    # Check if there are already duplicates\n    for num in count:\n        if count[num] > 1:\n            return 0\n    \n    # Create a new array with the AND operation applied\n    transformed = [num & x for num in a]\n    \n    # Count occurrences in the transformed array\n    transformed_count = {}\n    for num in transformed:\n        transformed_count[num] = transformed_count.get(num, 0) + 1\n    \n    # Check for duplicates in the transformed array\n    for num in transformed_count:\n        if transformed_count[num] > 1:\n            return 1\n    \n    # Check if any original number matches a transformed number\n    for num in a:\n        if num in transformed_count:\n            return 1\n    \n    return -1\n\n# Input reading\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(min_operations_to_equal_elements(n, x, a))"}
{"solution": "def has_single_plus_shape(h, w, picture):\n    # Find the center of the plus shape\n    center = None\n    for i in range(h):\n        for j in range(w):\n            if picture[i][j] == '*':\n                if center is None:\n                    center = (i, j)\n                else:\n                    # If we find more than one center, return NO\n                    return \"NO\"\n\n    if center is None:\n        return \"NO\"  # No '*' found\n\n    cx, cy = center\n\n    # Check for rays in all four directions\n    up, down, left, right = 0, 0, 0, 0\n\n    # Count upward\n    for i in range(cx - 1, -1, -1):\n        if picture[i][cy] == '*':\n            up += 1\n        else:\n            break\n\n    # Count downward\n    for i in range(cx + 1, h):\n        if picture[i][cy] == '*':\n            down += 1\n        else:\n            break\n\n    # Count leftward\n    for j in range(cy - 1, -1, -1):\n        if picture[cx][j] == '*':\n            left += 1\n        else:\n            break\n\n    # Count rightward\n    for j in range(cy + 1, w):\n        if picture[cx][j] == '*':\n            right += 1\n        else:\n            break\n\n    # Check if there is at least one ray in each direction\n    if up > 0 and down > 0 and left > 0 and right > 0:\n        # Check if all other cells are empty\n        for i in range(h):\n            for j in range(w):\n                if (i == cx and j == cy) or \\\n                   (up > 0 and i < cx and picture[i][cy] == '*') or \\\n                   (down > 0 and i > cx and picture[i][cy] == '*') or \\\n                   (left > 0 and j < cy and picture[cx][j] == '*') or \\\n                   (right > 0 and j > cy and picture[cx][j] == '*'):\n                    continue\n                if picture[i][j] == '*':\n                    return \"NO\"\n        return \"YES\"\n    \n    return \"NO\"\n\n# Input reading\nh, w = map(int, input().split())\npicture = [input().strip() for _ in range(h)]\n\n# Output the result\nprint(has_single_plus_shape(h, w, picture))"}
{"solution": "def create_adjacency_matrix(n, a, b):\n    if a + b > n + 1:\n        return \"NO\"\n    \n    # Initialize the adjacency matrix with zeros\n    matrix = [[0] * n for _ in range(n)]\n    \n    # Create components for the graph\n    components = []\n    for i in range(a):\n        components.append([i])\n    \n    # Fill the remaining vertices into the last component\n    for i in range(a, n):\n        components[-1].append(i)\n    \n    # Create edges within each component\n    for component in components:\n        size = len(component)\n        for i in range(size):\n            for j in range(i + 1, size):\n                matrix[component[i]][component[j]] = 1\n                matrix[component[j]][component[i]] = 1\n    \n    # Create components for the complement\n    complement_components = []\n    for i in range(b):\n        complement_components.append([i])\n    \n    # Fill the remaining vertices into the last component\n    for i in range(b, n):\n        complement_components[-1].append(i)\n    \n    # Check if the complement components are valid\n    if len(complement_components) > 1:\n        for i in range(len(complement_components) - 1):\n            for j in range(len(complement_components[i])):\n                for k in range(len(complement_components[i + 1])):\n                    matrix[complement_components[i][j]][complement_components[i + 1][k]] = 0\n                    matrix[complement_components[i + 1][k]][complement_components[i][j]] = 0\n    \n    return \"YES\", matrix\n\nn, a, b = map(int, input().split())\nresult = create_adjacency_matrix(n, a, b)\n\nif result == \"NO\":\n    print(result)\nelse:\n    print(result[0])\n    for row in result[1]:\n        print(''.join(map(str, row)))"}
{"solution": "def min_problems_needed(c, d, n, m, k):\n    total_needed = n * m\n    remaining_needed = max(0, total_needed - k)\n    \n    main_rounds = remaining_needed // n\n    if remaining_needed % n != 0:\n        main_rounds += 1\n    \n    additional_rounds = 0\n    if remaining_needed > 0:\n        additional_rounds = remaining_needed\n    \n    total_problems = main_rounds * c + additional_rounds * d\n    return total_problems\n\n# Read input\nc, d = map(int, input().split())\nn, m = map(int, input().split())\nk = int(input())\n\n# Calculate and print the result\nresult = min_problems_needed(c, d, n, m, k)\nprint(result)"}
{"solution": "def can_form_path(s):\n    from collections import defaultdict, deque\n\n    # Create a grid representation\n    grid = [[''] * 13 for _ in range(2)]\n    letter_positions = defaultdict(list)\n\n    # Fill the grid with letters from the string\n    for i, letter in enumerate(s):\n        row = i // 13\n        col = i % 13\n        grid[row][col] = letter\n        letter_positions[letter].append((row, col))\n\n    # Directions for adjacency (8 directions)\n    directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n\n    # Check if we can form the path\n    def is_adjacent(pos1, pos2):\n        return any((pos1[0] + dr == pos2[0] and pos1[1] + dc == pos2[1]) for dr, dc in directions)\n\n    # Create a path\n    path = []\n    visited = set()\n\n    for letter in s:\n        if letter in visited:\n            continue\n        if not path:\n            path.append(letter)\n            visited.add(letter)\n            continue\n        \n        last_letter = path[-1]\n        last_positions = letter_positions[last_letter]\n        current_positions = letter_positions[letter]\n        \n        found = False\n        for last_pos in last_positions:\n            for current_pos in current_positions:\n                if is_adjacent(last_pos, current_pos):\n                    path.append(letter)\n                    visited.add(letter)\n                    found = True\n                    break\n            if found:\n                break\n        \n        if not found:\n            return \"Impossible\"\n\n    # Create the output grid\n    output_grid = [[''] * 13 for _ in range(2)]\n    index = 0\n    for r in range(2):\n        for c in range(13):\n            if index < len(s):\n                output_grid[r][c] = s[index]\n                index += 1\n\n    return [''.join(output_grid[0]), ''.join(output_grid[1])]\n\ns = input().strip()\nresult = can_form_path(s)\nif result == \"Impossible\":\n    print(result)\nelse:\n    print(result[0])\n    print(result[1])"}
{"solution": "import math\n\nx, y = map(int, input().split())\n\nif x == y:\n    print('=')\nelse:\n    # Compare x^y and y^x using logarithms\n    # We compare y * log(x) with x * log(y)\n    left = y * math.log(x)\n    right = x * math.log(y)\n\n    if left < right:\n        print('<')\n    elif left > right:\n        print('>')"}
{"solution": "import math\n\ndef max_balloons(r, h):\n    balloon_radius = r / 2\n    balloon_diameter = balloon_radius * 2\n    \n    # Calculate the height available for balloons\n    height_available = h + r\n    \n    # Calculate the number of balloons that can fit in the height\n    num_balloons_height = height_available // balloon_diameter\n    \n    # Calculate the number of balloons that can fit in the semicircle\n    semicircle_radius = r\n    semicircle_diameter = balloon_diameter\n    \n    # The maximum number of balloons that can fit in the semicircle\n    num_balloons_width = math.floor(semicircle_radius / balloon_radius)\n    \n    # Total balloons is the product of the two dimensions\n    total_balloons = num_balloons_height * num_balloons_width\n    \n    return total_balloons\n\n# Read input\nr, h = map(int, input().split())\n# Calculate and print the result\nprint(max_balloons(r, h))"}
{"solution": "from collections import Counter\n\n# Read input\ncards = list(map(int, input().split()))\n\n# Calculate the total sum of the cards\ntotal_sum = sum(cards)\n\n# Count the occurrences of each number\ncount = Counter(cards)\n\n# Initialize the minimum sum as the total sum\nmin_sum = total_sum\n\n# Check for pairs and triplets\nfor number, freq in count.items():\n    if freq >= 2:\n        # If we can remove two cards of this number\n        min_sum = min(min_sum, total_sum - 2 * number)\n    if freq >= 3:\n        # If we can remove three cards of this number\n        min_sum = min(min_sum, total_sum - 3 * number)\n\n# Print the minimum possible sum\nprint(min_sum)"}
{"solution": "def minimum_distance(n, a, checkpoints):\n    checkpoints.sort()\n    \n    if n == 1:\n        return abs(a - checkpoints[0])\n    \n    left_most = checkpoints[0]\n    right_most = checkpoints[-1]\n    \n    # Calculate the distance if we visit the leftmost n-1 checkpoints\n    distance_to_left = abs(a - right_most) + (right_most - left_most)\n    \n    # Calculate the distance if we visit the rightmost n-1 checkpoints\n    distance_to_right = abs(a - left_most) + (right_most - left_most)\n    \n    return min(distance_to_left, distance_to_right)\n\n# Input reading\nn, a = map(int, input().split())\ncheckpoints = list(map(int, input().split()))\n\n# Output the result\nprint(minimum_distance(n, a, checkpoints))"}
{"solution": "def sum_of_digits(x):\n    return sum(int(d) for d in str(x))\n\ndef find_smallest_root(n):\n    for s in range(1, 163):  # s(x) can be at most 162 for x < 10^18\n        # Calculate the discriminant\n        discriminant = s * s + 4 * n\n        if discriminant < 0:\n            continue\n        \n        sqrt_d = int(discriminant**0.5)\n        if sqrt_d * sqrt_d != discriminant:\n            continue\n        \n        # Calculate the potential root x\n        x1 = (-s + sqrt_d) // 2\n        if x1 > 0 and (-s + sqrt_d) % 2 == 0:\n            if x1 * x1 + sum_of_digits(x1) * x1 == n:\n                return x1\n    \n    return -1\n\nn = int(input().strip())\nresult = find_smallest_root(n)\nprint(result)"}
{"solution": "def time_to_bed(current_time, sleep_duration):\n    # Split the current time and sleep duration into hours and minutes\n    current_hours, current_minutes = map(int, current_time.split(':'))\n    sleep_hours, sleep_minutes = map(int, sleep_duration.split(':'))\n    \n    # Convert both times to total minutes\n    total_current_minutes = current_hours * 60 + current_minutes\n    total_sleep_minutes = sleep_hours * 60 + sleep_minutes\n    \n    # Calculate the time when George went to bed in total minutes\n    total_bed_time_minutes = total_current_minutes - total_sleep_minutes\n    \n    # If the result is negative, it means he went to bed the previous day\n    if total_bed_time_minutes < 0:\n        total_bed_time_minutes += 24 * 60\n    \n    # Convert back to hours and minutes\n    bed_hours = total_bed_time_minutes // 60\n    bed_minutes = total_bed_time_minutes % 60\n    \n    # Format the output to ensure two digits for hours and minutes\n    return f\"{bed_hours:02}:{bed_minutes:02}\"\n\n# Read input\ncurrent_time = input().strip()\nsleep_duration = input().strip()\n\n# Calculate and print the time George went to bed\nprint(time_to_bed(current_time, sleep_duration))"}
{"solution": "n = int(input())\na = list(map(int, input().split()))\n\nmax_value = max(a)\nmax_length = 0\ncurrent_length = 0\n\nfor value in a:\n    if value == max_value:\n        current_length += 1\n    else:\n        max_length = max(max_length, current_length)\n        current_length = 0\n\nmax_length = max(max_length, current_length)\n\nprint(max_length)"}
{"solution": "def count_painting_ways(n, m, k):\n    MOD = 998244353\n    \n    if k == 0:\n        return m % MOD\n    \n    # Calculate the number of ways to paint the bricks\n    # Using the formula: m * (m - 1)^k * (1)^(n - k - 1)\n    # where (1)^(n - k - 1) is just 1 since we can choose any color for the remaining bricks\n    ways = m * pow(m - 1, k, MOD) % MOD\n    return ways\n\n# Read input\nn, m, k = map(int, input().split())\n# Output the result\nprint(count_painting_ways(n, m, k))"}
{"solution": "def is_magic_number(n):\n    s = str(n)\n    i = 0\n    while i < len(s):\n        if s[i:i+3] == '144':\n            i += 3\n        elif s[i:i+2] == '14':\n            i += 2\n        elif s[i] == '1':\n            i += 1\n        else:\n            return \"NO\"\n    return \"YES\"\n\nn = int(input().strip())\nprint(is_magic_number(n))"}
{"solution": "def min_moves_to_corners(n, m, i, j, a, b):\n    corners = [(1, 1), (1, m), (n, 1), (n, m)]\n    min_moves = float('inf')\n\n    for x, y in corners:\n        if (abs(x - i) % a == 0) and (abs(y - j) % b == 0):\n            moves_x = abs(x - i) // a\n            moves_y = abs(y - j) // b\n            if (moves_x % 2) == (moves_y % 2):\n                min_moves = min(min_moves, max(moves_x, moves_y))\n\n    return min_moves if min_moves != float('inf') else \"Poor Inna and pony!\"\n\n# Read input\nn, m, i, j, a, b = map(int, input().split())\n# Get the result\nresult = min_moves_to_corners(n, m, i, j, a, b)\n# Print the result\nprint(result)"}
{"solution": "def max_removals(s):\n    n = len(s)\n    removable = [False] * n\n\n    for i in range(n):\n        if i > 0 and ord(s[i]) - ord(s[i - 1]) == 1:\n            removable[i] = True\n        if i < n - 1 and ord(s[i]) - ord(s[i + 1]) == 1:\n            removable[i] = True\n\n    count = 0\n    while True:\n        found = False\n        for i in range(n):\n            if removable[i]:\n                count += 1\n                found = True\n                s = s[:i] + s[i + 1:]\n                n -= 1\n                removable = [False] * n\n                for j in range(n):\n                    if j > 0 and ord(s[j]) - ord(s[j - 1]) == 1:\n                        removable[j] = True\n                    if j < n - 1 and ord(s[j]) - ord(s[j + 1]) == 1:\n                        removable[j] = True\n                break\n        if not found:\n            break\n\n    return count\n\n# Input reading\nlength = int(input().strip())\ns = input().strip()\n\n# Output the result\nprint(max_removals(s))"}
{"solution": "def min_bills(n, k, denominations, q, requests):\n    results = []\n    \n    for amount in requests:\n        min_bills_needed = float('inf')\n        \n        for i in range(n):\n            for j in range(i, n):\n                d1 = denominations[i]\n                d2 = denominations[j]\n                \n                for x in range(k + 1):\n                    for y in range(k - x + 1):\n                        if x + y > k:\n                            continue\n                        total = x * d1 + y * d2\n                        if total == amount:\n                            min_bills_needed = min(min_bills_needed, x + y)\n        \n        if min_bills_needed == float('inf'):\n            results.append(-1)\n        else:\n            results.append(min_bills_needed)\n    \n    return results\n\n# Input reading\nn, k = map(int, input().split())\ndenominations = list(map(int, input().split()))\nq = int(input())\nrequests = [int(input()) for _ in range(q)]\n\n# Get results\nresults = min_bills(n, k, denominations, q, requests)\n\n# Output results\nfor result in results:\n    print(result)"}
{"solution": "def min_time_to_reach(s, x1, x2, t1, t2, p, d):\n    # Calculate the time it takes for Igor to walk directly to x2\n    direct_walk_time = abs(x1 - x2) * t2\n    \n    # Function to calculate the time for the tram to reach a certain position\n    def tram_time(start_pos, direction, target_pos):\n        if direction == 1:  # Tram going towards s\n            if start_pos <= target_pos:\n                return (target_pos - start_pos) * t1\n            else:\n                # Tram goes to s and then back to target_pos\n                time_to_s = (s - start_pos) * t1\n                time_back_to_target = (s - target_pos) * t1\n                return time_to_s + time_back_to_target\n        else:  # Tram going towards 0\n            if start_pos >= target_pos:\n                return (start_pos - target_pos) * t1\n            else:\n                # Tram goes to 0 and then back to target_pos\n                time_to_0 = start_pos * t1\n                time_back_to_target = target_pos * t1\n                return time_to_0 + time_back_to_target\n\n    # Calculate the time for Igor to wait for the tram and then ride it\n    min_time = direct_walk_time\n    \n    # Check all possible positions where Igor can catch the tram\n    for i in range(s + 1):\n        # Time for Igor to reach position i\n        time_to_i = abs(x1 - i) * t2\n        \n        # Time for the tram to reach position i\n        time_for_tram_to_i = tram_time(p, d, i)\n        \n        # Total time if Igor waits for the tram at position i\n        total_time = time_to_i + time_for_tram_to_i\n        \n        # Now calculate the time for the tram to take Igor to x2\n        time_for_tram_to_x2 = tram_time(i, d if i < x2 else -d, x2)\n        \n        # Update the minimum time\n        min_time = min(min_time, total_time + time_for_tram_to_x2)\n\n    return min_time\n\n# Input reading\ns, x1, x2 = map(int, input().split())\nt1, t2 = map(int, input().split())\np, d = map(int, input().split())\n\n# Calculate and print the result\nresult = min_time_to_reach(s, x1, x2, t1, t2, p, d)\nprint(result)"}
{"solution": "def count_occurrences(n, x):\n    count = 0\n    for i in range(1, n + 1):\n        if x % i == 0:\n            j = x // i\n            if 1 <= j <= n:\n                count += 1\n    return count\n\nn, x = map(int, input().split())\nresult = count_occurrences(n, x)\nprint(result)"}
{"solution": "n, k = map(int, input().split())\n\n# Generate the first k lowercase letters\nletters = [chr(i) for i in range(ord('a'), ord('a') + k)]\n\n# Create the password by repeating the letters while ensuring no two consecutive are the same\npassword = []\nfor i in range(n):\n    password.append(letters[i % k])\n\n# Join the list into a string and print the result\nprint(''.join(password))"}
{"solution": "def first_collision(n, directions, positions):\n    min_time = float('inf')\n    for i in range(n - 1):\n        if directions[i] == 'R' and directions[i + 1] == 'L':\n            time_to_collision = (positions[i + 1] - positions[i]) // 2\n            min_time = min(min_time, time_to_collision)\n    \n    return min_time if min_time != float('inf') else -1\n\n# Input reading\nn = int(input().strip())\ndirections = input().strip()\npositions = list(map(int, input().strip().split()))\n\n# Output the result\nprint(first_collision(n, directions, positions))"}
{"solution": "def can_fit(w1, h1, w2, h2, a, b):\n    return (w1 + w2 <= a and max(h1, h2) <= b) or (max(w1, w2) <= a and h1 + h2 <= b)\n\ndef max_area(n, a, b, seals):\n    max_total_area = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            w1, h1 = seals[i]\n            w2, h2 = seals[j]\n            area1 = w1 * h1\n            area2 = w2 * h2\n            \n            if can_fit(w1, h1, w2, h2, a, b):\n                max_total_area = max(max_total_area, area1 + area2)\n            if can_fit(w1, h1, h2, w2, a, b):\n                max_total_area = max(max_total_area, area1 + area2)\n            if can_fit(h1, w1, w2, h2, a, b):\n                max_total_area = max(max_total_area, area1 + area2)\n            if can_fit(h1, w1, h2, w2, a, b):\n                max_total_area = max(max_total_area, area1 + area2)\n\n    return max_total_area\n\n# Input reading\nn, a, b = map(int, input().split())\nseals = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_area(n, a, b, seals))"}
{"solution": "def find_inner_point(n, points):\n    x_count = {}\n    y_count = {}\n    \n    for x, y in points:\n        if x in x_count:\n            x_count[x] += 1\n        else:\n            x_count[x] = 1\n        \n        if y in y_count:\n            y_count[y] += 1\n        else:\n            y_count[y] = 1\n    \n    # The point that is not on the boundary will have an odd count\n    for x in x_count:\n        if x_count[x] % 2 == 1:\n            inner_x = x\n            break\n    \n    for y in y_count:\n        if y_count[y] % 2 == 1:\n            inner_y = y\n            break\n    \n    return inner_x, inner_y\n\nn = int(input().strip())\npoints = [tuple(map(int, input().strip().split())) for _ in range(4 * n + 1)]\nresult = find_inner_point(n, points)\nprint(result[0], result[1])"}
{"solution": "def product_of_digits(x):\n    product = 1\n    while x > 0:\n        product *= x % 10\n        x //= 10\n    return product\n\ndef max_product(n):\n    str_n = str(n)\n    max_prod = product_of_digits(n)\n    \n    for i in range(len(str_n)):\n        if str_n[i] == '0':\n            continue\n        \n        # Create a new number by reducing the current digit by 1 and setting all following digits to 9\n        new_number = str_n[:i] + str(int(str_n[i]) - 1) + '9' * (len(str_n) - i - 1)\n        max_prod = max(max_prod, product_of_digits(int(new_number)))\n    \n    return max_prod\n\nn = int(input())\nprint(max_product(n))"}
{"solution": "def smallest_winning_k(n, a):\n    total_votes_elodreip = sum(a)\n    max_a = max(a)\n    \n    k = max_a\n    while True:\n        votes_awruk = n * k - total_votes_elodreip\n        if votes_awruk > total_votes_elodreip:\n            return k\n        k += 1\n\nn = int(input())\na = list(map(int, input().split()))\nprint(smallest_winning_k(n, a))"}
{"solution": "def count_operations(s):\n    operations = 0\n    while True:\n        to_delete = set()\n        n = len(s)\n        \n        for i in range(n):\n            if (i > 0 and s[i] != s[i - 1]) or (i < n - 1 and s[i] != s[i + 1]):\n                to_delete.add(i)\n        \n        if not to_delete:\n            break\n        \n        s = ''.join(s[i] for i in range(n) if i not in to_delete)\n        operations += 1\n    \n    return operations\n\n# Read input\ninput_string = input().strip()\n# Get the result\nresult = count_operations(input_string)\n# Print the output\nprint(result)"}
{"solution": "from collections import Counter\nfrom itertools import combinations\n\ndef count_min_product_triples(n, a):\n    # Count the occurrences of each number\n    count = Counter(a)\n    \n    # Get the three smallest unique numbers\n    unique_numbers = sorted(count.keys())\n    \n    if len(unique_numbers) < 3:\n        return 0\n    \n    # The three smallest numbers\n    x1, x2, x3 = unique_numbers[0], unique_numbers[1], unique_numbers[2]\n    \n    # Calculate the minimum product\n    min_product = x1 * x2 * x3\n    \n    # Count the number of ways to form the triples\n    if count[x1] >= 3:\n        # Case where we can choose three from x1\n        return count[x1] * (count[x1] - 1) * (count[x1] - 2) // 6\n    elif count[x1] == 2 and count[x2] >= 1:\n        # Case where we choose two from x1 and one from x2\n        return count[x1] * (count[x1] - 1) // 2 * count[x2]\n    elif count[x1] == 1 and count[x2] >= 2:\n        # Case where we choose one from x1 and two from x2\n        return count[x2] * (count[x2] - 1) // 2 * count[x1]\n    else:\n        # Case where we choose one from each of the three smallest numbers\n        return count[x1] * count[x2] * count[x3]\n\n# Input reading\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(count_min_product_triples(n, a))"}
{"solution": "def min_cuts(n):\n    if n == 0:\n        return 0\n    elif n % 2 == 0:\n        return n // 2 + 1\n    else:\n        return n\n\nn = int(input().strip())\nprint(min_cuts(n))"}
{"solution": "n = int(input().strip())\n\n# If n is non-negative, the maximum state is n itself\nif n >= 0:\n    print(n)\nelse:\n    # Convert to string to manipulate digits\n    n_str = str(n)\n    \n    # Option 1: Remove the last digit\n    option1 = int(n_str[:-1])\n    \n    # Option 2: Remove the second to last digit\n    option2 = int(n_str[:-2] + n_str[-1]) if len(n_str) > 2 else option1\n    \n    # The maximum state of the bank account\n    print(max(n, option1, option2))"}
{"solution": "def determine_direction(start, end, n):\n    positions = ['v', '<', '^', '>']\n    start_index = positions.index(start)\n    end_index = positions.index(end)\n\n    # Calculate the clockwise and counter-clockwise positions\n    cw_position = (start_index + n) % 4\n    ccw_position = (start_index - n) % 4\n\n    if cw_position == end_index and ccw_position == end_index:\n        return \"undefined\"\n    elif cw_position == end_index:\n        return \"cw\"\n    elif ccw_position == end_index:\n        return \"ccw\"\n    else:\n        return \"undefined\"\n\n# Read input\ninput_data = input().strip().split()\nstart_position = input_data[0]\nend_position = input_data[1]\nn_seconds = int(input().strip())\n\n# Determine and print the direction\nresult = determine_direction(start_position, end_position, n_seconds)\nprint(result)"}
{"solution": "def domino_show(n, s):\n    # Create a list to represent the final state of the dominoes\n    final_state = list(s)\n    \n    # Process the dominoes\n    for i in range(n):\n        if final_state[i] == 'R':\n            j = i + 1\n            while j < n and final_state[j] == '.':\n                final_state[j] = 'R'\n                j += 1\n            if j < n and final_state[j] == 'L':\n                # If we encounter an 'L', we need to balance the forces\n                mid = (i + j) // 2\n                for k in range(i + 1, mid + 1):\n                    final_state[k] = 'R'\n                for k in range(mid + 1, j):\n                    final_state[k] = 'L'\n    \n    # Count the number of standing dominoes\n    standing_count = final_state.count('.')\n    \n    return standing_count\n\n# Read input\nn = int(input().strip())\ns = input().strip()\n\n# Get the result and print it\nresult = domino_show(n, s)\nprint(result)"}
{"solution": "def restore_permutation(n, m, leaders):\n    a = [0] * n\n    visited = [False] * n\n\n    for i in range(m - 1):\n        current_leader = leaders[i] - 1\n        next_leader = leaders[i + 1] - 1\n        step_count = (next_leader - current_leader + n) % n\n        \n        if a[current_leader] == 0:\n            a[current_leader] = step_count\n        elif a[current_leader] != step_count:\n            return -1\n        \n        visited[next_leader] = True\n\n    for i in range(n):\n        if a[i] == 0:\n            a[i] = n - sum(a) + a.count(0)\n\n    if len(set(a)) != n or any(x < 1 or x > n for x in a):\n        return -1\n\n    return a\n\nn, m = map(int, input().split())\nleaders = list(map(int, input().split()))\n\nresult = restore_permutation(n, m, leaders)\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))"}
{"solution": "def max_number_after_swaps(a, k):\n    a = list(str(a))\n    n = len(a)\n\n    for i in range(n):\n        if k <= 0:\n            break\n        max_digit = a[i]\n        max_index = i\n        \n        # Find the maximum digit we can bring to the current position\n        for j in range(i + 1, min(n, i + k + 1)):\n            if a[j] > max_digit:\n                max_digit = a[j]\n                max_index = j\n        \n        # Calculate how many swaps are needed to bring max_index to i\n        swaps_needed = max_index - i\n        \n        if swaps_needed <= k:\n            # Perform the swaps\n            for j in range(max_index, i, -1):\n                a[j], a[j - 1] = a[j - 1], a[j]\n            k -= swaps_needed\n\n    return ''.join(a)\n\n# Input reading\na, k = input().split()\na = int(a)\nk = int(k)\n\n# Output the result\nprint(max_number_after_swaps(a, k))"}
{"solution": "def next_number(sequence):\n    a, b, c, d = sequence\n\n    # Check for arithmetic progression\n    if (b - a) == (c - b) == (d - c):\n        next_ap = d + (d - c)\n        print(next_ap)\n        return\n\n    # Check for geometric progression\n    if (b / a == c / b == d / c) and (a != 0 and b != 0 and c != 0 and d != 0):\n        q = b / a\n        if q != 1:\n            next_gp = d * q\n            if next_gp.is_integer():\n                print(int(next_gp))\n                return\n\n    # If neither progression or next element is not an integer\n    print(42)\n\n# Read input\nsequence = list(map(int, input().split()))\nnext_number(sequence)"}
{"solution": "def max_distance(n, colors):\n    first_color = {}\n    last_color = {}\n    \n    for i in range(n):\n        color = colors[i]\n        if color not in first_color:\n            first_color[color] = i\n        last_color[color] = i\n    \n    max_dist = 0\n    for color in first_color:\n        for other_color in last_color:\n            if color != other_color:\n                dist = abs(last_color[other_color] - first_color[color])\n                max_dist = max(max_dist, dist)\n    \n    return max_dist\n\nn = int(input())\ncolors = list(map(int, input().split()))\nprint(max_distance(n, colors))"}
{"solution": "n, m, k = map(int, input().split())\n\n# Calculate the total number of places per lane\nplaces_per_lane = 2 * m\n\n# Determine the lane (1-indexed)\nlane = (k - 1) // places_per_lane + 1\n\n# Determine the position within the lane\nposition_in_lane = (k - 1) % places_per_lane\n\n# Determine the desk (1-indexed) and side (L or R)\ndesk = position_in_lane // 2 + 1\nside = 'L' if position_in_lane % 2 == 0 else 'R'\n\nprint(lane, desk, side)"}
{"solution": "def possible_final_colors(n, s):\n    count_R = s.count('R')\n    count_G = s.count('G')\n    count_B = s.count('B')\n\n    if count_R % 2 == 0 and count_G % 2 == 0 and count_B % 2 == 0:\n        return \"BGR\"\n    elif count_R % 2 == 1 and count_G % 2 == 1 and count_B % 2 == 1:\n        return \"BGR\"\n    else:\n        result = []\n        if count_R % 2 == 1:\n            result.append('R')\n        if count_G % 2 == 1:\n            result.append('G')\n        if count_B % 2 == 1:\n            result.append('B')\n        return ''.join(sorted(result))\n\nn = int(input())\ns = input().strip()\nprint(possible_final_colors(n, s))"}
