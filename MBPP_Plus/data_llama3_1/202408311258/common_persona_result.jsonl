{"task_id": "Mbpp/2", "solution": "def similar_elements(list1, list2):\n    # Convert both lists to sets to remove duplicates and allow for efficient intersection\n    set1 = set(list1)\n    set2 = set(list2)\n    \n    # Find the intersection of the two sets\n    shared_elements = set1.intersection(set2)\n    \n    # Return the result as a tuple\n    return tuple(shared_elements)"}
{"task_id": "Mbpp/3", "solution": "def is_not_prime(n):\n    \"\"\"Return True if n is not a prime number, otherwise False.\"\"\"\n    if n <= 1:\n        return True\n    if n == 2:\n        return False\n    if n % 2 == 0:\n        return True\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return True\n    return False"}
{"task_id": "Mbpp/4", "solution": "import heapq\n\ndef heap_queue_largest(numbers, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n\n    Args:\n        numbers (list): A list of integers.\n        n (int): The number of largest integers to find.\n\n    Returns:\n        list: A list of the n largest integers in descending order.\n    \"\"\"\n    # Use the heapq.nlargest function to find the n largest integers\n    # This function returns the n largest elements from the iterable specified by the key function\n    # In this case, we don't need a key function because we're just comparing integers\n    largest_numbers = heapq.nlargest(n, numbers)\n    \n    # Return the list of largest numbers\n    return largest_numbers"}
{"task_id": "Mbpp/6", "solution": "def differ_At_One_Bit_Pos(num1, num2):\n    \"\"\"\n    This function checks whether two numbers differ at one bit position only or not.\n\n    Args:\n        num1 (int): The first number.\n        num2 (int): The second number.\n\n    Returns:\n        bool: True if the numbers differ at one bit position, False otherwise.\n    \"\"\"\n    # Calculate the XOR of the two numbers\n    xor_result = num1 ^ num2\n    \n    # Count the number of bits set in the XOR result\n    bit_count = bin(xor_result).count('1')\n    \n    # If the numbers differ at one bit position, the XOR result will have exactly one bit set\n    return bit_count == 1"}
{"task_id": "Mbpp/7", "solution": "def find_char_long(s):\n    # Split the string into words\n    words = s.split()\n    # Filter words that are at least 4 characters long\n    long_words = [word for word in words if len(word) >= 4]\n    return long_words"}
{"task_id": "Mbpp/8", "solution": "def square_nums(nums):\n    \"\"\"\n    This function calculates the squares of individual elements in a list.\n\n    Args:\n        nums (list): A list of numbers.\n\n    Returns:\n        list: A list of squares of the input numbers.\n    \"\"\"\n    return [num ** 2 for num in nums]"}
{"task_id": "Mbpp/9", "solution": "def find_Rotations(s):\n    n = len(s)\n    for i in range(1, n):\n        if s == s[i:] + s[:i]:\n            return i\n    return n"}
{"task_id": "Mbpp/11", "solution": "def remove_Occ(s, c):\n    \"\"\"\n    Removes the first and last occurrence of a given character from the string.\n\n    Args:\n        s (str): The input string.\n        c (str): The character to be removed.\n\n    Returns:\n        str: The modified string with the first and last occurrence of the character removed.\n    \"\"\"\n    first_occurrence = s.find(c)\n    last_occurrence = s.rfind(c)\n\n    if first_occurrence!= -1 and last_occurrence!= -1:\n        if first_occurrence == last_occurrence:\n            return s.replace(c, '', 1)\n        else:\n            return s[:first_occurrence] + s[first_occurrence+1:last_occurrence] + s[last_occurrence+1:]\n    else:\n        return s"}
{"task_id": "Mbpp/12", "solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)"}
{"task_id": "Mbpp/14", "solution": "def find_Volume(base, height, length):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n    \n    Parameters:\n    base (float): The base of the triangular face.\n    height (float): The height of the triangular face.\n    length (float): The length of the prism.\n    \n    Returns:\n    float: The volume of the triangular prism.\n    \"\"\"\n    # Calculate the area of the triangular base\n    triangular_area = 0.5 * base * height\n    \n    # Calculate the volume of the prism\n    volume = triangular_area * length\n    \n    return volume"}
{"task_id": "Mbpp/16", "solution": "def text_lowercase_underscore(s):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters joined with an underscore, False otherwise.\n    \"\"\"\n    # Split the string into substrings separated by underscores\n    substrings = s.split(\"_\")\n    \n    # Check each substring to ensure it only contains lowercase letters\n    for substring in substrings:\n        # If any character in the substring is not a lowercase letter, return False\n        if not substring.islower():\n            return False\n    \n    # If all substrings pass the check, return True\n    return True"}
{"task_id": "Mbpp/17", "solution": "def square_perimeter(side_length):\n    \"\"\"\n    Calculate the perimeter of a square given its side length.\n\n    :param side_length: The length of one side of the square.\n    :return: The perimeter of the square.\n    \"\"\"\n    # Since a square has four equal sides, we can simply multiply the side length by 4\n    # to get the perimeter.\n    return side_length * 4"}
{"task_id": "Mbpp/18", "solution": "def remove_dirty_chars(s1, s2):\n    \"\"\"\n    Removes characters from the first string that are present in the second string.\n\n    Args:\n        s1 (str): The original string.\n        s2 (str): The string containing characters to be removed.\n\n    Returns:\n        str: The modified string with characters from s2 removed.\n    \"\"\"\n    # Convert the second string into a set for efficient lookups\n    dirty_chars = set(s2)\n    \n    # Use a list comprehension to filter out characters from s1 that are in dirty_chars\n    clean_chars = [char for char in s1 if char not in dirty_chars]\n    \n    # Join the clean characters back into a string\n    return ''.join(clean_chars)"}
{"task_id": "Mbpp/19", "solution": "def test_duplicate(arr):\n    return len(arr)!= len(set(arr))"}
{"task_id": "Mbpp/20", "solution": "def is_woodall(n):\n    \"\"\"\n    Checks if a given number is a Woodall number.\n\n    A Woodall number is a number of the form Wn = n * 2^n - 1.\n    \"\"\"\n    import math\n\n    # Calculate the value of n for the given Woodall number\n    n = math.floor(math.log2(n + 1))\n\n    # Check if the given number is equal to the calculated Woodall number\n    return n * (2 ** n) - 1 == n"}
{"task_id": "Mbpp/56", "solution": "def check(n):\n    # Convert the number to a string to reverse it\n    reversed_n = int(str(n)[::-1])\n    # Check if the number is one less than twice its reverse\n    return n == 2 * reversed_n - 1"}
{"task_id": "Mbpp/57", "solution": "def find_Max_Num(digits):\n    \"\"\"\n    This function takes a list of digits as input and returns the largest number that can be formed using these digits.\n    \n    The approach is to sort the digits in descending order and then join them together to form the largest number.\n    \"\"\"\n    \n    # Convert each digit to a string to enable sorting and joining\n    digits = [str(digit) for digit in digits]\n    \n    # Sort the digits in descending order\n    digits.sort(reverse=True)\n    \n    # Join the sorted digits together to form the largest number\n    max_num = int(''.join(digits))\n    \n    return max_num"}
{"task_id": "Mbpp/58", "solution": "def opposite_Signs(x, y):\n    # XOR the two numbers and check the sign bit\n    return (x ^ y) < 0"}
{"task_id": "Mbpp/59", "solution": "def is_octagonal(n):\n    \"\"\"\n    This function calculates the nth octagonal number.\n    \n    The formula for the nth octagonal number is n*(2n-1).\n    \n    Parameters:\n    n (int): The position of the octagonal number to be calculated.\n    \n    Returns:\n    int: The nth octagonal number.\n    \"\"\"\n    return n * (2 * n - 1)"}
{"task_id": "Mbpp/61", "solution": "def count_Substrings(s):\n    \"\"\"\n    This function counts the number of substrings in a given string where the sum of digits equals their length.\n\n    Parameters:\n    s (str): The input string containing digits.\n\n    Returns:\n    int: The number of substrings where the sum of digits equals their length.\n    \"\"\"\n    count = 0\n    for length in range(1, len(s) + 1):\n        for i in range(len(s) - length + 1):\n            substring = s[i:i + length]\n            if sum(int(digit) for digit in substring) == length:\n                count += 1\n    return count"}
{"task_id": "Mbpp/62", "solution": "def smallest_num(numbers):\n    \"\"\"\n    This function finds the smallest number in a given list of numbers.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        int: The smallest number in the list.\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"List cannot be empty\")\n\n    smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n\n    return smallest"}
{"task_id": "Mbpp/63", "solution": "def max_difference(pairs):\n    # Initialize the maximum difference to a very small number\n    max_diff = float('-inf')\n    \n    # Iterate through each pair in the list\n    for a, b in pairs:\n        # Calculate the absolute difference between the elements of the pair\n        diff = abs(a - b)\n        # Update the maximum difference if the current difference is greater\n        if diff > max_diff:\n            max_diff = diff\n    \n    return max_diff"}
{"task_id": "Mbpp/64", "solution": "def subject_marks(marks):\n    return sorted(marks, key=lambda x: x[1])"}
{"task_id": "Mbpp/65", "solution": "def recursive_list_sum(nested_list):\n    \"\"\"\n    This function takes a nested list as input, \n    flattens it, and returns the sum of all its elements.\n\n    Args:\n        nested_list (list): A list that may contain nested lists.\n\n    Returns:\n        int: The sum of all elements in the list.\n    \"\"\"\n    total = 0\n    for element in nested_list:\n        if isinstance(element, list):\n            total += recursive_list_sum(element)\n        else:\n            total += element\n    return total"}
{"task_id": "Mbpp/66", "solution": "def pos_count(lst):\n    return sum(1 for num in lst if num > 0)"}
{"task_id": "Mbpp/67", "solution": "def bell_number(n):\n    \"\"\"\n    Calculate the nth Bell number.\n\n    The Bell numbers are a sequence of numbers that arise in combinatorial mathematics,\n    beginning with B0 = 1, and then using the recurrence relation:\n    Bn+1 = \u03a3(k=0 to n) (n choose k) * Bk\n\n    :param n: The index of the Bell number to calculate.\n    :return: The nth Bell number.\n    \"\"\"\n    bell = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n    bell[0][0] = 1\n\n    # Fill the bell[][] in bottom up manner\n    for i in range(1, n + 1):\n        # Sum of Stirling numbers of the second kind\n        bell[i][0] = bell[i - 1][i - 1]\n\n        # Fill entries similar to Pascal's triangle\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n\n    return bell[n][0]"}
{"task_id": "Mbpp/68", "solution": "def is_Monotonic(arr):\n    increasing = decreasing = True\n\n    for i in range(len(arr) - 1):\n        if arr[i] > arr[i + 1]:\n            increasing = False\n        if arr[i] < arr[i + 1]:\n            decreasing = False\n\n    return increasing or decreasing"}
{"task_id": "Mbpp/69", "solution": "def is_sublist(main_list, sub_list):\n    \"\"\"\n    Checks if a sublist exists within a main list.\n    \n    Args:\n        main_list (list): The main list to search in.\n        sub_list (list): The sublist to search for.\n    \n    Returns:\n        bool: True if the sublist exists in the main list, False otherwise.\n    \"\"\"\n    # Initialize a flag to track if the sublist is found\n    found = False\n    \n    # Iterate over the main list with the index\n    for i in range(len(main_list)):\n        \n        # Check if the current element in the main list matches the first element of the sublist\n        if main_list[i] == sub_list[0]:\n            \n            # If the lengths of the remaining main list and the sublist are equal, compare them\n            if len(main_list[i:]) >= len(sub_list):\n                \n                # Compare the remaining main list and the sublist\n                if main_list[i:i+len(sub_list)] == sub_list:\n                    \n                    # If they match, set the flag to True and break the loop\n                    found = True\n                    break\n                    \n    # Return the flag\n    return found"}
{"task_id": "Mbpp/70", "solution": "def get_equal(tuples_list):\n    if not tuples_list:\n        return True\n    first_length = len(tuples_list[0])\n    for tup in tuples_list:\n        if len(tup)!= first_length:\n            return False\n    return True"}
{"task_id": "Mbpp/71", "solution": "def comb_sort(lst):\n    \"\"\"\n    Sorts a list of elements using the Comb Sort algorithm.\n\n    Args:\n        lst (list): The list of elements to be sorted.\n\n    Returns:\n        list: The sorted list of elements.\n    \"\"\"\n    def get_next_gap(gap):\n        \"\"\"\n        Calculates the next gap for the Comb Sort algorithm.\n\n        Args:\n            gap (int): The current gap.\n\n        Returns:\n            int: The next gap.\n        \"\"\"\n        gap = (gap * 10) // 13\n        if gap < 1:\n            return 1\n        return gap\n\n    n = len(lst)\n    gap = n\n    swapped = True\n\n    while gap!= 1 or swapped:\n        gap = get_next_gap(gap)\n        swapped = False\n\n        for i in range(0, n - gap):\n            j = i + gap\n            if lst[i] > lst[j]:\n                lst[i], lst[j] = lst[j], lst[i]\n                swapped = True\n\n    return lst"}
{"task_id": "Mbpp/72", "solution": "def dif_Square(n):\n    \"\"\"\n    Checks whether a given number can be represented as the difference of two squares.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number can be represented as the difference of two squares, False otherwise.\n    \"\"\"\n    # Initialize a variable to store the result\n    result = False\n    \n    # Iterate over all possible values of 'a' and 'b'\n    for a in range(1, int(n**0.5) + 1):\n        # Calculate 'b' using the formula b = sqrt(a^2 - n)\n        b = (a**2 - n)**0.5\n        \n        # Check if 'b' is an integer\n        if b == int(b):\n            # If 'b' is an integer, set the result to True and break the loop\n            result = True\n            break\n    \n    # Return the result\n    return result"}
{"task_id": "Mbpp/74", "solution": "def is_samepatterns(patterns, sequence):\n    if len(patterns)!= len(sequence):\n        return False\n    \n    pattern_map = {}\n    \n    for pattern, seq in zip(patterns, sequence):\n        if pattern in pattern_map:\n            if pattern_map[pattern]!= seq:\n                return False\n        else:\n            if seq in pattern_map.values():\n                return False\n            pattern_map[pattern] = seq\n    \n    return True"}
{"task_id": "Mbpp/75", "solution": "def find_tuples(tuples_list, k):\n    \"\"\"\n    This function filters a list of tuples and returns a new list containing only the tuples \n    where all elements are divisible by a given number k.\n\n    Args:\n        tuples_list (list): A list of tuples.\n        k (int): The divisor.\n\n    Returns:\n        list: A list of tuples where all elements are divisible by k.\n    \"\"\"\n    return [t for t in tuples_list if all(i % k == 0 for i in t)]"}
{"task_id": "Mbpp/77", "solution": "def is_Diff(number):\n    # Convert the number to a string to easily access each digit\n    num_str = str(number)\n    \n    # Initialize sums for odd and even positioned digits\n    odd_sum = 0\n    even_sum = 0\n    \n    # Iterate over the digits\n    for i, digit in enumerate(num_str):\n        if i % 2 == 0:\n            odd_sum += int(digit)\n        else:\n            even_sum += int(digit)\n    \n    # Calculate the difference\n    difference = abs(odd_sum - even_sum)\n    \n    # Check if the difference is divisible by 11\n    return difference % 11 == 0"}
{"task_id": "Mbpp/79", "solution": "def word_len(word):\n    \"\"\"\n    This function checks whether the length of the given word is odd or not.\n    \n    Parameters:\n    word (str): The word to check.\n    \n    Returns:\n    bool: True if the length of the word is odd, False otherwise.\n    \"\"\"\n    return len(word) % 2!= 0"}
{"task_id": "Mbpp/80", "solution": "def tetrahedral_number(n):\n    return n * (n + 1) * (n + 2) // 6"}
{"task_id": "Mbpp/82", "solution": "import math\n\ndef volume_sphere(radius):\n    \"\"\"\n    Calculate the volume of a sphere given its radius.\n\n    The formula for the volume of a sphere is (4/3) * \u03c0 * r^3, where r is the radius.\n\n    Args:\n        radius (float): The radius of the sphere.\n\n    Returns:\n        float: The volume of the sphere.\n    \"\"\"\n    return (4/3) * math.pi * (radius ** 3)"}
{"task_id": "Mbpp/83", "solution": "def get_Char(s):\n    # Calculate the sum of ASCII values of all characters in the string\n    ascii_sum = sum(ord(char) for char in s)\n    \n    # Find the result modulo 26\n    mod_result = ascii_sum % 26\n    \n    # Convert the result to a character (assuming 'a' corresponds to 0, 'b' to 1,..., 'z' to 25)\n    result_char = chr(mod_result + ord('a'))\n    \n    return result_char"}
{"task_id": "Mbpp/84", "solution": "def sequence(n):\n    \"\"\"\n    This function calculates the nth number in the Newman-Conway sequence.\n    \n    The Newman-Conway sequence is a sequence of numbers where each term is the sum of the previous term and the term before that, \n    but with the following conditions:\n    - If the previous term is 1, the term before that is 0.\n    - If the term before that is 1, the previous term is 0.\n    - If both the previous term and the term before that are 1, the term is 1.\n    \n    However, based on the given unit tests, it seems that the Newman-Conway sequence in this context is actually the sequence \n    where each term is the sum of the previous term and the term before that, but with the initial terms being 1 and 1.\n    \n    :param n: The position of the term in the sequence.\n    :return: The nth term in the Newman-Conway sequence.\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    elif n == 1:\n        return 1\n    elif n == 2:\n        return 1\n    else:\n        a, b = 1, 1\n        for _ in range(2, n):\n            a, b = b, a + b\n        return b"}
{"task_id": "Mbpp/85", "solution": "import math\n\ndef surfacearea_sphere(radius):\n    \"\"\"\n    Calculate the surface area of a sphere.\n\n    Args:\n        radius (float): The radius of the sphere.\n\n    Returns:\n        float: The surface area of the sphere.\n    \"\"\"\n    return 4 * math.pi * (radius ** 2)"}
{"task_id": "Mbpp/86", "solution": "def centered_hexagonal_number(n):\n    \"\"\"\n    Calculate the nth centered hexagonal number.\n\n    The centered hexagonal number is calculated using the formula:\n    CH(n) = 3n^2 - 3n + 1\n\n    Args:\n        n (int): The position of the centered hexagonal number.\n\n    Returns:\n        int: The nth centered hexagonal number.\n    \"\"\"\n    return 3 * n ** 2 - 3 * n + 1"}
{"task_id": "Mbpp/87", "solution": "def merge_dictionaries_three(dict1, dict2, dict3):\n    merged_dict = dict1.copy()\n    for key, value in dict2.items():\n        if key not in merged_dict:\n            merged_dict[key] = value\n    for key, value in dict3.items():\n        if key not in merged_dict:\n            merged_dict[key] = value\n    return merged_dict"}
{"task_id": "Mbpp/88", "solution": "def freq_count(lst):\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict"}
{"task_id": "Mbpp/89", "solution": "def closest_num(n):\n    return n - 1"}
{"task_id": "Mbpp/90", "solution": "def len_log(words):\n    if not words:\n        return 0\n    return max(len(word) for word in words)"}
{"task_id": "Mbpp/91", "solution": "def find_substring(strings, substring):\n    \"\"\"\n    Checks if a string is present as a substring in a given list of string values.\n\n    Args:\n        strings (list): A list of string values.\n        substring (str): The substring to be searched.\n\n    Returns:\n        bool: True if the substring is found, False otherwise.\n    \"\"\"\n    for string in strings:\n        if substring in string:\n            return True\n    return False"}
{"task_id": "Mbpp/92", "solution": "def is_undulating(n):\n    \"\"\"\n    Checks whether the given number is undulating or not.\n    \n    A number is undulating if its digits alternate between increasing and decreasing.\n    \n    Parameters:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is undulating, False otherwise.\n    \"\"\"\n    # Convert the number to a string to easily access its digits\n    digits = str(n)\n    \n    # If the number has less than 3 digits, it's undulating\n    if len(digits) < 3:\n        return True\n    \n    # Initialize the direction of the undulation (1 for increasing, -1 for decreasing)\n    direction = 1\n    \n    # Iterate over the digits in the number\n    for i in range(1, len(digits)):\n        # Calculate the difference between the current digit and the previous one\n        diff = int(digits[i]) - int(digits[i-1])\n        \n        # If the difference is 0, the number is not undulating\n        if diff == 0:\n            return False\n        \n        # If the difference has the wrong sign, the number is not undulating\n        if diff * direction < 0:\n            return False\n        \n        # Update the direction for the next iteration\n        direction *= -1\n    \n    # If we've reached this point, the number is undulating\n    return True"}
{"task_id": "Mbpp/93", "solution": "def power(a, b):\n    \"\"\"\n    Calculate the value of 'a' to the power 'b'.\n\n    Args:\n        a (int): The base number.\n        b (int): The exponent.\n\n    Returns:\n        int: The result of 'a' to the power 'b'.\n    \"\"\"\n    if b == 0:\n        return 1\n    elif b < 0:\n        return 1 / power(a, -b)\n    else:\n        return a * power(a, b - 1)"}
{"task_id": "Mbpp/94", "solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Returns the first value of the tuple with the smallest second value.\n\n    Args:\n        tuples_list (list): A list of tuples.\n\n    Returns:\n        The first value of the tuple with the smallest second value.\n    \"\"\"\n    return min(tuples_list, key=lambda x: x[1])[0]"}
{"task_id": "Mbpp/95", "solution": "def Find_Min_Length(list_of_lists):\n    if not list_of_lists:\n        return 0  \n    min_length = float('inf')\n    for lst in list_of_lists:\n        if len(lst) < min_length:\n            min_length = len(lst)\n    return min_length"}
{"task_id": "Mbpp/96", "solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count"}
{"task_id": "Mbpp/97", "solution": "def frequency_lists(lists):\n    flat_list = [item for sublist in lists for item in sublist]\n    frequency_dict = {}\n    for item in flat_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    return frequency_dict"}
{"task_id": "Mbpp/98", "solution": "import math\nfrom functools import reduce\nfrom operator import mul\n\ndef multiply_num(numbers):\n    if not numbers:\n        raise ValueError(\"The list should not be empty\")\n    product = reduce(mul, numbers)\n    length = len(numbers)\n    return product / length"}
{"task_id": "Mbpp/99", "solution": "def decimal_to_binary(n):\n    if n == 0:\n        return '0'\n    binary_str = ''\n    while n > 0:\n        binary_str = str(n % 2) + binary_str\n        n = n // 2\n    return binary_str"}
{"task_id": "Mbpp/100", "solution": "def next_smallest_palindrome(n):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n\n    n += 1\n    while not is_palindrome(n):\n        n += 1\n    return n"}
{"task_id": "Mbpp/101", "solution": "def kth_element(arr, k):\n    # Check if k is within the bounds of the array\n    if k < 1 or k > len(arr):\n        raise IndexError(\"k is out of range\")\n    \n    # Convert 1-based index to 0-based index\n    index = k - 1\n    \n    # Return the element at the 0-based index\n    return arr[index]"}
{"task_id": "Mbpp/102", "solution": "def snake_to_camel(snake_str):\n    # Split the string by underscores\n    components = snake_str.split('_')\n    # Capitalize the first letter of each component and join them\n    camel_str = components[0] + ''.join(x.capitalize() for x in components[1:])\n    return camel_str"}
{"task_id": "Mbpp/103", "solution": "def eulerian_num(n, m):\n    \"\"\"\n    Calculate the Eulerian number a(n, m).\n    \n    The Eulerian number a(n, m) is the number of permutations of n elements \n    that have exactly m ascents.\n    \n    :param n: The number of elements in the permutation.\n    :param m: The number of ascents in the permutation.\n    :return: The Eulerian number a(n, m).\n    \"\"\"\n    \n    # Initialize a 2D array to store the Eulerian numbers.\n    # The array has n+1 rows and m+1 columns.\n    a = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    \n    # Base case: a(0, 0) = 1\n    a[0][0] = 1\n    \n    # Calculate the Eulerian numbers for each row.\n    for i in range(1, n + 1):\n        # Calculate the Eulerian numbers for each column.\n        for j in range(min(i, m) + 1):\n            # If j is 0, the Eulerian number is the sum of the previous row.\n            if j == 0:\n                a[i][j] = sum(a[i - 1])\n            # Otherwise, the Eulerian number is the sum of the previous row \n            # minus the previous column.\n            else:\n                a[i][j] = (i - j) * a[i - 1][j - 1] + (j + 1) * a[i - 1][j]\n    \n    # Return the Eulerian number a(n, m).\n    return a[n][m]"}
{"task_id": "Mbpp/104", "solution": "def sort_sublists(list_of_lists):\n    \"\"\"\n    Sorts each sublist of strings in a given list of lists.\n\n    Args:\n        list_of_lists (list): A list containing sublists of strings.\n\n    Returns:\n        list: A list with each sublist sorted alphabetically.\n    \"\"\"\n    return [sorted(sublist, key=str.lower) for sublist in list_of_lists]"}
{"task_id": "Mbpp/105", "solution": "def count(lst):\n    return sum(1 for elem in lst if elem)"}
{"task_id": "Mbpp/106", "solution": "def add_lists(lst, tup):\n    \"\"\"\n    Appends the given list to the given tuple.\n\n    Args:\n        lst (list): The list to be appended.\n        tup (tuple): The tuple to which the list is to be appended.\n\n    Returns:\n        tuple: A new tuple containing all elements from the original tuple and the given list.\n    \"\"\"\n    return tup + tuple(lst)"}
{"task_id": "Mbpp/108", "solution": "def merge_sorted_list(list1, list2, list3):\n    \"\"\"\n    Merge three lists into a single sorted list.\n\n    Args:\n        list1 (list): The first list to merge.\n        list2 (list): The second list to merge.\n        list3 (list): The third list to merge.\n\n    Returns:\n        list: A single sorted list containing all elements from the input lists.\n    \"\"\"\n    # Combine the three lists into one\n    combined_list = list1 + list2 + list3\n    \n    # Sort the combined list in ascending order\n    sorted_list = sorted(combined_list)\n    \n    return sorted_list"}
{"task_id": "Mbpp/109", "solution": "def odd_Equivalent(binary_string, rotations):\n    \"\"\"\n    Calculate the number of numbers with an odd value when rotating a binary string the given number of times.\n\n    Args:\n    binary_string (str): The binary string to be rotated.\n    rotations (int): The number of times the binary string is rotated.\n\n    Returns:\n    int: The number of numbers with an odd value.\n    \"\"\"\n    # Initialize a counter for numbers with odd values\n    odd_count = 0\n    \n    # Calculate the length of the binary string\n    length = len(binary_string)\n    \n    # Iterate over the number of rotations\n    for i in range(rotations):\n        # Rotate the binary string by one position\n        rotated_string = binary_string[i:] + binary_string[:i]\n        \n        # Convert the rotated binary string to an integer\n        decimal_value = int(rotated_string, 2)\n        \n        # Check if the decimal value is odd\n        if decimal_value % 2!= 0:\n            # Increment the counter if the decimal value is odd\n            odd_count += 1\n    \n    # Return the count of numbers with odd values\n    return odd_count"}
{"task_id": "Mbpp/111", "solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    This function finds the common elements in given nested lists.\n    \n    Args:\n        nested_lists (list): A list of lists containing integers.\n    \n    Returns:\n        list: A list of common elements found in all nested lists.\n    \"\"\"\n    \n    # Check if the input list is empty\n    if not nested_lists:\n        return []\n    \n    # Initialize the set of common elements with the first list\n    common_elements = set(nested_lists[0])\n    \n    # Iterate over the remaining lists\n    for lst in nested_lists[1:]:\n        # Update the set of common elements by intersecting it with the current list\n        common_elements &= set(lst)\n    \n    # Convert the set of common elements back to a list and return it\n    return list(common_elements)"}
{"task_id": "Mbpp/113", "solution": "def check_integer(s):\n    try:\n        int(s)\n        return True\n    except ValueError:\n        return False"}
{"task_id": "Mbpp/115", "solution": "def empty_dit(dict_list):\n    return all(not d for d in dict_list)"}
{"task_id": "Mbpp/116", "solution": "def tuple_to_int(tup):\n    return int(''.join(map(str, tup)))"}
{"task_id": "Mbpp/117", "solution": "def list_to_float(lst):\n    \"\"\"\n    This function converts all possible convertible elements in a list of lists to floats.\n    \n    Args:\n        lst (list): A list of lists containing elements that can be converted to floats.\n    \n    Returns:\n        list: A list of lists with all convertible elements converted to floats.\n    \"\"\"\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each sublist in the input list\n    for sub_list in lst:\n        # Initialize an empty list to store the converted sublist\n        converted_sub_list = []\n        \n        # Iterate over each element in the sublist\n        for element in sub_list:\n            # Try to convert the element to a float\n            try:\n                # If the conversion is successful, append the float to the converted sublist\n                converted_sub_list.append(float(element))\n            except ValueError:\n                # If the conversion fails, append the original element to the converted sublist\n                converted_sub_list.append(element)\n        \n        # Append the converted sublist to the result\n        result.append(converted_sub_list)\n    \n    # Return the result\n    return result"}
{"task_id": "Mbpp/118", "solution": "def string_to_list(input_string):\n    \"\"\"\n    Converts a string to a list of strings split on the space character.\n\n    Args:\n        input_string (str): The input string to be converted.\n\n    Returns:\n        list: A list of strings split on the space character.\n    \"\"\"\n    return input_string.split()"}
{"task_id": "Mbpp/119", "solution": "def search(arr):\n    left, right = 0, len(arr) - 1\n    \n    while left < right:\n        mid = (left + right) // 2\n        \n        # Ensure mid is even\n        if mid % 2 == 1:\n            mid -= 1\n        \n        # Check if the single element is in the left half or right half\n        if arr[mid] == arr[mid + 1]:\n            left = mid + 2\n        else:\n            right = mid\n    \n    return arr[left]"}
{"task_id": "Mbpp/120", "solution": "def max_product_tuple(tuples_list):\n    \"\"\"\n    This function calculates the maximum absolute product between numbers in pairs of tuples within a given list.\n\n    Args:\n        tuples_list (list): A list of tuples, where each tuple contains two numbers.\n\n    Returns:\n        float: The maximum absolute product between numbers in pairs of tuples.\n    \"\"\"\n    # Initialize max_product as negative infinity to ensure the first product is greater\n    max_product = float('-inf')\n    \n    # Iterate over each tuple in the list\n    for tup in tuples_list:\n        # Calculate the absolute product of the numbers in the current tuple\n        product = abs(tup[0] * tup[1])\n        \n        # Update max_product if the current product is greater\n        if product > max_product:\n            max_product = product\n    \n    # Return the maximum absolute product found\n    return max_product"}
{"task_id": "Mbpp/123", "solution": "def amicable_numbers_sum(n):\n    \"\"\"\n    This function calculates the sum of all amicable numbers from 1 to a specified number.\n    \n    An amicable number is a number for which the sum of its proper divisors is equal to the number itself.\n    However, in this context, we are looking for pairs of numbers where the sum of the proper divisors of one number\n    is equal to the other number, and vice versa.\n    \n    :param n: The upper limit for the range of numbers to check.\n    :return: The sum of all amicable numbers in the range.\n    \"\"\"\n\n    # Initialize a list to store the sum of proper divisors for each number\n    sum_of_divisors = [0] * (n + 1)\n\n    # Calculate the sum of proper divisors for each number\n    for i in range(1, n + 1):\n        for j in range(i, n + 1, i):\n            sum_of_divisors[j] += i\n\n    # Initialize a set to store the amicable numbers\n    amicable_numbers = set()\n\n    # Find the amicable numbers\n    for i in range(1, n + 1):\n        if sum_of_divisors[i] <= n and sum_of_divisors[sum_of_divisors[i]] == i and sum_of_divisors[i]!= i:\n            amicable_numbers.add(i)\n            amicable_numbers.add(sum_of_divisors[i])\n\n    # Return the sum of the amicable numbers\n    return sum(amicable_numbers)"}
{"task_id": "Mbpp/124", "solution": "import math\n\ndef angle_complex(real, imag):\n    return math.atan2(imag, real)"}
{"task_id": "Mbpp/125", "solution": "def find_length(binary_string):\n    \"\"\"\n    This function calculates the maximum difference between the number of 0s and 1s in any sub-string of a given binary string.\n\n    Args:\n        binary_string (str): A string consisting of 0s and 1s.\n\n    Returns:\n        int: The maximum difference between the number of 0s and 1s in any sub-string.\n    \"\"\"\n\n    # Initialize variables to keep track of the maximum difference, current difference, and the minimum current difference\n    max_diff = 0\n    curr_diff = 0\n    min_diff = 0\n\n    # Iterate over the binary string\n    for char in binary_string:\n        # If the character is '0', decrement the current difference\n        if char == '0':\n            curr_diff -= 1\n        # If the character is '1', increment the current difference\n        else:\n            curr_diff += 1\n\n        # Update the maximum difference if the current difference is greater\n        max_diff = max(max_diff, curr_diff - min_diff)\n\n        # Update the minimum current difference if the current difference is smaller\n        min_diff = min(min_diff, curr_diff)\n\n    # Return the maximum difference\n    return max_diff"}
{"task_id": "Mbpp/126", "solution": "def sum(a, b):\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n\n    def divisors(n):\n        divs = set()\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                divs.add(i)\n                divs.add(n // i)\n        return divs\n\n    common_divs = divisors(gcd(a, b))\n    return sum(common_divs)"}
{"task_id": "Mbpp/127", "solution": "def multiply_int(a, b):\n    \"\"\"\n    This function multiplies two integers.\n\n    Args:\n        a (int): The first integer.\n        b (int): The second integer.\n\n    Returns:\n        int: The product of a and b.\n    \"\"\"\n    return a * b"}
{"task_id": "Mbpp/128", "solution": "def long_words(n, sentence):\n    \"\"\"\n    This function takes a sentence and an integer n as input, \n    and returns a list of words that are longer than n characters.\n\n    Parameters:\n    n (int): The minimum length of words to be included in the output.\n    sentence (str): The input sentence.\n\n    Returns:\n    list: A list of words that are longer than n characters.\n    \"\"\"\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Use a list comprehension to filter out words that are not longer than n characters\n    long_words = [word for word in words if len(word) > n]\n    \n    # Return the list of long words\n    return long_words"}
{"task_id": "Mbpp/129", "solution": "def magic_square_test(matrix):\n    # Check if the matrix is square\n    if len(matrix)!= len(matrix[0]):\n        return False\n\n    # Calculate the expected sum\n    expected_sum = sum(matrix[0])\n\n    # Check rows\n    for row in matrix:\n        if sum(row)!= expected_sum:\n            return False\n\n    # Check columns\n    for col in range(len(matrix[0])):\n        if sum(matrix[row][col] for row in range(len(matrix)))!= expected_sum:\n            return False\n\n    # Check diagonals\n    if sum(matrix[i][i] for i in range(len(matrix)))!= expected_sum:\n        return False\n    if sum(matrix[i][len(matrix) - i - 1] for i in range(len(matrix)))!= expected_sum:\n        return False\n\n    # Check if all numbers are unique\n    flat_list = [num for row in matrix for num in row]\n    if len(flat_list)!= len(set(flat_list)):\n        return False\n\n    return True"}
{"task_id": "Mbpp/130", "solution": "def max_occurrences(lst):\n    frequency_dict = {}\n    for item in lst:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    max_frequency = max(frequency_dict.values())\n    max_items = [item for item, frequency in frequency_dict.items() if frequency == max_frequency]\n    return min(max_items)"}
{"task_id": "Mbpp/131", "solution": "def reverse_vowels(s):\n    vowels = 'aeiouAEIOU'\n    s = list(s)\n    left, right = 0, len(s) - 1\n    \n    while left < right:\n        if s[left] not in vowels:\n            left += 1\n        elif s[right] not in vowels:\n            right -= 1\n        else:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n            \n    return ''.join(s)"}
{"task_id": "Mbpp/132", "solution": "def tup_string(tup):\n    return ''.join(tup)"}
{"task_id": "Mbpp/133", "solution": "def sum_negativenum(numbers):\n    return sum(num for num in numbers if num < 0)"}
{"task_id": "Mbpp/135", "solution": "def hexagonal_num(n):\n    return 2 * n * n - n"}
{"task_id": "Mbpp/137", "solution": "import math\n\ndef zero_count(arr):\n    if not arr:\n        return 0  # Handle empty array case\n    zeroes = arr.count(0)\n    non_zeroes = len(arr) - zeroes\n    if non_zeroes == 0:\n        return float('inf')  # Handle case where all elements are zero\n    return zeroes / non_zeroes"}
{"task_id": "Mbpp/138", "solution": "def is_Sum_Of_Powers_Of_Two(n):\n    \"\"\"\n    Checks whether a given number can be represented as the sum of non-zero powers of 2.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number can be represented as the sum of non-zero powers of 2, False otherwise.\n    \"\"\"\n    # Convert the number to binary and remove the '0b' prefix\n    binary = bin(n)[2:]\n    \n    # Check if all characters in the binary representation are either '1' or '0'\n    # If not, the number cannot be represented as the sum of non-zero powers of 2\n    if not set(binary).issubset({'0', '1'}):\n        return False\n    \n    # Count the number of '1's in the binary representation\n    # If the count is greater than 1, the number can be represented as the sum of non-zero powers of 2\n    return binary.count('1') > 0"}
{"task_id": "Mbpp/139", "solution": "import math\n\ndef circle_circumference(radius):\n    \"\"\"\n    Calculate the circumference of a circle given its radius.\n\n    Args:\n        radius (float): The radius of the circle.\n\n    Returns:\n        float: The circumference of the circle.\n    \"\"\"\n    return 2 * math.pi * radius"}
{"task_id": "Mbpp/140", "solution": "def extract_singly(lists):\n    \"\"\"\n    This function takes a list of tuples as input, \n    and returns a set of unique numbers from all tuples.\n\n    :param lists: A list of tuples containing numbers.\n    :return: A set of unique numbers.\n    \"\"\"\n    # Initialize an empty set to store unique numbers\n    unique_numbers = set()\n\n    # Iterate over each tuple in the list\n    for tup in lists:\n        # Iterate over each number in the tuple\n        for num in tup:\n            # Add the number to the set\n            unique_numbers.add(num)\n\n    # Return the set of unique numbers\n    return unique_numbers"}
{"task_id": "Mbpp/141", "solution": "def pancake_sort(arr):\n    \"\"\"\n    Sorts a list of elements using the pancake sort algorithm.\n\n    Args:\n        arr (list): The list of elements to be sorted.\n\n    Returns:\n        list: The sorted list of elements.\n    \"\"\"\n    n = len(arr)\n    # Start from the complete array and one by one reduce current size by one\n    for curr_size in range(n, 0, -1):\n        # Find index of the maximum element in arr[0..curr_size]\n        max_index = arr.index(max(arr[0:curr_size]))\n        # Move the maximum element to end of current array if it's not already at the end\n        if max_index!= curr_size-1:\n            # First flip'max_index'\n            arr = arr[:max_index+1][::-1] + arr[max_index+1:]\n            # Now move the maximum number to end by reversing current array\n            arr = arr[:curr_size][::-1] + arr[curr_size:]\n    return arr"}
{"task_id": "Mbpp/142", "solution": "def count_samepair(list1, list2, list3):\n    \"\"\"\n    This function counts the number of items that are identical in the same position of three given lists.\n\n    Args:\n        list1 (list): The first list to compare.\n        list2 (list): The second list to compare.\n        list3 (list): The third list to compare.\n\n    Returns:\n        int: The number of items that are identical in the same position of the three lists.\n    \"\"\"\n    # Initialize a counter to store the number of identical items\n    count = 0\n    \n    # Iterate over the indices of the first list\n    for i in range(len(list1)):\n        # Check if the item at the current index is the same in all three lists\n        if list1[i] == list2[i] == list3[i]:\n            # If the items are the same, increment the counter\n            count += 1\n    \n    # Return the total count of identical items\n    return count"}
{"task_id": "Mbpp/143", "solution": "def find_lists(tpl):\n    count = 0\n    for item in tpl:\n        if isinstance(item, list):\n            count += 1\n    return count"}
{"task_id": "Mbpp/145", "solution": "def max_Abs_Diff(arr):\n    \"\"\"\n    This function calculates the maximum absolute difference between any two elements in a given array.\n\n    Parameters:\n    arr (tuple): A tuple of integers.\n\n    Returns:\n    int: The maximum absolute difference between any two elements in the array.\n    \"\"\"\n    # First, we find the minimum element in the array\n    min_element = min(arr)\n    \n    # Then, we find the maximum element in the array\n    max_element = max(arr)\n    \n    # The maximum absolute difference is the difference between the maximum and minimum elements\n    return max_element - min_element"}
{"task_id": "Mbpp/160", "solution": "def find_solution(a, b, n):\n    \"\"\"\n    Returns integers x and y that satisfy ax + by = n as a tuple, \n    or return None if no solution exists.\n\n    :param a: Coefficient of x\n    :param b: Coefficient of y\n    :param n: Constant term\n    :return: Tuple of integers (x, y) or None\n    \"\"\"\n    def extended_gcd(a, b):\n        \"\"\"\n        Computes the extended Euclidean algorithm to find gcd(a, b) and \n        coefficients x, y such that ax + by = gcd(a, b).\n\n        :param a: First number\n        :param b: Second number\n        :return: Tuple of gcd(a, b) and coefficients x, y\n        \"\"\"\n        if a == 0:\n            return b, 0, 1\n        else:\n            gcd, x, y = extended_gcd(b % a, a)\n            return gcd, y - (b // a) * x, x\n\n    gcd, x, y = extended_gcd(a, b)\n    if n % gcd!= 0:\n        return None\n    else:\n        x *= n // gcd\n        y *= n // gcd\n        return x, y"}
{"task_id": "Mbpp/161", "solution": "def remove_elements(main_list, elements_to_remove):\n    \"\"\"\n    Removes all elements from the main list that are present in the elements_to_remove list.\n\n    Args:\n        main_list (list): The list from which elements will be removed.\n        elements_to_remove (list): The list containing elements to be removed.\n\n    Returns:\n        list: The main list with elements removed.\n    \"\"\"\n    return [element for element in main_list if element not in elements_to_remove]"}
{"task_id": "Mbpp/162", "solution": "def sum_series(n):\n    \"\"\"\n    Calculate the sum of the series (n - 2*i) from i=0 to n // 2.\n\n    Args:\n        n (int): The upper limit of the series.\n\n    Returns:\n        int: The sum of the series.\n    \"\"\"\n    return sum(n - 2*i for i in range((n + 1) // 2))"}
{"task_id": "Mbpp/164", "solution": "def are_equivalent(a, b):\n    def sum_of_divisors(n):\n        return sum(i for i in range(1, n + 1) if n % i == 0)\n\n    return sum_of_divisors(a) == sum_of_divisors(b)"}
{"task_id": "Mbpp/165", "solution": "def count_char_position(s):\n    \"\"\"\n    Count the number of characters in a string that occur at the same position in the string as in the English alphabet (case insensitive).\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    int: The number of characters that occur at the same position in the string as in the English alphabet.\n    \"\"\"\n    s = s.lower()\n    count = 0\n    for i, char in enumerate(s):\n        if char.isalpha() and ord(char) - 96 == i + 1:\n            count += 1\n    return count"}
{"task_id": "Mbpp/166", "solution": "def find_even_pair(nums):\n    \"\"\"\n    This function counts the number of pairs of integers in a list that xor to an even number.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        int: The number of pairs of integers that xor to an even number.\n    \"\"\"\n    even_count = sum(1 for num in nums if num % 2 == 0)\n    odd_count = len(nums) - even_count\n    return even_count * (even_count - 1) // 2 + odd_count * (odd_count - 1) // 2"}
{"task_id": "Mbpp/167", "solution": "def next_power_of_2(n):\n    \"\"\"\n    Returns the smallest power of 2 greater than or equal to n.\n    \n    This function uses bitwise operations to efficiently calculate the result.\n    \"\"\"\n    if n == 0:\n        return 1\n    \n    # Calculate the number of bits required to represent n\n    num_bits = n.bit_length()\n    \n    # The smallest power of 2 greater than or equal to n is 2 to the power of num_bits\n    return 1 << num_bits"}
{"task_id": "Mbpp/168", "solution": "def frequency(lst, num):\n    \"\"\"\n    Counts the number of occurrences of a number in a given list.\n\n    Args:\n        lst (list): The list to search in.\n        num (int): The number to search for.\n\n    Returns:\n        int: The number of occurrences of the number in the list.\n    \"\"\"\n    return lst.count(num)"}
{"task_id": "Mbpp/170", "solution": "def sum_range_list(lst, start, end):\n    \"\"\"\n    This function calculates the sum of numbers in a list within a range specified by two indices.\n\n    Args:\n        lst (list): The input list of numbers.\n        start (int): The starting index of the range (inclusive).\n        end (int): The ending index of the range (inclusive).\n\n    Returns:\n        int: The sum of numbers in the list within the specified range.\n    \"\"\"\n    # Check if the input list is empty\n    if not lst:\n        return 0\n    \n    # Check if the start and end indices are valid\n    if start < 0 or end >= len(lst) or start > end:\n        raise ValueError(\"Invalid start or end index\")\n    \n    # Use list slicing to get the numbers within the specified range\n    # and the built-in sum function to calculate their sum\n    return sum(lst[start:end+1])"}
{"task_id": "Mbpp/171", "solution": "def perimeter_pentagon(side_length):\n    \"\"\"\n    Calculate the perimeter of a regular pentagon given the length of its sides.\n\n    Parameters:\n    side_length (float): The length of one side of the pentagon.\n\n    Returns:\n    float: The perimeter of the pentagon.\n    \"\"\"\n    # A regular pentagon has 5 equal sides\n    number_of_sides = 5\n    \n    # Calculate the perimeter\n    perimeter = number_of_sides * side_length\n    \n    return perimeter"}
{"task_id": "Mbpp/172", "solution": "def count_occurance(s):\n    \"\"\"\n    Counts the number of occurrences of the string'std' in a given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The number of occurrences of'std' in the string.\n    \"\"\"\n    return s.count('std')"}
{"task_id": "Mbpp/222", "solution": "def check_type(t):\n    if not t:  \n        return True\n    first_type = type(t[0])\n    return all(type(item) == first_type for item in t)"}
{"task_id": "Mbpp/223", "solution": "def is_majority(arr, n, target):\n    \"\"\"\n    Checks if the given element is the majority element in the sorted array.\n\n    Args:\n    arr (list): A sorted list of elements.\n    n (int): The length of the array.\n    target (int): The element to check for majority.\n\n    Returns:\n    bool: True if the target is the majority element, False otherwise.\n    \"\"\"\n    # Calculate the threshold for majority\n    threshold = n // 2\n    \n    # Initialize the count of the target element\n    count = 0\n    \n    # Iterate over the array to count the occurrences of the target element\n    for num in arr:\n        if num == target:\n            count += 1\n        # If the target element is not found in the first half of the array, \n        # it cannot be the majority element\n        elif count == 0 and num > target:\n            break\n    \n    # Check if the count of the target element exceeds the threshold\n    return count > threshold"}
{"task_id": "Mbpp/224", "solution": "def count_Set_Bits(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count"}
{"task_id": "Mbpp/226", "solution": "def odd_values_string(s):\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 0])"}
{"task_id": "Mbpp/227", "solution": "def min_of_three(a, b, c):\n    \"\"\"\n    Function to find the minimum of three numbers.\n    \n    Parameters:\n    a (int or float): The first number.\n    b (int or float): The second number.\n    c (int or float): The third number.\n    \n    Returns:\n    int or float: The minimum of the three numbers.\n    \"\"\"\n    # Compare the first two numbers\n    if a < b:\n        min_val = a\n    else:\n        min_val = b\n    \n    # Compare the result with the third number\n    if c < min_val:\n        min_val = c\n    \n    return min_val"}
{"task_id": "Mbpp/229", "solution": "def re_arrange_array(arr, n):\n    # Separate the first n elements into negative and non-negative lists\n    negative_elements = []\n    non_negative_elements = []\n    \n    for i in range(n):\n        if arr[i] < 0:\n            negative_elements.append(arr[i])\n        else:\n            non_negative_elements.append(arr[i])\n    \n    # Combine the negative and non-negative lists\n    rearranged = negative_elements + non_negative_elements\n    \n    # Append the remaining elements of the array (if any)\n    rearranged += arr[n:]\n    \n    return rearranged"}
{"task_id": "Mbpp/230", "solution": "def replace_blank(input_string, char):\n    return input_string.replace(' ', char)"}
{"task_id": "Mbpp/232", "solution": "def larg_nnum(lst, n):\n    return sorted(set(lst), reverse=True)[:n]"}
{"task_id": "Mbpp/233", "solution": "import math\n\ndef lateralsurface_cylinder(radius, height):\n    \"\"\"\n    Calculate the lateral surface area of a cylinder.\n\n    Parameters:\n    radius (float): The radius of the cylinder's base.\n    height (float): The height of the cylinder.\n\n    Returns:\n    float: The lateral surface area of the cylinder.\n    \"\"\"\n    # Calculate the circumference of the base\n    circumference = 2 * math.pi * radius\n    \n    # Calculate the lateral surface area\n    lateral_surface_area = circumference * height\n    \n    return lateral_surface_area"}
{"task_id": "Mbpp/234", "solution": "def volume_cube(side_length):\n    \"\"\"\n    Calculate the volume of a cube given its side length.\n\n    Args:\n        side_length (int or float): The length of a side of the cube.\n\n    Returns:\n        int or float: The volume of the cube.\n    \"\"\"\n    return side_length ** 3"}
{"task_id": "Mbpp/235", "solution": "def even_bit_set_number(n):\n    \"\"\"\n    This function sets all even bits of a given number.\n    \n    Parameters:\n    n (int): The input number.\n    \n    Returns:\n    int: The number with all even bits set.\n    \"\"\"\n    # Create a mask with all even bits set\n    mask = 0b10101010\n    \n    # Use bitwise OR operation to set all even bits in the number\n    result = n | mask\n    \n    return result"}
{"task_id": "Mbpp/237", "solution": "def check_occurences(tuples_list):\n    \"\"\"\n    This function takes a list of tuples and returns a dictionary mapping each unique tuple to the number of times it occurs in the list.\n    The function considers (a, b) and (b, a) as the same tuple.\n    \"\"\"\n    \n    # Initialize an empty dictionary to store the occurrences of each tuple\n    occurrences = {}\n    \n    # Iterate over each tuple in the list\n    for tup in tuples_list:\n        # Sort the elements of the tuple to ensure (a, b) and (b, a) are considered the same\n        sorted_tup = tuple(sorted(tup))\n        \n        # If the sorted tuple is already in the dictionary, increment its count\n        if sorted_tup in occurrences:\n            occurrences[sorted_tup] += 1\n        # If the sorted tuple is not in the dictionary, add it with a count of 1\n        else:\n            occurrences[sorted_tup] = 1\n    \n    # Return the dictionary of tuple occurrences\n    return occurrences"}
{"task_id": "Mbpp/238", "solution": "def number_of_substrings(s):\n    \"\"\"\n    Calculate the number of non-empty substrings of a given string.\n\n    The formula to calculate the number of substrings is n*(n+1)/2, \n    where n is the length of the string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The number of non-empty substrings.\n    \"\"\"\n    n = len(s)\n    return n * (n + 1) // 2"}
{"task_id": "Mbpp/239", "solution": "def get_total_number_of_sequences(m, n):\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            for k in range(j // 2, 0, -1):\n                dp[i][j] += dp[i - 1][k]\n    return sum(dp[n][1:])"}
{"task_id": "Mbpp/240", "solution": "def replace_list(list1, list2):\n    \"\"\"\n    Replaces the last element of the first list with the elements of the second list.\n\n    Args:\n        list1 (list): The list from which the last element will be replaced.\n        list2 (list): The list whose elements will replace the last element of list1.\n\n    Returns:\n        list: The modified list.\n    \"\"\"\n    if len(list1) > 0:\n        return list1[:-1] + list2\n    else:\n        return list2"}
{"task_id": "Mbpp/242", "solution": "def count_charac(s):\n    \"\"\"\n    This function calculates the total number of characters in a given string.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    int: The total number of characters in the string.\n    \"\"\"\n    return len(s.replace(\" \", \"\"))"}
{"task_id": "Mbpp/244", "solution": "import math\n\ndef next_Perfect_Square(n):\n    # Find the integer part of the square root of n\n    root = math.isqrt(n)\n    # Increment the root to get the next integer\n    next_root = root + 1\n    # Return the square of the next integer\n    return next_root * next_root"}
{"task_id": "Mbpp/245", "solution": "def max_sum(arr):\n    n = len(arr)\n    inc = [0]*n\n    dec = [0]*n\n    \n    for i in range(n):\n        inc[i] = arr[i]\n        dec[i] = arr[i]\n        \n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and inc[i] < inc[j] + arr[i]:\n                inc[i] = inc[j] + arr[i]\n                \n    for i in range(n-2, -1, -1):\n        for j in range(n-1, i, -1):\n            if arr[i] > arr[j] and dec[i] < dec[j] + arr[i]:\n                dec[i] = dec[j] + arr[i]\n                \n    max_sum = 0\n    for i in range(n):\n        max_sum = max(max_sum, inc[i] + dec[i] - arr[i])\n        \n    return max_sum"}
{"task_id": "Mbpp/247", "solution": "def lps(s):\n    \"\"\"\n    This function calculates the length of the longest palindromic subsequence in the given string.\n    \n    Parameters:\n    s (str): The input string.\n    \n    Returns:\n    int: The length of the longest palindromic subsequence.\n    \"\"\"\n    \n    # Convert the string to lowercase and remove spaces\n    s = s.replace(\" \", \"\").lower()\n    \n    # Initialize a 2D array to store the lengths of palindromic subsequences\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    \n    # All substrings with one character are palindromes\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Check for substrings of length 2\n    for i in range(n - 1):\n        if s[i] == s[i + 1]:\n            dp[i][i + 1] = 2\n        else:\n            dp[i][i + 1] = 1\n    \n    # Check for lengths greater than 2\n    for length in range(3, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    \n    # The length of the longest palindromic subsequence is stored in dp[0][n - 1]\n    return dp[0][n - 1]"}
{"task_id": "Mbpp/249", "solution": "def intersection_array(arr1, arr2):\n    \"\"\"\n    This function finds the intersection of two arrays.\n    \n    Parameters:\n    arr1 (list): The first array.\n    arr2 (list): The second array.\n    \n    Returns:\n    list: A list containing the intersection of the two input arrays.\n    \"\"\"\n    # Convert the input arrays to sets for efficient lookup\n    set1 = set(arr1)\n    set2 = set(arr2)\n    \n    # Use set intersection to find the common elements\n    intersection = set1.intersection(set2)\n    \n    # Convert the intersection set back to a list and sort it\n    intersection_list = sorted(list(intersection))\n    \n    return intersection_list"}
{"task_id": "Mbpp/250", "solution": "def count_X(tup, elem):\n    \"\"\"\n    Counts the occurrences of an element in a tuple.\n\n    Args:\n        tup (tuple): The input tuple.\n        elem: The element to be counted.\n\n    Returns:\n        int: The number of occurrences of the element in the tuple.\n    \"\"\"\n    return tup.count(elem)"}
{"task_id": "Mbpp/251", "solution": "def insert_element(lst, element):\n    \"\"\"\n    Inserts an element before each element in a list.\n\n    Args:\n        lst (list): The input list.\n        element: The element to be inserted.\n\n    Returns:\n        list: The resulting list with the element inserted before each element.\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result"}
{"task_id": "Mbpp/252", "solution": "import cmath\n\ndef convert(complex_number):\n    \"\"\"\n    Convert a complex number to polar coordinates.\n\n    Args:\n        complex_number (complex): The complex number to convert.\n\n    Returns:\n        tuple: A tuple containing the magnitude and phase of the complex number.\n    \"\"\"\n    return cmath.polar(complex_number)"}
{"task_id": "Mbpp/253", "solution": "def count_integer(lst):\n    count = 0\n    for element in lst:\n        if isinstance(element, int):\n            count += 1\n    return count"}
{"task_id": "Mbpp/255", "solution": "import itertools\n\ndef combinations_colors(colors, n):\n    \"\"\"\n    Generates all combinations (with repetition) of the elements of the list and returns a list with a tuple for each combination.\n\n    Args:\n        colors (list): A list of colors.\n        n (int): The length of each combination.\n\n    Returns:\n        list: A list of tuples, where each tuple is a combination of colors.\n    \"\"\"\n    return list(itertools.combinations_with_replacement(colors, n))"}
{"task_id": "Mbpp/256", "solution": "def count_Primes_nums(n):\n    \"\"\"\n    This function takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n    \n    Parameters:\n    n (int): A non-negative number.\n    \n    Returns:\n    int: The number of prime numbers less than the given non-negative number.\n    \"\"\"\n    \n    # Initialize a boolean array, prime, of size n+1. We'll use this array to mark off composite numbers.\n    prime = [True] * (n + 1)\n    \n    # 0 and 1 are not prime numbers.\n    prime[0] = prime[1] = False\n    \n    # Iterate over the array starting from 2.\n    for p in range(2, int(n ** 0.5) + 1):\n        # If p is a prime number, mark off its multiples as composite.\n        if prime[p]:\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n    \n    # Count the number of prime numbers in the array.\n    count = sum(prime)\n    \n    return count"}
{"task_id": "Mbpp/257", "solution": "def swap_numbers(a, b):\n    \"\"\"\n    This function takes two numbers and returns a tuple with the second number first and the first number second.\n    \n    Parameters:\n    a (int, float): The first number.\n    b (int, float): The second number.\n    \n    Returns:\n    tuple: A tuple with the second number first and the first number second.\n    \"\"\"\n    return (b, a)"}
{"task_id": "Mbpp/259", "solution": "def maximize_elements(tuple1, tuple2):\n    \"\"\"\n    This function maximizes the given two tuples by comparing corresponding elements \n    and selecting the maximum value.\n\n    Args:\n        tuple1 (tuple): The first tuple.\n        tuple2 (tuple): The second tuple.\n\n    Returns:\n        tuple: A new tuple with the maximum values from the input tuples.\n    \"\"\"\n    # Use the zip function to iterate over the tuples in parallel\n    # Use a list comprehension to create a new tuple with the maximum values\n    return tuple(max(x, y) for x, y in zip(tuple1, tuple2))"}
{"task_id": "Mbpp/260", "solution": "def is_prime(n):\n    \"\"\"Check if a number is prime.\"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef newman_prime(n):\n    \"\"\"Find the nth Newman\u2013Shanks\u2013Williams prime number.\"\"\"\n    count = 0\n    num = 2\n    while True:\n        if is_prime(num) and is_prime((num - 1) // 2):\n            count += 1\n            if count == n:\n                return num\n        num += 1"}
{"task_id": "Mbpp/261", "solution": "def division_elements(tuple1, tuple2):\n    \"\"\"\n    This function performs element-wise division of two tuples.\n    \n    Args:\n        tuple1 (tuple): The dividend tuple.\n        tuple2 (tuple): The divisor tuple.\n    \n    Returns:\n        tuple: A tuple containing the results of element-wise division.\n    \"\"\"\n    \n    # Check if the tuples have the same length\n    if len(tuple1)!= len(tuple2):\n        raise ValueError(\"Both tuples must have the same length\")\n    \n    # Initialize an empty list to store the results\n    result = []\n    \n    # Iterate over the elements of the tuples\n    for i in range(len(tuple1)):\n        # Check for division by zero\n        if tuple2[i] == 0:\n            raise ZeroDivisionError(\"Cannot divide by zero\")\n        \n        # Perform the division and append the result to the list\n        result.append(tuple1[i] // tuple2[i])\n    \n    # Convert the list to a tuple and return it\n    return tuple(result)"}
{"task_id": "Mbpp/262", "solution": "def split_two_parts(lst, L):\n    \"\"\"\n    Splits a given list into two parts where the length of the first part is L.\n\n    Args:\n        lst (list): The input list to be split.\n        L (int): The length of the first part of the list.\n\n    Returns:\n        tuple: A tuple containing the two resulting lists.\n    \"\"\"\n    return lst[:L], lst[L:]"}
{"task_id": "Mbpp/264", "solution": "def dog_age(human_age):\n    \"\"\"\n    Calculate a dog's age in dog years.\n\n    The calculation is based on the assumption that a dog's age in dog years\n    is approximately 5 times its age in human years for the first 2 years,\n    and then 4 times its age in human years for each subsequent year.\n\n    Args:\n        human_age (int): The dog's age in human years.\n\n    Returns:\n        int: The dog's age in dog years.\n    \"\"\"\n    if human_age <= 2:\n        return human_age * 10.5\n    else:\n        return 21 + (human_age - 2) * 4"}
{"task_id": "Mbpp/265", "solution": "def list_split(lst, n):\n    return [[lst[i] for i in range(j, len(lst), n)] for j in range(n)]"}
{"task_id": "Mbpp/266", "solution": "def lateralsurface_cube(side_length):\n    \"\"\"\n    Calculate the lateral surface area of a cube given its side length.\n    \n    Parameters:\n    side_length (float): The length of a side of the cube.\n    \n    Returns:\n    float: The lateral surface area of the cube.\n    \"\"\"\n    return 4 * side_length ** 2"}
{"task_id": "Mbpp/267", "solution": "def square_Sum(n):\n    \"\"\"\n    This function takes an integer n and returns the sum of the squares of the first n odd natural numbers.\n    \"\"\"\n    sum_of_squares = 0\n    odd_number = 1\n    for _ in range(n):\n        sum_of_squares += odd_number ** 2\n        odd_number += 2\n    return sum_of_squares"}
{"task_id": "Mbpp/268", "solution": "def find_star_num(n):\n    \"\"\"\n    This function calculates then'th star number.\n    \n    A star number is a centered figurate number that represents a star with a certain number of points.\n    The formula for then'th star number is 6n*(n-1) + 1.\n    \n    Parameters:\n    n (int): The position of the star number to be calculated.\n    \n    Returns:\n    int: Then'th star number.\n    \"\"\"\n    return 6*n*(n-1) + 1"}
{"task_id": "Mbpp/269", "solution": "def ascii_value(char):\n    \"\"\"\n    This function returns the ASCII value of a given character.\n    \n    Parameters:\n    char (str): A single character whose ASCII value is to be found.\n    \n    Returns:\n    int: ASCII value of the character.\n    \"\"\"\n    # Ensure the input is a single character\n    if len(char)!= 1:\n        raise ValueError(\"Input must be a single character\")\n    \n    # Return the ASCII value using the ord() function\n    return ord(char)"}
{"task_id": "Mbpp/270", "solution": "def sum_even_and_even_index(numbers):\n    \"\"\"\n    This function calculates the sum of even numbers at even positions in a list.\n\n    Args:\n        numbers (list): A list of integers.\n\n    Returns:\n        int: The sum of even numbers at even positions.\n    \"\"\"\n    return sum(num for idx, num in enumerate(numbers) if idx % 2 == 0 and num % 2 == 0)"}
{"task_id": "Mbpp/271", "solution": "def even_Power_Sum(n):\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Loop through the first n even natural numbers\n    for i in range(1, n + 1):\n        even_number = 2 * i\n        total_sum += even_number ** 5\n    \n    return total_sum"}
{"task_id": "Mbpp/272", "solution": "def rear_extract(tuples_list):\n    \"\"\"\n    This function takes a list of tuples as input and returns a list containing the rear element of each tuple.\n\n    Args:\n        tuples_list (list): A list of tuples.\n\n    Returns:\n        list: A list containing the rear element of each tuple.\n    \"\"\"\n    return [t[-1] for t in tuples_list]"}
{"task_id": "Mbpp/273", "solution": "def substract_elements(tuple1, tuple2):\n    \"\"\"\n    This function takes two tuples as input and returns a new tuple.\n    The elements of the new tuple are the result of subtracting the elements of the second tuple from the elements of the first tuple at the same index.\n\n    Args:\n        tuple1 (tuple): The first tuple.\n        tuple2 (tuple): The second tuple.\n\n    Returns:\n        tuple: A new tuple with the subtracted elements.\n    \"\"\"\n    return tuple(x - y for x, y in zip(tuple1, tuple2))"}
{"task_id": "Mbpp/274", "solution": "import math\n\ndef even_binomial_Coeff_Sum(n):\n    \"\"\"\n    This function calculates the sum of even index binomial coefficients for a given positive integer n.\n    \n    Parameters:\n    n (int): A positive integer.\n    \n    Returns:\n    int: The sum of even index binomial coefficients.\n    \"\"\"\n    \n    # Initialize the sum of even index binomial coefficients to 0\n    even_sum = 0\n    \n    # Iterate over all possible indices (from 0 to n)\n    for i in range(n + 1):\n        # Check if the index is even\n        if i % 2 == 0:\n            # Calculate the binomial coefficient using the math.comb function\n            binomial_coeff = math.comb(n, i)\n            # Add the binomial coefficient to the sum\n            even_sum += binomial_coeff\n    \n    # Return the sum of even index binomial coefficients\n    return even_sum"}
{"task_id": "Mbpp/276", "solution": "import math\n\ndef volume_cylinder(radius, height):\n    \"\"\"\n    Calculate the volume of a cylinder.\n\n    Parameters:\n    radius (float): The radius of the cylinder.\n    height (float): The height of the cylinder.\n\n    Returns:\n    float: The volume of the cylinder.\n    \"\"\"\n    return math.pi * (radius ** 2) * height"}
{"task_id": "Mbpp/277", "solution": "def dict_filter(d, n):\n    \"\"\"\n    Filters the dictionary to only include entries with values greater than or equal to n.\n\n    Parameters:\n    d (dict): The dictionary to filter.\n    n (int): The threshold value.\n\n    Returns:\n    dict: A new dictionary with filtered entries.\n    \"\"\"\n    # Initialize an empty dictionary to store the filtered results\n    filtered_dict = {}\n    \n    # Iterate through the dictionary items\n    for key, value in d.items():\n        # Check if the value is greater than or equal to n\n        if value >= n:\n            # Add the entry to the filtered dictionary\n            filtered_dict[key] = value\n    \n    return filtered_dict"}
{"task_id": "Mbpp/278", "solution": "def count_first_elements(tup):\n    \"\"\"\n    This function counts the number of elements that occur before the tuple element in the given tuple.\n\n    Args:\n        tup (tuple): The input tuple.\n\n    Returns:\n        int: The number of elements before the tuple element.\n    \"\"\"\n    count = 0\n    for element in tup:\n        if isinstance(element, tuple):\n            break\n        count += 1\n    return count"}
{"task_id": "Mbpp/279", "solution": "def is_num_decagonal(n):\n    \"\"\"\n    Function to find the nth decagonal number.\n    A decagonal number is given by the formula: D(n) = 4n^2 - 3n\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    return 4 * n * n - 3 * n"}
{"task_id": "Mbpp/280", "solution": "def sequential_search(array, element):\n    \"\"\"\n    Searches for an element in an array and returns a tuple containing a boolean \n    indicating if the element is found and its index position (or -1 if not found).\n\n    Args:\n        array (list): The list of elements to search in.\n        element: The element to search for.\n\n    Returns:\n        tuple: A tuple containing a boolean indicating if the element is found and its index position.\n    \"\"\"\n    index = -1\n    for i in range(len(array)):\n        if array[i] == element:\n            index = i\n            break\n    return (index!= -1, index)"}
{"task_id": "Mbpp/281", "solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))"}
{"task_id": "Mbpp/282", "solution": "def sub_list(list1, list2):\n    return [a - b for a, b in zip(list1, list2)]"}
{"task_id": "Mbpp/283", "solution": "def validate(n):\n    from collections import Counter\n    \n    # Convert the integer to a string to iterate over each digit\n    str_n = str(n)\n    \n    # Count the frequency of each digit\n    digit_count = Counter(str_n)\n    \n    # Check if the frequency of each digit is less than or equal to the digit itself\n    for digit, count in digit_count.items():\n        if count > int(digit):\n            return False\n    return True"}
{"task_id": "Mbpp/284", "solution": "def check_element(lst, element):\n    return all(item == element for item in lst)"}
{"task_id": "Mbpp/285", "solution": "import re\n\ndef text_match_two_three(text):\n    # Define the regular expression pattern\n    pattern = r'ab{2,3}'\n    \n    # Use re.search to find if the pattern exists in the text\n    match = re.search(pattern, text)\n    \n    # Return True if a match is found, otherwise False\n    return bool(match)"}
{"task_id": "Mbpp/286", "solution": "def max_sub_array_sum_repeated(arr, n, k):\n    \"\"\"\n    This function finds the largest sum of a contiguous array in the modified array \n    which is formed by repeating the given array k times.\n\n    Parameters:\n    arr (list): The input array.\n    n (int): The size of the input array.\n    k (int): The number of times the array is repeated.\n\n    Returns:\n    int: The maximum sum of a contiguous subarray in the modified array.\n    \"\"\"\n    \n    # Calculate the total sum of the array\n    total_sum = sum(arr)\n    \n    # Initialize the maximum sum and the current sum\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    # Initialize the minimum sum and the current sum for the second pass\n    min_sum = float('inf')\n    current_min_sum = 0\n    \n    # First pass: Find the maximum sum of a contiguous subarray in the array\n    for i in range(n):\n        current_sum += arr[i]\n        max_sum = max(max_sum, current_sum)\n        if current_sum < 0:\n            current_sum = 0\n    \n    # Second pass: Find the minimum sum of a contiguous subarray in the array\n    for i in range(n):\n        current_min_sum += arr[i]\n        min_sum = min(min_sum, current_min_sum)\n        if current_min_sum > 0:\n            current_min_sum = 0\n    \n    # If k is 1, return the maximum sum\n    if k == 1:\n        return max_sum\n    \n    # If the total sum is positive, return the maximum sum plus the total sum times (k - 2)\n    if total_sum > 0:\n        return max_sum + total_sum * (k - 2)\n    \n    # If the total sum is not positive, return the maximum sum\n    return max(max_sum, total_sum * k)"}
{"task_id": "Mbpp/287", "solution": "def square_Sum(n):\n    # Initialize the sum to 0\n    sum_of_squares = 0\n    \n    # Loop through the first n even natural numbers\n    for i in range(1, n + 1):\n        even_number = 2 * i\n        sum_of_squares += even_number ** 2\n    \n    return sum_of_squares"}
{"task_id": "Mbpp/290", "solution": "def max_length(list_of_lists):\n    if not list_of_lists:\n        return (0, [])\n    \n    max_len = 0\n    max_list = []\n    \n    for lst in list_of_lists:\n        if len(lst) > max_len:\n            max_len = len(lst)\n            max_list = lst\n    \n    return (max_len, max_list)"}
{"task_id": "Mbpp/292", "solution": "def find(dividend, divisor):\n    \"\"\"\n    This function calculates the quotient of two numbers and rounds down to the nearest integer.\n\n    Args:\n        dividend (int): The number being divided.\n        divisor (int): The number by which we are dividing.\n\n    Returns:\n        int: The quotient of the two numbers, rounded down to the nearest integer.\n    \"\"\"\n    if divisor == 0:\n        raise ZeroDivisionError(\"Cannot divide by zero\")\n    return dividend // divisor"}
{"task_id": "Mbpp/293", "solution": "import math\n\ndef otherside_rightangle(a, b):\n    \"\"\"\n    Calculate the length of the third side of a right-angled triangle.\n\n    Parameters:\n    a (float): The length of one side of the triangle.\n    b (float): The length of the other side of the triangle.\n\n    Returns:\n    float: The length of the third side of the triangle.\n    \"\"\"\n    # Use the Pythagorean theorem to calculate the length of the third side\n    # The theorem states that in a right-angled triangle, the square of the length of the hypotenuse (the side opposite the right angle)\n    # is equal to the sum of the squares of the lengths of the other two sides\n    return math.sqrt(a**2 + b**2)"}
{"task_id": "Mbpp/294", "solution": "def max_val(heterogeneous_list):\n    \"\"\"\n    This function finds the maximum integer value in a given heterogeneous list.\n    \n    Parameters:\n    heterogeneous_list (list): A list containing different data types.\n    \n    Returns:\n    int: The maximum integer value in the list.\n    \"\"\"\n    \n    # Filter out the integers from the list\n    integers = [element for element in heterogeneous_list if isinstance(element, int)]\n    \n    # Check if there are any integers in the list\n    if not integers:\n        raise ValueError(\"The list does not contain any integers.\")\n    \n    # Find the maximum integer value\n    max_value = max(integers)\n    \n    return max_value"}
{"task_id": "Mbpp/295", "solution": "def sum_div(n):\n    # Initialize the sum of divisors\n    sum_of_divisors = 0\n    \n    # Iterate through all possible divisors\n    for i in range(1, n):\n        if n % i == 0:\n            sum_of_divisors += i\n    \n    return sum_of_divisors"}
{"task_id": "Mbpp/296", "solution": "def merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n\n    # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            # There are mid - i inversions, because all elements left to i in the left subarray\n            # are greater than arr[j]\n            temp_arr[k] = arr[j]\n            inv_count += (mid-i + 1)\n            j += 1\n        k += 1\n\n    # Copy the remaining elements of left subarray, if any\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    # Copy the remaining elements of right subarray, if any\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    # Copy the sorted subarray into Original array\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n        \n    return inv_count\n\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right)//2\n\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n    return inv_count\n\ndef get_Inv_Count(arr):\n    temp_arr = [0]*len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)"}
{"task_id": "Mbpp/297", "solution": "def flatten_list(nested_list):\n    \"\"\"\n    This function takes a nested list as input and returns a single, flat list.\n    \n    The function uses recursion to traverse the nested list structure. If an element is a list, \n    the function calls itself with that element as the new nested list. If an element is not a list, \n    it is added to the flat list.\n    \"\"\"\n    flat_list = []\n    for element in nested_list:\n        if isinstance(element, list):\n            flat_list.extend(flatten_list(element))\n        else:\n            flat_list.append(element)\n    return flat_list"}
{"task_id": "Mbpp/299", "solution": "def max_aggregate(students):\n    \"\"\"\n    Calculate the maximum aggregate from a list of tuples.\n\n    Args:\n    students (list): A list of tuples, where each tuple contains a student's name and their score.\n\n    Returns:\n    tuple: A tuple containing the name of the student with the maximum aggregate and their aggregate score.\n    \"\"\"\n    # Create a dictionary to store the aggregate scores for each student\n    aggregates = {}\n    \n    # Iterate over the list of students and their scores\n    for student, score in students:\n        # If the student is already in the dictionary, add the score to their aggregate\n        if student in aggregates:\n            aggregates[student] += score\n        # If the student is not in the dictionary, add them with their score as their aggregate\n        else:\n            aggregates[student] = score\n    \n    # Find the student with the maximum aggregate\n    max_student = max(aggregates, key=aggregates.get)\n    \n    # Return the student with the maximum aggregate and their aggregate score\n    return (max_student, aggregates[max_student])"}
{"task_id": "Mbpp/300", "solution": "import math\n\ndef count_binary_seq(n):\n    \"\"\"\n    Calculate the count of all binary sequences of length 2n \n    such that sum of first n bits is same as sum of last n bits.\n    \n    Args:\n    n (int): The half length of the binary sequence.\n    \n    Returns:\n    float: The count of binary sequences.\n    \"\"\"\n    \n    # Calculate the total number of binary sequences of length 2n\n    total_sequences = 2 ** (2 * n)\n    \n    # Initialize the count of sequences with equal sums\n    equal_sum_count = 0\n    \n    # Iterate over all possible sums of the first n bits\n    for i in range(n + 1):\n        # Calculate the number of sequences with i 1's in the first n bits\n        first_n_bits = math.comb(n, i)\n        \n        # Calculate the number of sequences with i 1's in the last n bits\n        last_n_bits = math.comb(n, i)\n        \n        # Multiply the counts and add to the total count\n        equal_sum_count += first_n_bits * last_n_bits\n    \n    return equal_sum_count"}
{"task_id": "Mbpp/301", "solution": "def dict_depth(dictionary):\n    \"\"\"\n    Calculate the depth of a dictionary.\n\n    The depth of a dictionary is the maximum number of nested dictionaries.\n    \"\"\"\n    if not isinstance(dictionary, dict):\n        return 0\n    elif not dictionary:\n        return 1\n    else:\n        return 1 + max((dict_depth(v) for v in dictionary.values() if isinstance(v, dict)), default=0)"}
{"task_id": "Mbpp/305", "solution": "def start_withp(lst):\n    \"\"\"\n    Returns two words from a list of words starting with letter 'p'.\n\n    Args:\n        lst (list): A list of strings.\n\n    Returns:\n        tuple: A tuple of two words starting with 'p'.\n    \"\"\"\n    words =''.join(lst).split()\n    p_words = [word for word in words if word.startswith('p') or word.startswith('P')]\n    return tuple(p_words[:2])"}
{"task_id": "Mbpp/306", "solution": "def max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a table to store the maximum sum of increasing subsequence\n    # ending at each position\n    max_sum = [0] * n\n    \n    # Initialize the maximum sum ending at the kth position\n    max_sum[k] = arr[k]\n    \n    # Compute the maximum sum of increasing subsequence ending at each position\n    # from the kth position to the end\n    for j in range(k + 1, n):\n        max_sum[j] = arr[j]\n        for l in range(k, j):\n            if arr[j] > arr[l]:\n                max_sum[j] = max(max_sum[j], max_sum[l] + arr[j])\n    \n    # Compute the maximum sum of increasing subsequence ending at each position\n    # from the beginning to the ith position\n    for j in range(i):\n        max_sum[j] = arr[j]\n        for l in range(j):\n            if arr[j] > arr[l]:\n                max_sum[j] = max(max_sum[j], max_sum[l] + arr[j])\n    \n    # Find the maximum sum of increasing subsequence ending at the ith position\n    # that includes the kth element\n    max_sum_i = 0\n    for j in range(i):\n        if arr[j] < arr[k]:\n            max_sum_i = max(max_sum_i, max_sum[j])\n    \n    # Return the maximum sum of increasing subsequence ending at the ith position\n    # that includes the kth element\n    return max_sum_i + max_sum[k]"}
{"task_id": "Mbpp/308", "solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Find the specified number of largest products from two given lists, \n    selecting one factor from each list.\n\n    Args:\n        list1 (list): The first list of numbers.\n        list2 (list): The second list of numbers.\n        n (int): The number of largest products to find.\n\n    Returns:\n        list: A list of the n largest products.\n    \"\"\"\n    # Generate all possible products\n    products = [x * y for x in list1 for y in list2]\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the n largest products\n    return products[:n]"}
{"task_id": "Mbpp/309", "solution": "def maximum(a, b):\n    \"\"\"\n    This function returns the maximum of two numbers.\n    \n    Parameters:\n    a (int or float): The first number.\n    b (int or float): The second number.\n    \n    Returns:\n    int or float: The maximum of the two numbers.\n    \"\"\"\n    return a if a > b else b"}
{"task_id": "Mbpp/310", "solution": "def string_to_tuple(s):\n    return tuple(s)"}
{"task_id": "Mbpp/311", "solution": "def set_left_most_unset_bit(n):\n    # If all bits are set, return the number itself\n    if n == 0:\n        return 1\n    \n    # Find the position of the left-most unset bit\n    position = 0\n    while (n & (1 << position))!= 0:\n        position += 1\n    \n    # Set the left-most unset bit\n    n |= (1 << position)\n    \n    return n"}
{"task_id": "Mbpp/312", "solution": "import math\n\ndef volume_cone(radius, height):\n    return (1/3) * math.pi * radius**2 * height"}
{"task_id": "Mbpp/388", "solution": "def highest_Power_of_2(n):\n    \"\"\"\n    This function calculates the highest power of 2 that is less than or equal to n.\n    \n    Parameters:\n    n (int): The input number.\n    \n    Returns:\n    int: The highest power of 2 that is less than or equal to n.\n    \"\"\"\n    \n    # Initialize the result variable to 1, which is the lowest power of 2\n    result = 1\n    \n    # Continue the loop until the result is less than or equal to n\n    while result <= n:\n        # If the result is equal to n, it means we have found the highest power of 2\n        if result == n:\n            return result\n        \n        # If the result is less than n, we can try the next higher power of 2\n        # We can do this by shifting the bits of the result to the left by 1 place\n        # This is equivalent to multiplying the result by 2\n        result <<= 1\n    \n    # If the loop ends, it means the result has exceeded n\n    # In this case, we need to return the previous power of 2, which is result // 2\n    return result >> 1"}
{"task_id": "Mbpp/389", "solution": "def find_lucas(n):\n    # Base cases\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    \n    # Initialize the first two Lucas numbers\n    lucas_0 = 2\n    lucas_1 = 1\n    \n    # Compute the nth Lucas number iteratively\n    for i in range(2, n + 1):\n        lucas_n = lucas_0 + lucas_1\n        lucas_0 = lucas_1\n        lucas_1 = lucas_n\n    \n    return lucas_n"}
{"task_id": "Mbpp/390", "solution": "def add_string(lst, format_str):\n    \"\"\"\n    Applies a given format string to all elements in a list.\n\n    Args:\n        lst (list): The list of elements to be formatted.\n        format_str (str): The format string to be applied.\n\n    Returns:\n        list: A new list with the format string applied to each element.\n    \"\"\"\n    return [format_str.format(i) for i in lst]"}
{"task_id": "Mbpp/391", "solution": "def convert_list_dictionary(keys, values, scores):\n    return [{key: {value: score}} for key, value, score in zip(keys, values, scores)]"}
{"task_id": "Mbpp/392", "solution": "def get_max_sum(n, memo={}):\n    \"\"\"\n    This function calculates the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n    \n    Args:\n        n (int): The input number.\n        memo (dict): A dictionary to store the results of subproblems to avoid redundant calculations.\n        \n    Returns:\n        int: The maximum sum possible.\n    \"\"\"\n    \n    # Base case: If n is 0 or less, return 0\n    if n <= 0:\n        return 0\n    \n    # If the result is already in the memo, return it\n    if n in memo:\n        return memo[n]\n    \n    # Calculate the maximum sum by considering all possible divisions\n    max_sum = n\n    for divisor in [2, 3, 4, 5]:\n        if n % divisor == 0:\n            max_sum = max(max_sum, get_max_sum(n // divisor, memo) + get_max_sum(n % divisor, memo))\n    \n    # Store the result in the memo and return it\n    memo[n] = max_sum\n    return max_sum"}
{"task_id": "Mbpp/394", "solution": "def check_distinct(tup):\n    \"\"\"\n    Checks if a given tuple contains no duplicates.\n\n    Args:\n        tup (tuple): The input tuple to be checked.\n\n    Returns:\n        bool: True if the tuple contains no duplicates, False otherwise.\n    \"\"\"\n    # Convert the tuple to a set, which automatically removes duplicates\n    # If the lengths of the tuple and the set are equal, then there were no duplicates\n    return len(tup) == len(set(tup))"}
{"task_id": "Mbpp/395", "solution": "def first_non_repeating_character(s):\n    char_count = {}\n    \n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    return None"}
{"task_id": "Mbpp/396", "solution": "def check_char(s):\n    if len(s) > 0 and s[0] == s[-1]:\n        return True\n    else:\n        return False"}
{"task_id": "Mbpp/397", "solution": "def median_numbers(a, b, c):\n    if (a <= b and b <= c) or (c <= b and b <= a):\n        return float(b)\n    elif (b <= a and a <= c) or (c <= a and a <= b):\n        return float(a)\n    else:\n        return float(c)"}
{"task_id": "Mbpp/398", "solution": "def sum_of_digits(lst):\n    \"\"\"\n    Compute the sum of digits of each number in a given list.\n\n    Args:\n        lst (list): A list containing numbers and/or lists of numbers.\n\n    Returns:\n        int: The sum of digits of all numbers in the list.\n    \"\"\"\n    def sum_digits(n):\n        return sum(int(digit) for digit in str(abs(n)))\n\n    total_sum = 0\n    for item in lst:\n        if isinstance(item, list):\n            total_sum += sum_of_digits(item)\n        elif isinstance(item, (int, float)):\n            total_sum += sum_digits(item)\n    return total_sum"}
{"task_id": "Mbpp/400", "solution": "def extract_freq(tuples_list):\n    \"\"\"\n    This function takes a list of tuples as input and returns the number of unique tuples.\n    \n    The function considers (a, b) and (b, a) as the same tuple.\n    \"\"\"\n    \n    # Create an empty set to store unique tuples. Sets in Python are unordered collections of unique elements.\n    unique_tuples = set()\n    \n    # Iterate over each tuple in the input list.\n    for tup in tuples_list:\n        # Sort the elements of the tuple and add it to the set. This ensures that (a, b) and (b, a) are considered the same.\n        unique_tuples.add(tuple(sorted(tup)))\n    \n    # Return the number of unique tuples, which is the size of the set.\n    return len(unique_tuples)"}
{"task_id": "Mbpp/404", "solution": "def minimum(a, b):\n    return a if a < b else b"}
{"task_id": "Mbpp/405", "solution": "def check_tuplex(tuplex, element):\n    \"\"\"\n    Checks if an element exists within a tuple.\n\n    Args:\n        tuplex (tuple): The tuple to search in.\n        element: The element to search for.\n\n    Returns:\n        bool: True if the element exists in the tuple, False otherwise.\n    \"\"\"\n    return element in tuplex"}
{"task_id": "Mbpp/406", "solution": "def find_Parity(n):\n    \"\"\"\n    This function determines whether the parity of a given number is odd.\n\n    Args:\n        n (int): The number to check for parity.\n\n    Returns:\n        bool: True if the parity is odd, False otherwise.\n    \"\"\"\n    return n % 2!= 0"}
{"task_id": "Mbpp/407", "solution": "def rearrange_bigger(n):\n    digits = [int(d) for d in str(n)]\n    for i in range(len(digits) - 1, 0, -1):\n        if digits[i - 1] < digits[i]:\n            break\n    else:\n        return None\n\n    for j in range(len(digits) - 1, i - 1, -1):\n        if digits[j] > digits[i - 1]:\n            digits[j], digits[i - 1] = digits[i - 1], digits[j]\n            break\n\n    return int(''.join(map(str, digits[:i] + sorted(digits[i:]))))"}
{"task_id": "Mbpp/409", "solution": "def min_product_tuple(pairs):\n    min_product = float('inf')\n    for a, b in pairs:\n        product = a * b\n        if product < min_product:\n            min_product = product\n    return min_product"}
{"task_id": "Mbpp/410", "solution": "def min_val(lst):\n    \"\"\"\n    This function finds the minimum value in a given heterogeneous list.\n    \n    It filters out non-numeric values and returns the smallest number.\n    \n    If the list is empty or contains no numbers, it raises a ValueError.\n    \"\"\"\n    numeric_values = [x for x in lst if isinstance(x, (int, float))]\n    if not numeric_values:\n        raise ValueError(\"List is empty or contains no numbers\")\n    return min(numeric_values)"}
{"task_id": "Mbpp/412", "solution": "def remove_odd(numbers):\n    \"\"\"\n    Removes odd numbers from a given list.\n\n    Args:\n        numbers (list): A list of integers.\n\n    Returns:\n        list: A new list containing only the even numbers from the input list.\n    \"\"\"\n    even_numbers = []\n    for num in numbers:\n        if num % 2 == 0:\n            even_numbers.append(num)\n    return even_numbers"}
{"task_id": "Mbpp/413", "solution": "def extract_nth_element(tuples_list, n):\n    \"\"\"\n    Extracts the nth element from a given list of tuples.\n\n    Args:\n        tuples_list (list): A list of tuples.\n        n (int): The index of the element to be extracted.\n\n    Returns:\n        list: A list of the nth elements from each tuple.\n    \"\"\"\n    return [t[n] for t in tuples_list]"}
{"task_id": "Mbpp/414", "solution": "def overlapping(seq1, seq2):\n    # Convert the second sequence to a set for O(1) average time complexity lookups\n    set_seq2 = set(seq2)\n    # Check if any element in the first sequence is in the set of the second sequence\n    for item in seq1:\n        if item in set_seq2:\n            return True\n    return False"}
{"task_id": "Mbpp/415", "solution": "def max_Product(arr):\n    if len(arr) < 2:\n        raise ValueError(\"Array must contain at least two elements\")\n    \n    # Initialize the two largest and two smallest values\n    max1 = max2 = float('-inf')\n    min1 = min2 = float('inf')\n    \n    for num in arr:\n        # Update the two largest values\n        if num > max1:\n            max2 = max1\n            max1 = num\n        elif num > max2:\n            max2 = num\n        \n        # Update the two smallest values\n        if num < min1:\n            min2 = min1\n            min1 = num\n        elif num < min2:\n            min2 = num\n    \n    # Compare the product of the two largest values with the product of the two smallest values\n    if max1 * max2 > min1 * min2:\n        return (max1, max2)\n    else:\n        return (min1, min2)"}
{"task_id": "Mbpp/418", "solution": "def Find_Max(lst):\n    max_element = lst[0]\n    for element in lst:\n        if len(element) > len(max_element):\n            max_element = element\n    return max_element"}
{"task_id": "Mbpp/419", "solution": "def round_and_sum(numbers):\n    rounded_numbers = [round(num) for num in numbers]\n    total_sum = sum(rounded_numbers)\n    result = total_sum * len(numbers)\n    print(result)"}
{"task_id": "Mbpp/420", "solution": "def cube_Sum(n):\n    # Calculate the sum of cubes of the first n even natural numbers\n    return sum((2 * i) ** 3 for i in range(1, n + 1))"}
{"task_id": "Mbpp/421", "solution": "def concatenate_tuple(tuple_to_concatenate):\n    \"\"\"\n    Concatenates each element of a tuple into a string, separated by a hyphen.\n\n    Args:\n        tuple_to_concatenate (tuple): A tuple containing elements to be concatenated.\n\n    Returns:\n        str: A string with each element of the tuple concatenated, separated by a hyphen.\n    \"\"\"\n    return '-'.join(map(str, tuple_to_concatenate))"}
{"task_id": "Mbpp/422", "solution": "def find_Average_Of_Cube(n):\n    # Calculate the sum of cubes of the first n natural numbers\n    sum_of_cubes = sum(i**3 for i in range(1, n+1))\n    # Calculate the average by dividing the sum by n\n    average_of_cubes = sum_of_cubes / n\n    return average_of_cubes"}
{"task_id": "Mbpp/424", "solution": "def extract_rear(strings):\n    \"\"\"\n    Extracts the last character from each string in the given tuple.\n\n    Args:\n        strings (tuple): A tuple of strings.\n\n    Returns:\n        list: A list of the last characters from each string.\n    \"\"\"\n    return [string[-1] for string in strings]"}
{"task_id": "Mbpp/425", "solution": "def count_element_in_list(lists, element):\n    \"\"\"\n    Counts the number of sublists containing a particular element.\n\n    Args:\n        lists (list): A list of sublists.\n        element: The element to be searched in the sublists.\n\n    Returns:\n        int: The number of sublists containing the element.\n    \"\"\"\n    count = 0\n    for sublist in lists:\n        if element in sublist:\n            count += 1\n    return count"}
{"task_id": "Mbpp/426", "solution": "def filter_oddnumbers(numbers):\n    return [num for num in numbers if num % 2!= 0]"}
{"task_id": "Mbpp/427", "solution": "def change_date_format(date_str):\n    \"\"\"\n    Converts a date string from yyyy-mm-dd format to dd-mm-yyyy format.\n\n    Args:\n        date_str (str): The date string in yyyy-mm-dd format.\n\n    Returns:\n        str: The date string in dd-mm-yyyy format.\n    \"\"\"\n    year, month, day = date_str.split('-')\n    return f'{day}-{month}-{year}'"}
{"task_id": "Mbpp/428", "solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr"}
{"task_id": "Mbpp/429", "solution": "def and_tuples(tuple1, tuple2):\n    \"\"\"\n    This function takes two tuples as input and returns a new tuple.\n    The new tuple contains the elementwise AND of the corresponding elements in the input tuples.\n    \n    Parameters:\n    tuple1 (tuple): The first tuple.\n    tuple2 (tuple): The second tuple.\n    \n    Returns:\n    tuple: A new tuple containing the elementwise AND of the input tuples.\n    \"\"\"\n    return tuple(a & b for a, b in zip(tuple1, tuple2))"}
{"task_id": "Mbpp/430", "solution": "def parabola_directrix(a, b, c):\n    \"\"\"\n    Calculate the directrix of a parabola given its coefficients.\n\n    The directrix of a parabola in the form y = ax^2 + bx + c is given by:\n    y = (4ac - b^2) / 4a\n\n    Parameters:\n    a (float): The coefficient of x^2 in the parabola equation.\n    b (float): The coefficient of x in the parabola equation.\n    c (float): The constant term in the parabola equation.\n\n    Returns:\n    float: The y-coordinate of the directrix.\n    \"\"\"\n    return (4*a*c - b**2) / (4*a)"}
{"task_id": "Mbpp/431", "solution": "def common_element(list1, list2):\n    return len(set(list1) & set(list2)) > 0"}
{"task_id": "Mbpp/432", "solution": "def median_trapezium(a, b, c):\n    \"\"\"\n    Calculate the median length of a trapezium.\n\n    The median length of a trapezium is the average of the lengths of the two parallel sides.\n\n    Parameters:\n    a (float): The length of the first parallel side.\n    b (float): The length of the second parallel side.\n    c (float): The length of the non-parallel side (not used in this calculation).\n\n    Returns:\n    float: The median length of the trapezium.\n    \"\"\"\n    return (a + b) / 2"}
{"task_id": "Mbpp/433", "solution": "def check_greater(arr, num):\n    for element in arr:\n        if num <= element:\n            return False\n    return True"}
{"task_id": "Mbpp/435", "solution": "def last_Digit(number):\n    return number % 10"}
{"task_id": "Mbpp/436", "solution": "def neg_nos(lst):\n    \"\"\"\n    Returns a list of negative numbers from the input list.\n\n    :param lst: A list of integers\n    :return: A list of negative integers\n    \"\"\"\n    return [num for num in lst if num < 0]"}
{"task_id": "Mbpp/437", "solution": "def remove_odd(s):\n    return s[1::2]"}
{"task_id": "Mbpp/438", "solution": "def count_bidirectional(tuples):\n    seen = set()\n    count = 0\n    for tup in tuples:\n        sorted_tup = tuple(sorted(tup))\n        if sorted_tup not in seen:\n            seen.add(sorted_tup)\n            count += 1\n    return count"}
{"task_id": "Mbpp/439", "solution": "def multiple_to_single(integers):\n    \"\"\"\n    This function joins a list of multiple integers into a single integer.\n    \n    Parameters:\n    integers (list): A list of integers to be joined.\n    \n    Returns:\n    int: A single integer formed by joining the integers in the input list.\n    \"\"\"\n    # Convert each integer to a string to easily concatenate them\n    str_integers = [str(abs(i)) for i in integers]\n    \n    # Join the strings together\n    joined_str = ''.join(str_integers)\n    \n    # Convert the joined string back to an integer\n    result = int(joined_str)\n    \n    # Determine the sign of the result based on the sign of the first integer\n    if integers[0] < 0:\n        result = -result\n    \n    return result"}
{"task_id": "Mbpp/440", "solution": "import re\n\ndef find_adverb_position(sentence):\n    \"\"\"\n    Find the first adverb and its position in a given sentence.\n\n    Args:\n        sentence (str): The input sentence.\n\n    Returns:\n        tuple: A tuple containing the start position, end position, and the adverb itself.\n    \"\"\"\n    # Use regular expression to find the first adverb\n    adverb_match = re.search(r'\\b\\w+(ly|wise|wards|ways)\\b', sentence)\n    \n    # If an adverb is found\n    if adverb_match:\n        # Get the start and end positions of the adverb\n        start_position = adverb_match.start()\n        end_position = adverb_match.end()\n        \n        # Return the start position, end position, and the adverb itself\n        return (start_position, end_position, adverb_match.group())\n    \n    # If no adverb is found, return None\n    else:\n        return None"}
{"task_id": "Mbpp/441", "solution": "def surfacearea_cube(side_length):\n    # Calculate the surface area of a cube\n    surface_area = 6 * (side_length ** 2)\n    return surface_area"}
{"task_id": "Mbpp/442", "solution": "def positive_count(arr):\n    if not arr:\n        return 0  # Handle the case of an empty array\n    positive_numbers = [num for num in arr if num > 0]\n    ratio = len(positive_numbers) / len(arr)\n    return round(ratio, 3)"}
{"task_id": "Mbpp/445", "solution": "def index_multiplication(tuple1, tuple2):\n    \"\"\"\n    This function performs index wise multiplication of tuple elements in the given two tuples.\n    \n    Args:\n        tuple1 (tuple): The first tuple containing tuples of integers.\n        tuple2 (tuple): The second tuple containing tuples of integers.\n    \n    Returns:\n        tuple: A tuple containing tuples of integers, where each integer is the product of corresponding integers in the input tuples.\n    \"\"\"\n    \n    # Initialize an empty list to store the results\n    result = []\n    \n    # Iterate over the tuples in the input tuples\n    for t1, t2 in zip(tuple1, tuple2):\n        # Initialize an empty list to store the products of corresponding integers\n        products = []\n        \n        # Iterate over the integers in the tuples\n        for i1, i2 in zip(t1, t2):\n            # Calculate the product of corresponding integers and append it to the products list\n            products.append(i1 * i2)\n        \n        # Convert the products list to a tuple and append it to the result list\n        result.append(tuple(products))\n    \n    # Convert the result list to a tuple and return it\n    return tuple(result)"}
{"task_id": "Mbpp/446", "solution": "def count_Occurrence(tuple_elements, list_elements):\n    \"\"\"\n    Counts the occurrences of all elements of a list in a tuple.\n\n    Args:\n        tuple_elements (tuple): The tuple to search in.\n        list_elements (list): The list of elements to search for.\n\n    Returns:\n        int: The total count of occurrences of all elements in the list.\n    \"\"\"\n    # Initialize a counter variable to store the total count\n    total_count = 0\n    \n    # Iterate over each element in the list\n    for element in list_elements:\n        # Count the occurrences of the current element in the tuple\n        # and add it to the total count\n        total_count += tuple_elements.count(element)\n    \n    # Return the total count\n    return total_count"}
{"task_id": "Mbpp/447", "solution": "def cube_nums(nums):\n    \"\"\"\n    This function calculates the cube of each number in a given list.\n\n    Args:\n        nums (list): A list of numbers.\n\n    Returns:\n        list: A list of cubes of the input numbers.\n    \"\"\"\n    # Initialize an empty list to store the cubes\n    cubes = []\n    \n    # Iterate over each number in the input list\n    for num in nums:\n        # Calculate the cube of the current number\n        cube = num ** 3\n        \n        # Append the cube to the list of cubes\n        cubes.append(cube)\n    \n    # Return the list of cubes\n    return cubes"}
{"task_id": "Mbpp/448", "solution": "def cal_sum(n):\n    \"\"\"\n    Calculate the sum of Perrin numbers up to the nth number.\n\n    The Perrin sequence is a sequence of integers, defined by the recurrence relation:\n    P(0) = 3, P(1) = 0, P(2) = 2, and P(n) = P(n-2) + P(n-3) for n > 2.\n\n    Args:\n        n (int): The number of Perrin numbers to sum.\n\n    Returns:\n        int: The sum of the first n Perrin numbers.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n\n    # Initialize the first three Perrin numbers\n    p0, p1, p2 = 3, 0, 2\n\n    # Initialize the sum with the first three Perrin numbers\n    total = p0 + p1 + p2\n\n    # Calculate the sum of the remaining Perrin numbers\n    for _ in range(3, n):\n        # Calculate the next Perrin number\n        p_next = p0 + p1\n\n        # Update the sum\n        total += p_next\n\n        # Update the previous Perrin numbers\n        p0, p1, p2 = p1, p2, p_next\n\n    return total"}
{"task_id": "Mbpp/450", "solution": "def extract_string(string_list, size):\n    \"\"\"\n    Extracts strings of a specified size from a given list of string values.\n\n    Args:\n        string_list (list): A list of string values.\n        size (int): The specified size of strings to extract.\n\n    Returns:\n        list: A list of strings that match the specified size.\n    \"\"\"\n    return [string for string in string_list if len(string) == size]"}
{"task_id": "Mbpp/451", "solution": "def remove_whitespaces(s):\n    return s.replace(\" \", \"\")"}
{"task_id": "Mbpp/453", "solution": "def sumofFactors(n):\n    \"\"\"\n    This function calculates the sum of even factors of a given number.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The sum of even factors of the input number.\n    \"\"\"\n    # Initialize the sum of even factors to 0\n    even_factors_sum = 0\n    \n    # Iterate over all numbers from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # Check if i is a factor of n\n        if n % i == 0:\n            # Check if the factor is even\n            if i % 2 == 0:\n                # Add the even factor to the sum\n                even_factors_sum += i\n    \n    # Return the sum of even factors\n    return even_factors_sum"}
{"task_id": "Mbpp/454", "solution": "import re\n\ndef text_match_wordz(text):\n    return bool(re.search(r'\\b\\w*z\\w*\\b', text))"}
{"task_id": "Mbpp/455", "solution": "def check_monthnumb_number(month_number):\n    \"\"\"\n    This function checks whether a given month number contains 31 days or not.\n\n    Args:\n        month_number (int): The month number to be checked.\n\n    Returns:\n        bool: True if the month has 31 days, False otherwise.\n    \"\"\"\n    # Define the months that have 31 days\n    months_with_31_days = [1, 3, 5, 7, 8, 10, 12]\n    \n    # Check if the given month number is in the list of months with 31 days\n    return month_number in months_with_31_days"}
{"task_id": "Mbpp/456", "solution": "def reverse_string_list(string_list):\n    \"\"\"\n    This function takes a list of string values as input and returns a new list \n    where each string in the original list is reversed.\n\n    Args:\n        string_list (list): A list of string values.\n\n    Returns:\n        list: A new list with each string in the original list reversed.\n    \"\"\"\n    # Initialize an empty list to store the reversed strings\n    reversed_list = []\n    \n    # Iterate over each string in the input list\n    for string in string_list:\n        # Reverse the string using slicing and append it to the reversed list\n        reversed_list.append(string[::-1])\n    \n    # Return the list of reversed strings\n    return reversed_list"}
{"task_id": "Mbpp/457", "solution": "def Find_Min(lists):\n    if not lists:\n        return []\n    min_list = lists[0]\n    for sublist in lists:\n        if len(sublist) < len(min_list):\n            min_list = sublist\n    return min_list"}
{"task_id": "Mbpp/458", "solution": "def rectangle_area(length, width):\n    \"\"\"\n    Calculate the area of a rectangle.\n\n    Parameters:\n    length (int): The length of the rectangle.\n    width (int): The width of the rectangle.\n\n    Returns:\n    int: The area of the rectangle.\n    \"\"\"\n    if not isinstance(length, (int, float)) or not isinstance(width, (int, float)):\n        raise TypeError(\"Both length and width must be numbers.\")\n    if length <= 0 or width <= 0:\n        raise ValueError(\"Both length and width must be positive.\")\n    return length * width"}
{"task_id": "Mbpp/459", "solution": "def remove_uppercase(s):\n    result = ''\n    uppercase_substring = ''\n    for char in s:\n        if char.isupper():\n            uppercase_substring += char\n        else:\n            if uppercase_substring:\n                uppercase_substring = ''\n            result += char\n    return result"}
{"task_id": "Mbpp/460", "solution": "def Extract(sublists):\n    \"\"\"\n    This function takes a list of sublists as input and returns a list containing the first element of each sublist.\n    \n    Parameters:\n    sublists (list): A list of sublists.\n    \n    Returns:\n    list: A list containing the first element of each sublist.\n    \"\"\"\n    return [sublist[0] for sublist in sublists]"}
{"task_id": "Mbpp/461", "solution": "def upper_ctr(s):\n    \"\"\"\n    Counts the number of uppercase characters in a given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The number of uppercase characters in the string.\n    \"\"\"\n    return sum(1 for c in s if c.isupper())"}
{"task_id": "Mbpp/462", "solution": "def combinations_list(lst):\n    def combinations(lst, n):\n        if n == 0:\n            return [[]]\n        result = []\n        for i in range(len(lst)):\n            current = lst[i]\n            rest = lst[i + 1:]\n            for c in combinations(rest, n - 1):\n                result.append([current] + c)\n        return result\n\n    result = []\n    for i in range(len(lst) + 1):\n        result.extend(combinations(lst, i))\n    return sorted(result, key=len)"}
{"task_id": "Mbpp/463", "solution": "def max_subarray_product(nums):\n    if not nums:\n        return 0\n\n    max_product = min_product = result = nums[0]\n\n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            max_product, min_product = min_product, max_product\n\n        max_product = max(nums[i], max_product * nums[i])\n        min_product = min(nums[i], min_product * nums[i])\n\n        result = max(result, max_product)\n\n    return result"}
{"task_id": "Mbpp/465", "solution": "def drop_empty(dictionary):\n    \"\"\"\n    Drops empty items from a given dictionary.\n\n    Args:\n        dictionary (dict): The dictionary to drop empty items from.\n\n    Returns:\n        dict: A new dictionary with empty items removed.\n    \"\"\"\n    return {key: value for key, value in dictionary.items() if value is not None}"}
{"task_id": "Mbpp/468", "solution": "def max_product(nums):\n    \"\"\"\n    This function finds the maximum product formed by multiplying numbers of an increasing subsequence of the input array.\n    \n    Args:\n    nums (list): A list of integers.\n    \n    Returns:\n    int: The maximum product of an increasing subsequence.\n    \"\"\"\n    \n    # Handle edge case where input list is empty\n    if not nums:\n        return 0\n    \n    # Initialize variables to store the maximum and minimum product ending at the current position\n    max_product = [0] * len(nums)\n    min_product = [0] * len(nums)\n    \n    # Initialize variables to store the maximum product found so far\n    max_product[0] = min_product[0] = result = nums[0]\n    \n    # Iterate over the input list starting from the second element\n    for i in range(1, len(nums)):\n        # If the current number is positive, update max_product and min_product accordingly\n        if nums[i] > 0:\n            max_product[i] = max(nums[i], max_product[i-1] * nums[i])\n            min_product[i] = min(nums[i], min_product[i-1] * nums[i])\n        # If the current number is negative, update max_product and min_product accordingly\n        else:\n            max_product[i] = max(nums[i], min_product[i-1] * nums[i])\n            min_product[i] = min(nums[i], max_product[i-1] * nums[i])\n        \n        # Update the maximum product found so far\n        result = max(result, max_product[i])\n    \n    # Return the maximum product found\n    return result"}
{"task_id": "Mbpp/470", "solution": "def add_pairwise(tup):\n    \"\"\"\n    This function calculates the pairwise addition of neighboring elements in a tuple.\n\n    Args:\n        tup (tuple): A tuple of integers.\n\n    Returns:\n        tuple: A tuple containing the pairwise addition of neighboring elements.\n    \"\"\"\n    # Initialize an empty list to store the pairwise sums\n    pairwise_sums = []\n    \n    # Iterate over the indices of the tuple, excluding the last one\n    for i in range(len(tup) - 1):\n        # Calculate the sum of the current element and the next one\n        pairwise_sum = tup[i] + tup[i + 1]\n        \n        # Append the sum to the list\n        pairwise_sums.append(pairwise_sum)\n    \n    # Convert the list to a tuple and return it\n    return tuple(pairwise_sums)"}
{"task_id": "Mbpp/471", "solution": "def find_remainder(arr, n):\n    \"\"\"\n    This function calculates the product of array elements modulo n.\n\n    Args:\n        arr (list): A list of integers.\n        n (int): The modulo value.\n\n    Returns:\n        int: The product of array elements modulo n.\n    \"\"\"\n    product = 1\n    for num in arr:\n        product = (product * num) % n\n    return product"}
{"task_id": "Mbpp/472", "solution": "def check_Consecutive(lst):\n    if not lst:\n        return False\n    sorted_lst = sorted(lst)\n    return len(sorted_lst) == len(set(sorted_lst)) and max(sorted_lst) - min(sorted_lst) == len(sorted_lst) - 1"}
{"task_id": "Mbpp/473", "solution": "def tuple_intersection(list1, list2):\n    set1 = set(tuple(sorted(t)) for t in list1)\n    set2 = set(tuple(sorted(t)) for t in list2)\n    return set1.intersection(set2)"}
{"task_id": "Mbpp/474", "solution": "def replace_char(s, old_char, new_char):\n    return s.replace(old_char, new_char)"}
{"task_id": "Mbpp/475", "solution": "def sort_counter(counter):\n    \"\"\"\n    Sorts a dictionary by value in descending order.\n\n    Args:\n        counter (dict): The dictionary to be sorted.\n\n    Returns:\n        list: A list of tuples containing the key-value pairs, sorted by value.\n    \"\"\"\n    return sorted(counter.items(), key=lambda x: x[1], reverse=True)"}
{"task_id": "Mbpp/476", "solution": "def big_sum(arr):\n    return max(arr) + min(arr)"}
{"task_id": "Mbpp/477", "solution": "def is_lower(input_string):\n    \"\"\"\n    Convert the given string to lower case.\n    \n    Parameters:\n    input_string (str): The string to be converted to lower case.\n    \n    Returns:\n    str: The lower case version of the input string.\n    \"\"\"\n    return input_string.lower()"}
{"task_id": "Mbpp/478", "solution": "def remove_lowercase(s):\n    result = []\n    temp = []\n    for char in s:\n        if char.islower():\n            if temp:\n                result.append(''.join(temp))\n                temp = []\n        else:\n            temp.append(char)\n    if temp:\n        result.append(''.join(temp))\n    return ''.join(result)"}
{"task_id": "Mbpp/479", "solution": "def first_Digit(n):\n    \"\"\"\n    This function finds the first digit of a given number.\n\n    Parameters:\n    n (int): The input number.\n\n    Returns:\n    int: The first digit of the input number.\n    \"\"\"\n    # Convert the number to a string to easily access the first character\n    str_n = str(abs(n))  # Use abs to handle negative numbers\n    \n    # Return the first character of the string, converted back to an integer\n    return int(str_n[0])"}
{"task_id": "Mbpp/554", "solution": "def Split(numbers):\n    \"\"\"\n    This function filters out the odd numbers from a list of integers.\n\n    Args:\n        numbers (list): A list of integers.\n\n    Returns:\n        list: A list of odd integers.\n    \"\"\"\n    return [num for num in numbers if num % 2!= 0]"}
{"task_id": "Mbpp/555", "solution": "def difference(n):\n    # Calculate the sum of the first n natural numbers\n    sum_n = n * (n + 1) // 2\n    \n    # Calculate the sum of the cubes of the first n natural numbers\n    sum_cubes = sum(i ** 3 for i in range(1, n + 1))\n    \n    # Find the difference\n    diff = sum_cubes - sum_n\n    \n    return diff"}
{"task_id": "Mbpp/556", "solution": "def find_Odd_Pair(arr, n):\n    odd_count = 0\n    even_count = 0\n    \n    # Count the number of odd and even numbers in the array\n    for num in arr:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # The number of pairs with odd XOR value is the product of the number of odd and even numbers\n    return odd_count * even_count"}
{"task_id": "Mbpp/557", "solution": "def toggle_string(s):\n    return s.swapcase()"}
{"task_id": "Mbpp/558", "solution": "def digit_distance_nums(num1, num2):\n    \"\"\"\n    Calculate the sum of the per-digit difference between two integers.\n\n    Args:\n        num1 (int): The first integer.\n        num2 (int): The second integer.\n\n    Returns:\n        int: The sum of the per-digit difference between num1 and num2.\n    \"\"\"\n    # Convert the integers to strings to easily access each digit\n    str_num1 = str(num1)\n    str_num2 = str(num2)\n\n    # Find the maximum length between the two numbers\n    max_len = max(len(str_num1), len(str_num2))\n\n    # Initialize the sum of the per-digit difference\n    total_diff = 0\n\n    # Iterate over the range of the maximum length\n    for i in range(max_len):\n        # Get the current digit from each number, or 0 if the digit does not exist\n        digit1 = int(str_num1[-1 - i]) if i < len(str_num1) else 0\n        digit2 = int(str_num2[-1 - i]) if i < len(str_num2) else 0\n\n        # Calculate the absolute difference between the current digits\n        diff = abs(digit1 - digit2)\n\n        # Add the difference to the total\n        total_diff += diff\n\n    # Return the total sum of the per-digit difference\n    return total_diff"}
{"task_id": "Mbpp/559", "solution": "def max_sub_array_sum(lst, n):\n    \"\"\"\n    This function finds the sum of the largest contiguous sublist in the given list.\n    \n    Parameters:\n    lst (list): The input list of integers.\n    n (int): The size of the input list.\n    \n    Returns:\n    int: The sum of the largest contiguous sublist.\n    \"\"\"\n    \n    # Initialize the maximum sum and the current sum to the first element of the list\n    max_sum = current_sum = lst[0]\n    \n    # Iterate over the list starting from the second element\n    for i in range(1, n):\n        # Update the current sum by adding the current element\n        # If the current sum becomes negative, reset it to the current element\n        current_sum = max(lst[i], current_sum + lst[i])\n        \n        # Update the maximum sum if the current sum is greater\n        max_sum = max(max_sum, current_sum)\n    \n    # Return the maximum sum\n    return max_sum"}
{"task_id": "Mbpp/560", "solution": "def union_elements(tuple1, tuple2):\n    \"\"\"\n    This function finds the union of elements in two given tuples and returns them in sorted order.\n\n    Args:\n        tuple1 (tuple): The first tuple.\n        tuple2 (tuple): The second tuple.\n\n    Returns:\n        tuple: A tuple containing the union of elements from both tuples in sorted order.\n    \"\"\"\n    # Combine the two tuples into a single set to remove duplicates\n    combined_set = set(tuple1) | set(tuple2)\n    \n    # Convert the set back into a tuple and sort it\n    sorted_tuple = tuple(sorted(combined_set))\n    \n    return sorted_tuple"}
{"task_id": "Mbpp/562", "solution": "def Find_Max_Length(sublists):\n    \"\"\"\n    This function finds the length of the longest sublist in a given list of sublists.\n\n    Args:\n        sublists (list): A list of sublists.\n\n    Returns:\n        int: The length of the longest sublist.\n    \"\"\"\n    # Initialize max_length to 0, assuming the list of sublists is not empty\n    max_length = 0\n    \n    # Iterate over each sublist in the list of sublists\n    for sublist in sublists:\n        # Find the length of the current sublist\n        sublist_length = len(sublist)\n        \n        # If the length of the current sublist is greater than max_length, update max_length\n        if sublist_length > max_length:\n            max_length = sublist_length\n    \n    # Return the length of the longest sublist\n    return max_length"}
{"task_id": "Mbpp/563", "solution": "import re\n\ndef extract_values(s):\n    # Use regular expression to find all values between quotation marks\n    return re.findall(r'\"(.*?)\"', s)"}
{"task_id": "Mbpp/564", "solution": "def count_Pairs(lst, n):\n    \"\"\"\n    This function calculates the number of possible unordered pairs \n    where both elements are unequal in a given list of integers.\n\n    Parameters:\n    lst (list): A list of integers.\n    n (int): The size of the list.\n\n    Returns:\n    int: The number of possible unordered pairs where both elements are unequal.\n    \"\"\"\n    # Initialize a dictionary to store the frequency of each element\n    freq = {}\n    \n    # Count the frequency of each element in the list\n    for num in lst:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    \n    # Initialize a variable to store the total number of pairs\n    total_pairs = 0\n    \n    # Calculate the total number of pairs\n    for count in freq.values():\n        # For each element, the number of pairs is the product of its frequency \n        # and the frequency of all other elements\n        total_pairs += count * (n - count)\n    \n    # Since we counted each pair twice, divide the total by 2\n    total_pairs //= 2\n    \n    return total_pairs"}
{"task_id": "Mbpp/565", "solution": "def split(string):\n    return list(string)"}
{"task_id": "Mbpp/566", "solution": "def sum_digits(n):\n    \"\"\"\n    Calculate the sum of the digits of a non-negative integer.\n\n    Args:\n        n (int): A non-negative integer.\n\n    Returns:\n        int: The sum of the digits of n.\n    \"\"\"\n    return sum(int(digit) for digit in str(n))"}
{"task_id": "Mbpp/567", "solution": "def issort_list(lst):\n    \"\"\"\n    Function to check whether a specified list is sorted in ascending order.\n    \n    Parameters:\n    lst (list): The list to check.\n    \n    Returns:\n    bool: True if the list is sorted, False otherwise.\n    \"\"\"\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n    return True"}
{"task_id": "Mbpp/568", "solution": "def empty_list(N):\n    return [{} for _ in range(N)]"}
{"task_id": "Mbpp/569", "solution": "def sort_sublists(list_of_lists):\n    # Iterate through each sublist in the main list\n    for sublist in list_of_lists:\n        # Sort the current sublist\n        sublist.sort()\n    return list_of_lists"}
{"task_id": "Mbpp/572", "solution": "def two_unique_nums(nums):\n    \"\"\"\n    This function takes a list of numbers as input and returns a new list containing only the numbers that appear exactly twice in the original list.\n\n    :param nums: A list of integers\n    :return: A list of integers\n    \"\"\"\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n\n    return [num for num, count in count_dict.items() if count == 1]"}
{"task_id": "Mbpp/573", "solution": "def unique_product(numbers):\n    unique_numbers = set(numbers)\n    product = 1\n    for number in unique_numbers:\n        product *= number\n    return product"}
{"task_id": "Mbpp/574", "solution": "import math\n\ndef surfacearea_cylinder(radius, height):\n    \"\"\"\n    Calculate the surface area of a cylinder.\n\n    Parameters:\n    radius (float): The radius of the cylinder.\n    height (float): The height of the cylinder.\n\n    Returns:\n    float: The surface area of the cylinder.\n    \"\"\"\n    # Calculate the area of the two circular bases\n    base_area = 2 * math.pi * radius ** 2\n    \n    # Calculate the lateral surface area\n    lateral_area = 2 * math.pi * radius * height\n    \n    # Return the total surface area\n    return base_area + lateral_area"}
{"task_id": "Mbpp/576", "solution": "def is_Sub_Array(main_list, sub_list):\n    # Get the lengths of both lists\n    main_len = len(main_list)\n    sub_len = len(sub_list)\n    \n    # If the sublist is longer than the main list, it cannot be a sublist\n    if sub_len > main_len:\n        return False\n    \n    # Iterate through the main list\n    for i in range(main_len - sub_len + 1):\n        # Check if the sublist matches the slice of the main list\n        if main_list[i:i + sub_len] == sub_list:\n            return True\n    \n    return False"}
{"task_id": "Mbpp/577", "solution": "def last_Digit_Factorial(n):\n    if n >= 5:\n        return 0\n    factorial = 1\n    for i in range(1, n + 1):\n        factorial *= i\n    return factorial % 10"}
{"task_id": "Mbpp/578", "solution": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleaves three lists of the same length into a single flat list.\n\n    Args:\n        list1 (list): The first list to interleave.\n        list2 (list): The second list to interleave.\n        list3 (list): The third list to interleave.\n\n    Returns:\n        list: A single flat list containing the interleaved elements of the input lists.\n    \"\"\"\n    return [element for triple in zip(list1, list2, list3) for element in triple]"}
{"task_id": "Mbpp/579", "solution": "def find_dissimilar(tuple1, tuple2):\n    \"\"\"\n    This function finds the dissimilar elements in two given tuples.\n    \n    Args:\n        tuple1 (tuple): The first tuple.\n        tuple2 (tuple): The second tuple.\n    \n    Returns:\n        tuple: A tuple containing the dissimilar elements from both tuples.\n    \"\"\"\n    # Convert the tuples to sets for efficient lookups\n    set1 = set(tuple1)\n    set2 = set(tuple2)\n    \n    # Find the elements that are in set1 but not in set2\n    dissimilar_from_tuple1 = tuple1 - set2\n    \n    # Find the elements that are in set2 but not in set1\n    dissimilar_from_tuple2 = tuple2 - set1\n    \n    # Combine the dissimilar elements from both tuples\n    dissimilar_elements = dissimilar_from_tuple1 + dissimilar_from_tuple2\n    \n    return dissimilar_elements"}
{"task_id": "Mbpp/580", "solution": "def extract_even(nested_tuple):\n    \"\"\"\n    This function removes uneven elements from a nested mixed tuple.\n    \n    Args:\n        nested_tuple (tuple): A tuple containing integers and/or nested tuples.\n    \n    Returns:\n        tuple: A new tuple with uneven elements removed.\n    \"\"\"\n    \n    # Initialize an empty list to store the even elements\n    even_elements = []\n    \n    # Iterate over each element in the nested tuple\n    for element in nested_tuple:\n        \n        # If the element is a tuple, recursively call the function on it\n        if isinstance(element, tuple):\n            even_elements.append(extract_even(element))\n        \n        # If the element is an integer and is even, add it to the list\n        elif isinstance(element, int) and element % 2 == 0:\n            even_elements.append(element)\n    \n    # Convert the list back to a tuple and return it\n    return tuple(even_elements)"}
{"task_id": "Mbpp/581", "solution": "import math\n\ndef surface_Area(base_edge, height):\n    \"\"\"\n    Calculate the surface area of a square pyramid.\n\n    The surface area of a square pyramid is the sum of the areas of its four triangular faces and its square base.\n    The area of each triangular face is half the product of the base edge and the slant height.\n    The slant height can be calculated using the Pythagorean theorem.\n\n    :param base_edge: The length of the base edge of the pyramid.\n    :param height: The height of the pyramid.\n    :return: The surface area of the pyramid.\n    \"\"\"\n\n    # Calculate the slant height using the Pythagorean theorem\n    slant_height = math.sqrt((base_edge / 2) ** 2 + height ** 2)\n\n    # Calculate the area of one triangular face\n    triangular_face_area = (base_edge * slant_height) / 2\n\n    # Calculate the total surface area\n    total_surface_area = 4 * triangular_face_area + base_edge ** 2\n\n    return total_surface_area"}
{"task_id": "Mbpp/582", "solution": "def my_dict(d):\n    return len(d) == 0"}
{"task_id": "Mbpp/583", "solution": "def catalan_number(n):\n    # Base case\n    if n == 0 or n == 1:\n        return 1\n    \n    # Initialize an array to store the results of subproblems\n    catalan = [0] * (n + 1)\n    \n    # Initialize the first two values in the array\n    catalan[0] = 1\n    catalan[1] = 1\n    \n    # Fill the array using the recursive formula\n    for i in range(2, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n    \n    return catalan[n]"}
{"task_id": "Mbpp/585", "solution": "def expensive_items(items, n):\n    # Sort the items by price in descending order\n    sorted_items = sorted(items, key=lambda x: x['price'], reverse=True)\n    # Return the top n items\n    return sorted_items[:n]"}
{"task_id": "Mbpp/586", "solution": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n\n    Args:\n        arr (list): The input list to be split.\n        n (int): The index at which the list is split.\n\n    Returns:\n        list: The modified list with the first part added to the end.\n    \"\"\"\n    return arr[n:] + arr[:n]"}
{"task_id": "Mbpp/587", "solution": "def list_tuple(input_list):\n    return tuple(input_list)"}
{"task_id": "Mbpp/588", "solution": "def big_diff(lst):\n    if not lst:\n        raise ValueError(\"List must not be empty\")\n    return max(lst) - min(lst)"}
{"task_id": "Mbpp/589", "solution": "import math\n\ndef perfect_squares(start, end):\n    \"\"\"\n    Returns a list of perfect squares between two given numbers.\n\n    Args:\n        start (int): The start of the range (inclusive).\n        end (int): The end of the range (inclusive).\n\n    Returns:\n        list: A list of perfect squares between start and end.\n    \"\"\"\n    perfect_squares_list = []\n    for i in range(math.ceil(math.sqrt(start)), math.floor(math.sqrt(end)) + 1):\n        perfect_squares_list.append(i ** 2)\n    return perfect_squares_list"}
{"task_id": "Mbpp/590", "solution": "import math\nimport cmath\n\ndef polar_rect(r, theta):\n    \"\"\"\n    Convert polar coordinates to rectangular coordinates.\n\n    Parameters:\n    r (float): The radius in polar coordinates.\n    theta (float): The angle in radians in polar coordinates.\n\n    Returns:\n    tuple: A tuple containing the rectangular coordinates as a tuple of floats and the complex number representation.\n    \"\"\"\n    # Calculate the rectangular coordinates using trigonometric functions\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n\n    # Create a complex number representation\n    complex_num = complex(x, y)\n\n    # Return the rectangular coordinates and the complex number representation\n    return ((x, y), complex_num)"}
{"task_id": "Mbpp/591", "solution": "def swap_List(input_list):\n    \"\"\"\n    This function interchanges the first and last elements in a list.\n\n    Args:\n        input_list (list): The input list to be modified.\n\n    Returns:\n        list: The modified list with the first and last elements interchanged.\n    \"\"\"\n    if len(input_list) > 1:\n        input_list[0], input_list[-1] = input_list[-1], input_list[0]\n    return input_list"}
{"task_id": "Mbpp/592", "solution": "import math\n\ndef sum_Of_product(n):\n    \"\"\"\n    This function calculates the sum of the product of consecutive binomial coefficients.\n    \n    Parameters:\n    n (int): The number of binomial coefficients to consider.\n    \n    Returns:\n    int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    \n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Iterate over the range from 1 to n (inclusive)\n    for i in range(1, n + 1):\n        # Calculate the product of consecutive binomial coefficients\n        product = 1\n        for j in range(i):\n            # Calculate the binomial coefficient using the math.comb function\n            product *= math.comb(n - 1, j)\n        \n        # Add the product to the total sum\n        total_sum += product\n    \n    # Return the total sum\n    return total_sum"}
{"task_id": "Mbpp/593", "solution": "def removezero_ip(ip):\n    # Split the IP address into its components\n    parts = ip.split('.')\n    # Remove leading zeroes from each part\n    parts = [str(int(part)) for part in parts]\n    # Join the parts back into a single string\n    return '.'.join(parts)"}
{"task_id": "Mbpp/594", "solution": "def diff_even_odd(numbers):\n    first_even = next((num for num in numbers if num % 2 == 0), None)\n    first_odd = next((num for num in numbers if num % 2!= 0), None)\n    \n    if first_even is None or first_odd is None:\n        raise ValueError(\"List must contain at least one even and one odd number\")\n    \n    return abs(first_even - first_odd)"}
{"task_id": "Mbpp/595", "solution": "def min_Swaps(s1, s2):\n    \"\"\"\n    This function calculates the minimum number of swaps required to convert one binary number to another.\n    \n    Args:\n    s1 (str): The first binary number as a string.\n    s2 (str): The second binary number as a string.\n    \n    Returns:\n    int or None: The minimum number of swaps required, or None if it's impossible to convert s1 to s2.\n    \"\"\"\n    \n    # Check if the two strings have the same length\n    if len(s1)!= len(s2):\n        return None\n    \n    # Initialize variables to store the number of mismatches and the number of swaps\n    mismatches = 0\n    swaps = 0\n    \n    # Iterate over the characters in the strings\n    for c1, c2 in zip(s1, s2):\n        # If the characters are different, increment the number of mismatches\n        if c1!= c2:\n            mismatches += 1\n        # If the number of mismatches is odd, increment the number of swaps\n        if mismatches % 2 == 1:\n            swaps += 1\n    \n    # If the number of mismatches is odd, it's impossible to convert s1 to s2\n    if mismatches % 2 == 1:\n        return None\n    \n    # Return the minimum number of swaps\n    return swaps"}
{"task_id": "Mbpp/596", "solution": "import sys\n\ndef tuple_size(t):\n    return sys.getsizeof(t)"}
{"task_id": "Mbpp/597", "solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Find the kth element from two sorted arrays.\n\n    Args:\n        arr1 (list): The first sorted array.\n        arr2 (list): The second sorted array.\n        k (int): The index of the desired element (1-indexed).\n\n    Returns:\n        int: The kth element from the combined sorted array.\n    \"\"\"\n    # Combine the two arrays into one\n    combined = arr1 + arr2\n    \n    # Sort the combined array\n    combined.sort()\n    \n    # Return the kth element (adjusting for 0-indexing)\n    return combined[k - 1]"}
{"task_id": "Mbpp/598", "solution": "def armstrong_number(n):\n    \"\"\"\n    Checks if a given number is an Armstrong number.\n    \n    An Armstrong number is a number that is equal to the sum of cubes of its digits.\n    For example, 371 is an Armstrong number since 3**3 + 7**3 + 1**3 = 371.\n    \"\"\"\n    # Convert the number to a string to easily get the number of digits\n    num_str = str(n)\n    num_digits = len(num_str)\n    \n    # Initialize a variable to store the sum of the cubes of the digits\n    sum_cubes = 0\n    \n    # Iterate over each digit in the number\n    for digit in num_str:\n        # Add the cube of the digit to the sum\n        sum_cubes += int(digit) ** num_digits\n    \n    # Check if the sum of the cubes is equal to the original number\n    return sum_cubes == n"}
{"task_id": "Mbpp/599", "solution": "def sum_average(n):\n    # Calculate the sum of the first n natural numbers\n    sum_n = n * (n + 1) // 2\n    # Calculate the average of the first n natural numbers\n    average_n = sum_n / n\n    # Return the sum and average as a tuple\n    return sum_n, average_n"}
{"task_id": "Mbpp/600", "solution": "def is_Even(number):\n    return number % 2 == 0"}
{"task_id": "Mbpp/602", "solution": "def first_repeated_char(s):\n    seen = set()\n    for char in s:\n        if char in seen:\n            return char\n        seen.add(char)\n    return None"}
{"task_id": "Mbpp/603", "solution": "def get_lucid(n):\n    \"\"\"\n    Returns a list of all lucid numbers smaller than or equal to a given integer.\n    \n    A lucid number is a number that is not divisible by any of its digits.\n    \"\"\"\n    def is_lucid(num):\n        \"\"\"\n        Checks if a number is lucid.\n        \n        A number is lucid if it is not divisible by any of its digits.\n        \"\"\"\n        for digit in str(num):\n            if digit == '0' or num % int(digit) == 0:\n                return False\n        return True\n\n    lucid_numbers = []\n    for i in range(1, n + 1):\n        if is_lucid(i):\n            lucid_numbers.append(i)\n    return lucid_numbers"}
{"task_id": "Mbpp/604", "solution": "def reverse_words(s: str) -> str:\n    \"\"\"\n    This function takes a string s and returns a new string with the words reversed.\n    \n    :param s: A string with words separated by spaces.\n    :return: A string with the words in reverse order.\n    \"\"\"\n    # Split the string into a list of words\n    words = s.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed list of words back into a string\n    reversed_string =''.join(reversed_words)\n    \n    return reversed_string"}
{"task_id": "Mbpp/605", "solution": "def prime_num(n):\n    \"\"\"\n    Checks if a given integer is a prime number.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the number is prime, False otherwise.\n    \"\"\"\n    if n <= 1:  # Prime numbers are greater than 1\n        return False\n    if n == 2:  # 2 is the only even prime number\n        return True\n    if n % 2 == 0:  # All other even numbers are not prime\n        return False\n    # Check odd factors up to the square root of n\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True"}
{"task_id": "Mbpp/606", "solution": "import math\n\ndef radian_degree(degree):\n    return degree * (math.pi / 180)"}
{"task_id": "Mbpp/607", "solution": "import re\n\ndef find_literals(string, pattern):\n    \"\"\"\n    Searches a string for a regex pattern and returns the matching substring, \n    a start index, and an end index.\n\n    Args:\n        string (str): The string to search.\n        pattern (str): The regex pattern to search for.\n\n    Returns:\n        tuple: A tuple containing the matching substring, start index, and end index.\n    \"\"\"\n    match = re.search(pattern, string)\n    if match:\n        return (match.group(), match.start(), match.end())\n    else:\n        return None"}
{"task_id": "Mbpp/608", "solution": "def bell_Number(n):\n    \"\"\"\n    Calculate the nth Bell number.\n\n    The Bell numbers are a sequence of numbers that arise in combinatorial mathematics,\n    beginning with B0 = 1, and then using the recurrence relation to compute the subsequent numbers.\n\n    :param n: The position of the Bell number to calculate.\n    :return: The nth Bell number.\n    \"\"\"\n    bell = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n\n    # Initialize the first row and column of the table\n    bell[0][0] = 1\n\n    # Fill the table in a bottom-up manner\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n\n    # The nth Bell number is stored in the last cell of the table\n    return bell[n][0]"}
{"task_id": "Mbpp/610", "solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Removes the k'th element from a list.\n\n    Args:\n        lst (list): The input list.\n        k (int): The index of the element to be removed (1-indexed).\n\n    Returns:\n        list: The list with the k'th element removed.\n    \"\"\"\n    return lst[:k-1] + lst[k:]"}
{"task_id": "Mbpp/611", "solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Returns the maximum value of the nth column in a given matrix.\n\n    Args:\n        matrix (list of lists): A 2D list representing the matrix.\n        n (int): The column index (0-based) for which to find the maximum value.\n\n    Returns:\n        The maximum value in the nth column of the matrix.\n    \"\"\"\n    # Check if the matrix is empty or the column index is out of range\n    if not matrix or n < 0 or n >= len(matrix[0]):\n        raise ValueError(\"Invalid matrix or column index\")\n\n    # Use a list comprehension to extract the nth column from the matrix\n    column = [row[n] for row in matrix]\n\n    # Return the maximum value in the extracted column\n    return max(column)"}
{"task_id": "Mbpp/612", "solution": "def merge(lists):\n    \"\"\"\n    This function takes a list of lists, where each sublist has two elements, \n    and returns a list of two lists where the first list has the first element \n    of each sublist and the second one has the second.\n\n    Args:\n        lists (list): A list of lists, where each sublist has two elements.\n\n    Returns:\n        list: A list of two lists where the first list has the first element \n        of each sublist and the second one has the second.\n    \"\"\"\n    return [[sublist[0] for sublist in lists], [sublist[1] for sublist in lists]]"}
{"task_id": "Mbpp/614", "solution": "def cummulative_sum(tuple_list):\n    \"\"\"\n    This function calculates the cumulative sum of all values present in a given tuple list.\n\n    Args:\n        tuple_list (list): A list of tuples containing integers.\n\n    Returns:\n        int: The cumulative sum of all values in the tuple list.\n    \"\"\"\n    # Initialize a variable to store the cumulative sum\n    cumulative_sum = 0\n    \n    # Iterate over each tuple in the tuple list\n    for tup in tuple_list:\n        # Iterate over each value in the tuple\n        for val in tup:\n            # Add the value to the cumulative sum\n            cumulative_sum += val\n    \n    # Return the cumulative sum\n    return cumulative_sum"}
{"task_id": "Mbpp/615", "solution": "def average_tuple(tuples):\n    \"\"\"\n    This function calculates the average value for each tuple in a given tuple of tuples.\n\n    Args:\n        tuples (tuple): A tuple of tuples containing numeric values.\n\n    Returns:\n        list: A list of average values for each tuple.\n    \"\"\"\n    return [sum(t) / len(t) for t in tuples]"}
{"task_id": "Mbpp/616", "solution": "def tuple_modulo(tuple1, tuple2):\n    \"\"\"\n    This function performs element-wise modulo operation on two tuples of the same length.\n\n    Args:\n        tuple1 (tuple): The first tuple.\n        tuple2 (tuple): The second tuple.\n\n    Returns:\n        tuple: A new tuple containing the element-wise modulo results.\n    \"\"\"\n    if len(tuple1)!= len(tuple2):\n        raise ValueError(\"Both tuples must be of the same length\")\n\n    return tuple(x % y for x, y in zip(tuple1, tuple2))"}
{"task_id": "Mbpp/618", "solution": "def div_list(list1, list2):\n    if len(list1)!= len(list2):\n        raise ValueError(\"Both lists must have the same length\")\n    return [a / b for a, b in zip(list1, list2)]"}
{"task_id": "Mbpp/619", "solution": "def move_num(s):\n    non_num = [char for char in s if not char.isdigit()]\n    num = [char for char in s if char.isdigit()]\n    return ''.join(non_num + num)"}
{"task_id": "Mbpp/620", "solution": "def largest_subset(numbers):\n    \"\"\"\n    This function finds the size of the largest subset of a list of numbers \n    so that every pair is divisible.\n\n    Args:\n        numbers (list): A list of integers.\n\n    Returns:\n        int: The size of the largest subset.\n    \"\"\"\n    \n    # Sort the list in ascending order\n    numbers.sort()\n    \n    # Initialize a list to store the size of the largest subset ending at each position\n    dp = [1] * len(numbers)\n    \n    # Initialize the maximum size of the subset\n    max_size = 1\n    \n    # Iterate over the list\n    for i in range(1, len(numbers)):\n        # For each number, check all previous numbers\n        for j in range(i):\n            # If the current number is divisible by the previous number, update the size of the subset\n            if numbers[i] % numbers[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n        # Update the maximum size of the subset\n        max_size = max(max_size, dp[i])\n    \n    # Return the maximum size of the subset\n    return max_size"}
{"task_id": "Mbpp/622", "solution": "def get_median(arr1, arr2, n):\n    \"\"\"\n    This function calculates the median of two sorted lists of the same size.\n\n    Parameters:\n    arr1 (list): The first sorted list.\n    arr2 (list): The second sorted list.\n    n (int): The size of the lists.\n\n    Returns:\n    float: The median of the combined list.\n    \"\"\"\n    # Merge the two sorted lists into one sorted list\n    merged = sorted(arr1 + arr2)\n\n    # Calculate the middle index of the merged list\n    mid = n * 2 // 2\n\n    # If the total number of elements is even, the median is the average of the two middle elements\n    if (n * 2) % 2 == 0:\n        return (merged[mid - 1] + merged[mid]) / 2\n    # If the total number of elements is odd, the median is the middle element\n    else:\n        return merged[mid]"}
{"task_id": "Mbpp/623", "solution": "def nth_nums(nums, n):\n    \"\"\"\n    Compute the n-th power of each number in a list.\n\n    Args:\n        nums (list): A list of numbers.\n        n (int): The power to which each number should be raised.\n\n    Returns:\n        list: A list of numbers, each raised to the power of n.\n    \"\"\"\n    return [num ** n for num in nums]"}
{"task_id": "Mbpp/624", "solution": "def is_upper(s):\n    return s.upper()"}
{"task_id": "Mbpp/626", "solution": "import math\n\ndef triangle_area(radius):\n    \"\"\"\n    Calculate the area of the largest triangle that can be inscribed in a semicircle with a given radius.\n\n    Args:\n        radius (float): The radius of the semicircle.\n\n    Returns:\n        float: The area of the largest triangle, or None if the radius is negative.\n    \"\"\"\n    if radius < 0:\n        return None\n    elif radius == 0:\n        return 0\n    else:\n        # The largest triangle that can be inscribed in a semicircle is a right triangle with the diameter as its hypotenuse.\n        # The height of this triangle is equal to the radius of the semicircle.\n        # The base of this triangle is equal to the diameter of the semicircle, which is twice the radius.\n        # The area of a triangle is half the product of its base and height.\n        return 0.5 * (2 * radius) * radius"}
{"task_id": "Mbpp/628", "solution": "def replace_spaces(s):\n    \"\"\"\n    Replaces all spaces in the given string with '%20'.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The string with all spaces replaced with '%20'.\n    \"\"\"\n    return s.replace(' ', '%20')"}
{"task_id": "Mbpp/629", "solution": "def Split(numbers):\n    \"\"\"\n    This function takes a list of numbers as input and returns a new list containing only the even numbers.\n\n    :param numbers: A list of integers\n    :return: A list of even integers\n    \"\"\"\n    return [num for num in numbers if num % 2 == 0]"}
{"task_id": "Mbpp/630", "solution": "def get_coordinates(coord):\n    \"\"\"\n    This function generates all adjacent coordinates of a given coordinate tuple.\n    \n    Parameters:\n    coord (tuple): A tuple containing the x and y coordinates.\n    \n    Returns:\n    list: A list of lists, where each sublist contains the adjacent coordinates.\n    \"\"\"\n    \n    # Extract the x and y coordinates from the input tuple\n    x, y = coord\n    \n    # Initialize an empty list to store the adjacent coordinates\n    adjacent_coords = []\n    \n    # Iterate over the range of x-1 to x+2 (inclusive) to generate adjacent x coordinates\n    for i in range(x-1, x+2):\n        # Iterate over the range of y-1 to y+2 (inclusive) to generate adjacent y coordinates\n        for j in range(y-1, y+2):\n            # Append the adjacent coordinates as a list to the result list\n            adjacent_coords.append([i, j])\n    \n    # Return the list of adjacent coordinates\n    return adjacent_coords"}
{"task_id": "Mbpp/631", "solution": "def replace_spaces(input_string):\n    \"\"\"\n    Replaces whitespaces with underscores and vice versa in a given string.\n\n    Args:\n        input_string (str): The input string to be processed.\n\n    Returns:\n        str: The processed string with whitespaces replaced by underscores and vice versa.\n    \"\"\"\n    # Initialize an empty string to store the result\n    result = \"\"\n\n    # Iterate over each character in the input string\n    for char in input_string:\n        # Check if the character is a whitespace\n        if char.isspace():\n            # If it's a whitespace, replace it with an underscore\n            result += \"_\"\n        # Check if the character is an underscore\n        elif char == \"_\":\n            # If it's an underscore, replace it with a whitespace\n            result += \" \"\n        else:\n            # If it's neither a whitespace nor an underscore, just append it to the result\n            result += char\n\n    # Return the processed string\n    return result"}
{"task_id": "Mbpp/632", "solution": "def move_zero(lst):\n    \"\"\"\n    Move all zeroes to the end of the given list.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        list: The list with all zeroes moved to the end.\n    \"\"\"\n    # Separate non-zero elements from the list\n    non_zero_elements = [element for element in lst if element!= 0]\n    \n    # Calculate the number of zeroes in the list\n    num_zeroes = len(lst) - len(non_zero_elements)\n    \n    # Create a list of zeroes with the calculated length\n    zeroes = [0] * num_zeroes\n    \n    # Combine the non-zero elements and zeroes to form the result\n    result = non_zero_elements + zeroes\n    \n    return result"}
{"task_id": "Mbpp/633", "solution": "def pair_xor_Sum(arr, n):\n    \"\"\"\n    This function calculates the sum of XOR of all pairs of numbers in the given list.\n\n    Parameters:\n    arr (list): The input list of numbers.\n    n (int): The number of elements in the list.\n\n    Returns:\n    int: The sum of XOR of all pairs of numbers in the list.\n    \"\"\"\n    # Initialize the result variable to 0\n    result = 0\n    \n    # Iterate over each element in the list\n    for i in range(n):\n        # Iterate over each element in the list starting from the next index\n        for j in range(i + 1, n):\n            # Calculate the XOR of the current pair of numbers and add it to the result\n            result += arr[i] ^ arr[j]\n    \n    # Return the final result\n    return result"}
{"task_id": "Mbpp/635", "solution": "def heapify(arr, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n\n    if left < n and arr[i] < arr[left]:\n        largest = left\n\n    if right < n and arr[largest] < arr[right]:\n        largest = right\n\n    if largest!= i:\n        arr[i], arr[largest] = arr[largest], arr[i]\n        heapify(arr, n, largest)\n\n\ndef heap_sort(arr):\n    n = len(arr)\n\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n\n    for i in range(n - 1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]\n        heapify(arr, i, 0)\n\n    return arr"}
{"task_id": "Mbpp/637", "solution": "def noprofit_noloss(cost_price, selling_price):\n    return cost_price == selling_price"}
{"task_id": "Mbpp/638", "solution": "import math\n\ndef wind_chill(wind_velocity, temperature):\n    \"\"\"\n    Calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\n\n    :param wind_velocity: Wind velocity in km/h\n    :param temperature: Temperature in celsius\n    :return: Wind chill index rounded to the next integer\n    \"\"\"\n    # Convert wind velocity from km/h to m/s\n    wind_velocity_ms = wind_velocity / 3.6\n    \n    # Calculate wind chill index using the formula: WCI = 13.12 + 0.6215T - 11.37(V^0.16) + 0.3965T(V^0.16)\n    wind_chill_index = 13.12 + 0.6215 * temperature - 11.37 * (wind_velocity_ms ** 0.16) + 0.3965 * temperature * (wind_velocity_ms ** 0.16)\n    \n    # Round wind chill index to the next integer\n    wind_chill_index = math.ceil(wind_chill_index)\n    \n    return wind_chill_index"}
{"task_id": "Mbpp/639", "solution": "def sample_nam(names):\n    # Filter out names that start with a lowercase letter\n    filtered_names = [name for name in names if not name[0].islower()]\n    # Sum the lengths of the remaining names\n    total_length = sum(len(name) for name in filtered_names)\n    return total_length"}
{"task_id": "Mbpp/640", "solution": "def remove_parenthesis(s):\n    \"\"\"\n    Removes the parenthesis and what is inbetween them from a string.\n\n    Args:\n        s (str or list): The input string or list of strings.\n\n    Returns:\n        str: The string with the parenthesis and their contents removed.\n    \"\"\"\n    if isinstance(s, list):\n        s = s[0]\n    result = \"\"\n    open_parenthesis = False\n    for char in s:\n        if char == \"(\":\n            open_parenthesis = True\n        elif char == \")\":\n            open_parenthesis = False\n        elif not open_parenthesis:\n            result += char\n    return result"}
{"task_id": "Mbpp/641", "solution": "def is_nonagonal(n):\n    \"\"\"\n    Function to find the nth nonagonal number.\n    A nonagonal number is given by the formula: n(7n-5)/2\n    \"\"\"\n    return n * (7 * n - 5) // 2"}
{"task_id": "Mbpp/643", "solution": "def text_match_wordz_middle(text):\n    words = text.split()\n    for word in words:\n        word = word.strip('.,!?\"\\'')\n        if len(word) > 1 and 'z' in word[1:-1]:\n            return True\n    return False"}
{"task_id": "Mbpp/644", "solution": "def reverse_Array_Upto_K(arr, k):\n    if k > len(arr):\n        raise ValueError(\"k should be within the bounds of the array length\")\n    return arr[:k][::-1] + arr[k:]"}
{"task_id": "Mbpp/720", "solution": "def add_dict_to_tuple(tup, dict):\n    \"\"\"\n    Adds a dictionary to a tuple and returns the resulting tuple.\n\n    Args:\n        tup (tuple): The input tuple.\n        dict (dict): The dictionary to be added to the tuple.\n\n    Returns:\n        tuple: A new tuple containing the original tuple elements and the dictionary.\n    \"\"\"\n    return tup + (dict,)"}
{"task_id": "Mbpp/721", "solution": "def maxAverageOfPath(matrix):\n    n = len(matrix)\n    dp = [[0]*n for _ in range(n)]\n    dp[0][0] = matrix[0][0]\n    \n    # Initialize first row\n    for i in range(1, n):\n        dp[0][i] = dp[0][i-1] + matrix[0][i]\n        \n    # Initialize first column\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n        \n    # Fill up the dp table\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n            \n    # Calculate the maximum average\n    max_sum = dp[n-1][n-1]\n    max_average = max_sum / (n * n)\n    \n    return max_average"}
{"task_id": "Mbpp/722", "solution": "def filter_data(students, min_height, min_weight):\n    filtered_students = {}\n    for name, (height, weight) in students.items():\n        if height > min_height and weight > min_weight:\n            filtered_students[name] = (height, weight)\n    return filtered_students"}
{"task_id": "Mbpp/723", "solution": "def count_same_pair(list1, list2):\n    \"\"\"\n    This function counts the number of indices where two lists have the same values.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n\n    Returns:\n        int: The number of indices where the lists have the same values.\n    \"\"\"\n    # Initialize a counter variable to store the count of same indices\n    count = 0\n    \n    # Iterate over the indices of the lists\n    for i in range(len(list1)):\n        # Check if the values at the current index are the same in both lists\n        if list1[i] == list2[i]:\n            # If they are the same, increment the counter\n            count += 1\n    \n    # Return the count of same indices\n    return count"}
{"task_id": "Mbpp/724", "solution": "def power_base_sum(base, power):\n    # Calculate the base raised to the power\n    result = base ** power\n    \n    # Convert the result to a string to iterate over each digit\n    result_str = str(result)\n    \n    # Initialize the sum of digits\n    sum_of_digits = 0\n    \n    # Iterate over each character in the string, convert it to an integer, and add to the sum\n    for char in result_str:\n        sum_of_digits += int(char)\n    \n    return sum_of_digits"}
{"task_id": "Mbpp/725", "solution": "def extract_quotation(s):\n    import re\n    return re.findall(r'\"(.*?)\"', s)"}
{"task_id": "Mbpp/726", "solution": "def multiply_elements(numbers):\n    \"\"\"\n    This function takes a tuple of numbers as input and returns a tuple where each element is the product of two adjacent elements in the input tuple.\n\n    Args:\n        numbers (tuple): A tuple of numbers.\n\n    Returns:\n        tuple: A tuple of products of adjacent elements.\n    \"\"\"\n    # Initialize an empty list to store the products of adjacent elements\n    products = []\n    \n    # Iterate over the indices of the input tuple, excluding the last index\n    for i in range(len(numbers) - 1):\n        # Calculate the product of the current element and the next element\n        product = numbers[i] * numbers[i + 1]\n        \n        # Append the product to the list of products\n        products.append(product)\n    \n    # Convert the list of products to a tuple and return it\n    return tuple(products)"}
{"task_id": "Mbpp/728", "solution": "def sum_list(list1, list2):\n    \"\"\"\n    This function takes two lists of integers as input and returns a new list \n    where each element is the sum of the corresponding elements in the input lists.\n\n    Args:\n        list1 (list): The first list of integers.\n        list2 (list): The second list of integers.\n\n    Returns:\n        list: A new list where each element is the sum of the corresponding elements in the input lists.\n    \"\"\"\n    return [a + b for a, b in zip(list1, list2)]"}
{"task_id": "Mbpp/730", "solution": "def consecutive_duplicates(input_list):\n    \"\"\"\n    Removes consecutive duplicates from a given list.\n\n    Args:\n        input_list (list): The list from which to remove consecutive duplicates.\n\n    Returns:\n        list: The list with consecutive duplicates removed.\n    \"\"\"\n    if not input_list:\n        return []\n\n    result = [input_list[0]]\n    for i in range(1, len(input_list)):\n        if input_list[i]!= input_list[i - 1]:\n            result.append(input_list[i])\n\n    return result"}
{"task_id": "Mbpp/731", "solution": "import math\n\ndef lateralsurface_cone(r, h):\n    \"\"\"\n    Calculate the lateral surface area of a cone given radius r and height h.\n    \n    Parameters:\n    r (float): The radius of the cone.\n    h (float): The height of the cone.\n    \n    Returns:\n    float: The lateral surface area of the cone.\n    \"\"\"\n    # Calculate the slant height using the Pythagorean theorem\n    slant_height = math.sqrt(r**2 + h**2)\n    \n    # Calculate the lateral surface area using the formula \u03c0 * r * slant_height\n    lateral_surface_area = math.pi * r * slant_height\n    \n    return lateral_surface_area"}
{"task_id": "Mbpp/732", "solution": "def replace_specialchar(s):\n    \"\"\"\n    Replaces all occurrences of spaces, commas, or dots with a colon.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        str: The modified string with spaces, commas, and dots replaced with colons.\n    \"\"\"\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')"}
{"task_id": "Mbpp/733", "solution": "def find_first_occurrence(arr, target):\n    left, right = 0, len(arr) - 1\n    result = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            result = mid\n            right = mid - 1  # Continue searching in the left half\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return result"}
{"task_id": "Mbpp/734", "solution": "def sum_Of_Subarray_Prod(arr):\n    n = len(arr)\n    total_sum = 0\n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total_sum += product\n    return total_sum"}
{"task_id": "Mbpp/735", "solution": "def toggle_middle_bits(n):\n    \"\"\"\n    Toggles the middle bits of a given number, excluding the first and last bits.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The number with its middle bits toggled.\n    \"\"\"\n    # Calculate the number of bits in the given number\n    num_bits = n.bit_length()\n\n    # Create a mask with all bits set to 1, except the first and last bits\n    mask = (1 << (num_bits - 1)) - 1 - 1\n\n    # Toggle the middle bits by XORing the number with the mask\n    return n ^ mask"}
{"task_id": "Mbpp/736", "solution": "def left_insertion(arr, x):\n    \"\"\"\n    Locate the left insertion point for a specified value in sorted order.\n    \n    Parameters:\n    arr (list): A list of sorted elements.\n    x (int/float): The value to find the insertion point for.\n    \n    Returns:\n    int: The index where the value should be inserted to maintain sorted order.\n    \"\"\"\n    left, right = 0, len(arr)\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] < x:\n            left = mid + 1\n        else:\n            right = mid\n    return left"}
{"task_id": "Mbpp/737", "solution": "import re\n\ndef check_str(s):\n    \"\"\"\n    Checks whether the given string starts with a vowel or not using regex.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        bool: True if the string starts with a vowel, False otherwise.\n    \"\"\"\n    # Define the regex pattern to match any vowel (both lowercase and uppercase)\n    pattern = re.compile(r'^[aeiouAEIOU]')\n    \n    # Use the regex pattern to search for a match at the start of the string\n    return bool(pattern.match(s))"}
{"task_id": "Mbpp/739", "solution": "def find_Index(n):\n    \"\"\"\n    This function finds the index of the smallest triangular number with n digits.\n\n    Args:\n        n (int): The number of digits.\n\n    Returns:\n        int: The index of the smallest triangular number with n digits.\n    \"\"\"\n    # Initialize the index and the triangular number\n    index = 1\n    triangular_num = 1\n\n    # Continue generating triangular numbers until we find one with n digits\n    while len(str(triangular_num)) < n:\n        # Increment the index and generate the next triangular number\n        index += 1\n        triangular_num += index\n\n    # Return the index of the smallest triangular number with n digits\n    return index"}
{"task_id": "Mbpp/740", "solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert a tuple to a dictionary using adjacent elements as key-value pairs.\n\n    Args:\n        tup (tuple): The input tuple.\n\n    Returns:\n        dict: A dictionary where each key-value pair is formed by adjacent elements in the tuple.\n    \"\"\"\n    return dict(zip(tup[::2], tup[1::2]))"}
{"task_id": "Mbpp/741", "solution": "def all_Characters_Same(s):\n    if not s:\n        return True\n    first_char = s[0]\n    for char in s:\n        if char!= first_char:\n            return False\n    return True"}
{"task_id": "Mbpp/742", "solution": "import math\n\ndef area_tetrahedron(a):\n    \"\"\"\n    Calculate the area of a regular tetrahedron.\n\n    Parameters:\n    a (float): The length of an edge of the tetrahedron.\n\n    Returns:\n    float: The area of the tetrahedron.\n    \"\"\"\n    # Calculate the area using the formula: sqrt(3) * a^2\n    area = math.sqrt(3) * (a ** 2)\n    return area"}
{"task_id": "Mbpp/743", "solution": "def rotate_right(lst, n):\n    \"\"\"\n    Rotate a given list by specified number of items to the right direction.\n\n    Args:\n        lst (list): The input list to be rotated.\n        n (int): The number of positions to rotate the list to the right.\n\n    Returns:\n        list: The rotated list.\n    \"\"\"\n    # Calculate the effective number of positions to rotate, \n    # considering cases where n is greater than the length of the list\n    n = n % len(lst)\n    \n    # Split the list into two parts at the rotation point\n    # The part to be moved to the beginning of the list\n    tail = lst[-n:]\n    \n    # The part to remain at the end of the list\n    head = lst[:-n]\n    \n    # Combine the two parts in the rotated order\n    return tail + head"}
{"task_id": "Mbpp/744", "solution": "def check_none(tup):\n    \"\"\"\n    This function checks if a given tuple contains any None values.\n\n    Args:\n        tup (tuple): The input tuple to be checked.\n\n    Returns:\n        bool: True if the tuple contains at least one None value, False otherwise.\n    \"\"\"\n    return any(val is None for val in tup)"}
{"task_id": "Mbpp/745", "solution": "def divisible_by_digits(startnum, endnum):\n    def is_divisible(num):\n        for digit in str(num):\n            if digit == '0' or num % int(digit)!= 0:\n                return False\n        return True\n\n    return [num for num in range(startnum, endnum + 1) if is_divisible(num)]"}
{"task_id": "Mbpp/746", "solution": "import math\n\ndef sector_area(radius, angle):\n    if angle > 360:\n        return None\n    return 0.5 * radius ** 2 * math.radians(angle)"}
{"task_id": "Mbpp/748", "solution": "def capital_words_spaces(s):\n    result = ''\n    for i, char in enumerate(s):\n        if char.isupper() and i!= 0:\n            result +=''\n        result += char\n    return result"}
{"task_id": "Mbpp/749", "solution": "def sort_numeric_strings(strings):\n    \"\"\"\n    Sorts a list of numeric strings in ascending numerical order.\n\n    Args:\n        strings (list): A list of numeric strings.\n\n    Returns:\n        list: A sorted list of numeric strings.\n    \"\"\"\n    return sorted(strings, key=lambda x: int(x))"}
{"task_id": "Mbpp/750", "solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Adds the given tuple to the given list.\n\n    Args:\n        lst (list): The list to which the tuple will be added.\n        tup (tuple): The tuple to be added to the list.\n\n    Returns:\n        list: The updated list with the tuple elements appended.\n    \"\"\"\n    return lst + list(tup)"}
{"task_id": "Mbpp/751", "solution": "def check_min_heap(arr):\n    n = len(arr)\n    for i in range(n // 2):\n        left_child = 2 * i + 1\n        right_child = 2 * i + 2\n        if left_child < n and arr[i] > arr[left_child]:\n            return False\n        if right_child < n and arr[i] > arr[right_child]:\n            return False\n    return True"}
{"task_id": "Mbpp/752", "solution": "def jacobsthal_num(n):\n    \"\"\"\n    This function calculates the nth Jacobsthal number.\n    \n    The Jacobsthal numbers follow a specific recurrence relation: \n    J(n) = J(n-1) + 2 * J(n-2) with initial conditions J(0) = 0 and J(1) = 1.\n    \n    Parameters:\n    n (int): The position of the Jacobsthal number to be calculated.\n    \n    Returns:\n    int: The nth Jacobsthal number.\n    \"\"\"\n    \n    # Base cases\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    # Initialize variables to store the last two Jacobsthal numbers\n    a, b = 0, 1\n    \n    # Calculate the nth Jacobsthal number\n    for _ in range(2, n + 1):\n        # Update the last two Jacobsthal numbers\n        a, b = b, b + 2 * a\n    \n    # Return the nth Jacobsthal number\n    return b"}
{"task_id": "Mbpp/753", "solution": "def min_k(records, k):\n    \"\"\"\n    Find minimum k records from a tuple list.\n\n    Args:\n    records (list): A list of tuples containing a name and a value.\n    k (int): The number of minimum records to find.\n\n    Returns:\n    list: A list of the k tuples with the smallest values.\n    \"\"\"\n    # Sort the records based on the value in ascending order\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Return the k smallest records\n    return sorted_records[:k]"}
{"task_id": "Mbpp/754", "solution": "def extract_index_list(l1, l2, l3):\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements"}
{"task_id": "Mbpp/755", "solution": "def second_smallest(numbers):\n    \"\"\"\n    This function finds the second smallest number in a list.\n    \n    If the list contains less than two unique numbers, it returns None.\n    \n    :param numbers: A list of numbers\n    :return: The second smallest number in the list, or None if not found\n    \"\"\"\n    # Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # If the list contains less than two unique numbers, return None\n    if len(unique_numbers) < 2:\n        return None\n    \n    # Remove the smallest number from the set\n    unique_numbers.remove(min(unique_numbers))\n    \n    # Return the smallest number from the updated set, which is the second smallest number\n    return min(unique_numbers)"}
{"task_id": "Mbpp/757", "solution": "def count_reverse_pairs(strings):\n    \"\"\"\n    Counts the pairs of reverse strings in the given string list.\n\n    Args:\n        strings (list): A list of strings.\n\n    Returns:\n        int: The number of pairs of reverse strings.\n    \"\"\"\n    # Create a dictionary to store the frequency of each string\n    freq_dict = {}\n    \n    # Initialize the count of reverse pairs\n    reverse_pairs = 0\n    \n    # Iterate over each string in the list\n    for string in strings:\n        # Reverse the string\n        reversed_string = string[::-1]\n        \n        # If the reversed string is already in the dictionary, increment the count\n        if reversed_string in freq_dict:\n            reverse_pairs += freq_dict[reversed_string]\n        \n        # Increment the frequency of the current string\n        freq_dict[string] = freq_dict.get(string, 0) + 1\n    \n    # Return the count of reverse pairs\n    return reverse_pairs"}
{"task_id": "Mbpp/758", "solution": "def unique_sublists(lst):\n    count_dict = {}\n    for sublist in lst:\n        sublist_tuple = tuple(sublist)\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        else:\n            count_dict[sublist_tuple] = 1\n    return count_dict"}
{"task_id": "Mbpp/759", "solution": "def is_decimal(s):\n    \"\"\"\n    Checks whether a given string is a decimal number with a precision of 2.\n\n    Args:\n        s (str): The input string to be checked.\n\n    Returns:\n        bool: True if the string is a decimal number with a precision of 2, False otherwise.\n    \"\"\"\n    # Remove leading and trailing whitespace\n    s = s.strip()\n    \n    # Check if the string contains a decimal point\n    if '.' not in s:\n        return False\n    \n    # Split the string into two parts at the decimal point\n    parts = s.split('.')\n    \n    # Check if there are more than two parts (i.e., more than one decimal point)\n    if len(parts) > 2:\n        return False\n    \n    # Check if the first part is a digit\n    if not parts[0].isdigit():\n        return False\n    \n    # Check if the second part is a digit and has a length of 2\n    if len(parts[1])!= 2 or not parts[1].isdigit():\n        return False\n    \n    # If all checks pass, the string is a decimal number with a precision of 2\n    return True"}
{"task_id": "Mbpp/760", "solution": "def unique_Element(lst):\n    \"\"\"\n    Checks whether a list of numbers contains only one distinct element.\n\n    Args:\n        lst (list): A list of numbers.\n\n    Returns:\n        bool: True if the list contains only one distinct element, False otherwise.\n    \"\"\"\n    return len(set(lst)) == 1"}
{"task_id": "Mbpp/762", "solution": "def check_monthnumber_number(month):\n    # Months with 30 days: April (4), June (6), September (9), November (11)\n    if month in [4, 6, 9, 11]:\n        return True\n    else:\n        return False"}
{"task_id": "Mbpp/763", "solution": "def find_min_diff(arr, n):\n    \"\"\"\n    This function finds the minimum difference between any two elements in a given array.\n\n    Parameters:\n    arr (list): The input array.\n    n (int): The size of the array.\n\n    Returns:\n    int: The minimum difference between any two elements in the array.\n    \"\"\"\n    # Sort the array in ascending order\n    arr = sorted(arr)\n    \n    # Initialize the minimum difference with the difference between the first two elements\n    min_diff = arr[1] - arr[0]\n    \n    # Iterate through the sorted array to find the minimum difference\n    for i in range(1, n - 1):\n        # Calculate the difference between the current element and the next element\n        diff = arr[i + 1] - arr[i]\n        \n        # Update the minimum difference if the current difference is smaller\n        if diff < min_diff:\n            min_diff = diff\n    \n    # Return the minimum difference\n    return min_diff"}
{"task_id": "Mbpp/764", "solution": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digits in a given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The number of digits in the string.\n    \"\"\"\n    return sum(c.isdigit() for c in s)"}
{"task_id": "Mbpp/765", "solution": "def is_polite(n):\n    def is_polite_num(num):\n        count = 0\n        for i in range(1, num):\n            if num % i == 0:\n                count += 1\n        return count == num\n\n    polite_num = n\n    while True:\n        if is_polite_num(polite_num):\n            return polite_num\n        polite_num += 1"}
{"task_id": "Mbpp/766", "solution": "def pair_wise(lst):\n    \"\"\"\n    Returns a list of all pairs of consecutive items in a given list.\n\n    :param lst: The input list\n    :return: A list of tuples, where each tuple contains a pair of consecutive items from the input list\n    \"\"\"\n    return list(zip(lst, lst[1:]))"}
{"task_id": "Mbpp/767", "solution": "def get_pairs_count(numbers, sum):\n    \"\"\"\n    Counts the number of pairs in the given list of numbers whose sum is equal to the given sum.\n\n    Args:\n        numbers (list): A list of integers.\n        sum (int): The target sum.\n\n    Returns:\n        int: The number of pairs whose sum is equal to the given sum.\n    \"\"\"\n    count = 0\n    num_dict = {}\n    \n    # Iterate over the list of numbers\n    for num in numbers:\n        # Calculate the complement of the current number\n        complement = sum - num\n        \n        # If the complement is already in the dictionary, increment the count\n        if complement in num_dict:\n            count += num_dict[complement]\n        \n        # Increment the count of the current number in the dictionary\n        num_dict[num] = num_dict.get(num, 0) + 1\n    \n    return count"}
{"task_id": "Mbpp/769", "solution": "def Diff(list1, list2):\n    return list(set(list1 + list2) - set(list1) - set(list2)) + [item for item in list1 if item not in list2] + [item for item in list2 if item not in list1]"}
{"task_id": "Mbpp/770", "solution": "def odd_num_sum(n):\n    \"\"\"\n    Calculate the sum of the fourth power of the first n odd natural numbers.\n\n    Args:\n        n (int): The number of odd natural numbers to consider.\n\n    Returns:\n        int: The sum of the fourth power of the first n odd natural numbers.\n    \"\"\"\n    # Initialize the sum variable to 0\n    total_sum = 0\n    \n    # Initialize the counter for odd numbers to 0\n    odd_count = 0\n    \n    # Initialize the current number to 1 (the first odd natural number)\n    num = 1\n    \n    # Continue generating odd numbers until we have n of them\n    while odd_count < n:\n        # Calculate the fourth power of the current number\n        power = num ** 4\n        \n        # Add the fourth power to the total sum\n        total_sum += power\n        \n        # Increment the odd number counter\n        odd_count += 1\n        \n        # Move on to the next odd number\n        num += 2\n    \n    # Return the total sum\n    return total_sum"}
{"task_id": "Mbpp/771", "solution": "def check_expression(expression):\n    \"\"\"\n    Checks if the given expression is balanced or not.\n\n    Args:\n        expression (str): The input expression to be checked.\n\n    Returns:\n        bool: True if the expression is balanced, False otherwise.\n    \"\"\"\n    stack = []\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n\n    for char in expression:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping.keys():\n            if not stack or mapping[char]!= stack.pop():\n                return False\n\n    return not stack"}
{"task_id": "Mbpp/772", "solution": "def remove_length(s, k):\n    words = s.split()\n    return''.join([word for word in words if len(word)!= k])"}
{"task_id": "Mbpp/773", "solution": "def occurance_substring(string, substring):\n    \"\"\"\n    This function finds the occurrence and position of the substrings within a string.\n    \n    Args:\n        string (str): The main string to search in.\n        substring (str): The substring to search for.\n    \n    Returns:\n        tuple: A tuple containing the substring, its start position, and its end position. \n               Returns None if there is no match.\n    \"\"\"\n    # Check if the substring exists in the string\n    if substring in string:\n        # Find the start position of the substring\n        start_position = string.find(substring)\n        # Calculate the end position of the substring\n        end_position = start_position + len(substring)\n        # Return the substring, its start position, and its end position\n        return (substring, start_position, end_position)\n    else:\n        # Return None if there is no match\n        return None"}
{"task_id": "Mbpp/775", "solution": "def odd_position(lst):\n    \"\"\"\n    Checks whether every odd index contains odd numbers in a given list.\n\n    Args:\n        lst (list): A list of integers.\n\n    Returns:\n        bool: True if every odd index contains an odd number, False otherwise.\n    \"\"\"\n    return all(lst[i] % 2!= 0 for i in range(len(lst)) if i % 2!= 0)"}
{"task_id": "Mbpp/777", "solution": "def find_sum(lst):\n    from collections import Counter\n    element_count = Counter(lst)\n    return sum(element for element, count in element_count.items() if count == 1)"}
{"task_id": "Mbpp/778", "solution": "def pack_consecutive_duplicates(lst):\n    \"\"\"\n    Packs consecutive duplicates of a given list elements into sublists.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        list: A list of sublists, where each sublist contains consecutive duplicates from the input list.\n    \"\"\"\n    result = []\n    current_group = [lst[0]] if lst else []\n\n    for i in range(1, len(lst)):\n        if lst[i] == lst[i - 1]:\n            current_group.append(lst[i])\n        else:\n            result.append(current_group)\n            current_group = [lst[i]]\n\n    if current_group:\n        result.append(current_group)\n\n    return result"}
{"task_id": "Mbpp/780", "solution": "def find_combinations(tuple_list):\n    \"\"\"\n    This function finds the combinations of sums with tuples in the given tuple list.\n    \n    Args:\n        tuple_list (list): A list of tuples.\n    \n    Returns:\n        list: A list of tuples, where each tuple is a combination of sums.\n    \"\"\"\n    \n    # Initialize an empty list to store the combinations of sums\n    combinations = []\n    \n    # Iterate over each tuple in the list\n    for i in range(len(tuple_list)):\n        # Iterate over each tuple in the list (starting from the next tuple)\n        for j in range(i + 1, len(tuple_list)):\n            # Calculate the sum of corresponding elements in the two tuples\n            combination = tuple(a + b for a, b in zip(tuple_list[i], tuple_list[j]))\n            # Add the combination to the list\n            combinations.append(combination)\n    \n    # Return the list of combinations\n    return combinations"}
{"task_id": "Mbpp/781", "solution": "def count_divisors(n):\n    \"\"\"\n    Checks whether the count of divisors of a number is even.\n\n    Args:\n        n (int): The number to check.\n\n    Returns:\n        bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0"}
{"task_id": "Mbpp/782", "solution": "def odd_length_sum(arr):\n    n = len(arr)\n    total_sum = 0\n    \n    for length in range(1, n + 1):\n        if length % 2!= 0:\n            for i in range(n - length + 1):\n                total_sum += sum(arr[i:i + length])\n    \n    return total_sum"}
{"task_id": "Mbpp/783", "solution": "def rgb_to_hsv(r, g, b):\n    \"\"\"\n    Convert RGB color to HSV color.\n\n    Args:\n        r (int): The red component of the RGB color, in the range [0, 255].\n        g (int): The green component of the RGB color, in the range [0, 255].\n        b (int): The blue component of the RGB color, in the range [0, 255].\n\n    Returns:\n        tuple: A tuple containing the HSV color components, in the format (h, s, v).\n            h is the hue, in the range [0, 360].\n            s is the saturation, in the range [0, 100].\n            v is the value, in the range [0, 100].\n    \"\"\"\n\n    # Normalize the RGB values to the range [0, 1]\n    r, g, b = r / 255.0, g / 255.0, b / 255.0\n\n    # Find the maximum and minimum of the RGB values\n    mx = max(r, g, b)\n    mn = min(r, g, b)\n    df = mx - mn\n\n    # If the maximum and minimum values are the same, the color is grayscale\n    if mx == mn:\n        h = 0\n    # If the maximum value is red, calculate the hue\n    elif mx == r:\n        h = (60 * ((g - b) / df) + 360) % 360\n    # If the maximum value is green, calculate the hue\n    elif mx == g:\n        h = (60 * ((b - r) / df) + 120) % 360\n    # If the maximum value is blue, calculate the hue\n    elif mx == b:\n        h = (60 * ((r - g) / df) + 240) % 360\n\n    # If the maximum value is 0, the saturation is 0\n    if mx == 0:\n        s = 0\n    # Otherwise, calculate the saturation\n    else:\n        s = (df / mx) * 100\n\n    # Calculate the value\n    v = mx * 100\n\n    return h, s, v"}
{"task_id": "Mbpp/784", "solution": "def mul_even_odd(lst):\n    even = next((num for num in lst if num % 2 == 0), None)\n    odd = next((num for num in lst if num % 2!= 0), None)\n    return even * odd if even is not None and odd is not None else None"}
{"task_id": "Mbpp/785", "solution": "def tuple_str_int(s):\n    \"\"\"\n    Converts a tuple string to an integer tuple.\n\n    Args:\n        s (str): A string representing a tuple of integers.\n\n    Returns:\n        tuple: A tuple of integers.\n    \"\"\"\n    # Remove the parentheses from the string\n    s = s.strip(\"()\")\n\n    # Split the string into a list of strings, each representing an integer\n    str_list = s.split(\", \")\n\n    # Convert each string in the list to an integer and return as a tuple\n    return tuple(int(num) for num in str_list)"}
{"task_id": "Mbpp/786", "solution": "def right_insertion(arr, value):\n    \"\"\"\n    Locate the right insertion point for a specified value in sorted order.\n    \n    Parameters:\n    arr (list): A list of sorted integers.\n    value (int): The value to insert.\n    \n    Returns:\n    int: The index where the value should be inserted to maintain sorted order.\n    \"\"\"\n    left, right = 0, len(arr)\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] <= value:\n            left = mid + 1\n        else:\n            right = mid\n    return left"}
{"task_id": "Mbpp/787", "solution": "import re\n\ndef text_match_three(text):\n    pattern = re.compile(r'a(b{3})')\n    return bool(pattern.search(text))"}
{"task_id": "Mbpp/788", "solution": "def new_tuple(lst, string):\n    return tuple(lst) + (string,)"}
{"task_id": "Mbpp/790", "solution": "def even_position(lst):\n    for i in range(0, len(lst), 2):\n        if lst[i] % 2!= 0:\n            return False\n    return True"}
{"task_id": "Mbpp/791", "solution": "def remove_nested(t):\n    result = []\n    for item in t:\n        if not isinstance(item, tuple):\n            result.append(item)\n    return tuple(result)"}
{"task_id": "Mbpp/792", "solution": "def count_list(nested_list):\n    \"\"\"\n    Counts the number of lists within a given list.\n\n    Args:\n        nested_list (list): A list containing nested lists.\n\n    Returns:\n        int: The number of lists within the given list.\n    \"\"\"\n    return len([item for item in nested_list if isinstance(item, list)])"}
{"task_id": "Mbpp/793", "solution": "def last(arr, target):\n    \"\"\"\n    Find the last position of an element in a sorted array.\n\n    Args:\n        arr (list): A sorted list of elements.\n        target: The element to find the last position of.\n\n    Returns:\n        int: The last position of the target element in the array.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    result = -1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            result = mid\n            left = mid + 1\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return result"}
{"task_id": "Mbpp/794", "solution": "import re\n\ndef text_starta_endb(text):\n    pattern = r'^a.*b$'\n    return bool(re.match(pattern, text))"}
{"task_id": "Mbpp/796", "solution": "def return_sum(dictionary):\n    \"\"\"\n    This function calculates the sum of all items in a given dictionary.\n    \n    Parameters:\n    dictionary (dict): A dictionary containing numeric values.\n    \n    Returns:\n    int: The sum of all items in the dictionary.\n    \"\"\"\n    \n    # Initialize a variable to store the sum\n    total_sum = 0\n    \n    # Iterate over each value in the dictionary\n    for value in dictionary.values():\n        # Add the value to the total sum\n        total_sum += value\n    \n    # Return the total sum\n    return total_sum"}
{"task_id": "Mbpp/797", "solution": "def sum_in_range(l, r):\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Iterate through the range from l to r (inclusive)\n    for num in range(l, r + 1):\n        # Check if the number is odd\n        if num % 2!= 0:\n            # Add the odd number to the total sum\n            total_sum += num\n    \n    return total_sum"}
{"task_id": "Mbpp/798", "solution": "def _sum(array):\n    \"\"\"\n    This function calculates the sum of all elements in a given array.\n\n    Args:\n        array (list): A list of numbers.\n\n    Returns:\n        int: The sum of all elements in the array.\n    \"\"\"\n    total = 0\n    for num in array:\n        total += num\n    return total"}
{"task_id": "Mbpp/799", "solution": "def left_rotate(n, d):\n    \"\"\"\n    Rotate left bits by d bits in a given 32-bit number.\n\n    Args:\n        n (int): The input number.\n        d (int): The number of bits to rotate.\n\n    Returns:\n        int: The result of rotating the bits of n to the left by d positions.\n    \"\"\"\n    # Calculate the actual number of bits to rotate, considering the 32-bit limit\n    d = d % 32\n    \n    # Perform the left rotation using bitwise operations\n    result = (n << d) | (n >> (32 - d))\n    \n    # Ensure the result is within the 32-bit range\n    result = result & 0xFFFFFFFF\n    \n    return result"}
{"task_id": "Mbpp/800", "solution": "def remove_all_spaces(s):\n    return s.replace(' ', '')"}
{"task_id": "Mbpp/801", "solution": "def test_three_equal(a, b, c):\n    \"\"\"\n    This function counts the number of equal numbers from three given integers.\n\n    Args:\n        a (int): The first integer.\n        b (int): The second integer.\n        c (int): The third integer.\n\n    Returns:\n        int: The number of equal numbers.\n    \"\"\"\n    numbers = [a, b, c]\n    most_common = max(set(numbers), key=numbers.count)\n    return numbers.count(most_common)"}
{"task_id": "Mbpp/803", "solution": "import math\n\ndef is_perfect_square(n):\n    if n < 0:\n        return False\n    sqrt_n = int(math.sqrt(n))\n    return sqrt_n * sqrt_n == n"}
{"task_id": "Mbpp/804", "solution": "def is_product_even(numbers):\n    for number in numbers:\n        if number % 2 == 0:\n            return True\n    return False"}
{"task_id": "Mbpp/805", "solution": "def max_sum_list(lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n\n    Args:\n        lists (list): A list of lists containing integers.\n\n    Returns:\n        list: The list with the highest sum of elements.\n    \"\"\"\n    return max(lists, key=sum)"}
{"task_id": "Mbpp/806", "solution": "def max_run_uppercase(s):\n    max_run = 0\n    current_run = 0\n    \n    for char in s:\n        if char.isupper():\n            current_run += 1\n            if current_run > max_run:\n                max_run = current_run\n        else:\n            current_run = 0\n    \n    return max_run"}
{"task_id": "Mbpp/807", "solution": "def first_odd(numbers):\n    for number in numbers:\n        if number % 2!= 0:\n            return number\n    return None"}
{"task_id": "Mbpp/808", "solution": "def check_K(tup, k):\n    return k in tup"}
{"task_id": "Mbpp/809", "solution": "def check_smaller(tuple1, tuple2):\n    \"\"\"\n    This function checks if each element of the second tuple is smaller than its corresponding element in the first tuple.\n\n    Args:\n        tuple1 (tuple): The first tuple.\n        tuple2 (tuple): The second tuple.\n\n    Returns:\n        bool: True if each element of the second tuple is smaller than its corresponding element in the first tuple, False otherwise.\n    \"\"\"\n    # Check if the tuples have the same length\n    if len(tuple1)!= len(tuple2):\n        raise ValueError(\"Tuples must have the same length\")\n\n    # Use the all() function with a generator expression to check if each element of the second tuple is smaller than its corresponding element in the first tuple\n    return all(x < y for x, y in zip(tuple2, tuple1))"}
